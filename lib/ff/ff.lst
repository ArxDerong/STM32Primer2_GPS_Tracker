   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"ff.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.mem_cpy,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	mem_cpy:
  24              	.LFB0:
  25              		.file 1 "lib/ff/ff.c"
   1:lib/ff/ff.c   **** /*----------------------------------------------------------------------------/
   2:lib/ff/ff.c   **** /  FatFs - FAT file system module  R0.09a                 (C)ChaN, 2012
   3:lib/ff/ff.c   **** /-----------------------------------------------------------------------------/
   4:lib/ff/ff.c   **** / FatFs module is a generic FAT file system module for small embedded systems.
   5:lib/ff/ff.c   **** / This is a free software that opened for education, research and commercial
   6:lib/ff/ff.c   **** / developments under license policy of following terms.
   7:lib/ff/ff.c   **** /
   8:lib/ff/ff.c   **** /  Copyright (C) 2012, ChaN, all right reserved.
   9:lib/ff/ff.c   **** /
  10:lib/ff/ff.c   **** / * The FatFs module is a free software and there is NO WARRANTY.
  11:lib/ff/ff.c   **** / * No restriction on use. You can use, modify and redistribute it for
  12:lib/ff/ff.c   **** /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
  13:lib/ff/ff.c   **** / * Redistributions of source code must retain the above copyright notice.
  14:lib/ff/ff.c   **** /
  15:lib/ff/ff.c   **** /-----------------------------------------------------------------------------/
  16:lib/ff/ff.c   **** / Feb 26,'06 R0.00  Prototype.
  17:lib/ff/ff.c   **** /
  18:lib/ff/ff.c   **** / Apr 29,'06 R0.01  First stable version.
  19:lib/ff/ff.c   **** /
  20:lib/ff/ff.c   **** / Jun 01,'06 R0.02  Added FAT12 support.
  21:lib/ff/ff.c   **** /                   Removed unbuffered mode.
  22:lib/ff/ff.c   **** /                   Fixed a problem on small (<32M) partition.
  23:lib/ff/ff.c   **** / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
  24:lib/ff/ff.c   **** /
  25:lib/ff/ff.c   **** / Sep 22,'06 R0.03  Added f_rename().
  26:lib/ff/ff.c   **** /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
  27:lib/ff/ff.c   **** / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
  28:lib/ff/ff.c   **** /                   Fixed f_mkdir() creates incorrect directory on FAT32.
  29:lib/ff/ff.c   **** /
  30:lib/ff/ff.c   **** / Feb 04,'07 R0.04  Supported multiple drive system.
  31:lib/ff/ff.c   **** /                   Changed some interfaces for multiple drive system.
  32:lib/ff/ff.c   **** /                   Changed f_mountdrv() to f_mount().
  33:lib/ff/ff.c   **** /                   Added f_mkfs().
  34:lib/ff/ff.c   **** / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
  35:lib/ff/ff.c   **** /                   Added a capability of extending file size to f_lseek().
  36:lib/ff/ff.c   **** /                   Added minimization level 3.
  37:lib/ff/ff.c   **** /                   Fixed an endian sensitive code in f_mkfs().
  38:lib/ff/ff.c   **** / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
  39:lib/ff/ff.c   **** /                   Added FSInfo support.
  40:lib/ff/ff.c   **** /                   Fixed DBCS name can result FR_INVALID_NAME.
  41:lib/ff/ff.c   **** /                   Fixed short seek (<= csize) collapses the file object.
  42:lib/ff/ff.c   **** /
  43:lib/ff/ff.c   **** / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
  44:lib/ff/ff.c   **** /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
  45:lib/ff/ff.c   **** /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
  46:lib/ff/ff.c   **** / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
  47:lib/ff/ff.c   **** /                   Fixed off by one error at FAT sub-type determination.
  48:lib/ff/ff.c   **** /                   Fixed btr in f_read() can be mistruncated.
  49:lib/ff/ff.c   **** /                   Fixed cached sector is not flushed when create and close without write.
  50:lib/ff/ff.c   **** /
  51:lib/ff/ff.c   **** / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
  52:lib/ff/ff.c   **** /                   Improved performance of f_lseek() on moving to the same or following cluster.
  53:lib/ff/ff.c   **** /
  54:lib/ff/ff.c   **** / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
  55:lib/ff/ff.c   **** /                   Added long file name feature.
  56:lib/ff/ff.c   **** /                   Added multiple code page feature.
  57:lib/ff/ff.c   **** /                   Added re-entrancy for multitask operation.
  58:lib/ff/ff.c   **** /                   Added auto cluster size selection to f_mkfs().
  59:lib/ff/ff.c   **** /                   Added rewind option to f_readdir().
  60:lib/ff/ff.c   **** /                   Changed result code of critical errors.
  61:lib/ff/ff.c   **** /                   Renamed string functions to avoid name collision.
  62:lib/ff/ff.c   **** / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
  63:lib/ff/ff.c   **** /                   Added multiple sector size feature.
  64:lib/ff/ff.c   **** / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
  65:lib/ff/ff.c   **** /                   Fixed wrong cache control in f_lseek().
  66:lib/ff/ff.c   **** /                   Added relative path feature.
  67:lib/ff/ff.c   **** /                   Added f_chdir() and f_chdrive().
  68:lib/ff/ff.c   **** /                   Added proper case conversion to extended char.
  69:lib/ff/ff.c   **** / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
  70:lib/ff/ff.c   **** /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
  71:lib/ff/ff.c   **** /                   Fixed name matching error on the 13 char boundary.
  72:lib/ff/ff.c   **** /                   Added a configuration option, _LFN_UNICODE.
  73:lib/ff/ff.c   **** /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
  74:lib/ff/ff.c   **** /
  75:lib/ff/ff.c   **** / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
  76:lib/ff/ff.c   **** /                   Added file lock feature. (_FS_SHARE)
  77:lib/ff/ff.c   **** /                   Added fast seek feature. (_USE_FASTSEEK)
  78:lib/ff/ff.c   **** /                   Changed some types on the API, XCHAR->TCHAR.
  79:lib/ff/ff.c   **** /                   Changed fname member in the FILINFO structure on Unicode cfg.
  80:lib/ff/ff.c   **** /                   String functions support UTF-8 encoding files on Unicode cfg.
  81:lib/ff/ff.c   **** / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
  82:lib/ff/ff.c   **** /                   Added sector erase feature. (_USE_ERASE)
  83:lib/ff/ff.c   **** /                   Moved file lock semaphore table from fs object to the bss.
  84:lib/ff/ff.c   **** /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name con
  85:lib/ff/ff.c   **** /                   Fixed f_mkfs() creates wrong FAT32 volume.
  86:lib/ff/ff.c   **** / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
  87:lib/ff/ff.c   **** /                   f_lseek() reports required table size on creating CLMP.
  88:lib/ff/ff.c   **** /                   Extended format syntax of f_printf function.
  89:lib/ff/ff.c   **** /                   Ignores duplicated directory separators in given path name.
  90:lib/ff/ff.c   **** /
  91:lib/ff/ff.c   **** / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
  92:lib/ff/ff.c   **** /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
  93:lib/ff/ff.c   **** / Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
  94:lib/ff/ff.c   **** /                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
  95:lib/ff/ff.c   **** /                   Changed option name _FS_SHARE to _FS_LOCK.
  96:lib/ff/ff.c   **** /---------------------------------------------------------------------------*/
  97:lib/ff/ff.c   **** 
  98:lib/ff/ff.c   **** #include "ff.h"			/* FatFs configurations and declarations */
  99:lib/ff/ff.c   **** #include "diskio.h"		/* Declarations of low level disk I/O functions */
 100:lib/ff/ff.c   **** 
 101:lib/ff/ff.c   **** 
 102:lib/ff/ff.c   **** /*--------------------------------------------------------------------------
 103:lib/ff/ff.c   **** 
 104:lib/ff/ff.c   ****    Module Private Definitions
 105:lib/ff/ff.c   **** 
 106:lib/ff/ff.c   **** ---------------------------------------------------------------------------*/
 107:lib/ff/ff.c   **** 
 108:lib/ff/ff.c   **** #if _FATFS != 4004	/* Revision ID */
 109:lib/ff/ff.c   **** #error Wrong include file (ff.h).
 110:lib/ff/ff.c   **** #endif
 111:lib/ff/ff.c   **** 
 112:lib/ff/ff.c   **** 
 113:lib/ff/ff.c   **** /* Definitions on sector size */
 114:lib/ff/ff.c   **** #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
 115:lib/ff/ff.c   **** #error Wrong sector size.
 116:lib/ff/ff.c   **** #endif
 117:lib/ff/ff.c   **** #if _MAX_SS != 512
 118:lib/ff/ff.c   **** #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
 119:lib/ff/ff.c   **** #else
 120:lib/ff/ff.c   **** #define	SS(fs)	512U			/* Fixed sector size */
 121:lib/ff/ff.c   **** #endif
 122:lib/ff/ff.c   **** 
 123:lib/ff/ff.c   **** 
 124:lib/ff/ff.c   **** /* Reentrancy related */
 125:lib/ff/ff.c   **** #if _FS_REENTRANT
 126:lib/ff/ff.c   **** #if _USE_LFN == 1
 127:lib/ff/ff.c   **** #error Static LFN work area must not be used in re-entrant configuration.
 128:lib/ff/ff.c   **** #endif
 129:lib/ff/ff.c   **** #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
 130:lib/ff/ff.c   **** #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
 131:lib/ff/ff.c   **** #else
 132:lib/ff/ff.c   **** #define	ENTER_FF(fs)
 133:lib/ff/ff.c   **** #define LEAVE_FF(fs, res)	return res
 134:lib/ff/ff.c   **** #endif
 135:lib/ff/ff.c   **** 
 136:lib/ff/ff.c   **** #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
 137:lib/ff/ff.c   **** 
 138:lib/ff/ff.c   **** 
 139:lib/ff/ff.c   **** /* File access control feature */
 140:lib/ff/ff.c   **** #if _FS_LOCK
 141:lib/ff/ff.c   **** #if _FS_READONLY
 142:lib/ff/ff.c   **** #error _FS_LOCK must be 0 on read-only cfg.
 143:lib/ff/ff.c   **** #endif
 144:lib/ff/ff.c   **** typedef struct {
 145:lib/ff/ff.c   **** 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
 146:lib/ff/ff.c   **** 	DWORD clu;				/* File ID 2, directory */
 147:lib/ff/ff.c   **** 	WORD idx;				/* File ID 3, directory index */
 148:lib/ff/ff.c   **** 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
 149:lib/ff/ff.c   **** } FILESEM;
 150:lib/ff/ff.c   **** #endif
 151:lib/ff/ff.c   **** 
 152:lib/ff/ff.c   **** 
 153:lib/ff/ff.c   **** 
 154:lib/ff/ff.c   **** /* DBCS code ranges and SBCS extend char conversion table */
 155:lib/ff/ff.c   **** 
 156:lib/ff/ff.c   **** #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
 157:lib/ff/ff.c   **** #define _DF1S	0x81	/* DBC 1st byte range 1 start */
 158:lib/ff/ff.c   **** #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
 159:lib/ff/ff.c   **** #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
 160:lib/ff/ff.c   **** #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
 161:lib/ff/ff.c   **** #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
 162:lib/ff/ff.c   **** #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
 163:lib/ff/ff.c   **** #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
 164:lib/ff/ff.c   **** #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
 165:lib/ff/ff.c   **** 
 166:lib/ff/ff.c   **** #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
 167:lib/ff/ff.c   **** #define _DF1S	0x81
 168:lib/ff/ff.c   **** #define _DF1E	0xFE
 169:lib/ff/ff.c   **** #define _DS1S	0x40
 170:lib/ff/ff.c   **** #define _DS1E	0x7E
 171:lib/ff/ff.c   **** #define _DS2S	0x80
 172:lib/ff/ff.c   **** #define _DS2E	0xFE
 173:lib/ff/ff.c   **** 
 174:lib/ff/ff.c   **** #elif _CODE_PAGE == 949	/* Korean */
 175:lib/ff/ff.c   **** #define _DF1S	0x81
 176:lib/ff/ff.c   **** #define _DF1E	0xFE
 177:lib/ff/ff.c   **** #define _DS1S	0x41
 178:lib/ff/ff.c   **** #define _DS1E	0x5A
 179:lib/ff/ff.c   **** #define _DS2S	0x61
 180:lib/ff/ff.c   **** #define _DS2E	0x7A
 181:lib/ff/ff.c   **** #define _DS3S	0x81
 182:lib/ff/ff.c   **** #define _DS3E	0xFE
 183:lib/ff/ff.c   **** 
 184:lib/ff/ff.c   **** #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
 185:lib/ff/ff.c   **** #define _DF1S	0x81
 186:lib/ff/ff.c   **** #define _DF1E	0xFE
 187:lib/ff/ff.c   **** #define _DS1S	0x40
 188:lib/ff/ff.c   **** #define _DS1E	0x7E
 189:lib/ff/ff.c   **** #define _DS2S	0xA1
 190:lib/ff/ff.c   **** #define _DS2E	0xFE
 191:lib/ff/ff.c   **** 
 192:lib/ff/ff.c   **** #elif _CODE_PAGE == 437	/* U.S. (OEM) */
 193:lib/ff/ff.c   **** #define _DF1S	0
 194:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x9
 195:lib/ff/ff.c   **** 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 196:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 197:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 198:lib/ff/ff.c   **** 
 199:lib/ff/ff.c   **** #elif _CODE_PAGE == 720	/* Arabic (OEM) */
 200:lib/ff/ff.c   **** #define _DF1S	0
 201:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x9
 202:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 203:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 204:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 205:lib/ff/ff.c   **** 
 206:lib/ff/ff.c   **** #elif _CODE_PAGE == 737	/* Greek (OEM) */
 207:lib/ff/ff.c   **** #define _DF1S	0
 208:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 209:lib/ff/ff.c   **** 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,
 210:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 211:lib/ff/ff.c   **** 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 212:lib/ff/ff.c   **** 
 213:lib/ff/ff.c   **** #elif _CODE_PAGE == 775	/* Baltic (OEM) */
 214:lib/ff/ff.c   **** #define _DF1S	0
 215:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x9
 216:lib/ff/ff.c   **** 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 217:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,
 218:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 219:lib/ff/ff.c   **** 
 220:lib/ff/ff.c   **** #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
 221:lib/ff/ff.c   **** #define _DF1S	0
 222:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x9
 223:lib/ff/ff.c   **** 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 224:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 225:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 226:lib/ff/ff.c   **** 
 227:lib/ff/ff.c   **** #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
 228:lib/ff/ff.c   **** #define _DF1S	0
 229:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x9
 230:lib/ff/ff.c   **** 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,
 231:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,
 232:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,
 233:lib/ff/ff.c   **** 
 234:lib/ff/ff.c   **** #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
 235:lib/ff/ff.c   **** #define _DF1S	0
 236:lib/ff/ff.c   **** #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x9
 237:lib/ff/ff.c   **** 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 238:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,
 239:lib/ff/ff.c   **** 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,
 240:lib/ff/ff.c   **** 
 241:lib/ff/ff.c   **** #elif _CODE_PAGE == 857	/* Turkish (OEM) */
 242:lib/ff/ff.c   **** #define _DF1S	0
 243:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x9
 244:lib/ff/ff.c   **** 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 245:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 246:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,
 247:lib/ff/ff.c   **** 
 248:lib/ff/ff.c   **** #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
 249:lib/ff/ff.c   **** #define _DF1S	0
 250:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x9
 251:lib/ff/ff.c   **** 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 252:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,
 253:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 254:lib/ff/ff.c   **** 
 255:lib/ff/ff.c   **** #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
 256:lib/ff/ff.c   **** #define _DF1S	0
 257:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 258:lib/ff/ff.c   **** 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 259:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 260:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 261:lib/ff/ff.c   **** 
 262:lib/ff/ff.c   **** #elif _CODE_PAGE == 866	/* Russian (OEM) */
 263:lib/ff/ff.c   **** #define _DF1S	0
 264:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 265:lib/ff/ff.c   **** 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,
 266:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 267:lib/ff/ff.c   **** 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,
 268:lib/ff/ff.c   **** 
 269:lib/ff/ff.c   **** #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
 270:lib/ff/ff.c   **** #define _DF1S	0
 271:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 272:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 273:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 274:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 275:lib/ff/ff.c   **** 
 276:lib/ff/ff.c   **** #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
 277:lib/ff/ff.c   **** #define _DF1S	0
 278:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 279:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 280:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 281:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 282:lib/ff/ff.c   **** 
 283:lib/ff/ff.c   **** #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
 284:lib/ff/ff.c   **** #define _DF1S	0
 285:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x8
 286:lib/ff/ff.c   **** 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 287:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 288:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 289:lib/ff/ff.c   **** 
 290:lib/ff/ff.c   **** #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
 291:lib/ff/ff.c   **** #define _DF1S	0
 292:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 293:lib/ff/ff.c   **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 294:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 295:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 296:lib/ff/ff.c   **** 
 297:lib/ff/ff.c   **** #elif _CODE_PAGE == 1253 /* Greek (Windows) */
 298:lib/ff/ff.c   **** #define _DF1S	0
 299:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 300:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 301:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 302:lib/ff/ff.c   **** 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,
 303:lib/ff/ff.c   **** 
 304:lib/ff/ff.c   **** #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
 305:lib/ff/ff.c   **** #define _DF1S	0
 306:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 307:lib/ff/ff.c   **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 308:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 309:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 310:lib/ff/ff.c   **** 
 311:lib/ff/ff.c   **** #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
 312:lib/ff/ff.c   **** #define _DF1S	0
 313:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 314:lib/ff/ff.c   **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 315:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 316:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 317:lib/ff/ff.c   **** 
 318:lib/ff/ff.c   **** #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
 319:lib/ff/ff.c   **** #define _DF1S	0
 320:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 321:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 322:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 323:lib/ff/ff.c   **** 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,
 324:lib/ff/ff.c   **** 
 325:lib/ff/ff.c   **** #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
 326:lib/ff/ff.c   **** #define _DF1S	0
 327:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 328:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 329:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 330:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 331:lib/ff/ff.c   **** 
 332:lib/ff/ff.c   **** #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
 333:lib/ff/ff.c   **** #define _DF1S	0
 334:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 335:lib/ff/ff.c   **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 336:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 337:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,
 338:lib/ff/ff.c   **** 
 339:lib/ff/ff.c   **** #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
 340:lib/ff/ff.c   **** #if _USE_LFN
 341:lib/ff/ff.c   **** #error Cannot use LFN feature without valid code page.
 342:lib/ff/ff.c   **** #endif
 343:lib/ff/ff.c   **** #define _DF1S	0
 344:lib/ff/ff.c   **** 
 345:lib/ff/ff.c   **** #else
 346:lib/ff/ff.c   **** #error Unknown code page
 347:lib/ff/ff.c   **** 
 348:lib/ff/ff.c   **** #endif
 349:lib/ff/ff.c   **** 
 350:lib/ff/ff.c   **** 
 351:lib/ff/ff.c   **** /* Character code support macros */
 352:lib/ff/ff.c   **** #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
 353:lib/ff/ff.c   **** #define IsLower(c)	(((c)>='a')&&((c)<='z'))
 354:lib/ff/ff.c   **** #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
 355:lib/ff/ff.c   **** 
 356:lib/ff/ff.c   **** #if _DF1S		/* Code page is DBCS */
 357:lib/ff/ff.c   **** 
 358:lib/ff/ff.c   **** #ifdef _DF2S	/* Two 1st byte areas */
 359:lib/ff/ff.c   **** #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) 
 360:lib/ff/ff.c   **** #else			/* One 1st byte area */
 361:lib/ff/ff.c   **** #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
 362:lib/ff/ff.c   **** #endif
 363:lib/ff/ff.c   **** 
 364:lib/ff/ff.c   **** #ifdef _DS3S	/* Three 2nd byte areas */
 365:lib/ff/ff.c   **** #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) 
 366:lib/ff/ff.c   **** #else			/* Two 2nd byte areas */
 367:lib/ff/ff.c   **** #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) 
 368:lib/ff/ff.c   **** #endif
 369:lib/ff/ff.c   **** 
 370:lib/ff/ff.c   **** #else			/* Code page is SBCS */
 371:lib/ff/ff.c   **** 
 372:lib/ff/ff.c   **** #define IsDBCS1(c)	0
 373:lib/ff/ff.c   **** #define IsDBCS2(c)	0
 374:lib/ff/ff.c   **** 
 375:lib/ff/ff.c   **** #endif /* _DF1S */
 376:lib/ff/ff.c   **** 
 377:lib/ff/ff.c   **** 
 378:lib/ff/ff.c   **** /* Name status flags */
 379:lib/ff/ff.c   **** #define NS			11		/* Index of name status byte in fn[] */
 380:lib/ff/ff.c   **** #define NS_LOSS		0x01	/* Out of 8.3 format */
 381:lib/ff/ff.c   **** #define NS_LFN		0x02	/* Force to create LFN entry */
 382:lib/ff/ff.c   **** #define NS_LAST		0x04	/* Last segment */
 383:lib/ff/ff.c   **** #define NS_BODY		0x08	/* Lower case flag (body) */
 384:lib/ff/ff.c   **** #define NS_EXT		0x10	/* Lower case flag (ext) */
 385:lib/ff/ff.c   **** #define NS_DOT		0x20	/* Dot entry */
 386:lib/ff/ff.c   **** 
 387:lib/ff/ff.c   **** 
 388:lib/ff/ff.c   **** /* FAT sub-type boundaries */
 389:lib/ff/ff.c   **** /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
 390:lib/ff/ff.c   **** #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
 391:lib/ff/ff.c   **** #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
 392:lib/ff/ff.c   **** 
 393:lib/ff/ff.c   **** 
 394:lib/ff/ff.c   **** /* FatFs refers the members in the FAT structures as byte array instead of
 395:lib/ff/ff.c   **** / structure member because the structure is not binary compatible between
 396:lib/ff/ff.c   **** / different platforms */
 397:lib/ff/ff.c   **** 
 398:lib/ff/ff.c   **** #define BS_jmpBoot			0	/* Jump instruction (3) */
 399:lib/ff/ff.c   **** #define BS_OEMName			3	/* OEM name (8) */
 400:lib/ff/ff.c   **** #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
 401:lib/ff/ff.c   **** #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
 402:lib/ff/ff.c   **** #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
 403:lib/ff/ff.c   **** #define BPB_NumFATs			16	/* Number of FAT copies (1) */
 404:lib/ff/ff.c   **** #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
 405:lib/ff/ff.c   **** #define BPB_TotSec16		19	/* Volume size [sector] (2) */
 406:lib/ff/ff.c   **** #define BPB_Media			21	/* Media descriptor (1) */
 407:lib/ff/ff.c   **** #define BPB_FATSz16			22	/* FAT size [sector] (2) */
 408:lib/ff/ff.c   **** #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
 409:lib/ff/ff.c   **** #define BPB_NumHeads		26	/* Number of heads (2) */
 410:lib/ff/ff.c   **** #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
 411:lib/ff/ff.c   **** #define BPB_TotSec32		32	/* Volume size [sector] (4) */
 412:lib/ff/ff.c   **** #define BS_DrvNum			36	/* Physical drive number (2) */
 413:lib/ff/ff.c   **** #define BS_BootSig			38	/* Extended boot signature (1) */
 414:lib/ff/ff.c   **** #define BS_VolID			39	/* Volume serial number (4) */
 415:lib/ff/ff.c   **** #define BS_VolLab			43	/* Volume label (8) */
 416:lib/ff/ff.c   **** #define BS_FilSysType		54	/* File system type (1) */
 417:lib/ff/ff.c   **** #define BPB_FATSz32			36	/* FAT size [sector] (4) */
 418:lib/ff/ff.c   **** #define BPB_ExtFlags		40	/* Extended flags (2) */
 419:lib/ff/ff.c   **** #define BPB_FSVer			42	/* File system version (2) */
 420:lib/ff/ff.c   **** #define BPB_RootClus		44	/* Root dir first cluster (4) */
 421:lib/ff/ff.c   **** #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
 422:lib/ff/ff.c   **** #define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
 423:lib/ff/ff.c   **** #define BS_DrvNum32			64	/* Physical drive number (2) */
 424:lib/ff/ff.c   **** #define BS_BootSig32		66	/* Extended boot signature (1) */
 425:lib/ff/ff.c   **** #define BS_VolID32			67	/* Volume serial number (4) */
 426:lib/ff/ff.c   **** #define BS_VolLab32			71	/* Volume label (8) */
 427:lib/ff/ff.c   **** #define BS_FilSysType32		82	/* File system type (1) */
 428:lib/ff/ff.c   **** #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
 429:lib/ff/ff.c   **** #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
 430:lib/ff/ff.c   **** #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
 431:lib/ff/ff.c   **** #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
 432:lib/ff/ff.c   **** #define MBR_Table			446	/* MBR: Partition table offset (2) */
 433:lib/ff/ff.c   **** #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
 434:lib/ff/ff.c   **** #define BS_55AA				510	/* Boot sector signature (2) */
 435:lib/ff/ff.c   **** 
 436:lib/ff/ff.c   **** #define	DIR_Name			0	/* Short file name (11) */
 437:lib/ff/ff.c   **** #define	DIR_Attr			11	/* Attribute (1) */
 438:lib/ff/ff.c   **** #define	DIR_NTres			12	/* NT flag (1) */
 439:lib/ff/ff.c   **** #define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
 440:lib/ff/ff.c   **** #define	DIR_CrtTime			14	/* Created time (2) */
 441:lib/ff/ff.c   **** #define	DIR_CrtDate			16	/* Created date (2) */
 442:lib/ff/ff.c   **** #define DIR_LstAccDate		18	/* Last accessed date (2) */
 443:lib/ff/ff.c   **** #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
 444:lib/ff/ff.c   **** #define	DIR_WrtTime			22	/* Modified time (2) */
 445:lib/ff/ff.c   **** #define	DIR_WrtDate			24	/* Modified date (2) */
 446:lib/ff/ff.c   **** #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
 447:lib/ff/ff.c   **** #define	DIR_FileSize		28	/* File size (4) */
 448:lib/ff/ff.c   **** #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
 449:lib/ff/ff.c   **** #define	LDIR_Attr			11	/* LFN attribute (1) */
 450:lib/ff/ff.c   **** #define	LDIR_Type			12	/* LFN type (1) */
 451:lib/ff/ff.c   **** #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
 452:lib/ff/ff.c   **** #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
 453:lib/ff/ff.c   **** #define	SZ_DIR				32		/* Size of a directory entry */
 454:lib/ff/ff.c   **** #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
 455:lib/ff/ff.c   **** #define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
 456:lib/ff/ff.c   **** #define	NDDE				0x05	/* Replacement of the character collides with DDE */
 457:lib/ff/ff.c   **** 
 458:lib/ff/ff.c   **** 
 459:lib/ff/ff.c   **** /*------------------------------------------------------------*/
 460:lib/ff/ff.c   **** /* Module private work area                                   */
 461:lib/ff/ff.c   **** /*------------------------------------------------------------*/
 462:lib/ff/ff.c   **** /* Note that uninitialized variables with static duration are
 463:lib/ff/ff.c   **** /  zeroed/nulled at start-up. If not, the compiler or start-up
 464:lib/ff/ff.c   **** /  routine is out of ANSI-C standard.
 465:lib/ff/ff.c   **** */
 466:lib/ff/ff.c   **** 
 467:lib/ff/ff.c   **** #if _VOLUMES
 468:lib/ff/ff.c   **** static
 469:lib/ff/ff.c   **** FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
 470:lib/ff/ff.c   **** #else
 471:lib/ff/ff.c   **** #error Number of volumes must not be 0.
 472:lib/ff/ff.c   **** #endif
 473:lib/ff/ff.c   **** 
 474:lib/ff/ff.c   **** static
 475:lib/ff/ff.c   **** WORD Fsid;				/* File system mount ID */
 476:lib/ff/ff.c   **** 
 477:lib/ff/ff.c   **** #if _FS_RPATH
 478:lib/ff/ff.c   **** static
 479:lib/ff/ff.c   **** BYTE CurrVol;			/* Current drive */
 480:lib/ff/ff.c   **** #endif
 481:lib/ff/ff.c   **** 
 482:lib/ff/ff.c   **** #if _FS_LOCK
 483:lib/ff/ff.c   **** static
 484:lib/ff/ff.c   **** FILESEM	Files[_FS_LOCK];	/* File lock semaphores */
 485:lib/ff/ff.c   **** #endif
 486:lib/ff/ff.c   **** 
 487:lib/ff/ff.c   **** #if _USE_LFN == 0			/* No LFN feature */
 488:lib/ff/ff.c   **** #define	DEF_NAMEBUF			BYTE sfn[12]
 489:lib/ff/ff.c   **** #define INIT_BUF(dobj)		(dobj).fn = sfn
 490:lib/ff/ff.c   **** #define	FREE_BUF()
 491:lib/ff/ff.c   **** 
 492:lib/ff/ff.c   **** #elif _USE_LFN == 1			/* LFN feature with static working buffer */
 493:lib/ff/ff.c   **** static WCHAR LfnBuf[_MAX_LFN+1];
 494:lib/ff/ff.c   **** #define	DEF_NAMEBUF			BYTE sfn[12]
 495:lib/ff/ff.c   **** #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
 496:lib/ff/ff.c   **** #define	FREE_BUF()
 497:lib/ff/ff.c   **** 
 498:lib/ff/ff.c   **** #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
 499:lib/ff/ff.c   **** #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
 500:lib/ff/ff.c   **** #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
 501:lib/ff/ff.c   **** #define	FREE_BUF()
 502:lib/ff/ff.c   **** 
 503:lib/ff/ff.c   **** #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
 504:lib/ff/ff.c   **** #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
 505:lib/ff/ff.c   **** #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
 506:lib/ff/ff.c   **** 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
 507:lib/ff/ff.c   **** 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
 508:lib/ff/ff.c   **** #define	FREE_BUF()			ff_memfree(lfn)
 509:lib/ff/ff.c   **** 
 510:lib/ff/ff.c   **** #else
 511:lib/ff/ff.c   **** #error Wrong LFN configuration.
 512:lib/ff/ff.c   **** #endif
 513:lib/ff/ff.c   **** 
 514:lib/ff/ff.c   **** 
 515:lib/ff/ff.c   **** 
 516:lib/ff/ff.c   **** 
 517:lib/ff/ff.c   **** /*--------------------------------------------------------------------------
 518:lib/ff/ff.c   **** 
 519:lib/ff/ff.c   ****    Module Private Functions
 520:lib/ff/ff.c   **** 
 521:lib/ff/ff.c   **** ---------------------------------------------------------------------------*/
 522:lib/ff/ff.c   **** 
 523:lib/ff/ff.c   **** 
 524:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 525:lib/ff/ff.c   **** /* String functions                                                      */
 526:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 527:lib/ff/ff.c   **** 
 528:lib/ff/ff.c   **** /* Copy memory to memory */
 529:lib/ff/ff.c   **** static
 530:lib/ff/ff.c   **** void mem_cpy (void* dst, const void* src, UINT cnt) {
  26              		.loc 1 530 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 10B5     		push	{r4, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 4, -8
  35              		.cfi_offset 14, -4
  36              	.LVL1:
 531:lib/ff/ff.c   **** 	BYTE *d = (BYTE*)dst;
 532:lib/ff/ff.c   **** 	const BYTE *s = (const BYTE*)src;
 533:lib/ff/ff.c   **** 
 534:lib/ff/ff.c   **** #if _WORD_ACCESS == 1
 535:lib/ff/ff.c   **** 	while (cnt >= sizeof (int)) {
  37              		.loc 1 535 0
  38 0002 0023     		movs	r3, #0
  39              	.LVL2:
  40              	.L2:
  41              		.loc 1 535 0 is_stmt 0 discriminator 1
  42 0004 D41A     		subs	r4, r2, r3
  43 0006 032C     		cmp	r4, #3
  44 0008 03D9     		bls	.L7
  45              	.L3:
 536:lib/ff/ff.c   **** 		*(int*)d = *(int*)s;
  46              		.loc 1 536 0 is_stmt 1
  47 000a CC58     		ldr	r4, [r1, r3]
  48 000c C450     		str	r4, [r0, r3]
  49 000e 0433     		adds	r3, r3, #4
  50 0010 F8E7     		b	.L2
  51              	.L7:
  52 0012 02F00304 		and	r4, r2, #3
 530:lib/ff/ff.c   **** void mem_cpy (void* dst, const void* src, UINT cnt) {
  53              		.loc 1 530 0
  54 0016 22F00302 		bic	r2, r2, #3
  55 001a 8018     		adds	r0, r0, r2
  56              	.LVL3:
  57 001c 8A18     		adds	r2, r1, r2
  58 001e 0023     		movs	r3, #0
  59              	.LVL4:
  60              	.L4:
 537:lib/ff/ff.c   **** 		d += sizeof (int); s += sizeof (int);
 538:lib/ff/ff.c   **** 		cnt -= sizeof (int);
 539:lib/ff/ff.c   **** 	}
 540:lib/ff/ff.c   **** #endif
 541:lib/ff/ff.c   **** 	while (cnt--)
  61              		.loc 1 541 0 discriminator 1
  62 0020 A342     		cmp	r3, r4
  63 0022 03D0     		beq	.L8
  64              	.L5:
 542:lib/ff/ff.c   **** 		*d++ = *s++;
  65              		.loc 1 542 0
  66 0024 D15C     		ldrb	r1, [r2, r3]	@ zero_extendqisi2
  67 0026 C154     		strb	r1, [r0, r3]
  68 0028 0133     		adds	r3, r3, #1
  69 002a F9E7     		b	.L4
  70              	.L8:
 543:lib/ff/ff.c   **** }
  71              		.loc 1 543 0
  72 002c 10BD     		pop	{r4, pc}
  73              		.cfi_endproc
  74              	.LFE0:
  76              		.section	.text.mem_set,"ax",%progbits
  77              		.align	1
  78              		.thumb
  79              		.thumb_func
  81              	mem_set:
  82              	.LFB1:
 544:lib/ff/ff.c   **** 
 545:lib/ff/ff.c   **** /* Fill memory */
 546:lib/ff/ff.c   **** static
 547:lib/ff/ff.c   **** void mem_set (void* dst, int val, UINT cnt) {
  83              		.loc 1 547 0
  84              		.cfi_startproc
  85              		@ args = 0, pretend = 0, frame = 0
  86              		@ frame_needed = 0, uses_anonymous_args = 0
  87              		@ link register save eliminated.
  88              	.LVL5:
  89              	.LVL6:
  90              		.loc 1 547 0
  91 0000 8218     		adds	r2, r0, r2
  92              	.LVL7:
  93              	.L10:
 548:lib/ff/ff.c   **** 	BYTE *d = (BYTE*)dst;
 549:lib/ff/ff.c   **** 
 550:lib/ff/ff.c   **** 	while (cnt--)
  94              		.loc 1 550 0 discriminator 1
  95 0002 9042     		cmp	r0, r2
  96 0004 02D0     		beq	.L12
  97              	.L11:
 551:lib/ff/ff.c   **** 		*d++ = (BYTE)val;
  98              		.loc 1 551 0
  99 0006 00F8011B 		strb	r1, [r0], #1
 100              	.LVL8:
 101 000a FAE7     		b	.L10
 102              	.L12:
 552:lib/ff/ff.c   **** }
 103              		.loc 1 552 0
 104 000c 7047     		bx	lr
 105              		.cfi_endproc
 106              	.LFE1:
 108              		.section	.text.clmt_clust,"ax",%progbits
 109              		.align	1
 110              		.thumb
 111              		.thumb_func
 113              	clmt_clust:
 114              	.LFB11:
 553:lib/ff/ff.c   **** 
 554:lib/ff/ff.c   **** /* Compare memory to memory */
 555:lib/ff/ff.c   **** static
 556:lib/ff/ff.c   **** int mem_cmp (const void* dst, const void* src, UINT cnt) {
 557:lib/ff/ff.c   **** 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 558:lib/ff/ff.c   **** 	int r = 0;
 559:lib/ff/ff.c   **** 
 560:lib/ff/ff.c   **** 	while (cnt-- && (r = *d++ - *s++) == 0) ;
 561:lib/ff/ff.c   **** 	return r;
 562:lib/ff/ff.c   **** }
 563:lib/ff/ff.c   **** 
 564:lib/ff/ff.c   **** /* Check if chr is contained in the string */
 565:lib/ff/ff.c   **** static
 566:lib/ff/ff.c   **** int chk_chr (const char* str, int chr) {
 567:lib/ff/ff.c   **** 	while (*str && *str != chr) str++;
 568:lib/ff/ff.c   **** 	return *str;
 569:lib/ff/ff.c   **** }
 570:lib/ff/ff.c   **** 
 571:lib/ff/ff.c   **** 
 572:lib/ff/ff.c   **** 
 573:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 574:lib/ff/ff.c   **** /* Request/Release grant to access the volume                            */
 575:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 576:lib/ff/ff.c   **** #if _FS_REENTRANT
 577:lib/ff/ff.c   **** 
 578:lib/ff/ff.c   **** static
 579:lib/ff/ff.c   **** int lock_fs (
 580:lib/ff/ff.c   **** 	FATFS *fs		/* File system object */
 581:lib/ff/ff.c   **** )
 582:lib/ff/ff.c   **** {
 583:lib/ff/ff.c   **** 	return ff_req_grant(fs->sobj);
 584:lib/ff/ff.c   **** }
 585:lib/ff/ff.c   **** 
 586:lib/ff/ff.c   **** 
 587:lib/ff/ff.c   **** static
 588:lib/ff/ff.c   **** void unlock_fs (
 589:lib/ff/ff.c   **** 	FATFS *fs,		/* File system object */
 590:lib/ff/ff.c   **** 	FRESULT res		/* Result code to be returned */
 591:lib/ff/ff.c   **** )
 592:lib/ff/ff.c   **** {
 593:lib/ff/ff.c   **** 	if (fs &&
 594:lib/ff/ff.c   **** 		res != FR_NOT_ENABLED &&
 595:lib/ff/ff.c   **** 		res != FR_INVALID_DRIVE &&
 596:lib/ff/ff.c   **** 		res != FR_INVALID_OBJECT &&
 597:lib/ff/ff.c   **** 		res != FR_TIMEOUT) {
 598:lib/ff/ff.c   **** 		ff_rel_grant(fs->sobj);
 599:lib/ff/ff.c   **** 	}
 600:lib/ff/ff.c   **** }
 601:lib/ff/ff.c   **** #endif
 602:lib/ff/ff.c   **** 
 603:lib/ff/ff.c   **** 
 604:lib/ff/ff.c   **** 
 605:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 606:lib/ff/ff.c   **** /* File lock control functions                                           */
 607:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 608:lib/ff/ff.c   **** #if _FS_LOCK
 609:lib/ff/ff.c   **** 
 610:lib/ff/ff.c   **** static
 611:lib/ff/ff.c   **** FRESULT chk_lock (	/* Check if the file can be accessed */
 612:lib/ff/ff.c   **** 	DIR* dj,		/* Directory object pointing the file to be checked */
 613:lib/ff/ff.c   **** 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
 614:lib/ff/ff.c   **** )
 615:lib/ff/ff.c   **** {
 616:lib/ff/ff.c   **** 	UINT i, be;
 617:lib/ff/ff.c   **** 
 618:lib/ff/ff.c   **** 	/* Search file semaphore table */
 619:lib/ff/ff.c   **** 	for (i = be = 0; i < _FS_LOCK; i++) {
 620:lib/ff/ff.c   **** 		if (Files[i].fs) {	/* Existing entry */
 621:lib/ff/ff.c   **** 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
 622:lib/ff/ff.c   **** 				Files[i].clu == dj->sclust &&
 623:lib/ff/ff.c   **** 				Files[i].idx == dj->index) break;
 624:lib/ff/ff.c   **** 		} else {			/* Blank entry */
 625:lib/ff/ff.c   **** 			be++;
 626:lib/ff/ff.c   **** 		}
 627:lib/ff/ff.c   **** 	}
 628:lib/ff/ff.c   **** 	if (i == _FS_LOCK)	/* The file is not opened */
 629:lib/ff/ff.c   **** 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file?
 630:lib/ff/ff.c   **** 
 631:lib/ff/ff.c   **** 	/* The file has been opened. Reject any open against writing file and all write mode open */
 632:lib/ff/ff.c   **** 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 633:lib/ff/ff.c   **** }
 634:lib/ff/ff.c   **** 
 635:lib/ff/ff.c   **** 
 636:lib/ff/ff.c   **** static
 637:lib/ff/ff.c   **** int enq_lock (void)	/* Check if an entry is available for a new file */
 638:lib/ff/ff.c   **** {
 639:lib/ff/ff.c   **** 	UINT i;
 640:lib/ff/ff.c   **** 
 641:lib/ff/ff.c   **** 	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 642:lib/ff/ff.c   **** 	return (i == _FS_LOCK) ? 0 : 1;
 643:lib/ff/ff.c   **** }
 644:lib/ff/ff.c   **** 
 645:lib/ff/ff.c   **** 
 646:lib/ff/ff.c   **** static
 647:lib/ff/ff.c   **** UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
 648:lib/ff/ff.c   **** 	DIR* dj,	/* Directory object pointing the file to register or increment */
 649:lib/ff/ff.c   **** 	int acc		/* Desired access mode (0:Read, !0:Write) */
 650:lib/ff/ff.c   **** )
 651:lib/ff/ff.c   **** {
 652:lib/ff/ff.c   **** 	UINT i;
 653:lib/ff/ff.c   **** 
 654:lib/ff/ff.c   **** 
 655:lib/ff/ff.c   **** 	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
 656:lib/ff/ff.c   **** 		if (Files[i].fs == dj->fs &&
 657:lib/ff/ff.c   **** 			Files[i].clu == dj->sclust &&
 658:lib/ff/ff.c   **** 			Files[i].idx == dj->index) break;
 659:lib/ff/ff.c   **** 	}
 660:lib/ff/ff.c   **** 
 661:lib/ff/ff.c   **** 	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 662:lib/ff/ff.c   **** 		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 663:lib/ff/ff.c   **** 		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
 664:lib/ff/ff.c   **** 		Files[i].fs = dj->fs;
 665:lib/ff/ff.c   **** 		Files[i].clu = dj->sclust;
 666:lib/ff/ff.c   **** 		Files[i].idx = dj->index;
 667:lib/ff/ff.c   **** 		Files[i].ctr = 0;
 668:lib/ff/ff.c   **** 	}
 669:lib/ff/ff.c   **** 
 670:lib/ff/ff.c   **** 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 671:lib/ff/ff.c   **** 
 672:lib/ff/ff.c   **** 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 673:lib/ff/ff.c   **** 
 674:lib/ff/ff.c   **** 	return i + 1;
 675:lib/ff/ff.c   **** }
 676:lib/ff/ff.c   **** 
 677:lib/ff/ff.c   **** 
 678:lib/ff/ff.c   **** static
 679:lib/ff/ff.c   **** FRESULT dec_lock (	/* Decrement file open counter */
 680:lib/ff/ff.c   **** 	UINT i			/* Semaphore index */
 681:lib/ff/ff.c   **** )
 682:lib/ff/ff.c   **** {
 683:lib/ff/ff.c   **** 	WORD n;
 684:lib/ff/ff.c   **** 	FRESULT res;
 685:lib/ff/ff.c   **** 
 686:lib/ff/ff.c   **** 
 687:lib/ff/ff.c   **** 	if (--i < _FS_LOCK) {
 688:lib/ff/ff.c   **** 		n = Files[i].ctr;
 689:lib/ff/ff.c   **** 		if (n == 0x100) n = 0;
 690:lib/ff/ff.c   **** 		if (n) n--;
 691:lib/ff/ff.c   **** 		Files[i].ctr = n;
 692:lib/ff/ff.c   **** 		if (!n) Files[i].fs = 0;
 693:lib/ff/ff.c   **** 		res = FR_OK;
 694:lib/ff/ff.c   **** 	} else {
 695:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 696:lib/ff/ff.c   **** 	}
 697:lib/ff/ff.c   **** 	return res;
 698:lib/ff/ff.c   **** }
 699:lib/ff/ff.c   **** 
 700:lib/ff/ff.c   **** 
 701:lib/ff/ff.c   **** static
 702:lib/ff/ff.c   **** void clear_lock (	/* Clear lock entries of the volume */
 703:lib/ff/ff.c   **** 	FATFS *fs
 704:lib/ff/ff.c   **** )
 705:lib/ff/ff.c   **** {
 706:lib/ff/ff.c   **** 	UINT i;
 707:lib/ff/ff.c   **** 
 708:lib/ff/ff.c   **** 	for (i = 0; i < _FS_LOCK; i++) {
 709:lib/ff/ff.c   **** 		if (Files[i].fs == fs) Files[i].fs = 0;
 710:lib/ff/ff.c   **** 	}
 711:lib/ff/ff.c   **** }
 712:lib/ff/ff.c   **** #endif
 713:lib/ff/ff.c   **** 
 714:lib/ff/ff.c   **** 
 715:lib/ff/ff.c   **** 
 716:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 717:lib/ff/ff.c   **** /* Change window offset                                                  */
 718:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 719:lib/ff/ff.c   **** 
 720:lib/ff/ff.c   **** static
 721:lib/ff/ff.c   **** FRESULT move_window (
 722:lib/ff/ff.c   **** 	FATFS *fs,		/* File system object */
 723:lib/ff/ff.c   **** 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
 724:lib/ff/ff.c   **** )					/* Move to zero only writes back dirty window */
 725:lib/ff/ff.c   **** {
 726:lib/ff/ff.c   **** 	DWORD wsect;
 727:lib/ff/ff.c   **** 
 728:lib/ff/ff.c   **** 
 729:lib/ff/ff.c   **** 	wsect = fs->winsect;
 730:lib/ff/ff.c   **** 	if (wsect != sector) {	/* Changed current window */
 731:lib/ff/ff.c   **** #if !_FS_READONLY
 732:lib/ff/ff.c   **** 		if (fs->wflag) {	/* Write back dirty window if needed */
 733:lib/ff/ff.c   **** 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 734:lib/ff/ff.c   **** 				return FR_DISK_ERR;
 735:lib/ff/ff.c   **** 			fs->wflag = 0;
 736:lib/ff/ff.c   **** 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
 737:lib/ff/ff.c   **** 				BYTE nf;
 738:lib/ff/ff.c   **** 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
 739:lib/ff/ff.c   **** 					wsect += fs->fsize;
 740:lib/ff/ff.c   **** 					disk_write(fs->drv, fs->win, wsect, 1);
 741:lib/ff/ff.c   **** 				}
 742:lib/ff/ff.c   **** 			}
 743:lib/ff/ff.c   **** 		}
 744:lib/ff/ff.c   **** #endif
 745:lib/ff/ff.c   **** 		if (sector) {
 746:lib/ff/ff.c   **** 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 747:lib/ff/ff.c   **** 				return FR_DISK_ERR;
 748:lib/ff/ff.c   **** 			fs->winsect = sector;
 749:lib/ff/ff.c   **** 		}
 750:lib/ff/ff.c   **** 	}
 751:lib/ff/ff.c   **** 
 752:lib/ff/ff.c   **** 	return FR_OK;
 753:lib/ff/ff.c   **** }
 754:lib/ff/ff.c   **** 
 755:lib/ff/ff.c   **** 
 756:lib/ff/ff.c   **** 
 757:lib/ff/ff.c   **** 
 758:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 759:lib/ff/ff.c   **** /* Clean-up cached data                                                  */
 760:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 761:lib/ff/ff.c   **** #if !_FS_READONLY
 762:lib/ff/ff.c   **** static
 763:lib/ff/ff.c   **** FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
 764:lib/ff/ff.c   **** 	FATFS *fs	/* File system object */
 765:lib/ff/ff.c   **** )
 766:lib/ff/ff.c   **** {
 767:lib/ff/ff.c   **** 	FRESULT res;
 768:lib/ff/ff.c   **** 
 769:lib/ff/ff.c   **** 
 770:lib/ff/ff.c   **** 	res = move_window(fs, 0);
 771:lib/ff/ff.c   **** 	if (res == FR_OK) {
 772:lib/ff/ff.c   **** 		/* Update FSInfo sector if needed */
 773:lib/ff/ff.c   **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 774:lib/ff/ff.c   **** 			fs->winsect = 0;
 775:lib/ff/ff.c   **** 			/* Create FSInfo structure */
 776:lib/ff/ff.c   **** 			mem_set(fs->win, 0, 512);
 777:lib/ff/ff.c   **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);
 778:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 779:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 780:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 781:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 782:lib/ff/ff.c   **** 			/* Write it into the FSInfo sector */
 783:lib/ff/ff.c   **** 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
 784:lib/ff/ff.c   **** 			fs->fsi_flag = 0;
 785:lib/ff/ff.c   **** 		}
 786:lib/ff/ff.c   **** 		/* Make sure that no pending write process in the physical drive */
 787:lib/ff/ff.c   **** 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 788:lib/ff/ff.c   **** 			res = FR_DISK_ERR;
 789:lib/ff/ff.c   **** 	}
 790:lib/ff/ff.c   **** 
 791:lib/ff/ff.c   **** 	return res;
 792:lib/ff/ff.c   **** }
 793:lib/ff/ff.c   **** #endif
 794:lib/ff/ff.c   **** 
 795:lib/ff/ff.c   **** 
 796:lib/ff/ff.c   **** 
 797:lib/ff/ff.c   **** 
 798:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 799:lib/ff/ff.c   **** /* Get sector# from cluster#                                             */
 800:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 801:lib/ff/ff.c   **** 
 802:lib/ff/ff.c   **** 
 803:lib/ff/ff.c   **** DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
 804:lib/ff/ff.c   **** 	FATFS *fs,		/* File system object */
 805:lib/ff/ff.c   **** 	DWORD clst		/* Cluster# to be converted */
 806:lib/ff/ff.c   **** )
 807:lib/ff/ff.c   **** {
 808:lib/ff/ff.c   **** 	clst -= 2;
 809:lib/ff/ff.c   **** 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 810:lib/ff/ff.c   **** 	return clst * fs->csize + fs->database;
 811:lib/ff/ff.c   **** }
 812:lib/ff/ff.c   **** 
 813:lib/ff/ff.c   **** 
 814:lib/ff/ff.c   **** 
 815:lib/ff/ff.c   **** 
 816:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 817:lib/ff/ff.c   **** /* FAT access - Read value of a FAT entry                                */
 818:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 819:lib/ff/ff.c   **** 
 820:lib/ff/ff.c   **** 
 821:lib/ff/ff.c   **** DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
 822:lib/ff/ff.c   **** 	FATFS *fs,	/* File system object */
 823:lib/ff/ff.c   **** 	DWORD clst	/* Cluster# to get the link information */
 824:lib/ff/ff.c   **** )
 825:lib/ff/ff.c   **** {
 826:lib/ff/ff.c   **** 	UINT wc, bc;
 827:lib/ff/ff.c   **** 	BYTE *p;
 828:lib/ff/ff.c   **** 
 829:lib/ff/ff.c   **** 
 830:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 831:lib/ff/ff.c   **** 		return 1;
 832:lib/ff/ff.c   **** 
 833:lib/ff/ff.c   **** 	switch (fs->fs_type) {
 834:lib/ff/ff.c   **** 	case FS_FAT12 :
 835:lib/ff/ff.c   **** 		bc = (UINT)clst; bc += bc / 2;
 836:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 837:lib/ff/ff.c   **** 		wc = fs->win[bc % SS(fs)]; bc++;
 838:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 839:lib/ff/ff.c   **** 		wc |= fs->win[bc % SS(fs)] << 8;
 840:lib/ff/ff.c   **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 841:lib/ff/ff.c   **** 
 842:lib/ff/ff.c   **** 	case FS_FAT16 :
 843:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 844:lib/ff/ff.c   **** 		p = &fs->win[clst * 2 % SS(fs)];
 845:lib/ff/ff.c   **** 		return LD_WORD(p);
 846:lib/ff/ff.c   **** 
 847:lib/ff/ff.c   **** 	case FS_FAT32 :
 848:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 849:lib/ff/ff.c   **** 		p = &fs->win[clst * 4 % SS(fs)];
 850:lib/ff/ff.c   **** 		return LD_DWORD(p) & 0x0FFFFFFF;
 851:lib/ff/ff.c   **** 	}
 852:lib/ff/ff.c   **** 
 853:lib/ff/ff.c   **** 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 854:lib/ff/ff.c   **** }
 855:lib/ff/ff.c   **** 
 856:lib/ff/ff.c   **** 
 857:lib/ff/ff.c   **** 
 858:lib/ff/ff.c   **** 
 859:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 860:lib/ff/ff.c   **** /* FAT access - Change value of a FAT entry                              */
 861:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 862:lib/ff/ff.c   **** #if !_FS_READONLY
 863:lib/ff/ff.c   **** 
 864:lib/ff/ff.c   **** FRESULT put_fat (
 865:lib/ff/ff.c   **** 	FATFS *fs,	/* File system object */
 866:lib/ff/ff.c   **** 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
 867:lib/ff/ff.c   **** 	DWORD val	/* New value to mark the cluster */
 868:lib/ff/ff.c   **** )
 869:lib/ff/ff.c   **** {
 870:lib/ff/ff.c   **** 	UINT bc;
 871:lib/ff/ff.c   **** 	BYTE *p;
 872:lib/ff/ff.c   **** 	FRESULT res;
 873:lib/ff/ff.c   **** 
 874:lib/ff/ff.c   **** 
 875:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 876:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 877:lib/ff/ff.c   **** 
 878:lib/ff/ff.c   **** 	} else {
 879:lib/ff/ff.c   **** 		switch (fs->fs_type) {
 880:lib/ff/ff.c   **** 		case FS_FAT12 :
 881:lib/ff/ff.c   **** 			bc = (UINT)clst; bc += bc / 2;
 882:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 883:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 884:lib/ff/ff.c   **** 			p = &fs->win[bc % SS(fs)];
 885:lib/ff/ff.c   **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 886:lib/ff/ff.c   **** 			bc++;
 887:lib/ff/ff.c   **** 			fs->wflag = 1;
 888:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 889:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 890:lib/ff/ff.c   **** 			p = &fs->win[bc % SS(fs)];
 891:lib/ff/ff.c   **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 892:lib/ff/ff.c   **** 			break;
 893:lib/ff/ff.c   **** 
 894:lib/ff/ff.c   **** 		case FS_FAT16 :
 895:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 896:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 897:lib/ff/ff.c   **** 			p = &fs->win[clst * 2 % SS(fs)];
 898:lib/ff/ff.c   **** 			ST_WORD(p, (WORD)val);
 899:lib/ff/ff.c   **** 			break;
 900:lib/ff/ff.c   **** 
 901:lib/ff/ff.c   **** 		case FS_FAT32 :
 902:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 903:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 904:lib/ff/ff.c   **** 			p = &fs->win[clst * 4 % SS(fs)];
 905:lib/ff/ff.c   **** 			val |= LD_DWORD(p) & 0xF0000000;
 906:lib/ff/ff.c   **** 			ST_DWORD(p, val);
 907:lib/ff/ff.c   **** 			break;
 908:lib/ff/ff.c   **** 
 909:lib/ff/ff.c   **** 		default :
 910:lib/ff/ff.c   **** 			res = FR_INT_ERR;
 911:lib/ff/ff.c   **** 		}
 912:lib/ff/ff.c   **** 		fs->wflag = 1;
 913:lib/ff/ff.c   **** 	}
 914:lib/ff/ff.c   **** 
 915:lib/ff/ff.c   **** 	return res;
 916:lib/ff/ff.c   **** }
 917:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
 918:lib/ff/ff.c   **** 
 919:lib/ff/ff.c   **** 
 920:lib/ff/ff.c   **** 
 921:lib/ff/ff.c   **** 
 922:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 923:lib/ff/ff.c   **** /* FAT handling - Remove a cluster chain                                 */
 924:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 925:lib/ff/ff.c   **** #if !_FS_READONLY
 926:lib/ff/ff.c   **** static
 927:lib/ff/ff.c   **** FRESULT remove_chain (
 928:lib/ff/ff.c   **** 	FATFS *fs,			/* File system object */
 929:lib/ff/ff.c   **** 	DWORD clst			/* Cluster# to remove a chain from */
 930:lib/ff/ff.c   **** )
 931:lib/ff/ff.c   **** {
 932:lib/ff/ff.c   **** 	FRESULT res;
 933:lib/ff/ff.c   **** 	DWORD nxt;
 934:lib/ff/ff.c   **** #if _USE_ERASE
 935:lib/ff/ff.c   **** 	DWORD scl = clst, ecl = clst, rt[2];
 936:lib/ff/ff.c   **** #endif
 937:lib/ff/ff.c   **** 
 938:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 939:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 940:lib/ff/ff.c   **** 
 941:lib/ff/ff.c   **** 	} else {
 942:lib/ff/ff.c   **** 		res = FR_OK;
 943:lib/ff/ff.c   **** 		while (clst < fs->n_fatent) {			/* Not a last link? */
 944:lib/ff/ff.c   **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 945:lib/ff/ff.c   **** 			if (nxt == 0) break;				/* Empty cluster? */
 946:lib/ff/ff.c   **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 947:lib/ff/ff.c   **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 948:lib/ff/ff.c   **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 949:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 950:lib/ff/ff.c   **** 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 951:lib/ff/ff.c   **** 				fs->free_clust++;
 952:lib/ff/ff.c   **** 				fs->fsi_flag = 1;
 953:lib/ff/ff.c   **** 			}
 954:lib/ff/ff.c   **** #if _USE_ERASE
 955:lib/ff/ff.c   **** 			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
 956:lib/ff/ff.c   **** 				ecl = nxt;
 957:lib/ff/ff.c   **** 			} else {				/* End of contiguous clusters */ 
 958:lib/ff/ff.c   **** 				rt[0] = clust2sect(fs, scl);					/* Start sector */
 959:lib/ff/ff.c   **** 				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
 960:lib/ff/ff.c   **** 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
 961:lib/ff/ff.c   **** 				scl = ecl = nxt;
 962:lib/ff/ff.c   **** 			}
 963:lib/ff/ff.c   **** #endif
 964:lib/ff/ff.c   **** 			clst = nxt;	/* Next cluster */
 965:lib/ff/ff.c   **** 		}
 966:lib/ff/ff.c   **** 	}
 967:lib/ff/ff.c   **** 
 968:lib/ff/ff.c   **** 	return res;
 969:lib/ff/ff.c   **** }
 970:lib/ff/ff.c   **** #endif
 971:lib/ff/ff.c   **** 
 972:lib/ff/ff.c   **** 
 973:lib/ff/ff.c   **** 
 974:lib/ff/ff.c   **** 
 975:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 976:lib/ff/ff.c   **** /* FAT handling - Stretch or Create a cluster chain                      */
 977:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 978:lib/ff/ff.c   **** #if !_FS_READONLY
 979:lib/ff/ff.c   **** static
 980:lib/ff/ff.c   **** DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster
 981:lib/ff/ff.c   **** 	FATFS *fs,			/* File system object */
 982:lib/ff/ff.c   **** 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
 983:lib/ff/ff.c   **** )
 984:lib/ff/ff.c   **** {
 985:lib/ff/ff.c   **** 	DWORD cs, ncl, scl;
 986:lib/ff/ff.c   **** 	FRESULT res;
 987:lib/ff/ff.c   **** 
 988:lib/ff/ff.c   **** 
 989:lib/ff/ff.c   **** 	if (clst == 0) {		/* Create a new chain */
 990:lib/ff/ff.c   **** 		scl = fs->last_clust;			/* Get suggested start point */
 991:lib/ff/ff.c   **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
 992:lib/ff/ff.c   **** 	}
 993:lib/ff/ff.c   **** 	else {					/* Stretch the current chain */
 994:lib/ff/ff.c   **** 		cs = get_fat(fs, clst);			/* Check the cluster status */
 995:lib/ff/ff.c   **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
 996:lib/ff/ff.c   **** 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 997:lib/ff/ff.c   **** 		scl = clst;
 998:lib/ff/ff.c   **** 	}
 999:lib/ff/ff.c   **** 
1000:lib/ff/ff.c   **** 	ncl = scl;				/* Start cluster */
1001:lib/ff/ff.c   **** 	for (;;) {
1002:lib/ff/ff.c   **** 		ncl++;							/* Next cluster */
1003:lib/ff/ff.c   **** 		if (ncl >= fs->n_fatent) {		/* Wrap around */
1004:lib/ff/ff.c   **** 			ncl = 2;
1005:lib/ff/ff.c   **** 			if (ncl > scl) return 0;	/* No free cluster */
1006:lib/ff/ff.c   **** 		}
1007:lib/ff/ff.c   **** 		cs = get_fat(fs, ncl);			/* Get the cluster status */
1008:lib/ff/ff.c   **** 		if (cs == 0) break;				/* Found a free cluster */
1009:lib/ff/ff.c   **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
1010:lib/ff/ff.c   **** 			return cs;
1011:lib/ff/ff.c   **** 		if (ncl == scl) return 0;		/* No free cluster */
1012:lib/ff/ff.c   **** 	}
1013:lib/ff/ff.c   **** 
1014:lib/ff/ff.c   **** 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
1015:lib/ff/ff.c   **** 	if (res == FR_OK && clst != 0) {
1016:lib/ff/ff.c   **** 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
1017:lib/ff/ff.c   **** 	}
1018:lib/ff/ff.c   **** 	if (res == FR_OK) {
1019:lib/ff/ff.c   **** 		fs->last_clust = ncl;			/* Update FSINFO */
1020:lib/ff/ff.c   **** 		if (fs->free_clust != 0xFFFFFFFF) {
1021:lib/ff/ff.c   **** 			fs->free_clust--;
1022:lib/ff/ff.c   **** 			fs->fsi_flag = 1;
1023:lib/ff/ff.c   **** 		}
1024:lib/ff/ff.c   **** 	} else {
1025:lib/ff/ff.c   **** 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
1026:lib/ff/ff.c   **** 	}
1027:lib/ff/ff.c   **** 
1028:lib/ff/ff.c   **** 	return ncl;		/* Return new cluster number or error code */
1029:lib/ff/ff.c   **** }
1030:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
1031:lib/ff/ff.c   **** 
1032:lib/ff/ff.c   **** 
1033:lib/ff/ff.c   **** 
1034:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1035:lib/ff/ff.c   **** /* FAT handling - Convert offset into cluster with link map table        */
1036:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1037:lib/ff/ff.c   **** 
1038:lib/ff/ff.c   **** #if _USE_FASTSEEK
1039:lib/ff/ff.c   **** static
1040:lib/ff/ff.c   **** DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
1041:lib/ff/ff.c   **** 	FIL* fp,		/* Pointer to the file object */
1042:lib/ff/ff.c   **** 	DWORD ofs		/* File offset to be converted to cluster# */
1043:lib/ff/ff.c   **** )
1044:lib/ff/ff.c   **** {
 115              		.loc 1 1044 0
 116              		.cfi_startproc
 117              		@ args = 0, pretend = 0, frame = 0
 118              		@ frame_needed = 0, uses_anonymous_args = 0
 119              		@ link register save eliminated.
 120              	.LVL9:
1045:lib/ff/ff.c   **** 	DWORD cl, ncl, *tbl;
1046:lib/ff/ff.c   **** 
1047:lib/ff/ff.c   **** 
1048:lib/ff/ff.c   **** 	tbl = fp->cltbl + 1;	/* Top of CLMT */
 121              		.loc 1 1048 0
 122 0000 436A     		ldr	r3, [r0, #36]
 123 0002 0433     		adds	r3, r3, #4
 124              	.LVL10:
1049:lib/ff/ff.c   **** 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
 125              		.loc 1 1049 0
 126 0004 490A     		lsrs	r1, r1, #9
 127              	.LVL11:
 128 0006 0268     		ldr	r2, [r0, #0]
 129 0008 9078     		ldrb	r0, [r2, #2]	@ zero_extendqisi2
 130              	.LVL12:
 131 000a B1FBF0F1 		udiv	r1, r1, r0
 132              	.LVL13:
 133              	.L16:
1050:lib/ff/ff.c   **** 	for (;;) {
1051:lib/ff/ff.c   **** 		ncl = *tbl++;			/* Number of cluters in the fragment */
 134              		.loc 1 1051 0
 135 000e 1868     		ldr	r0, [r3, #0]
 136              	.LVL14:
1052:lib/ff/ff.c   **** 		if (!ncl) return 0;		/* End of table? (error) */
 137              		.loc 1 1052 0
 138 0010 30B1     		cbz	r0, .L14
1053:lib/ff/ff.c   **** 		if (cl < ncl) break;	/* In this fragment? */
 139              		.loc 1 1053 0
 140 0012 8142     		cmp	r1, r0
 141 0014 02D3     		bcc	.L15
1054:lib/ff/ff.c   **** 		cl -= ncl; tbl++;		/* Next fragment */
 142              		.loc 1 1054 0
 143 0016 091A     		subs	r1, r1, r0
 144              	.LVL15:
1040:lib/ff/ff.c   **** DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
 145              		.loc 1 1040 0
 146 0018 0833     		adds	r3, r3, #8
 147              	.LVL16:
1055:lib/ff/ff.c   **** 	}
 148              		.loc 1 1055 0
 149 001a F8E7     		b	.L16
 150              	.LVL17:
 151              	.L15:
1056:lib/ff/ff.c   **** 	return cl + *tbl;	/* Return the cluster number */
 152              		.loc 1 1056 0
 153 001c 5B68     		ldr	r3, [r3, #4]
 154              	.LVL18:
 155 001e C818     		adds	r0, r1, r3
 156              	.LVL19:
 157              	.L14:
1057:lib/ff/ff.c   **** }
 158              		.loc 1 1057 0
 159 0020 7047     		bx	lr
 160              		.cfi_endproc
 161              	.LFE11:
 163              		.section	.text.get_fileinfo,"ax",%progbits
 164              		.align	1
 165              		.thumb
 166              		.thumb_func
 168              	get_fileinfo:
 169              	.LFB21:
1058:lib/ff/ff.c   **** #endif	/* _USE_FASTSEEK */
1059:lib/ff/ff.c   **** 
1060:lib/ff/ff.c   **** 
1061:lib/ff/ff.c   **** 
1062:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1063:lib/ff/ff.c   **** /* Directory handling - Set directory index                              */
1064:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1065:lib/ff/ff.c   **** 
1066:lib/ff/ff.c   **** static
1067:lib/ff/ff.c   **** FRESULT dir_sdi (
1068:lib/ff/ff.c   **** 	DIR *dj,		/* Pointer to directory object */
1069:lib/ff/ff.c   **** 	WORD idx		/* Index of directory table */
1070:lib/ff/ff.c   **** )
1071:lib/ff/ff.c   **** {
1072:lib/ff/ff.c   **** 	DWORD clst;
1073:lib/ff/ff.c   **** 	WORD ic;
1074:lib/ff/ff.c   **** 
1075:lib/ff/ff.c   **** 
1076:lib/ff/ff.c   **** 	dj->index = idx;
1077:lib/ff/ff.c   **** 	clst = dj->sclust;
1078:lib/ff/ff.c   **** 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
1079:lib/ff/ff.c   **** 		return FR_INT_ERR;
1080:lib/ff/ff.c   **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
1081:lib/ff/ff.c   **** 		clst = dj->fs->dirbase;
1082:lib/ff/ff.c   **** 
1083:lib/ff/ff.c   **** 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
1084:lib/ff/ff.c   **** 		dj->clust = clst;
1085:lib/ff/ff.c   **** 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
1086:lib/ff/ff.c   **** 			return FR_INT_ERR;
1087:lib/ff/ff.c   **** 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
1088:lib/ff/ff.c   **** 	}
1089:lib/ff/ff.c   **** 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
1090:lib/ff/ff.c   **** 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
1091:lib/ff/ff.c   **** 		while (idx >= ic) {	/* Follow cluster chain */
1092:lib/ff/ff.c   **** 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
1093:lib/ff/ff.c   **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
1094:lib/ff/ff.c   **** 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
1095:lib/ff/ff.c   **** 				return FR_INT_ERR;
1096:lib/ff/ff.c   **** 			idx -= ic;
1097:lib/ff/ff.c   **** 		}
1098:lib/ff/ff.c   **** 		dj->clust = clst;
1099:lib/ff/ff.c   **** 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
1100:lib/ff/ff.c   **** 	}
1101:lib/ff/ff.c   **** 
1102:lib/ff/ff.c   **** 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector 
1103:lib/ff/ff.c   **** 
1104:lib/ff/ff.c   **** 	return FR_OK;	/* Seek succeeded */
1105:lib/ff/ff.c   **** }
1106:lib/ff/ff.c   **** 
1107:lib/ff/ff.c   **** 
1108:lib/ff/ff.c   **** 
1109:lib/ff/ff.c   **** 
1110:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1111:lib/ff/ff.c   **** /* Directory handling - Move directory table index next                  */
1112:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1113:lib/ff/ff.c   **** 
1114:lib/ff/ff.c   **** static
1115:lib/ff/ff.c   **** FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch
1116:lib/ff/ff.c   **** 	DIR *dj,		/* Pointer to directory object */
1117:lib/ff/ff.c   **** 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
1118:lib/ff/ff.c   **** )
1119:lib/ff/ff.c   **** {
1120:lib/ff/ff.c   **** 	DWORD clst;
1121:lib/ff/ff.c   **** 	WORD i;
1122:lib/ff/ff.c   **** 
1123:lib/ff/ff.c   **** 
1124:lib/ff/ff.c   **** 	stretch = stretch;		/* To suppress warning on read-only cfg. */
1125:lib/ff/ff.c   **** 	i = dj->index + 1;
1126:lib/ff/ff.c   **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
1127:lib/ff/ff.c   **** 		return FR_NO_FILE;
1128:lib/ff/ff.c   **** 
1129:lib/ff/ff.c   **** 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
1130:lib/ff/ff.c   **** 		dj->sect++;					/* Next sector */
1131:lib/ff/ff.c   **** 
1132:lib/ff/ff.c   **** 		if (dj->clust == 0) {	/* Static table */
1133:lib/ff/ff.c   **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
1134:lib/ff/ff.c   **** 				return FR_NO_FILE;
1135:lib/ff/ff.c   **** 		}
1136:lib/ff/ff.c   **** 		else {					/* Dynamic table */
1137:lib/ff/ff.c   **** 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
1138:lib/ff/ff.c   **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
1139:lib/ff/ff.c   **** 				if (clst <= 1) return FR_INT_ERR;
1140:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
1141:lib/ff/ff.c   **** 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
1142:lib/ff/ff.c   **** #if !_FS_READONLY
1143:lib/ff/ff.c   **** 					BYTE c;
1144:lib/ff/ff.c   **** 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
1145:lib/ff/ff.c   **** 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
1146:lib/ff/ff.c   **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
1147:lib/ff/ff.c   **** 					if (clst == 1) return FR_INT_ERR;
1148:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
1149:lib/ff/ff.c   **** 					/* Clean-up stretched table */
1150:lib/ff/ff.c   **** 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
1151:lib/ff/ff.c   **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
1152:lib/ff/ff.c   **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
1153:lib/ff/ff.c   **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
1154:lib/ff/ff.c   **** 						dj->fs->wflag = 1;
1155:lib/ff/ff.c   **** 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
1156:lib/ff/ff.c   **** 						dj->fs->winsect++;
1157:lib/ff/ff.c   **** 					}
1158:lib/ff/ff.c   **** 					dj->fs->winsect -= c;						/* Rewind window address */
1159:lib/ff/ff.c   **** #else
1160:lib/ff/ff.c   **** 					return FR_NO_FILE;			/* Report EOT */
1161:lib/ff/ff.c   **** #endif
1162:lib/ff/ff.c   **** 				}
1163:lib/ff/ff.c   **** 				dj->clust = clst;				/* Initialize data for new cluster */
1164:lib/ff/ff.c   **** 				dj->sect = clust2sect(dj->fs, clst);
1165:lib/ff/ff.c   **** 			}
1166:lib/ff/ff.c   **** 		}
1167:lib/ff/ff.c   **** 	}
1168:lib/ff/ff.c   **** 
1169:lib/ff/ff.c   **** 	dj->index = i;
1170:lib/ff/ff.c   **** 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
1171:lib/ff/ff.c   **** 
1172:lib/ff/ff.c   **** 	return FR_OK;
1173:lib/ff/ff.c   **** }
1174:lib/ff/ff.c   **** 
1175:lib/ff/ff.c   **** 
1176:lib/ff/ff.c   **** 
1177:lib/ff/ff.c   **** 
1178:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1179:lib/ff/ff.c   **** /* Directory handling - Load/Store start cluster number                  */
1180:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1181:lib/ff/ff.c   **** 
1182:lib/ff/ff.c   **** static
1183:lib/ff/ff.c   **** DWORD ld_clust (
1184:lib/ff/ff.c   **** 	FATFS *fs,	/* Pointer to the fs object */
1185:lib/ff/ff.c   **** 	BYTE *dir	/* Pointer to the directory entry */
1186:lib/ff/ff.c   **** )
1187:lib/ff/ff.c   **** {
1188:lib/ff/ff.c   **** 	DWORD cl;
1189:lib/ff/ff.c   **** 
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
1193:lib/ff/ff.c   **** 
1194:lib/ff/ff.c   **** 	return cl;
1195:lib/ff/ff.c   **** }
1196:lib/ff/ff.c   **** 
1197:lib/ff/ff.c   **** 
1198:lib/ff/ff.c   **** #if !_FS_READONLY
1199:lib/ff/ff.c   **** static
1200:lib/ff/ff.c   **** void st_clust (
1201:lib/ff/ff.c   **** 	BYTE *dir,	/* Pointer to the directory entry */
1202:lib/ff/ff.c   **** 	DWORD cl	/* Value to be set */
1203:lib/ff/ff.c   **** )
1204:lib/ff/ff.c   **** {
1205:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusLO, cl);
1206:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
1207:lib/ff/ff.c   **** }
1208:lib/ff/ff.c   **** #endif
1209:lib/ff/ff.c   **** 
1210:lib/ff/ff.c   **** 
1211:lib/ff/ff.c   **** 
1212:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1213:lib/ff/ff.c   **** /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1214:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1215:lib/ff/ff.c   **** #if _USE_LFN
1216:lib/ff/ff.c   **** static
1217:lib/ff/ff.c   **** const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory 
1218:lib/ff/ff.c   **** 
1219:lib/ff/ff.c   **** 
1220:lib/ff/ff.c   **** static
1221:lib/ff/ff.c   **** int cmp_lfn (			/* 1:Matched, 0:Not matched */
1222:lib/ff/ff.c   **** 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
1223:lib/ff/ff.c   **** 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
1224:lib/ff/ff.c   **** )
1225:lib/ff/ff.c   **** {
1226:lib/ff/ff.c   **** 	UINT i, s;
1227:lib/ff/ff.c   **** 	WCHAR wc, uc;
1228:lib/ff/ff.c   **** 
1229:lib/ff/ff.c   **** 
1230:lib/ff/ff.c   **** 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
1231:lib/ff/ff.c   **** 	s = 0; wc = 1;
1232:lib/ff/ff.c   **** 	do {
1233:lib/ff/ff.c   **** 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
1234:lib/ff/ff.c   **** 		if (wc) {	/* Last char has not been processed */
1235:lib/ff/ff.c   **** 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
1236:lib/ff/ff.c   **** 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
1237:lib/ff/ff.c   **** 				return 0;				/* Not matched */
1238:lib/ff/ff.c   **** 		} else {
1239:lib/ff/ff.c   **** 			if (uc != 0xFFFF) return 0;	/* Check filler */
1240:lib/ff/ff.c   **** 		}
1241:lib/ff/ff.c   **** 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
1242:lib/ff/ff.c   **** 
1243:lib/ff/ff.c   **** 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
1244:lib/ff/ff.c   **** 		return 0;
1245:lib/ff/ff.c   **** 
1246:lib/ff/ff.c   **** 	return 1;						/* The part of LFN matched */
1247:lib/ff/ff.c   **** }
1248:lib/ff/ff.c   **** 
1249:lib/ff/ff.c   **** 
1250:lib/ff/ff.c   **** 
1251:lib/ff/ff.c   **** static
1252:lib/ff/ff.c   **** int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
1253:lib/ff/ff.c   **** 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
1254:lib/ff/ff.c   **** 	BYTE *dir			/* Pointer to the directory entry */
1255:lib/ff/ff.c   **** )
1256:lib/ff/ff.c   **** {
1257:lib/ff/ff.c   **** 	UINT i, s;
1258:lib/ff/ff.c   **** 	WCHAR wc, uc;
1259:lib/ff/ff.c   **** 
1260:lib/ff/ff.c   **** 
1261:lib/ff/ff.c   **** 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
1262:lib/ff/ff.c   **** 
1263:lib/ff/ff.c   **** 	s = 0; wc = 1;
1264:lib/ff/ff.c   **** 	do {
1265:lib/ff/ff.c   **** 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
1266:lib/ff/ff.c   **** 		if (wc) {	/* Last char has not been processed */
1267:lib/ff/ff.c   **** 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
1268:lib/ff/ff.c   **** 			lfnbuf[i++] = wc = uc;			/* Store it */
1269:lib/ff/ff.c   **** 		} else {
1270:lib/ff/ff.c   **** 			if (uc != 0xFFFF) return 0;		/* Check filler */
1271:lib/ff/ff.c   **** 		}
1272:lib/ff/ff.c   **** 	} while (++s < 13);						/* Read all character in the entry */
1273:lib/ff/ff.c   **** 
1274:lib/ff/ff.c   **** 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
1275:lib/ff/ff.c   **** 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
1276:lib/ff/ff.c   **** 		lfnbuf[i] = 0;
1277:lib/ff/ff.c   **** 	}
1278:lib/ff/ff.c   **** 
1279:lib/ff/ff.c   **** 	return 1;
1280:lib/ff/ff.c   **** }
1281:lib/ff/ff.c   **** 
1282:lib/ff/ff.c   **** 
1283:lib/ff/ff.c   **** #if !_FS_READONLY
1284:lib/ff/ff.c   **** static
1285:lib/ff/ff.c   **** void fit_lfn (
1286:lib/ff/ff.c   **** 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
1287:lib/ff/ff.c   **** 	BYTE *dir,				/* Pointer to the directory entry */
1288:lib/ff/ff.c   **** 	BYTE ord,				/* LFN order (1-20) */
1289:lib/ff/ff.c   **** 	BYTE sum				/* SFN sum */
1290:lib/ff/ff.c   **** )
1291:lib/ff/ff.c   **** {
1292:lib/ff/ff.c   **** 	UINT i, s;
1293:lib/ff/ff.c   **** 	WCHAR wc;
1294:lib/ff/ff.c   **** 
1295:lib/ff/ff.c   **** 
1296:lib/ff/ff.c   **** 	dir[LDIR_Chksum] = sum;			/* Set check sum */
1297:lib/ff/ff.c   **** 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
1298:lib/ff/ff.c   **** 	dir[LDIR_Type] = 0;
1299:lib/ff/ff.c   **** 	ST_WORD(dir+LDIR_FstClusLO, 0);
1300:lib/ff/ff.c   **** 
1301:lib/ff/ff.c   **** 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
1302:lib/ff/ff.c   **** 	s = wc = 0;
1303:lib/ff/ff.c   **** 	do {
1304:lib/ff/ff.c   **** 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
1305:lib/ff/ff.c   **** 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
1306:lib/ff/ff.c   **** 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
1307:lib/ff/ff.c   **** 	} while (++s < 13);
1308:lib/ff/ff.c   **** 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
1309:lib/ff/ff.c   **** 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
1310:lib/ff/ff.c   **** }
1311:lib/ff/ff.c   **** 
1312:lib/ff/ff.c   **** #endif
1313:lib/ff/ff.c   **** #endif
1314:lib/ff/ff.c   **** 
1315:lib/ff/ff.c   **** 
1316:lib/ff/ff.c   **** 
1317:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1318:lib/ff/ff.c   **** /* Create numbered name                                                  */
1319:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1320:lib/ff/ff.c   **** #if _USE_LFN
1321:lib/ff/ff.c   **** void gen_numname (
1322:lib/ff/ff.c   **** 	BYTE *dst,			/* Pointer to generated SFN */
1323:lib/ff/ff.c   **** 	const BYTE *src,	/* Pointer to source SFN to be modified */
1324:lib/ff/ff.c   **** 	const WCHAR *lfn,	/* Pointer to LFN */
1325:lib/ff/ff.c   **** 	WORD seq			/* Sequence number */
1326:lib/ff/ff.c   **** )
1327:lib/ff/ff.c   **** {
1328:lib/ff/ff.c   **** 	BYTE ns[8], c;
1329:lib/ff/ff.c   **** 	UINT i, j;
1330:lib/ff/ff.c   **** 
1331:lib/ff/ff.c   **** 
1332:lib/ff/ff.c   **** 	mem_cpy(dst, src, 11);
1333:lib/ff/ff.c   **** 
1334:lib/ff/ff.c   **** 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
1335:lib/ff/ff.c   **** 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
1336:lib/ff/ff.c   **** 	}
1337:lib/ff/ff.c   **** 
1338:lib/ff/ff.c   **** 	/* itoa (hexdecimal) */
1339:lib/ff/ff.c   **** 	i = 7;
1340:lib/ff/ff.c   **** 	do {
1341:lib/ff/ff.c   **** 		c = (seq % 16) + '0';
1342:lib/ff/ff.c   **** 		if (c > '9') c += 7;
1343:lib/ff/ff.c   **** 		ns[i--] = c;
1344:lib/ff/ff.c   **** 		seq /= 16;
1345:lib/ff/ff.c   **** 	} while (seq);
1346:lib/ff/ff.c   **** 	ns[i] = '~';
1347:lib/ff/ff.c   **** 
1348:lib/ff/ff.c   **** 	/* Append the number */
1349:lib/ff/ff.c   **** 	for (j = 0; j < i && dst[j] != ' '; j++) {
1350:lib/ff/ff.c   **** 		if (IsDBCS1(dst[j])) {
1351:lib/ff/ff.c   **** 			if (j == i - 1) break;
1352:lib/ff/ff.c   **** 			j++;
1353:lib/ff/ff.c   **** 		}
1354:lib/ff/ff.c   **** 	}
1355:lib/ff/ff.c   **** 	do {
1356:lib/ff/ff.c   **** 		dst[j++] = (i < 8) ? ns[i++] : ' ';
1357:lib/ff/ff.c   **** 	} while (j < 8);
1358:lib/ff/ff.c   **** }
1359:lib/ff/ff.c   **** #endif
1360:lib/ff/ff.c   **** 
1361:lib/ff/ff.c   **** 
1362:lib/ff/ff.c   **** 
1363:lib/ff/ff.c   **** 
1364:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1365:lib/ff/ff.c   **** /* Calculate sum of an SFN                                               */
1366:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1367:lib/ff/ff.c   **** #if _USE_LFN
1368:lib/ff/ff.c   **** static
1369:lib/ff/ff.c   **** BYTE sum_sfn (
1370:lib/ff/ff.c   **** 	const BYTE *dir		/* Ptr to directory entry */
1371:lib/ff/ff.c   **** )
1372:lib/ff/ff.c   **** {
1373:lib/ff/ff.c   **** 	BYTE sum = 0;
1374:lib/ff/ff.c   **** 	UINT n = 11;
1375:lib/ff/ff.c   **** 
1376:lib/ff/ff.c   **** 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1377:lib/ff/ff.c   **** 	return sum;
1378:lib/ff/ff.c   **** }
1379:lib/ff/ff.c   **** #endif
1380:lib/ff/ff.c   **** 
1381:lib/ff/ff.c   **** 
1382:lib/ff/ff.c   **** 
1383:lib/ff/ff.c   **** 
1384:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1385:lib/ff/ff.c   **** /* Directory handling - Find an object in the directory                  */
1386:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1387:lib/ff/ff.c   **** 
1388:lib/ff/ff.c   **** static
1389:lib/ff/ff.c   **** FRESULT dir_find (
1390:lib/ff/ff.c   **** 	DIR *dj			/* Pointer to the directory object linked to the file name */
1391:lib/ff/ff.c   **** )
1392:lib/ff/ff.c   **** {
1393:lib/ff/ff.c   **** 	FRESULT res;
1394:lib/ff/ff.c   **** 	BYTE c, *dir;
1395:lib/ff/ff.c   **** #if _USE_LFN
1396:lib/ff/ff.c   **** 	BYTE a, ord, sum;
1397:lib/ff/ff.c   **** #endif
1398:lib/ff/ff.c   **** 
1399:lib/ff/ff.c   **** 	res = dir_sdi(dj, 0);			/* Rewind directory object */
1400:lib/ff/ff.c   **** 	if (res != FR_OK) return res;
1401:lib/ff/ff.c   **** 
1402:lib/ff/ff.c   **** #if _USE_LFN
1403:lib/ff/ff.c   **** 	ord = sum = 0xFF;
1404:lib/ff/ff.c   **** #endif
1405:lib/ff/ff.c   **** 	do {
1406:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
1407:lib/ff/ff.c   **** 		if (res != FR_OK) break;
1408:lib/ff/ff.c   **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
1409:lib/ff/ff.c   **** 		c = dir[DIR_Name];
1410:lib/ff/ff.c   **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
1411:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1412:lib/ff/ff.c   **** 		a = dir[DIR_Attr] & AM_MASK;
1413:lib/ff/ff.c   **** 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
1414:lib/ff/ff.c   **** 			ord = 0xFF;
1415:lib/ff/ff.c   **** 		} else {
1416:lib/ff/ff.c   **** 			if (a == AM_LFN) {			/* An LFN entry is found */
1417:lib/ff/ff.c   **** 				if (dj->lfn) {
1418:lib/ff/ff.c   **** 					if (c & LLE) {		/* Is it start of LFN sequence? */
1419:lib/ff/ff.c   **** 						sum = dir[LDIR_Chksum];
1420:lib/ff/ff.c   **** 						c &= ~LLE; ord = c;	/* LFN start order */
1421:lib/ff/ff.c   **** 						dj->lfn_idx = dj->index;
1422:lib/ff/ff.c   **** 					}
1423:lib/ff/ff.c   **** 					/* Check validity of the LFN entry and compare it with given name */
1424:lib/ff/ff.c   **** 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1425:lib/ff/ff.c   **** 				}
1426:lib/ff/ff.c   **** 			} else {					/* An SFN entry is found */
1427:lib/ff/ff.c   **** 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
1428:lib/ff/ff.c   **** 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
1429:lib/ff/ff.c   **** 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
1430:lib/ff/ff.c   **** 			}
1431:lib/ff/ff.c   **** 		}
1432:lib/ff/ff.c   **** #else		/* Non LFN configuration */
1433:lib/ff/ff.c   **** 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
1434:lib/ff/ff.c   **** 			break;
1435:lib/ff/ff.c   **** #endif
1436:lib/ff/ff.c   **** 		res = dir_next(dj, 0);		/* Next entry */
1437:lib/ff/ff.c   **** 	} while (res == FR_OK);
1438:lib/ff/ff.c   **** 
1439:lib/ff/ff.c   **** 	return res;
1440:lib/ff/ff.c   **** }
1441:lib/ff/ff.c   **** 
1442:lib/ff/ff.c   **** 
1443:lib/ff/ff.c   **** 
1444:lib/ff/ff.c   **** 
1445:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1446:lib/ff/ff.c   **** /* Read an object from the directory                                     */
1447:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1448:lib/ff/ff.c   **** #if _FS_MINIMIZE <= 1
1449:lib/ff/ff.c   **** static
1450:lib/ff/ff.c   **** FRESULT dir_read (
1451:lib/ff/ff.c   **** 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
1452:lib/ff/ff.c   **** )
1453:lib/ff/ff.c   **** {
1454:lib/ff/ff.c   **** 	FRESULT res;
1455:lib/ff/ff.c   **** 	BYTE c, *dir;
1456:lib/ff/ff.c   **** #if _USE_LFN
1457:lib/ff/ff.c   **** 	BYTE a, ord = 0xFF, sum = 0xFF;
1458:lib/ff/ff.c   **** #endif
1459:lib/ff/ff.c   **** 
1460:lib/ff/ff.c   **** 	res = FR_NO_FILE;
1461:lib/ff/ff.c   **** 	while (dj->sect) {
1462:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
1463:lib/ff/ff.c   **** 		if (res != FR_OK) break;
1464:lib/ff/ff.c   **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
1465:lib/ff/ff.c   **** 		c = dir[DIR_Name];
1466:lib/ff/ff.c   **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
1467:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1468:lib/ff/ff.c   **** 		a = dir[DIR_Attr] & AM_MASK;
1469:lib/ff/ff.c   **** 		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without 
1470:lib/ff/ff.c   **** 			ord = 0xFF;
1471:lib/ff/ff.c   **** 		} else {
1472:lib/ff/ff.c   **** 			if (a == AM_LFN) {			/* An LFN entry is found */
1473:lib/ff/ff.c   **** 				if (c & LLE) {			/* Is it start of LFN sequence? */
1474:lib/ff/ff.c   **** 					sum = dir[LDIR_Chksum];
1475:lib/ff/ff.c   **** 					c &= ~LLE; ord = c;
1476:lib/ff/ff.c   **** 					dj->lfn_idx = dj->index;
1477:lib/ff/ff.c   **** 				}
1478:lib/ff/ff.c   **** 				/* Check LFN validity and capture it */
1479:lib/ff/ff.c   **** 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1480:lib/ff/ff.c   **** 			} else {					/* An SFN entry is found */
1481:lib/ff/ff.c   **** 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
1482:lib/ff/ff.c   **** 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
1483:lib/ff/ff.c   **** 				break;
1484:lib/ff/ff.c   **** 			}
1485:lib/ff/ff.c   **** 		}
1486:lib/ff/ff.c   **** #else		/* Non LFN configuration */
1487:lib/ff/ff.c   **** 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
1488:lib/ff/ff.c   **** 			break;
1489:lib/ff/ff.c   **** #endif
1490:lib/ff/ff.c   **** 		res = dir_next(dj, 0);				/* Next entry */
1491:lib/ff/ff.c   **** 		if (res != FR_OK) break;
1492:lib/ff/ff.c   **** 	}
1493:lib/ff/ff.c   **** 
1494:lib/ff/ff.c   **** 	if (res != FR_OK) dj->sect = 0;
1495:lib/ff/ff.c   **** 
1496:lib/ff/ff.c   **** 	return res;
1497:lib/ff/ff.c   **** }
1498:lib/ff/ff.c   **** #endif
1499:lib/ff/ff.c   **** 
1500:lib/ff/ff.c   **** 
1501:lib/ff/ff.c   **** 
1502:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1503:lib/ff/ff.c   **** /* Register an object to the directory                                   */
1504:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1505:lib/ff/ff.c   **** #if !_FS_READONLY
1506:lib/ff/ff.c   **** static
1507:lib/ff/ff.c   **** FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_D
1508:lib/ff/ff.c   **** 	DIR *dj				/* Target directory with object name to be created */
1509:lib/ff/ff.c   **** )
1510:lib/ff/ff.c   **** {
1511:lib/ff/ff.c   **** 	FRESULT res;
1512:lib/ff/ff.c   **** 	BYTE c, *dir;
1513:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1514:lib/ff/ff.c   **** 	WORD n, ne, is;
1515:lib/ff/ff.c   **** 	BYTE sn[12], *fn, sum;
1516:lib/ff/ff.c   **** 	WCHAR *lfn;
1517:lib/ff/ff.c   **** 
1518:lib/ff/ff.c   **** 
1519:lib/ff/ff.c   **** 	fn = dj->fn; lfn = dj->lfn;
1520:lib/ff/ff.c   **** 	mem_cpy(sn, fn, 12);
1521:lib/ff/ff.c   **** 
1522:lib/ff/ff.c   **** 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
1523:lib/ff/ff.c   **** 		return FR_INVALID_NAME;
1524:lib/ff/ff.c   **** 
1525:lib/ff/ff.c   **** 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
1526:lib/ff/ff.c   **** 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
1527:lib/ff/ff.c   **** 		for (n = 1; n < 100; n++) {
1528:lib/ff/ff.c   **** 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
1529:lib/ff/ff.c   **** 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
1530:lib/ff/ff.c   **** 			if (res != FR_OK) break;
1531:lib/ff/ff.c   **** 		}
1532:lib/ff/ff.c   **** 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
1533:lib/ff/ff.c   **** 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
1534:lib/ff/ff.c   **** 		fn[NS] = sn[NS]; dj->lfn = lfn;
1535:lib/ff/ff.c   **** 	}
1536:lib/ff/ff.c   **** 
1537:lib/ff/ff.c   **** 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
1538:lib/ff/ff.c   **** 		for (ne = 0; lfn[ne]; ne++) ;
1539:lib/ff/ff.c   **** 		ne = (ne + 25) / 13;
1540:lib/ff/ff.c   **** 	} else {						/* Otherwise reserve only an SFN entry. */
1541:lib/ff/ff.c   **** 		ne = 1;
1542:lib/ff/ff.c   **** 	}
1543:lib/ff/ff.c   **** 
1544:lib/ff/ff.c   **** 	/* Reserve contiguous entries */
1545:lib/ff/ff.c   **** 	res = dir_sdi(dj, 0);
1546:lib/ff/ff.c   **** 	if (res != FR_OK) return res;
1547:lib/ff/ff.c   **** 	n = is = 0;
1548:lib/ff/ff.c   **** 	do {
1549:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
1550:lib/ff/ff.c   **** 		if (res != FR_OK) break;
1551:lib/ff/ff.c   **** 		c = *dj->dir;				/* Check the entry status */
1552:lib/ff/ff.c   **** 		if (c == DDE || c == 0) {	/* Is it a blank entry? */
1553:lib/ff/ff.c   **** 			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
1554:lib/ff/ff.c   **** 			if (++n == ne) break;	/* A contiguous entry that required count is found */
1555:lib/ff/ff.c   **** 		} else {
1556:lib/ff/ff.c   **** 			n = 0;					/* Not a blank entry. Restart to search */
1557:lib/ff/ff.c   **** 		}
1558:lib/ff/ff.c   **** 		res = dir_next(dj, 1);		/* Next entry with table stretch */
1559:lib/ff/ff.c   **** 	} while (res == FR_OK);
1560:lib/ff/ff.c   **** 
1561:lib/ff/ff.c   **** 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
1562:lib/ff/ff.c   **** 		res = dir_sdi(dj, is);
1563:lib/ff/ff.c   **** 		if (res == FR_OK) {
1564:lib/ff/ff.c   **** 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
1565:lib/ff/ff.c   **** 			ne--;
1566:lib/ff/ff.c   **** 			do {					/* Store LFN entries in bottom first */
1567:lib/ff/ff.c   **** 				res = move_window(dj->fs, dj->sect);
1568:lib/ff/ff.c   **** 				if (res != FR_OK) break;
1569:lib/ff/ff.c   **** 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
1570:lib/ff/ff.c   **** 				dj->fs->wflag = 1;
1571:lib/ff/ff.c   **** 				res = dir_next(dj, 0);	/* Next entry */
1572:lib/ff/ff.c   **** 			} while (res == FR_OK && --ne);
1573:lib/ff/ff.c   **** 		}
1574:lib/ff/ff.c   **** 	}
1575:lib/ff/ff.c   **** 
1576:lib/ff/ff.c   **** #else	/* Non LFN configuration */
1577:lib/ff/ff.c   **** 	res = dir_sdi(dj, 0);
1578:lib/ff/ff.c   **** 	if (res == FR_OK) {
1579:lib/ff/ff.c   **** 		do {	/* Find a blank entry for the SFN */
1580:lib/ff/ff.c   **** 			res = move_window(dj->fs, dj->sect);
1581:lib/ff/ff.c   **** 			if (res != FR_OK) break;
1582:lib/ff/ff.c   **** 			c = *dj->dir;
1583:lib/ff/ff.c   **** 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
1584:lib/ff/ff.c   **** 			res = dir_next(dj, 1);			/* Next entry with table stretch */
1585:lib/ff/ff.c   **** 		} while (res == FR_OK);
1586:lib/ff/ff.c   **** 	}
1587:lib/ff/ff.c   **** #endif
1588:lib/ff/ff.c   **** 
1589:lib/ff/ff.c   **** 	if (res == FR_OK) {		/* Initialize the SFN entry */
1590:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
1591:lib/ff/ff.c   **** 		if (res == FR_OK) {
1592:lib/ff/ff.c   **** 			dir = dj->dir;
1593:lib/ff/ff.c   **** 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
1594:lib/ff/ff.c   **** 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
1595:lib/ff/ff.c   **** #if _USE_LFN
1596:lib/ff/ff.c   **** 			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
1597:lib/ff/ff.c   **** #endif
1598:lib/ff/ff.c   **** 			dj->fs->wflag = 1;
1599:lib/ff/ff.c   **** 		}
1600:lib/ff/ff.c   **** 	}
1601:lib/ff/ff.c   **** 
1602:lib/ff/ff.c   **** 	return res;
1603:lib/ff/ff.c   **** }
1604:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
1605:lib/ff/ff.c   **** 
1606:lib/ff/ff.c   **** 
1607:lib/ff/ff.c   **** 
1608:lib/ff/ff.c   **** 
1609:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1610:lib/ff/ff.c   **** /* Remove an object from the directory                                   */
1611:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1612:lib/ff/ff.c   **** #if !_FS_READONLY && !_FS_MINIMIZE
1613:lib/ff/ff.c   **** static
1614:lib/ff/ff.c   **** FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
1615:lib/ff/ff.c   **** 	DIR *dj				/* Directory object pointing the entry to be removed */
1616:lib/ff/ff.c   **** )
1617:lib/ff/ff.c   **** {
1618:lib/ff/ff.c   **** 	FRESULT res;
1619:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1620:lib/ff/ff.c   **** 	WORD i;
1621:lib/ff/ff.c   **** 
1622:lib/ff/ff.c   **** 	i = dj->index;	/* SFN index */
1623:lib/ff/ff.c   **** 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of th
1624:lib/ff/ff.c   **** 	if (res == FR_OK) {
1625:lib/ff/ff.c   **** 		do {
1626:lib/ff/ff.c   **** 			res = move_window(dj->fs, dj->sect);
1627:lib/ff/ff.c   **** 			if (res != FR_OK) break;
1628:lib/ff/ff.c   **** 			*dj->dir = DDE;			/* Mark the entry "deleted" */
1629:lib/ff/ff.c   **** 			dj->fs->wflag = 1;
1630:lib/ff/ff.c   **** 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
1631:lib/ff/ff.c   **** 			res = dir_next(dj, 0);		/* Next entry */
1632:lib/ff/ff.c   **** 		} while (res == FR_OK);
1633:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) res = FR_INT_ERR;
1634:lib/ff/ff.c   **** 	}
1635:lib/ff/ff.c   **** 
1636:lib/ff/ff.c   **** #else			/* Non LFN configuration */
1637:lib/ff/ff.c   **** 	res = dir_sdi(dj, dj->index);
1638:lib/ff/ff.c   **** 	if (res == FR_OK) {
1639:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
1640:lib/ff/ff.c   **** 		if (res == FR_OK) {
1641:lib/ff/ff.c   **** 			*dj->dir = DDE;			/* Mark the entry "deleted" */
1642:lib/ff/ff.c   **** 			dj->fs->wflag = 1;
1643:lib/ff/ff.c   **** 		}
1644:lib/ff/ff.c   **** 	}
1645:lib/ff/ff.c   **** #endif
1646:lib/ff/ff.c   **** 
1647:lib/ff/ff.c   **** 	return res;
1648:lib/ff/ff.c   **** }
1649:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
1650:lib/ff/ff.c   **** 
1651:lib/ff/ff.c   **** 
1652:lib/ff/ff.c   **** 
1653:lib/ff/ff.c   **** 
1654:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1655:lib/ff/ff.c   **** /* Pick a segment and create the object name in directory form           */
1656:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1657:lib/ff/ff.c   **** 
1658:lib/ff/ff.c   **** static
1659:lib/ff/ff.c   **** FRESULT create_name (
1660:lib/ff/ff.c   **** 	DIR *dj,			/* Pointer to the directory object */
1661:lib/ff/ff.c   **** 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
1662:lib/ff/ff.c   **** )
1663:lib/ff/ff.c   **** {
1664:lib/ff/ff.c   **** #ifdef _EXCVT
1665:lib/ff/ff.c   **** 	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
1666:lib/ff/ff.c   **** #endif
1667:lib/ff/ff.c   **** 
1668:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1669:lib/ff/ff.c   **** 	BYTE b, cf;
1670:lib/ff/ff.c   **** 	WCHAR w, *lfn;
1671:lib/ff/ff.c   **** 	UINT i, ni, si, di;
1672:lib/ff/ff.c   **** 	const TCHAR *p;
1673:lib/ff/ff.c   **** 
1674:lib/ff/ff.c   **** 	/* Create LFN in Unicode */
1675:lib/ff/ff.c   **** 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
1676:lib/ff/ff.c   **** 	lfn = dj->lfn;
1677:lib/ff/ff.c   **** 	si = di = 0;
1678:lib/ff/ff.c   **** 	for (;;) {
1679:lib/ff/ff.c   **** 		w = p[si++];					/* Get a character */
1680:lib/ff/ff.c   **** 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
1681:lib/ff/ff.c   **** 		if (di >= _MAX_LFN)				/* Reject too long name */
1682:lib/ff/ff.c   **** 			return FR_INVALID_NAME;
1683:lib/ff/ff.c   **** #if !_LFN_UNICODE
1684:lib/ff/ff.c   **** 		w &= 0xFF;
1685:lib/ff/ff.c   **** 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1686:lib/ff/ff.c   **** 			b = (BYTE)p[si++];			/* Get 2nd byte */
1687:lib/ff/ff.c   **** 			if (!IsDBCS2(b))
1688:lib/ff/ff.c   **** 				return FR_INVALID_NAME;	/* Reject invalid sequence */
1689:lib/ff/ff.c   **** 			w = (w << 8) + b;			/* Create a DBC */
1690:lib/ff/ff.c   **** 		}
1691:lib/ff/ff.c   **** 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
1692:lib/ff/ff.c   **** 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
1693:lib/ff/ff.c   **** #endif
1694:lib/ff/ff.c   **** 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1695:lib/ff/ff.c   **** 			return FR_INVALID_NAME;
1696:lib/ff/ff.c   **** 		lfn[di++] = w;					/* Store the Unicode char */
1697:lib/ff/ff.c   **** 	}
1698:lib/ff/ff.c   **** 	*path = &p[si];						/* Return pointer to the next segment */
1699:lib/ff/ff.c   **** 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
1700:lib/ff/ff.c   **** #if _FS_RPATH
1701:lib/ff/ff.c   **** 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1702:lib/ff/ff.c   **** 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1703:lib/ff/ff.c   **** 		lfn[di] = 0;
1704:lib/ff/ff.c   **** 		for (i = 0; i < 11; i++)
1705:lib/ff/ff.c   **** 			dj->fn[i] = (i < di) ? '.' : ' ';
1706:lib/ff/ff.c   **** 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
1707:lib/ff/ff.c   **** 		return FR_OK;
1708:lib/ff/ff.c   **** 	}
1709:lib/ff/ff.c   **** #endif
1710:lib/ff/ff.c   **** 	while (di) {						/* Strip trailing spaces and dots */
1711:lib/ff/ff.c   **** 		w = lfn[di-1];
1712:lib/ff/ff.c   **** 		if (w != ' ' && w != '.') break;
1713:lib/ff/ff.c   **** 		di--;
1714:lib/ff/ff.c   **** 	}
1715:lib/ff/ff.c   **** 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
1716:lib/ff/ff.c   **** 
1717:lib/ff/ff.c   **** 	lfn[di] = 0;						/* LFN is created */
1718:lib/ff/ff.c   **** 
1719:lib/ff/ff.c   **** 	/* Create SFN in directory form */
1720:lib/ff/ff.c   **** 	mem_set(dj->fn, ' ', 11);
1721:lib/ff/ff.c   **** 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
1722:lib/ff/ff.c   **** 	if (si) cf |= NS_LOSS | NS_LFN;
1723:lib/ff/ff.c   **** 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
1724:lib/ff/ff.c   **** 
1725:lib/ff/ff.c   **** 	b = i = 0; ni = 8;
1726:lib/ff/ff.c   **** 	for (;;) {
1727:lib/ff/ff.c   **** 		w = lfn[si++];					/* Get an LFN char */
1728:lib/ff/ff.c   **** 		if (!w) break;					/* Break on end of the LFN */
1729:lib/ff/ff.c   **** 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
1730:lib/ff/ff.c   **** 			cf |= NS_LOSS | NS_LFN; continue;
1731:lib/ff/ff.c   **** 		}
1732:lib/ff/ff.c   **** 
1733:lib/ff/ff.c   **** 		if (i >= ni || si == di) {		/* Extension or end of SFN */
1734:lib/ff/ff.c   **** 			if (ni == 11) {				/* Long extension */
1735:lib/ff/ff.c   **** 				cf |= NS_LOSS | NS_LFN; break;
1736:lib/ff/ff.c   **** 			}
1737:lib/ff/ff.c   **** 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
1738:lib/ff/ff.c   **** 			if (si > di) break;			/* No extension */
1739:lib/ff/ff.c   **** 			si = di; i = 8; ni = 11;	/* Enter extension section */
1740:lib/ff/ff.c   **** 			b <<= 2; continue;
1741:lib/ff/ff.c   **** 		}
1742:lib/ff/ff.c   **** 
1743:lib/ff/ff.c   **** 		if (w >= 0x80) {				/* Non ASCII char */
1744:lib/ff/ff.c   **** #ifdef _EXCVT
1745:lib/ff/ff.c   **** 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
1746:lib/ff/ff.c   **** 			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
1747:lib/ff/ff.c   **** #else
1748:lib/ff/ff.c   **** 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
1749:lib/ff/ff.c   **** #endif
1750:lib/ff/ff.c   **** 			cf |= NS_LFN;				/* Force create LFN entry */
1751:lib/ff/ff.c   **** 		}
1752:lib/ff/ff.c   **** 
1753:lib/ff/ff.c   **** 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
1754:lib/ff/ff.c   **** 			if (i >= ni - 1) {
1755:lib/ff/ff.c   **** 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1756:lib/ff/ff.c   **** 			}
1757:lib/ff/ff.c   **** 			dj->fn[i++] = (BYTE)(w >> 8);
1758:lib/ff/ff.c   **** 		} else {						/* Single byte char */
1759:lib/ff/ff.c   **** 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
1760:lib/ff/ff.c   **** 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1761:lib/ff/ff.c   **** 			} else {
1762:lib/ff/ff.c   **** 				if (IsUpper(w)) {		/* ASCII large capital */
1763:lib/ff/ff.c   **** 					b |= 2;
1764:lib/ff/ff.c   **** 				} else {
1765:lib/ff/ff.c   **** 					if (IsLower(w)) {	/* ASCII small capital */
1766:lib/ff/ff.c   **** 						b |= 1; w -= 0x20;
1767:lib/ff/ff.c   **** 					}
1768:lib/ff/ff.c   **** 				}
1769:lib/ff/ff.c   **** 			}
1770:lib/ff/ff.c   **** 		}
1771:lib/ff/ff.c   **** 		dj->fn[i++] = (BYTE)w;
1772:lib/ff/ff.c   **** 	}
1773:lib/ff/ff.c   **** 
1774:lib/ff/ff.c   **** 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace i
1775:lib/ff/ff.c   **** 
1776:lib/ff/ff.c   **** 	if (ni == 8) b <<= 2;
1777:lib/ff/ff.c   **** 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capital
1778:lib/ff/ff.c   **** 		cf |= NS_LFN;
1779:lib/ff/ff.c   **** 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are create
1780:lib/ff/ff.c   **** 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
1781:lib/ff/ff.c   **** 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
1782:lib/ff/ff.c   **** 	}
1783:lib/ff/ff.c   **** 
1784:lib/ff/ff.c   **** 	dj->fn[NS] = cf;	/* SFN is created */
1785:lib/ff/ff.c   **** 
1786:lib/ff/ff.c   **** 	return FR_OK;
1787:lib/ff/ff.c   **** 
1788:lib/ff/ff.c   **** 
1789:lib/ff/ff.c   **** #else	/* Non-LFN configuration */
1790:lib/ff/ff.c   **** 	BYTE b, c, d, *sfn;
1791:lib/ff/ff.c   **** 	UINT ni, si, i;
1792:lib/ff/ff.c   **** 	const char *p;
1793:lib/ff/ff.c   **** 
1794:lib/ff/ff.c   **** 	/* Create file name in directory form */
1795:lib/ff/ff.c   **** 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
1796:lib/ff/ff.c   **** 	sfn = dj->fn;
1797:lib/ff/ff.c   **** 	mem_set(sfn, ' ', 11);
1798:lib/ff/ff.c   **** 	si = i = b = 0; ni = 8;
1799:lib/ff/ff.c   **** #if _FS_RPATH
1800:lib/ff/ff.c   **** 	if (p[si] == '.') { /* Is this a dot entry? */
1801:lib/ff/ff.c   **** 		for (;;) {
1802:lib/ff/ff.c   **** 			c = (BYTE)p[si++];
1803:lib/ff/ff.c   **** 			if (c != '.' || si >= 3) break;
1804:lib/ff/ff.c   **** 			sfn[i++] = c;
1805:lib/ff/ff.c   **** 		}
1806:lib/ff/ff.c   **** 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
1807:lib/ff/ff.c   **** 		*path = &p[si];									/* Return pointer to the next segment */
1808:lib/ff/ff.c   **** 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
1809:lib/ff/ff.c   **** 		return FR_OK;
1810:lib/ff/ff.c   **** 	}
1811:lib/ff/ff.c   **** #endif
1812:lib/ff/ff.c   **** 	for (;;) {
1813:lib/ff/ff.c   **** 		c = (BYTE)p[si++];
1814:lib/ff/ff.c   **** 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
1815:lib/ff/ff.c   **** 		if (c == '.' || i >= ni) {
1816:lib/ff/ff.c   **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
1817:lib/ff/ff.c   **** 			i = 8; ni = 11;
1818:lib/ff/ff.c   **** 			b <<= 2; continue;
1819:lib/ff/ff.c   **** 		}
1820:lib/ff/ff.c   **** 		if (c >= 0x80) {				/* Extended char? */
1821:lib/ff/ff.c   **** 			b |= 3;						/* Eliminate NT flag */
1822:lib/ff/ff.c   **** #ifdef _EXCVT
1823:lib/ff/ff.c   **** 			c = excvt[c - 0x80];		/* Upper conversion (SBCS) */
1824:lib/ff/ff.c   **** #else
1825:lib/ff/ff.c   **** #if !_DF1S	/* ASCII only cfg */
1826:lib/ff/ff.c   **** 			return FR_INVALID_NAME;
1827:lib/ff/ff.c   **** #endif
1828:lib/ff/ff.c   **** #endif
1829:lib/ff/ff.c   **** 		}
1830:lib/ff/ff.c   **** 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1831:lib/ff/ff.c   **** 			d = (BYTE)p[si++];			/* Get 2nd byte */
1832:lib/ff/ff.c   **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
1833:lib/ff/ff.c   **** 				return FR_INVALID_NAME;
1834:lib/ff/ff.c   **** 			sfn[i++] = c;
1835:lib/ff/ff.c   **** 			sfn[i++] = d;
1836:lib/ff/ff.c   **** 		} else {						/* Single byte code */
1837:lib/ff/ff.c   **** 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
1838:lib/ff/ff.c   **** 				return FR_INVALID_NAME;
1839:lib/ff/ff.c   **** 			if (IsUpper(c)) {			/* ASCII large capital? */
1840:lib/ff/ff.c   **** 				b |= 2;
1841:lib/ff/ff.c   **** 			} else {
1842:lib/ff/ff.c   **** 				if (IsLower(c)) {		/* ASCII small capital? */
1843:lib/ff/ff.c   **** 					b |= 1; c -= 0x20;
1844:lib/ff/ff.c   **** 				}
1845:lib/ff/ff.c   **** 			}
1846:lib/ff/ff.c   **** 			sfn[i++] = c;
1847:lib/ff/ff.c   **** 		}
1848:lib/ff/ff.c   **** 	}
1849:lib/ff/ff.c   **** 	*path = &p[si];						/* Return pointer to the next segment */
1850:lib/ff/ff.c   **** 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
1851:lib/ff/ff.c   **** 
1852:lib/ff/ff.c   **** 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
1853:lib/ff/ff.c   **** 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
1854:lib/ff/ff.c   **** 
1855:lib/ff/ff.c   **** 	if (ni == 8) b <<= 2;
1856:lib/ff/ff.c   **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
1857:lib/ff/ff.c   **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
1858:lib/ff/ff.c   **** 
1859:lib/ff/ff.c   **** 	sfn[NS] = c;		/* Store NT flag, File name is created */
1860:lib/ff/ff.c   **** 
1861:lib/ff/ff.c   **** 	return FR_OK;
1862:lib/ff/ff.c   **** #endif
1863:lib/ff/ff.c   **** }
1864:lib/ff/ff.c   **** 
1865:lib/ff/ff.c   **** 
1866:lib/ff/ff.c   **** 
1867:lib/ff/ff.c   **** 
1868:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1869:lib/ff/ff.c   **** /* Get file information from directory entry                             */
1870:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1871:lib/ff/ff.c   **** #if _FS_MINIMIZE <= 1
1872:lib/ff/ff.c   **** static
1873:lib/ff/ff.c   **** void get_fileinfo (		/* No return code */
1874:lib/ff/ff.c   **** 	DIR *dj,			/* Pointer to the directory object */
1875:lib/ff/ff.c   **** 	FILINFO *fno	 	/* Pointer to the file information to be filled */
1876:lib/ff/ff.c   **** )
1877:lib/ff/ff.c   **** {
 170              		.loc 1 1877 0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 0
 173              		@ frame_needed = 0, uses_anonymous_args = 0
 174              	.LVL20:
 175 0000 70B5     		push	{r4, r5, r6, lr}
 176              	.LCFI1:
 177              		.cfi_def_cfa_offset 16
 178              		.cfi_offset 4, -16
 179              		.cfi_offset 5, -12
 180              		.cfi_offset 6, -8
 181              		.cfi_offset 14, -4
1878:lib/ff/ff.c   **** 	UINT i;
1879:lib/ff/ff.c   **** 	BYTE nt, *dir;
1880:lib/ff/ff.c   **** 	TCHAR *p, c;
1881:lib/ff/ff.c   **** 
1882:lib/ff/ff.c   **** 
1883:lib/ff/ff.c   **** 	p = fno->fname;
 182              		.loc 1 1883 0
 183 0002 01F10902 		add	r2, r1, #9
 184              	.LVL21:
1884:lib/ff/ff.c   **** 	if (dj->sect) {
 185              		.loc 1 1884 0
 186 0006 0369     		ldr	r3, [r0, #16]
 187 0008 4BB3     		cbz	r3, .L19
1885:lib/ff/ff.c   **** 		dir = dj->dir;
 188              		.loc 1 1885 0
 189 000a 4369     		ldr	r3, [r0, #20]
 190              	.LVL22:
 191 000c 1046     		mov	r0, r2
 192              	.LVL23:
1886:lib/ff/ff.c   **** 		nt = dir[DIR_NTres];		/* NT flag */
1887:lib/ff/ff.c   **** 		for (i = 0; i < 8; i++) {	/* Copy name body */
 193              		.loc 1 1887 0
 194 000e 0024     		movs	r4, #0
 195              	.LVL24:
 196              	.L22:
 197 0010 0246     		mov	r2, r0
1888:lib/ff/ff.c   **** 			c = dir[i];
 198              		.loc 1 1888 0
 199 0012 1D5D     		ldrb	r5, [r3, r4]	@ zero_extendqisi2
 200              	.LVL25:
1889:lib/ff/ff.c   **** 			if (c == ' ') break;
 201              		.loc 1 1889 0
 202 0014 6EB2     		sxtb	r6, r5
 203 0016 202E     		cmp	r6, #32
 204 0018 08D0     		beq	.L20
1890:lib/ff/ff.c   **** 			if (c == NDDE) c = (TCHAR)DDE;
 205              		.loc 1 1890 0
 206 001a 052E     		cmp	r6, #5
 207 001c 08BF     		it	eq
 208 001e E525     		moveq	r5, #229
1891:lib/ff/ff.c   **** 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
1892:lib/ff/ff.c   **** #if _LFN_UNICODE
1893:lib/ff/ff.c   **** 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1894:lib/ff/ff.c   **** 				c = (c << 8) | dir[++i];
1895:lib/ff/ff.c   **** 			c = ff_convert(c, 1);
1896:lib/ff/ff.c   **** 			if (!c) c = '?';
1897:lib/ff/ff.c   **** #endif
1898:lib/ff/ff.c   **** 			*p++ = c;
 209              		.loc 1 1898 0
 210 0020 00F8015B 		strb	r5, [r0], #1
 211              	.LVL26:
 212 0024 0246     		mov	r2, r0
 213              	.LVL27:
1887:lib/ff/ff.c   **** 		for (i = 0; i < 8; i++) {	/* Copy name body */
 214              		.loc 1 1887 0
 215 0026 0134     		adds	r4, r4, #1
 216              	.LVL28:
 217 0028 082C     		cmp	r4, #8
 218 002a F1D1     		bne	.L22
 219              	.LVL29:
 220              	.L20:
1899:lib/ff/ff.c   **** 		}
1900:lib/ff/ff.c   **** 		if (dir[8] != ' ') {		/* Copy name extension */
 221              		.loc 1 1900 0
 222 002c 1C7A     		ldrb	r4, [r3, #8]	@ zero_extendqisi2
 223 002e 202C     		cmp	r4, #32
 224 0030 0DD0     		beq	.L23
1901:lib/ff/ff.c   **** 			*p++ = '.';
 225              		.loc 1 1901 0
 226 0032 2E22     		movs	r2, #46
 227 0034 00F8012B 		strb	r2, [r0], #1
 228              	.LVL30:
1902:lib/ff/ff.c   **** 			for (i = 8; i < 11; i++) {
 229              		.loc 1 1902 0
 230 0038 0824     		movs	r4, #8
 231              	.LVL31:
 232              	.L24:
 233 003a 0246     		mov	r2, r0
1903:lib/ff/ff.c   **** 				c = dir[i];
 234              		.loc 1 1903 0
 235 003c 1D5D     		ldrb	r5, [r3, r4]	@ zero_extendqisi2
 236              	.LVL32:
1904:lib/ff/ff.c   **** 				if (c == ' ') break;
 237              		.loc 1 1904 0
 238 003e 202D     		cmp	r5, #32
 239 0040 05D0     		beq	.L23
1905:lib/ff/ff.c   **** 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
1906:lib/ff/ff.c   **** #if _LFN_UNICODE
1907:lib/ff/ff.c   **** 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1908:lib/ff/ff.c   **** 					c = (c << 8) | dir[++i];
1909:lib/ff/ff.c   **** 				c = ff_convert(c, 1);
1910:lib/ff/ff.c   **** 				if (!c) c = '?';
1911:lib/ff/ff.c   **** #endif
1912:lib/ff/ff.c   **** 				*p++ = c;
 240              		.loc 1 1912 0
 241 0042 00F8015B 		strb	r5, [r0], #1
 242 0046 0246     		mov	r2, r0
 243              	.LVL33:
1902:lib/ff/ff.c   **** 			for (i = 8; i < 11; i++) {
 244              		.loc 1 1902 0
 245 0048 0134     		adds	r4, r4, #1
 246              	.LVL34:
 247 004a 0B2C     		cmp	r4, #11
 248 004c F5D1     		bne	.L24
 249              	.LVL35:
 250              	.L23:
1913:lib/ff/ff.c   **** 			}
1914:lib/ff/ff.c   **** 		}
1915:lib/ff/ff.c   **** 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 251              		.loc 1 1915 0
 252 004e D87A     		ldrb	r0, [r3, #11]	@ zero_extendqisi2
 253 0050 0872     		strb	r0, [r1, #8]
1916:lib/ff/ff.c   **** 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
 254              		.loc 1 1916 0
 255 0052 D869     		ldr	r0, [r3, #28]
 256 0054 0860     		str	r0, [r1, #0]
1917:lib/ff/ff.c   **** 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
 257              		.loc 1 1917 0
 258 0056 188B     		ldrh	r0, [r3, #24]
 259 0058 8880     		strh	r0, [r1, #4]	@ movhi
1918:lib/ff/ff.c   **** 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
 260              		.loc 1 1918 0
 261 005a DB8A     		ldrh	r3, [r3, #22]
 262              	.LVL36:
 263 005c CB80     		strh	r3, [r1, #6]	@ movhi
 264              	.LVL37:
 265              	.L19:
1919:lib/ff/ff.c   **** 	}
1920:lib/ff/ff.c   **** 	*p = 0;		/* Terminate SFN str by a \0 */
 266              		.loc 1 1920 0
 267 005e 0021     		movs	r1, #0
 268              	.LVL38:
 269 0060 1170     		strb	r1, [r2, #0]
 270 0062 70BD     		pop	{r4, r5, r6, pc}
 271              		.cfi_endproc
 272              	.LFE21:
 274              		.section	.text.validate,"ax",%progbits
 275              		.align	1
 276              		.thumb
 277              		.thumb_func
 279              	validate:
 280              	.LFB25:
1921:lib/ff/ff.c   **** 
1922:lib/ff/ff.c   **** #if _USE_LFN
1923:lib/ff/ff.c   **** 	if (fno->lfname && fno->lfsize) {
1924:lib/ff/ff.c   **** 		TCHAR *tp = fno->lfname;
1925:lib/ff/ff.c   **** 		WCHAR w, *lfn;
1926:lib/ff/ff.c   **** 
1927:lib/ff/ff.c   **** 		i = 0;
1928:lib/ff/ff.c   **** 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1929:lib/ff/ff.c   **** 			lfn = dj->lfn;
1930:lib/ff/ff.c   **** 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
1931:lib/ff/ff.c   **** #if !_LFN_UNICODE
1932:lib/ff/ff.c   **** 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
1933:lib/ff/ff.c   **** 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
1934:lib/ff/ff.c   **** 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1935:lib/ff/ff.c   **** 					tp[i++] = (TCHAR)(w >> 8);
1936:lib/ff/ff.c   **** #endif
1937:lib/ff/ff.c   **** 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
1938:lib/ff/ff.c   **** 				tp[i++] = (TCHAR)w;
1939:lib/ff/ff.c   **** 			}
1940:lib/ff/ff.c   **** 		}
1941:lib/ff/ff.c   **** 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
1942:lib/ff/ff.c   **** 	}
1943:lib/ff/ff.c   **** #endif
1944:lib/ff/ff.c   **** }
1945:lib/ff/ff.c   **** #endif /* _FS_MINIMIZE <= 1 */
1946:lib/ff/ff.c   **** 
1947:lib/ff/ff.c   **** 
1948:lib/ff/ff.c   **** 
1949:lib/ff/ff.c   **** 
1950:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1951:lib/ff/ff.c   **** /* Follow a file path                                                    */
1952:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1953:lib/ff/ff.c   **** 
1954:lib/ff/ff.c   **** static
1955:lib/ff/ff.c   **** FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
1956:lib/ff/ff.c   **** 	DIR *dj,			/* Directory object to return last directory and found object */
1957:lib/ff/ff.c   **** 	const TCHAR *path	/* Full-path string to find a file or directory */
1958:lib/ff/ff.c   **** )
1959:lib/ff/ff.c   **** {
1960:lib/ff/ff.c   **** 	FRESULT res;
1961:lib/ff/ff.c   **** 	BYTE *dir, ns;
1962:lib/ff/ff.c   **** 
1963:lib/ff/ff.c   **** 
1964:lib/ff/ff.c   **** #if _FS_RPATH
1965:lib/ff/ff.c   **** 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
1966:lib/ff/ff.c   **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
1967:lib/ff/ff.c   **** 	} else {							/* No heading separator */
1968:lib/ff/ff.c   **** 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
1969:lib/ff/ff.c   **** 	}
1970:lib/ff/ff.c   **** #else
1971:lib/ff/ff.c   **** 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
1972:lib/ff/ff.c   **** 		path++;
1973:lib/ff/ff.c   **** 	dj->sclust = 0;						/* Start from the root dir */
1974:lib/ff/ff.c   **** #endif
1975:lib/ff/ff.c   **** 
1976:lib/ff/ff.c   **** 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
1977:lib/ff/ff.c   **** 		res = dir_sdi(dj, 0);
1978:lib/ff/ff.c   **** 		dj->dir = 0;
1979:lib/ff/ff.c   **** 	} else {							/* Follow path */
1980:lib/ff/ff.c   **** 		for (;;) {
1981:lib/ff/ff.c   **** 			res = create_name(dj, &path);	/* Get a segment */
1982:lib/ff/ff.c   **** 			if (res != FR_OK) break;
1983:lib/ff/ff.c   **** 			res = dir_find(dj);				/* Find it */
1984:lib/ff/ff.c   **** 			ns = *(dj->fn+NS);
1985:lib/ff/ff.c   **** 			if (res != FR_OK) {				/* Failed to find the object */
1986:lib/ff/ff.c   **** 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
1987:lib/ff/ff.c   **** 				/* Object not found */
1988:lib/ff/ff.c   **** 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
1989:lib/ff/ff.c   **** 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
1990:lib/ff/ff.c   **** 					res = FR_OK;
1991:lib/ff/ff.c   **** 					if (!(ns & NS_LAST)) continue;
1992:lib/ff/ff.c   **** 				} else {							/* Could not find the object */
1993:lib/ff/ff.c   **** 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
1994:lib/ff/ff.c   **** 				}
1995:lib/ff/ff.c   **** 				break;
1996:lib/ff/ff.c   **** 			}
1997:lib/ff/ff.c   **** 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
1998:lib/ff/ff.c   **** 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
1999:lib/ff/ff.c   **** 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
2000:lib/ff/ff.c   **** 				res = FR_NO_PATH; break;
2001:lib/ff/ff.c   **** 			}
2002:lib/ff/ff.c   **** 			dj->sclust = ld_clust(dj->fs, dir);
2003:lib/ff/ff.c   **** 		}
2004:lib/ff/ff.c   **** 	}
2005:lib/ff/ff.c   **** 
2006:lib/ff/ff.c   **** 	return res;
2007:lib/ff/ff.c   **** }
2008:lib/ff/ff.c   **** 
2009:lib/ff/ff.c   **** 
2010:lib/ff/ff.c   **** 
2011:lib/ff/ff.c   **** 
2012:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2013:lib/ff/ff.c   **** /* Load a sector and check if it is an FAT Volume Boot Record            */
2014:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2015:lib/ff/ff.c   **** 
2016:lib/ff/ff.c   **** static
2017:lib/ff/ff.c   **** BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
2018:lib/ff/ff.c   **** 	FATFS *fs,	/* File system object */
2019:lib/ff/ff.c   **** 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
2020:lib/ff/ff.c   **** )
2021:lib/ff/ff.c   **** {
2022:lib/ff/ff.c   **** 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
2023:lib/ff/ff.c   **** 		return 3;
2024:lib/ff/ff.c   **** 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 
2025:lib/ff/ff.c   **** 		return 2;
2026:lib/ff/ff.c   **** 
2027:lib/ff/ff.c   **** 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
2028:lib/ff/ff.c   **** 		return 0;
2029:lib/ff/ff.c   **** 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
2030:lib/ff/ff.c   **** 		return 0;
2031:lib/ff/ff.c   **** 
2032:lib/ff/ff.c   **** 	return 1;
2033:lib/ff/ff.c   **** }
2034:lib/ff/ff.c   **** 
2035:lib/ff/ff.c   **** 
2036:lib/ff/ff.c   **** 
2037:lib/ff/ff.c   **** 
2038:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2039:lib/ff/ff.c   **** /* Check if the file system object is valid or not                       */
2040:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2041:lib/ff/ff.c   **** 
2042:lib/ff/ff.c   **** static
2043:lib/ff/ff.c   **** FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
2044:lib/ff/ff.c   **** 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
2045:lib/ff/ff.c   **** 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
2046:lib/ff/ff.c   **** 	BYTE wmode			/* !=0: Check write protection for write access */
2047:lib/ff/ff.c   **** )
2048:lib/ff/ff.c   **** {
2049:lib/ff/ff.c   **** 	BYTE fmt, b, pi, *tbl;
2050:lib/ff/ff.c   **** 	UINT vol;
2051:lib/ff/ff.c   **** 	DSTATUS stat;
2052:lib/ff/ff.c   **** 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
2053:lib/ff/ff.c   **** 	WORD nrsv;
2054:lib/ff/ff.c   **** 	const TCHAR *p = *path;
2055:lib/ff/ff.c   **** 	FATFS *fs;
2056:lib/ff/ff.c   **** 
2057:lib/ff/ff.c   **** 
2058:lib/ff/ff.c   **** 	/* Get logical drive number from the path name */
2059:lib/ff/ff.c   **** 	vol = p[0] - '0';					/* Is there a drive number? */
2060:lib/ff/ff.c   **** 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
2061:lib/ff/ff.c   **** 		p += 2; *path = p;				/* Return pointer to the path name */
2062:lib/ff/ff.c   **** 	} else {							/* No drive number is given */
2063:lib/ff/ff.c   **** #if _FS_RPATH
2064:lib/ff/ff.c   **** 		vol = CurrVol;					/* Use current drive */
2065:lib/ff/ff.c   **** #else
2066:lib/ff/ff.c   **** 		vol = 0;						/* Use drive 0 */
2067:lib/ff/ff.c   **** #endif
2068:lib/ff/ff.c   **** 	}
2069:lib/ff/ff.c   **** 
2070:lib/ff/ff.c   **** 	/* Check if the file system object is valid or not */
2071:lib/ff/ff.c   **** 	*rfs = 0;
2072:lib/ff/ff.c   **** 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
2073:lib/ff/ff.c   **** 		return FR_INVALID_DRIVE;
2074:lib/ff/ff.c   **** 	fs = FatFs[vol];					/* Get corresponding file system object */
2075:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
2076:lib/ff/ff.c   **** 
2077:lib/ff/ff.c   **** 	ENTER_FF(fs);						/* Lock file system */
2078:lib/ff/ff.c   **** 
2079:lib/ff/ff.c   **** 	*rfs = fs;							/* Return pointer to the corresponding file system object */
2080:lib/ff/ff.c   **** 	if (fs->fs_type) {					/* If the volume has been mounted */
2081:lib/ff/ff.c   **** 		stat = disk_status(fs->drv);
2082:lib/ff/ff.c   **** 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed)
2083:lib/ff/ff.c   **** 			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
2084:lib/ff/ff.c   **** 				return FR_WRITE_PROTECTED;
2085:lib/ff/ff.c   **** 			return FR_OK;				/* The file system object is valid */
2086:lib/ff/ff.c   **** 		}
2087:lib/ff/ff.c   **** 	}
2088:lib/ff/ff.c   **** 
2089:lib/ff/ff.c   **** 	/* The file system object is not valid. */
2090:lib/ff/ff.c   **** 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
2091:lib/ff/ff.c   **** 
2092:lib/ff/ff.c   **** 	fs->fs_type = 0;					/* Clear the file system object */
2093:lib/ff/ff.c   **** 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
2094:lib/ff/ff.c   **** 	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
2095:lib/ff/ff.c   **** 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
2096:lib/ff/ff.c   **** 		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
2097:lib/ff/ff.c   **** 	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
2098:lib/ff/ff.c   **** 		return FR_WRITE_PROTECTED;
2099:lib/ff/ff.c   **** #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
2100:lib/ff/ff.c   **** 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
2101:lib/ff/ff.c   **** 		return FR_DISK_ERR;
2102:lib/ff/ff.c   **** #endif
2103:lib/ff/ff.c   **** 	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
2104:lib/ff/ff.c   **** 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
2105:lib/ff/ff.c   **** 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
2106:lib/ff/ff.c   **** 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
2107:lib/ff/ff.c   **** 		/* Check the partition listed in the partition table */
2108:lib/ff/ff.c   **** 		pi = LD2PT(vol);
2109:lib/ff/ff.c   **** 		if (pi) pi--;
2110:lib/ff/ff.c   **** 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2111:lib/ff/ff.c   **** 		if (tbl[4]) {						/* Is the partition existing? */
2112:lib/ff/ff.c   **** 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
2113:lib/ff/ff.c   **** 			fmt = check_fs(fs, bsect);		/* Check the partition */
2114:lib/ff/ff.c   **** 		}
2115:lib/ff/ff.c   **** 	}
2116:lib/ff/ff.c   **** 	if (fmt == 3) return FR_DISK_ERR;
2117:lib/ff/ff.c   **** 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
2118:lib/ff/ff.c   **** 
2119:lib/ff/ff.c   **** 	/* An FAT volume is found. Following code initializes the file system object */
2120:lib/ff/ff.c   **** 
2121:lib/ff/ff.c   **** 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical s
2122:lib/ff/ff.c   **** 		return FR_NO_FILESYSTEM;
2123:lib/ff/ff.c   **** 
2124:lib/ff/ff.c   **** 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
2125:lib/ff/ff.c   **** 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
2126:lib/ff/ff.c   **** 	fs->fsize = fasize;
2127:lib/ff/ff.c   **** 
2128:lib/ff/ff.c   **** 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
2129:lib/ff/ff.c   **** 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
2130:lib/ff/ff.c   **** 	fasize *= b;										/* Number of sectors for FAT area */
2131:lib/ff/ff.c   **** 
2132:lib/ff/ff.c   **** 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
2133:lib/ff/ff.c   **** 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
2134:lib/ff/ff.c   **** 
2135:lib/ff/ff.c   **** 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
2136:lib/ff/ff.c   **** 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector 
2137:lib/ff/ff.c   **** 
2138:lib/ff/ff.c   **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
2139:lib/ff/ff.c   **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
2140:lib/ff/ff.c   **** 
2141:lib/ff/ff.c   **** 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
2142:lib/ff/ff.c   **** 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
2143:lib/ff/ff.c   **** 
2144:lib/ff/ff.c   **** 	/* Determine the FAT sub type */
2145:lib/ff/ff.c   **** 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
2146:lib/ff/ff.c   **** 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
2147:lib/ff/ff.c   **** 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
2148:lib/ff/ff.c   **** 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
2149:lib/ff/ff.c   **** 	fmt = FS_FAT12;
2150:lib/ff/ff.c   **** 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
2151:lib/ff/ff.c   **** 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
2152:lib/ff/ff.c   **** 
2153:lib/ff/ff.c   **** 	/* Boundaries and Limits */
2154:lib/ff/ff.c   **** 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
2155:lib/ff/ff.c   **** 	fs->database = bsect + sysect;						/* Data start sector */
2156:lib/ff/ff.c   **** 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
2157:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
2158:lib/ff/ff.c   **** 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
2159:lib/ff/ff.c   **** 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
2160:lib/ff/ff.c   **** 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
2161:lib/ff/ff.c   **** 	} else {
2162:lib/ff/ff.c   **** 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
2163:lib/ff/ff.c   **** 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
2164:lib/ff/ff.c   **** 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
2165:lib/ff/ff.c   **** 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
2166:lib/ff/ff.c   **** 	}
2167:lib/ff/ff.c   **** 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
2168:lib/ff/ff.c   **** 		return FR_NO_FILESYSTEM;
2169:lib/ff/ff.c   **** 
2170:lib/ff/ff.c   **** #if !_FS_READONLY
2171:lib/ff/ff.c   **** 	/* Initialize cluster allocation information */
2172:lib/ff/ff.c   **** 	fs->free_clust = 0xFFFFFFFF;
2173:lib/ff/ff.c   **** 	fs->last_clust = 0;
2174:lib/ff/ff.c   **** 
2175:lib/ff/ff.c   **** 	/* Get fsinfo if available */
2176:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
2177:lib/ff/ff.c   **** 	 	fs->fsi_flag = 0;
2178:lib/ff/ff.c   **** 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
2179:lib/ff/ff.c   **** 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
2180:lib/ff/ff.c   **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
2181:lib/ff/ff.c   **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
2182:lib/ff/ff.c   **** 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
2183:lib/ff/ff.c   **** 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
2184:lib/ff/ff.c   **** 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
2185:lib/ff/ff.c   **** 		}
2186:lib/ff/ff.c   **** 	}
2187:lib/ff/ff.c   **** #endif
2188:lib/ff/ff.c   **** 	fs->fs_type = fmt;		/* FAT sub-type */
2189:lib/ff/ff.c   **** 	fs->id = ++Fsid;		/* File system mount ID */
2190:lib/ff/ff.c   **** 	fs->winsect = 0;		/* Invalidate sector cache */
2191:lib/ff/ff.c   **** 	fs->wflag = 0;
2192:lib/ff/ff.c   **** #if _FS_RPATH
2193:lib/ff/ff.c   **** 	fs->cdir = 0;			/* Current directory (root dir) */
2194:lib/ff/ff.c   **** #endif
2195:lib/ff/ff.c   **** #if _FS_LOCK				/* Clear file lock semaphores */
2196:lib/ff/ff.c   **** 	clear_lock(fs);
2197:lib/ff/ff.c   **** #endif
2198:lib/ff/ff.c   **** 
2199:lib/ff/ff.c   **** 	return FR_OK;
2200:lib/ff/ff.c   **** }
2201:lib/ff/ff.c   **** 
2202:lib/ff/ff.c   **** 
2203:lib/ff/ff.c   **** 
2204:lib/ff/ff.c   **** 
2205:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2206:lib/ff/ff.c   **** /* Check if the file/dir object is valid or not                          */
2207:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2208:lib/ff/ff.c   **** 
2209:lib/ff/ff.c   **** static
2210:lib/ff/ff.c   **** FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
2211:lib/ff/ff.c   **** 	void* obj		/* Pointer to the object FIL/DIR to check validity */
2212:lib/ff/ff.c   **** )
2213:lib/ff/ff.c   **** {
 281              		.loc 1 2213 0
 282              		.cfi_startproc
 283              		@ args = 0, pretend = 0, frame = 0
 284              		@ frame_needed = 0, uses_anonymous_args = 0
 285              	.LVL39:
 286 0000 08B5     		push	{r3, lr}
 287              	.LCFI2:
 288              		.cfi_def_cfa_offset 8
 289              		.cfi_offset 3, -8
 290              		.cfi_offset 14, -4
 291              	.LVL40:
2214:lib/ff/ff.c   **** 	FIL *fil;
2215:lib/ff/ff.c   **** 
2216:lib/ff/ff.c   **** 
2217:lib/ff/ff.c   **** 	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
2218:lib/ff/ff.c   **** 	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 292              		.loc 1 2218 0
 293 0002 0368     		ldr	r3, [r0, #0]
 294 0004 73B1     		cbz	r3, .L44
 295              		.loc 1 2218 0 is_stmt 0 discriminator 1
 296 0006 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 297 0008 62B1     		cbz	r2, .L44
 298 000a D988     		ldrh	r1, [r3, #6]
 299 000c 8088     		ldrh	r0, [r0, #4]
 300              	.LVL41:
 301 000e 8142     		cmp	r1, r0
 302 0010 08D1     		bne	.L44
2219:lib/ff/ff.c   **** 		return FR_INVALID_OBJECT;
2220:lib/ff/ff.c   **** 
2221:lib/ff/ff.c   **** 	ENTER_FF(fil->fs);		/* Lock file system */
2222:lib/ff/ff.c   **** 
2223:lib/ff/ff.c   **** 	if (disk_status(fil->fs->drv) & STA_NOINIT)
 303              		.loc 1 2223 0 is_stmt 1
 304 0012 5878     		ldrb	r0, [r3, #1]	@ zero_extendqisi2
 305 0014 FFF7FEFF 		bl	disk_status
 306              	.LVL42:
 307 0018 10F0010F 		tst	r0, #1
2224:lib/ff/ff.c   **** 		return FR_NOT_READY;
 308              		.loc 1 2224 0
 309 001c 0CBF     		ite	eq
 310 001e 0020     		moveq	r0, #0
 311 0020 0320     		movne	r0, #3
 312 0022 08BD     		pop	{r3, pc}
 313              	.L44:
2219:lib/ff/ff.c   **** 		return FR_INVALID_OBJECT;
 314              		.loc 1 2219 0
 315 0024 0920     		movs	r0, #9
2225:lib/ff/ff.c   **** 
2226:lib/ff/ff.c   **** 	return FR_OK;
2227:lib/ff/ff.c   **** }
 316              		.loc 1 2227 0
 317 0026 08BD     		pop	{r3, pc}
 318              		.cfi_endproc
 319              	.LFE25:
 321              		.section	.text.move_window,"ax",%progbits
 322              		.align	1
 323              		.thumb
 324              		.thumb_func
 326              	move_window:
 327              	.LFB4:
 725:lib/ff/ff.c   **** {
 328              		.loc 1 725 0
 329              		.cfi_startproc
 330              		@ args = 0, pretend = 0, frame = 0
 331              		@ frame_needed = 0, uses_anonymous_args = 0
 332              	.LVL43:
 333 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 334              	.LCFI3:
 335              		.cfi_def_cfa_offset 24
 336              		.cfi_offset 4, -24
 337              		.cfi_offset 5, -20
 338              		.cfi_offset 6, -16
 339              		.cfi_offset 7, -12
 340              		.cfi_offset 8, -8
 341              		.cfi_offset 14, -4
 342 0004 0446     		mov	r4, r0
 343 0006 0E46     		mov	r6, r1
 729:lib/ff/ff.c   **** 	wsect = fs->winsect;
 344              		.loc 1 729 0
 345 0008 056B     		ldr	r5, [r0, #48]
 346              	.LVL44:
 730:lib/ff/ff.c   **** 	if (wsect != sector) {	/* Changed current window */
 347              		.loc 1 730 0
 348 000a 8D42     		cmp	r5, r1
 349 000c 02D1     		bne	.L47
 350              	.LVL45:
 351              	.L51:
 752:lib/ff/ff.c   **** 	return FR_OK;
 352              		.loc 1 752 0
 353 000e 0020     		movs	r0, #0
 354 0010 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 355              	.LVL46:
 356              	.L47:
 732:lib/ff/ff.c   **** 		if (fs->wflag) {	/* Write back dirty window if needed */
 357              		.loc 1 732 0
 358 0014 0379     		ldrb	r3, [r0, #4]	@ zero_extendqisi2
 359 0016 13B9     		cbnz	r3, .L49
 360              	.LVL47:
 361              	.L53:
 745:lib/ff/ff.c   **** 		if (sector) {
 362              		.loc 1 745 0
 363 0018 002E     		cmp	r6, #0
 364 001a F8D0     		beq	.L51
 365 001c 1FE0     		b	.L57
 366              	.LVL48:
 367              	.L49:
 733:lib/ff/ff.c   **** 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 368              		.loc 1 733 0
 369 001e 00F13408 		add	r8, r0, #52
 370 0022 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 371              	.LVL49:
 372 0024 4146     		mov	r1, r8
 373              	.LVL50:
 374 0026 2A46     		mov	r2, r5
 375 0028 0123     		movs	r3, #1
 376 002a FFF7FEFF 		bl	disk_write
 377              	.LVL51:
 378 002e 10B1     		cbz	r0, .L52
 379              	.L56:
 734:lib/ff/ff.c   **** 				return FR_DISK_ERR;
 380              		.loc 1 734 0
 381 0030 0120     		movs	r0, #1
 382 0032 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 383              	.L52:
 735:lib/ff/ff.c   **** 			fs->wflag = 0;
 384              		.loc 1 735 0
 385 0036 2071     		strb	r0, [r4, #4]
 736:lib/ff/ff.c   **** 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
 386              		.loc 1 736 0
 387 0038 226A     		ldr	r2, [r4, #32]
 388 003a 606A     		ldr	r0, [r4, #36]
 389 003c 1118     		adds	r1, r2, r0
 390 003e 8D42     		cmp	r5, r1
 391 0040 EAD2     		bcs	.L53
 392              	.LBB15:
 738:lib/ff/ff.c   **** 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
 393              		.loc 1 738 0
 394 0042 E778     		ldrb	r7, [r4, #3]	@ zero_extendqisi2
 395              	.LVL52:
 396              	.L54:
 738:lib/ff/ff.c   **** 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
 397              		.loc 1 738 0 is_stmt 0 discriminator 1
 398 0044 012F     		cmp	r7, #1
 399 0046 E7D9     		bls	.L53
 400              	.L55:
 739:lib/ff/ff.c   **** 					wsect += fs->fsize;
 401              		.loc 1 739 0 is_stmt 1 discriminator 2
 402 0048 236A     		ldr	r3, [r4, #32]
 403 004a ED18     		adds	r5, r5, r3
 404              	.LVL53:
 740:lib/ff/ff.c   **** 					disk_write(fs->drv, fs->win, wsect, 1);
 405              		.loc 1 740 0 discriminator 2
 406 004c 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 407 004e 4146     		mov	r1, r8
 408 0050 2A46     		mov	r2, r5
 409 0052 0123     		movs	r3, #1
 410 0054 FFF7FEFF 		bl	disk_write
 411              	.LVL54:
 738:lib/ff/ff.c   **** 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
 412              		.loc 1 738 0 discriminator 2
 413 0058 013F     		subs	r7, r7, #1
 414              	.LVL55:
 415 005a FFB2     		uxtb	r7, r7
 416              	.LVL56:
 417 005c F2E7     		b	.L54
 418              	.LVL57:
 419              	.L57:
 420              	.LBE15:
 746:lib/ff/ff.c   **** 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 421              		.loc 1 746 0
 422 005e 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 423 0060 04F13401 		add	r1, r4, #52
 424 0064 3246     		mov	r2, r6
 425 0066 0123     		movs	r3, #1
 426 0068 FFF7FEFF 		bl	disk_read
 427              	.LVL58:
 428 006c 0028     		cmp	r0, #0
 429 006e DFD1     		bne	.L56
 748:lib/ff/ff.c   **** 			fs->winsect = sector;
 430              		.loc 1 748 0
 431 0070 2663     		str	r6, [r4, #48]
 753:lib/ff/ff.c   **** }
 432              		.loc 1 753 0
 433 0072 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 434              		.cfi_endproc
 435              	.LFE4:
 437              		.section	.text.sync,"ax",%progbits
 438              		.align	1
 439              		.thumb
 440              		.thumb_func
 442              	sync:
 443              	.LFB5:
 766:lib/ff/ff.c   **** {
 444              		.loc 1 766 0
 445              		.cfi_startproc
 446              		@ args = 0, pretend = 0, frame = 0
 447              		@ frame_needed = 0, uses_anonymous_args = 0
 448              	.LVL59:
 449 0000 70B5     		push	{r4, r5, r6, lr}
 450              	.LCFI4:
 451              		.cfi_def_cfa_offset 16
 452              		.cfi_offset 4, -16
 453              		.cfi_offset 5, -12
 454              		.cfi_offset 6, -8
 455              		.cfi_offset 14, -4
 456 0002 0446     		mov	r4, r0
 770:lib/ff/ff.c   **** 	res = move_window(fs, 0);
 457              		.loc 1 770 0
 458 0004 0021     		movs	r1, #0
 459 0006 FFF7FEFF 		bl	move_window
 460              	.LVL60:
 461 000a 0546     		mov	r5, r0
 462              	.LVL61:
 771:lib/ff/ff.c   **** 	if (res == FR_OK) {
 463              		.loc 1 771 0
 464 000c 5DBB     		cbnz	r5, .L59
 773:lib/ff/ff.c   **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 465              		.loc 1 773 0
 466 000e 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 467 0010 032B     		cmp	r3, #3
 468 0012 20D1     		bne	.L60
 773:lib/ff/ff.c   **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 469              		.loc 1 773 0 is_stmt 0 discriminator 1
 470 0014 6079     		ldrb	r0, [r4, #5]	@ zero_extendqisi2
 471              	.LVL62:
 472 0016 F0B1     		cbz	r0, .L60
 774:lib/ff/ff.c   **** 			fs->winsect = 0;
 473              		.loc 1 774 0 is_stmt 1
 474 0018 2563     		str	r5, [r4, #48]
 776:lib/ff/ff.c   **** 			mem_set(fs->win, 0, 512);
 475              		.loc 1 776 0
 476 001a 04F13406 		add	r6, r4, #52
 477 001e 3046     		mov	r0, r6
 478 0020 2946     		mov	r1, r5
 479 0022 4FF40072 		mov	r2, #512
 480 0026 FFF7FEFF 		bl	mem_set
 481              	.LVL63:
 777:lib/ff/ff.c   **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);
 482              		.loc 1 777 0
 483 002a 4AF65521 		movw	r1, #43605
 484 002e A4F83212 		strh	r1, [r4, #562]	@ movhi
 778:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 485              		.loc 1 778 0
 486 0032 0D4A     		ldr	r2, .L64
 487 0034 6263     		str	r2, [r4, #52]
 779:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 488              		.loc 1 779 0
 489 0036 0D4B     		ldr	r3, .L64+4
 490 0038 C4F81832 		str	r3, [r4, #536]
 780:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 491              		.loc 1 780 0
 492 003c 2069     		ldr	r0, [r4, #16]
 493 003e C4F81C02 		str	r0, [r4, #540]
 781:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 494              		.loc 1 781 0
 495 0042 E168     		ldr	r1, [r4, #12]
 496 0044 C4F82012 		str	r1, [r4, #544]
 783:lib/ff/ff.c   **** 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
 497              		.loc 1 783 0
 498 0048 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 499 004a 3146     		mov	r1, r6
 500 004c 6269     		ldr	r2, [r4, #20]
 501 004e 0123     		movs	r3, #1
 502 0050 FFF7FEFF 		bl	disk_write
 503              	.LVL64:
 784:lib/ff/ff.c   **** 			fs->fsi_flag = 0;
 504              		.loc 1 784 0
 505 0054 6571     		strb	r5, [r4, #5]
 506              	.L60:
 787:lib/ff/ff.c   **** 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 507              		.loc 1 787 0
 508 0056 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 509 0058 0021     		movs	r1, #0
 510 005a 0A46     		mov	r2, r1
 511 005c FFF7FEFF 		bl	disk_ioctl
 512              	.LVL65:
 513 0060 0030     		adds	r0, r0, #0
 514 0062 18BF     		it	ne
 515 0064 0120     		movne	r0, #1
 516              	.L59:
 517              	.LVL66:
 792:lib/ff/ff.c   **** }
 518              		.loc 1 792 0
 519 0066 70BD     		pop	{r4, r5, r6, pc}
 520              	.L65:
 521              		.align	2
 522              	.L64:
 523 0068 52526141 		.word	1096897106
 524 006c 72724161 		.word	1631679090
 525              		.cfi_endproc
 526              	.LFE5:
 528              		.section	.text.check_fs,"ax",%progbits
 529              		.align	1
 530              		.thumb
 531              		.thumb_func
 533              	check_fs:
 534              	.LFB23:
2021:lib/ff/ff.c   **** {
 535              		.loc 1 2021 0
 536              		.cfi_startproc
 537              		@ args = 0, pretend = 0, frame = 0
 538              		@ frame_needed = 0, uses_anonymous_args = 0
 539              	.LVL67:
 540 0000 10B5     		push	{r4, lr}
 541              	.LCFI5:
 542              		.cfi_def_cfa_offset 8
 543              		.cfi_offset 4, -8
 544              		.cfi_offset 14, -4
 545 0002 0446     		mov	r4, r0
 546 0004 0A46     		mov	r2, r1
2022:lib/ff/ff.c   **** 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 547              		.loc 1 2022 0
 548 0006 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 549              	.LVL68:
 550 0008 04F13401 		add	r1, r4, #52
 551              	.LVL69:
 552 000c 0123     		movs	r3, #1
 553 000e FFF7FEFF 		bl	disk_read
 554              	.LVL70:
 555 0012 A0B9     		cbnz	r0, .L68
2024:lib/ff/ff.c   **** 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 
 556              		.loc 1 2024 0
 557 0014 B4F83222 		ldrh	r2, [r4, #562]
 558 0018 4AF65523 		movw	r3, #43605
 559 001c 9A42     		cmp	r2, r3
 560 001e 10D1     		bne	.L69
2027:lib/ff/ff.c   **** 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 561              		.loc 1 2027 0
 562 0020 D4F86A10 		ldr	r1, [r4, #106]
 563 0024 21F07F42 		bic	r2, r1, #-16777216
 564 0028 074B     		ldr	r3, .L71
 565 002a 9A42     		cmp	r2, r3
 566 002c 0AD0     		beq	.L67
 567              	.LVL71:
 568              	.LBB18:
 569              	.LBB19:
2029:lib/ff/ff.c   **** 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 570              		.loc 1 2029 0
 571 002e D4F88600 		ldr	r0, [r4, #134]
 572 0032 20F07F41 		bic	r1, r0, #-16777216
 573              	.LBE19:
 574              	.LBE18:
2030:lib/ff/ff.c   **** 		return 0;
 575              		.loc 1 2030 0
 576 0036 C81A     		subs	r0, r1, r3
 577 0038 18BF     		it	ne
 578 003a 0120     		movne	r0, #1
 579 003c 10BD     		pop	{r4, pc}
 580              	.LVL72:
 581              	.L68:
2023:lib/ff/ff.c   **** 		return 3;
 582              		.loc 1 2023 0
 583 003e 0320     		movs	r0, #3
 584 0040 10BD     		pop	{r4, pc}
 585              	.L69:
2025:lib/ff/ff.c   **** 		return 2;
 586              		.loc 1 2025 0
 587 0042 0220     		movs	r0, #2
 588              	.L67:
2033:lib/ff/ff.c   **** }
 589              		.loc 1 2033 0
 590 0044 10BD     		pop	{r4, pc}
 591              	.L72:
 592 0046 00BF     		.align	2
 593              	.L71:
 594 0048 46415400 		.word	5521734
 595              		.cfi_endproc
 596              	.LFE23:
 598              		.section	.text.chk_mounted,"ax",%progbits
 599              		.align	1
 600              		.thumb
 601              		.thumb_func
 603              	chk_mounted:
 604              	.LFB24:
2048:lib/ff/ff.c   **** {
 605              		.loc 1 2048 0
 606              		.cfi_startproc
 607              		@ args = 0, pretend = 0, frame = 0
 608              		@ frame_needed = 0, uses_anonymous_args = 0
 609              	.LVL73:
 610 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 611              	.LCFI6:
 612              		.cfi_def_cfa_offset 24
 613              		.cfi_offset 4, -24
 614              		.cfi_offset 5, -20
 615              		.cfi_offset 6, -16
 616              		.cfi_offset 7, -12
 617              		.cfi_offset 8, -8
 618              		.cfi_offset 14, -4
 619 0004 1546     		mov	r5, r2
2054:lib/ff/ff.c   **** 	const TCHAR *p = *path;
 620              		.loc 1 2054 0
 621 0006 0268     		ldr	r2, [r0, #0]
 622              	.LVL74:
2059:lib/ff/ff.c   **** 	vol = p[0] - '0';					/* Is there a drive number? */
 623              		.loc 1 2059 0
 624 0008 92F90030 		ldrsb	r3, [r2, #0]
 625 000c 303B     		subs	r3, r3, #48
 626              	.LVL75:
2060:lib/ff/ff.c   **** 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 627              		.loc 1 2060 0
 628 000e 092B     		cmp	r3, #9
 629 0010 06D8     		bhi	.L74
2060:lib/ff/ff.c   **** 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 630              		.loc 1 2060 0 is_stmt 0 discriminator 1
 631 0012 92F90140 		ldrsb	r4, [r2, #1]
 632 0016 3A2C     		cmp	r4, #58
 633 0018 02D1     		bne	.L74
 634              	.LVL76:
2061:lib/ff/ff.c   **** 		p += 2; *path = p;				/* Return pointer to the path name */
 635              		.loc 1 2061 0 is_stmt 1
 636 001a 0232     		adds	r2, r2, #2
 637              	.LVL77:
 638 001c 0260     		str	r2, [r0, #0]
 639 001e 01E0     		b	.L75
 640              	.L74:
2064:lib/ff/ff.c   **** 		vol = CurrVol;					/* Use current drive */
 641              		.loc 1 2064 0
 642 0020 774B     		ldr	r3, .L120
 643              	.LVL78:
 644 0022 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 645              	.LVL79:
 646              	.L75:
2071:lib/ff/ff.c   **** 	*rfs = 0;
 647              		.loc 1 2071 0
 648 0024 0020     		movs	r0, #0
 649              	.LVL80:
 650 0026 0860     		str	r0, [r1, #0]
2072:lib/ff/ff.c   **** 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 651              		.loc 1 2072 0
 652 0028 002B     		cmp	r3, #0
 653 002a 40F0D780 		bne	.L92
2074:lib/ff/ff.c   **** 	fs = FatFs[vol];					/* Get corresponding file system object */
 654              		.loc 1 2074 0
 655 002e 754C     		ldr	r4, .L120+4
 656 0030 2468     		ldr	r4, [r4, #0]
 657              	.LVL81:
2075:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 658              		.loc 1 2075 0
 659 0032 002C     		cmp	r4, #0
 660 0034 00F0D580 		beq	.L93
2079:lib/ff/ff.c   **** 	*rfs = fs;							/* Return pointer to the corresponding file system object */
 661              		.loc 1 2079 0
 662 0038 0C60     		str	r4, [r1, #0]
2080:lib/ff/ff.c   **** 	if (fs->fs_type) {					/* If the volume has been mounted */
 663              		.loc 1 2080 0
 664 003a 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 665              	.LVL82:
 666 003c 81B1     		cbz	r1, .L77
2081:lib/ff/ff.c   **** 		stat = disk_status(fs->drv);
 667              		.loc 1 2081 0
 668 003e 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 669 0040 FFF7FEFF 		bl	disk_status
 670              	.LVL83:
2082:lib/ff/ff.c   **** 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed)
 671              		.loc 1 2082 0
 672 0044 C307     		lsls	r3, r0, #31
 673 0046 0BD4     		bmi	.L77
2083:lib/ff/ff.c   **** 			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 674              		.loc 1 2083 0
 675 0048 002D     		cmp	r5, #0
 676 004a 00F0CD80 		beq	.L94
2083:lib/ff/ff.c   **** 			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 677              		.loc 1 2083 0 is_stmt 0 discriminator 1
 678 004e 00F00402 		and	r2, r0, #4
 679 0052 D3B2     		uxtb	r3, r2
2084:lib/ff/ff.c   **** 				return FR_WRITE_PROTECTED;
 680              		.loc 1 2084 0 is_stmt 1 discriminator 1
 681 0054 002B     		cmp	r3, #0
 682 0056 14BF     		ite	ne
 683 0058 0A20     		movne	r0, #10
 684 005a 0020     		moveq	r0, #0
 685              	.LVL84:
 686 005c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 687              	.L77:
2092:lib/ff/ff.c   **** 	fs->fs_type = 0;					/* Clear the file system object */
 688              		.loc 1 2092 0
 689 0060 0020     		movs	r0, #0
 690 0062 2070     		strb	r0, [r4, #0]
2093:lib/ff/ff.c   **** 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 691              		.loc 1 2093 0
 692 0064 6070     		strb	r0, [r4, #1]
2094:lib/ff/ff.c   **** 	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 693              		.loc 1 2094 0
 694 0066 FFF7FEFF 		bl	disk_initialize
 695              	.LVL85:
2095:lib/ff/ff.c   **** 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 696              		.loc 1 2095 0
 697 006a C107     		lsls	r1, r0, #31
 698 006c 00F1BF80 		bmi	.L96
2097:lib/ff/ff.c   **** 	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 699              		.loc 1 2097 0
 700 0070 2DB1     		cbz	r5, .L78
2097:lib/ff/ff.c   **** 	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 701              		.loc 1 2097 0 is_stmt 0 discriminator 1
 702 0072 00F00403 		and	r3, r0, #4
 703 0076 DAB2     		uxtb	r2, r3
 704 0078 002A     		cmp	r2, #0
 705 007a 40F0BB80 		bne	.L97
 706              	.L78:
 707              	.LVL86:
2104:lib/ff/ff.c   **** 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 708              		.loc 1 2104 0 is_stmt 1
 709 007e 2046     		mov	r0, r4
 710              	.LVL87:
 711 0080 0021     		movs	r1, #0
 712 0082 FFF7FEFF 		bl	check_fs
 713              	.LVL88:
2106:lib/ff/ff.c   **** 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
 714              		.loc 1 2106 0
 715 0086 0128     		cmp	r0, #1
 716 0088 0CD1     		bne	.L98
 717              	.LVL89:
2111:lib/ff/ff.c   **** 		if (tbl[4]) {						/* Is the partition existing? */
 718              		.loc 1 2111 0
 719 008a 94F8F601 		ldrb	r0, [r4, #502]	@ zero_extendqisi2
 720              	.LVL90:
 721 008e 10B9     		cbnz	r0, .L80
 722              	.LVL91:
 723              	.L81:
2117:lib/ff/ff.c   **** 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 724              		.loc 1 2117 0
 725 0090 0D20     		movs	r0, #13
 726 0092 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 727              	.LVL92:
 728              	.L80:
2112:lib/ff/ff.c   **** 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 729              		.loc 1 2112 0
 730 0096 D4F8FA61 		ldr	r6, [r4, #506]
 731              	.LVL93:
2113:lib/ff/ff.c   **** 			fmt = check_fs(fs, bsect);		/* Check the partition */
 732              		.loc 1 2113 0
 733 009a 2046     		mov	r0, r4
 734 009c 3146     		mov	r1, r6
 735 009e FFF7FEFF 		bl	check_fs
 736              	.LVL94:
 737 00a2 00E0     		b	.L79
 738              	.LVL95:
 739              	.L98:
2104:lib/ff/ff.c   **** 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 740              		.loc 1 2104 0
 741 00a4 0026     		movs	r6, #0
 742              	.LVL96:
 743              	.L79:
2116:lib/ff/ff.c   **** 	if (fmt == 3) return FR_DISK_ERR;
 744              		.loc 1 2116 0
 745 00a6 0328     		cmp	r0, #3
 746 00a8 00F0A780 		beq	.L99
2117:lib/ff/ff.c   **** 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 747              		.loc 1 2117 0
 748 00ac 0028     		cmp	r0, #0
 749 00ae EFD1     		bne	.L81
2121:lib/ff/ff.c   **** 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical s
 750              		.loc 1 2121 0
 751 00b0 B4F83F10 		ldrh	r1, [r4, #63]
 752 00b4 B1F5007F 		cmp	r1, #512
 753 00b8 EAD1     		bne	.L81
2124:lib/ff/ff.c   **** 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 754              		.loc 1 2124 0
 755 00ba B4F84A30 		ldrh	r3, [r4, #74]
 756              	.LVL97:
2125:lib/ff/ff.c   **** 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 757              		.loc 1 2125 0
 758 00be 03B9     		cbnz	r3, .L82
2125:lib/ff/ff.c   **** 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 759              		.loc 1 2125 0 is_stmt 0 discriminator 1
 760 00c0 A36D     		ldr	r3, [r4, #88]
 761              	.LVL98:
 762              	.L82:
2126:lib/ff/ff.c   **** 	fs->fsize = fasize;
 763              		.loc 1 2126 0 is_stmt 1
 764 00c2 2362     		str	r3, [r4, #32]
2128:lib/ff/ff.c   **** 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 765              		.loc 1 2128 0
 766 00c4 94F84450 		ldrb	r5, [r4, #68]	@ zero_extendqisi2
 767              	.LVL99:
 768 00c8 E570     		strb	r5, [r4, #3]
2129:lib/ff/ff.c   **** 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 769              		.loc 1 2129 0
 770 00ca 6A1E     		subs	r2, r5, #1
 771 00cc 012A     		cmp	r2, #1
 772 00ce DFD8     		bhi	.L81
 773              	.LVL100:
2132:lib/ff/ff.c   **** 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 774              		.loc 1 2132 0
 775 00d0 94F84100 		ldrb	r0, [r4, #65]	@ zero_extendqisi2
 776              	.LVL101:
 777 00d4 A070     		strb	r0, [r4, #2]
2133:lib/ff/ff.c   **** 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 778              		.loc 1 2133 0
 779 00d6 0028     		cmp	r0, #0
 780 00d8 DAD0     		beq	.L81
2133:lib/ff/ff.c   **** 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 781              		.loc 1 2133 0 is_stmt 0 discriminator 2
 782 00da 411E     		subs	r1, r0, #1
 783 00dc 0142     		tst	r1, r0
 784 00de D7D1     		bne	.L81
2135:lib/ff/ff.c   **** 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 785              		.loc 1 2135 0 is_stmt 1
 786 00e0 B4F84510 		ldrh	r1, [r4, #69]
 787 00e4 2181     		strh	r1, [r4, #8]	@ movhi
2136:lib/ff/ff.c   **** 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector 
 788              		.loc 1 2136 0
 789 00e6 0A07     		lsls	r2, r1, #28
 790 00e8 D2D1     		bne	.L81
2138:lib/ff/ff.c   **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 791              		.loc 1 2138 0
 792 00ea B4F84720 		ldrh	r2, [r4, #71]
 793              	.LVL102:
2139:lib/ff/ff.c   **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 794              		.loc 1 2139 0
 795 00ee 02B9     		cbnz	r2, .L83
2139:lib/ff/ff.c   **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 796              		.loc 1 2139 0 is_stmt 0 discriminator 1
 797 00f0 626D     		ldr	r2, [r4, #84]
 798              	.LVL103:
 799              	.L83:
2141:lib/ff/ff.c   **** 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 800              		.loc 1 2141 0 is_stmt 1
 801 00f2 B4F84270 		ldrh	r7, [r4, #66]
 802              	.LVL104:
2142:lib/ff/ff.c   **** 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 803              		.loc 1 2142 0
 804 00f6 002F     		cmp	r7, #0
 805 00f8 CAD0     		beq	.L81
2130:lib/ff/ff.c   **** 	fasize *= b;										/* Number of sectors for FAT area */
 806              		.loc 1 2130 0
 807 00fa 05FB03F8 		mul	r8, r5, r3
2145:lib/ff/ff.c   **** 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 808              		.loc 1 2145 0
 809 00fe 07EB111C 		add	ip, r7, r1, lsr #4
 810 0102 0CEB080E 		add	lr, ip, r8
 811              	.LVL105:
2146:lib/ff/ff.c   **** 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 812              		.loc 1 2146 0
 813 0106 7245     		cmp	r2, lr
 814 0108 C2D3     		bcc	.L81
2147:lib/ff/ff.c   **** 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 815              		.loc 1 2147 0
 816 010a CEEB0202 		rsb	r2, lr, r2
 817              	.LVL106:
 818 010e B2FBF0F2 		udiv	r2, r2, r0
 819              	.LVL107:
2148:lib/ff/ff.c   **** 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 820              		.loc 1 2148 0
 821 0112 002A     		cmp	r2, #0
 822 0114 BCD0     		beq	.L81
 823              	.LVL108:
2150:lib/ff/ff.c   **** 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 824              		.loc 1 2150 0
 825 0116 40F6F575 		movw	r5, #4085
 826              	.LVL109:
 827 011a AA42     		cmp	r2, r5
 828 011c 06D9     		bls	.L100
 829              	.LVL110:
 830 011e 4FF6F570 		movw	r0, #65525
 831 0122 8242     		cmp	r2, r0
 832 0124 8CBF     		ite	hi
 833 0126 0325     		movhi	r5, #3
 834 0128 0225     		movls	r5, #2
 835 012a 00E0     		b	.L85
 836              	.LVL111:
 837              	.L100:
2149:lib/ff/ff.c   **** 	fmt = FS_FAT12;
 838              		.loc 1 2149 0
 839 012c 0125     		movs	r5, #1
 840              	.LVL112:
 841              	.L85:
2154:lib/ff/ff.c   **** 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 842              		.loc 1 2154 0
 843 012e 0232     		adds	r2, r2, #2
 844              	.LVL113:
 845 0130 E261     		str	r2, [r4, #28]
2155:lib/ff/ff.c   **** 	fs->database = bsect + sysect;						/* Data start sector */
 846              		.loc 1 2155 0
 847 0132 0EEB0600 		add	r0, lr, r6
 848 0136 E062     		str	r0, [r4, #44]
2156:lib/ff/ff.c   **** 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 849              		.loc 1 2156 0
 850 0138 F719     		adds	r7, r6, r7
 851 013a 6762     		str	r7, [r4, #36]
2157:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
 852              		.loc 1 2157 0
 853 013c 032D     		cmp	r5, #3
 854 013e 05D1     		bne	.L86
2158:lib/ff/ff.c   **** 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 855              		.loc 1 2158 0
 856 0140 0029     		cmp	r1, #0
 857 0142 A5D1     		bne	.L81
2159:lib/ff/ff.c   **** 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 858              		.loc 1 2159 0
 859 0144 216E     		ldr	r1, [r4, #96]
 860 0146 A162     		str	r1, [r4, #40]
2160:lib/ff/ff.c   **** 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 861              		.loc 1 2160 0
 862 0148 9000     		lsls	r0, r2, #2
 863              	.LVL114:
 864 014a 0DE0     		b	.L87
 865              	.LVL115:
 866              	.L86:
2162:lib/ff/ff.c   **** 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 867              		.loc 1 2162 0
 868 014c 0029     		cmp	r1, #0
 869 014e 9FD0     		beq	.L81
2163:lib/ff/ff.c   **** 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 870              		.loc 1 2163 0
 871 0150 4744     		add	r7, r8, r7
 872 0152 A762     		str	r7, [r4, #40]
2165:lib/ff/ff.c   **** 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 873              		.loc 1 2165 0
 874 0154 022D     		cmp	r5, #2
 875 0156 01D1     		bne	.L88
2165:lib/ff/ff.c   **** 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 876              		.loc 1 2165 0 is_stmt 0 discriminator 1
 877 0158 5000     		lsls	r0, r2, #1
 878 015a 05E0     		b	.L87
 879              	.L88:
2165:lib/ff/ff.c   **** 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 880              		.loc 1 2165 0 discriminator 2
 881 015c 0321     		movs	r1, #3
 882 015e 5143     		muls	r1, r2, r1
 883 0160 02F00102 		and	r2, r2, #1
 884              	.LVL116:
 885 0164 02EB5100 		add	r0, r2, r1, lsr #1
 886              	.L87:
 887              	.LVL117:
2167:lib/ff/ff.c   **** 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 888              		.loc 1 2167 0 is_stmt 1
 889 0168 00F2FF12 		addw	r2, r0, #511
 890 016c B3EB522F 		cmp	r3, r2, lsr #9
 891 0170 8ED3     		bcc	.L81
2172:lib/ff/ff.c   **** 	fs->free_clust = 0xFFFFFFFF;
 892              		.loc 1 2172 0
 893 0172 4FF0FF33 		mov	r3, #-1
 894              	.LVL118:
 895 0176 2361     		str	r3, [r4, #16]
2173:lib/ff/ff.c   **** 	fs->last_clust = 0;
 896              		.loc 1 2173 0
 897 0178 0020     		movs	r0, #0
 898              	.LVL119:
 899 017a E060     		str	r0, [r4, #12]
2176:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
 900              		.loc 1 2176 0
 901 017c 032D     		cmp	r5, #3
 902 017e 20D1     		bne	.L90
2177:lib/ff/ff.c   **** 	 	fs->fsi_flag = 0;
 903              		.loc 1 2177 0
 904 0180 6071     		strb	r0, [r4, #5]
2178:lib/ff/ff.c   **** 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 905              		.loc 1 2178 0
 906 0182 B4F86410 		ldrh	r1, [r4, #100]
 907 0186 7218     		adds	r2, r6, r1
 908              	.LVL120:
 909 0188 6261     		str	r2, [r4, #20]
2179:lib/ff/ff.c   **** 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 910              		.loc 1 2179 0
 911 018a 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 912 018c 04F13401 		add	r1, r4, #52
 913 0190 0123     		movs	r3, #1
 914 0192 FFF7FEFF 		bl	disk_read
 915              	.LVL121:
 916 0196 A0B9     		cbnz	r0, .L90
2179:lib/ff/ff.c   **** 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 917              		.loc 1 2179 0 is_stmt 0 discriminator 1
 918 0198 B4F83222 		ldrh	r2, [r4, #562]
 919 019c 4AF65523 		movw	r3, #43605
 920 01a0 9A42     		cmp	r2, r3
 921 01a2 0ED1     		bne	.L90
2180:lib/ff/ff.c   **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 922              		.loc 1 2180 0 is_stmt 1
 923 01a4 606B     		ldr	r0, [r4, #52]
 924 01a6 1849     		ldr	r1, .L120+8
 925 01a8 8842     		cmp	r0, r1
 926 01aa 0AD1     		bne	.L90
2181:lib/ff/ff.c   **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 927              		.loc 1 2181 0
 928 01ac D4F81832 		ldr	r3, [r4, #536]
 929 01b0 164A     		ldr	r2, .L120+12
 930 01b2 9342     		cmp	r3, r2
 931 01b4 05D1     		bne	.L90
2183:lib/ff/ff.c   **** 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 932              		.loc 1 2183 0
 933 01b6 D4F82002 		ldr	r0, [r4, #544]
 934 01ba E060     		str	r0, [r4, #12]
2184:lib/ff/ff.c   **** 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 935              		.loc 1 2184 0
 936 01bc D4F81C12 		ldr	r1, [r4, #540]
 937 01c0 2161     		str	r1, [r4, #16]
 938              	.L90:
2188:lib/ff/ff.c   **** 	fs->fs_type = fmt;		/* FAT sub-type */
 939              		.loc 1 2188 0
 940 01c2 2570     		strb	r5, [r4, #0]
2189:lib/ff/ff.c   **** 	fs->id = ++Fsid;		/* File system mount ID */
 941              		.loc 1 2189 0
 942 01c4 124A     		ldr	r2, .L120+16
 943 01c6 1388     		ldrh	r3, [r2, #0]
 944 01c8 581C     		adds	r0, r3, #1
 945 01ca 81B2     		uxth	r1, r0
 946 01cc 1180     		strh	r1, [r2, #0]	@ movhi
 947 01ce E180     		strh	r1, [r4, #6]	@ movhi
2190:lib/ff/ff.c   **** 	fs->winsect = 0;		/* Invalidate sector cache */
 948              		.loc 1 2190 0
 949 01d0 0020     		movs	r0, #0
 950 01d2 2063     		str	r0, [r4, #48]
2191:lib/ff/ff.c   **** 	fs->wflag = 0;
 951              		.loc 1 2191 0
 952 01d4 2071     		strb	r0, [r4, #4]
2193:lib/ff/ff.c   **** 	fs->cdir = 0;			/* Current directory (root dir) */
 953              		.loc 1 2193 0
 954 01d6 A061     		str	r0, [r4, #24]
2199:lib/ff/ff.c   **** 	return FR_OK;
 955              		.loc 1 2199 0
 956 01d8 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 957              	.LVL122:
 958              	.L92:
2073:lib/ff/ff.c   **** 		return FR_INVALID_DRIVE;
 959              		.loc 1 2073 0
 960 01dc 0B20     		movs	r0, #11
 961 01de BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 962              	.LVL123:
 963              	.L93:
2075:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 964              		.loc 1 2075 0
 965 01e2 0C20     		movs	r0, #12
 966 01e4 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 967              	.LVL124:
 968              	.L94:
2085:lib/ff/ff.c   **** 			return FR_OK;				/* The file system object is valid */
 969              		.loc 1 2085 0
 970 01e8 2846     		mov	r0, r5
 971              	.LVL125:
 972 01ea BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 973              	.LVL126:
 974              	.L96:
2096:lib/ff/ff.c   **** 		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 975              		.loc 1 2096 0
 976 01ee 0320     		movs	r0, #3
 977              	.LVL127:
 978 01f0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 979              	.LVL128:
 980              	.L97:
2098:lib/ff/ff.c   **** 		return FR_WRITE_PROTECTED;
 981              		.loc 1 2098 0
 982 01f4 0A20     		movs	r0, #10
 983              	.LVL129:
 984 01f6 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 985              	.LVL130:
 986              	.L99:
2116:lib/ff/ff.c   **** 	if (fmt == 3) return FR_DISK_ERR;
 987              		.loc 1 2116 0
 988 01fa 0120     		movs	r0, #1
 989              	.LVL131:
2200:lib/ff/ff.c   **** }
 990              		.loc 1 2200 0
 991 01fc BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 992              	.L121:
 993              		.align	2
 994              	.L120:
 995 0200 00000000 		.word	.LANCHOR0
 996 0204 00000000 		.word	.LANCHOR1
 997 0208 52526141 		.word	1096897106
 998 020c 72724161 		.word	1631679090
 999 0210 00000000 		.word	.LANCHOR2
 1000              		.cfi_endproc
 1001              	.LFE24:
 1003              		.section	.text.clust2sect,"ax",%progbits
 1004              		.align	1
 1005              		.global	clust2sect
 1006              		.thumb
 1007              		.thumb_func
 1009              	clust2sect:
 1010              	.LFB6:
 807:lib/ff/ff.c   **** {
 1011              		.loc 1 807 0
 1012              		.cfi_startproc
 1013              		@ args = 0, pretend = 0, frame = 0
 1014              		@ frame_needed = 0, uses_anonymous_args = 0
 1015              		@ link register save eliminated.
 1016              	.LVL132:
 808:lib/ff/ff.c   **** 	clst -= 2;
 1017              		.loc 1 808 0
 1018 0000 0239     		subs	r1, r1, #2
 1019              	.LVL133:
 809:lib/ff/ff.c   **** 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 1020              		.loc 1 809 0
 1021 0002 C369     		ldr	r3, [r0, #28]
 1022 0004 9A1E     		subs	r2, r3, #2
 1023 0006 9142     		cmp	r1, r2
 1024 0008 04D2     		bcs	.L124
 810:lib/ff/ff.c   **** 	return clst * fs->csize + fs->database;
 1025              		.loc 1 810 0
 1026 000a 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 1027 000c C06A     		ldr	r0, [r0, #44]
 1028              	.LVL134:
 1029 000e 02FB0100 		mla	r0, r2, r1, r0
 1030 0012 7047     		bx	lr
 1031              	.LVL135:
 1032              	.L124:
 809:lib/ff/ff.c   **** 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 1033              		.loc 1 809 0
 1034 0014 0020     		movs	r0, #0
 1035              	.LVL136:
 811:lib/ff/ff.c   **** }
 1036              		.loc 1 811 0
 1037 0016 7047     		bx	lr
 1038              		.cfi_endproc
 1039              	.LFE6:
 1041              		.section	.text.get_fat,"ax",%progbits
 1042              		.align	1
 1043              		.global	get_fat
 1044              		.thumb
 1045              		.thumb_func
 1047              	get_fat:
 1048              	.LFB7:
 825:lib/ff/ff.c   **** {
 1049              		.loc 1 825 0
 1050              		.cfi_startproc
 1051              		@ args = 0, pretend = 0, frame = 0
 1052              		@ frame_needed = 0, uses_anonymous_args = 0
 1053              	.LVL137:
 1054 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1055              	.LCFI7:
 1056              		.cfi_def_cfa_offset 24
 1057              		.cfi_offset 3, -24
 1058              		.cfi_offset 4, -20
 1059              		.cfi_offset 5, -16
 1060              		.cfi_offset 6, -12
 1061              		.cfi_offset 7, -8
 1062              		.cfi_offset 14, -4
 1063 0002 0446     		mov	r4, r0
 1064 0004 0D46     		mov	r5, r1
 830:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 1065              		.loc 1 830 0
 1066 0006 0129     		cmp	r1, #1
 1067 0008 48D9     		bls	.L135
 830:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 1068              		.loc 1 830 0 is_stmt 0 discriminator 1
 1069 000a C369     		ldr	r3, [r0, #28]
 1070 000c 9942     		cmp	r1, r3
 1071 000e 45D2     		bcs	.L135
 1072              	.LVL138:
 1073              	.LBB22:
 1074              	.LBB23:
 833:lib/ff/ff.c   **** 	switch (fs->fs_type) {
 1075              		.loc 1 833 0 is_stmt 1
 1076 0010 0178     		ldrb	r1, [r0, #0]	@ zero_extendqisi2
 1077              	.LVL139:
 1078 0012 0229     		cmp	r1, #2
 1079 0014 27D0     		beq	.L129
 1080 0016 0329     		cmp	r1, #3
 1081 0018 30D0     		beq	.L130
 1082 001a 0129     		cmp	r1, #1
 1083 001c 3BD1     		bne	.L137
 1084              	.LVL140:
 835:lib/ff/ff.c   **** 		bc = (UINT)clst; bc += bc / 2;
 1085              		.loc 1 835 0
 1086 001e 05EB5506 		add	r6, r5, r5, lsr #1
 1087              	.LVL141:
 836:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 1088              		.loc 1 836 0
 1089 0022 426A     		ldr	r2, [r0, #36]
 1090 0024 02EB5621 		add	r1, r2, r6, lsr #9
 1091 0028 FFF7FEFF 		bl	move_window
 1092              	.LVL142:
 1093 002c 0028     		cmp	r0, #0
 1094 002e 32D1     		bne	.L137
 1095              	.L131:
 837:lib/ff/ff.c   **** 		wc = fs->win[bc % SS(fs)]; bc++;
 1096              		.loc 1 837 0
 1097 0030 F005     		lsls	r0, r6, #23
 1098 0032 04EBD057 		add	r7, r4, r0, lsr #23
 1099 0036 97F83470 		ldrb	r7, [r7, #52]	@ zero_extendqisi2
 1100              	.LVL143:
 1101 003a 0136     		adds	r6, r6, #1
 1102              	.LVL144:
 838:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 1103              		.loc 1 838 0
 1104 003c 636A     		ldr	r3, [r4, #36]
 1105 003e 2046     		mov	r0, r4
 1106 0040 03EB5621 		add	r1, r3, r6, lsr #9
 1107 0044 FFF7FEFF 		bl	move_window
 1108              	.LVL145:
 1109 0048 28BB     		cbnz	r0, .L137
 839:lib/ff/ff.c   **** 		wc |= fs->win[bc % SS(fs)] << 8;
 1110              		.loc 1 839 0
 1111 004a F605     		lsls	r6, r6, #23
 1112              	.LVL146:
 1113 004c 04EBD654 		add	r4, r4, r6, lsr #23
 1114              	.LVL147:
 1115 0050 94F83410 		ldrb	r1, [r4, #52]	@ zero_extendqisi2
 1116 0054 47EA0120 		orr	r0, r7, r1, lsl #8
 1117              	.LVL148:
 840:lib/ff/ff.c   **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 1118              		.loc 1 840 0
 1119 0058 EA07     		lsls	r2, r5, #31
 1120 005a 01D5     		bpl	.L133
 1121 005c 0009     		lsrs	r0, r0, #4
 1122              	.LVL149:
 1123 005e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1124              	.LVL150:
 1125              	.L133:
 1126 0060 0205     		lsls	r2, r0, #20
 1127 0062 100D     		lsrs	r0, r2, #20
 1128              	.LVL151:
 1129 0064 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1130              	.LVL152:
 1131              	.L129:
 843:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 1132              		.loc 1 843 0
 1133 0066 426A     		ldr	r2, [r0, #36]
 1134 0068 02EB1521 		add	r1, r2, r5, lsr #8
 1135 006c FFF7FEFF 		bl	move_window
 1136              	.LVL153:
 1137 0070 88B9     		cbnz	r0, .L137
 1138              	.LVL154:
 844:lib/ff/ff.c   **** 		p = &fs->win[clst * 2 % SS(fs)];
 1139              		.loc 1 844 0
 1140 0072 2D06     		lsls	r5, r5, #24
 1141              	.LVL155:
 1142 0074 04EBD554 		add	r4, r4, r5, lsr #23
 1143              	.LVL156:
 845:lib/ff/ff.c   **** 		return LD_WORD(p);
 1144              		.loc 1 845 0
 1145 0078 A08E     		ldrh	r0, [r4, #52]
 1146 007a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1147              	.LVL157:
 1148              	.L130:
 848:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 1149              		.loc 1 848 0
 1150 007c 436A     		ldr	r3, [r0, #36]
 1151 007e 03EBD511 		add	r1, r3, r5, lsr #7
 1152 0082 FFF7FEFF 		bl	move_window
 1153              	.LVL158:
 1154 0086 30B9     		cbnz	r0, .L137
 1155              	.LVL159:
 849:lib/ff/ff.c   **** 		p = &fs->win[clst * 4 % SS(fs)];
 1156              		.loc 1 849 0
 1157 0088 6D06     		lsls	r5, r5, #25
 1158              	.LVL160:
 1159 008a 04EBD554 		add	r4, r4, r5, lsr #23
 1160              	.LVL161:
 850:lib/ff/ff.c   **** 		return LD_DWORD(p) & 0x0FFFFFFF;
 1161              		.loc 1 850 0
 1162 008e 616B     		ldr	r1, [r4, #52]
 1163 0090 21F07040 		bic	r0, r1, #-268435456
 1164 0094 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1165              	.LVL162:
 1166              	.L137:
 853:lib/ff/ff.c   **** 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 1167              		.loc 1 853 0
 1168 0096 4FF0FF30 		mov	r0, #-1
 1169 009a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1170              	.LVL163:
 1171              	.L135:
 1172              	.LBE23:
 1173              	.LBE22:
 831:lib/ff/ff.c   **** 		return 1;
 1174              		.loc 1 831 0
 1175 009c 0120     		movs	r0, #1
 1176              	.LVL164:
 854:lib/ff/ff.c   **** }
 1177              		.loc 1 854 0
 1178 009e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1179              		.cfi_endproc
 1180              	.LFE7:
 1182              		.section	.text.dir_sdi,"ax",%progbits
 1183              		.align	1
 1184              		.thumb
 1185              		.thumb_func
 1187              	dir_sdi:
 1188              	.LFB12:
1071:lib/ff/ff.c   **** {
 1189              		.loc 1 1071 0
 1190              		.cfi_startproc
 1191              		@ args = 0, pretend = 0, frame = 0
 1192              		@ frame_needed = 0, uses_anonymous_args = 0
 1193              	.LVL165:
 1194 0000 70B5     		push	{r4, r5, r6, lr}
 1195              	.LCFI8:
 1196              		.cfi_def_cfa_offset 16
 1197              		.cfi_offset 4, -16
 1198              		.cfi_offset 5, -12
 1199              		.cfi_offset 6, -8
 1200              		.cfi_offset 14, -4
 1201 0002 0446     		mov	r4, r0
 1202 0004 0D46     		mov	r5, r1
1076:lib/ff/ff.c   **** 	dj->index = idx;
 1203              		.loc 1 1076 0
 1204 0006 E180     		strh	r1, [r4, #6]	@ movhi
1077:lib/ff/ff.c   **** 	clst = dj->sclust;
 1205              		.loc 1 1077 0
 1206 0008 8168     		ldr	r1, [r0, #8]
 1207              	.LVL166:
1078:lib/ff/ff.c   **** 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
 1208              		.loc 1 1078 0
 1209 000a 0129     		cmp	r1, #1
 1210 000c 01D1     		bne	.L139
 1211              	.LVL167:
 1212              	.L141:
1079:lib/ff/ff.c   **** 		return FR_INT_ERR;
 1213              		.loc 1 1079 0
 1214 000e 0220     		movs	r0, #2
 1215 0010 70BD     		pop	{r4, r5, r6, pc}
 1216              	.LVL168:
 1217              	.L139:
1078:lib/ff/ff.c   **** 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
 1218              		.loc 1 1078 0 discriminator 1
 1219 0012 0368     		ldr	r3, [r0, #0]
 1220 0014 DA69     		ldr	r2, [r3, #28]
 1221 0016 9142     		cmp	r1, r2
 1222 0018 F9D2     		bcs	.L141
1080:lib/ff/ff.c   **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 1223              		.loc 1 1080 0
 1224 001a 71B9     		cbnz	r1, .L142
1080:lib/ff/ff.c   **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 1225              		.loc 1 1080 0 is_stmt 0 discriminator 1
 1226 001c 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 1227              	.LVL169:
 1228 001e 0328     		cmp	r0, #3
 1229 0020 01D1     		bne	.L143
1081:lib/ff/ff.c   **** 		clst = dj->fs->dirbase;
 1230              		.loc 1 1081 0 is_stmt 1
 1231 0022 996A     		ldr	r1, [r3, #40]
 1232              	.LVL170:
1083:lib/ff/ff.c   **** 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
 1233              		.loc 1 1083 0
 1234 0024 49B9     		cbnz	r1, .L142
 1235              	.L143:
1084:lib/ff/ff.c   **** 		dj->clust = clst;
 1236              		.loc 1 1084 0
 1237 0026 0020     		movs	r0, #0
 1238 0028 E060     		str	r0, [r4, #12]
1085:lib/ff/ff.c   **** 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 1239              		.loc 1 1085 0
 1240 002a 1989     		ldrh	r1, [r3, #8]
 1241              	.LVL171:
 1242 002c A942     		cmp	r1, r5
 1243 002e EED9     		bls	.L141
1087:lib/ff/ff.c   **** 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 1244              		.loc 1 1087 0
 1245 0030 9B6A     		ldr	r3, [r3, #40]
 1246 0032 03EB1512 		add	r2, r3, r5, lsr #4
 1247 0036 2261     		str	r2, [r4, #16]
 1248 0038 19E0     		b	.L144
 1249              	.LVL172:
 1250              	.L142:
1090:lib/ff/ff.c   **** 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
 1251              		.loc 1 1090 0
 1252 003a 9E78     		ldrb	r6, [r3, #2]	@ zero_extendqisi2
 1253 003c 3601     		lsls	r6, r6, #4
 1254              	.LVL173:
 1255              	.L145:
1091:lib/ff/ff.c   **** 		while (idx >= ic) {	/* Follow cluster chain */
 1256              		.loc 1 1091 0 discriminator 1
 1257 003e B542     		cmp	r5, r6
 1258 0040 0ED3     		bcc	.L148
 1259              	.L146:
1092:lib/ff/ff.c   **** 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 1260              		.loc 1 1092 0
 1261 0042 2068     		ldr	r0, [r4, #0]
 1262 0044 FFF7FEFF 		bl	get_fat
 1263              	.LVL174:
 1264 0048 0146     		mov	r1, r0
 1265              	.LVL175:
1093:lib/ff/ff.c   **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1266              		.loc 1 1093 0
 1267 004a 0130     		adds	r0, r0, #1
 1268              	.LVL176:
 1269 004c 18D0     		beq	.L147
1094:lib/ff/ff.c   **** 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
 1270              		.loc 1 1094 0
 1271 004e 0129     		cmp	r1, #1
 1272 0050 DDD9     		bls	.L141
1094:lib/ff/ff.c   **** 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
 1273              		.loc 1 1094 0 is_stmt 0 discriminator 1
 1274 0052 2368     		ldr	r3, [r4, #0]
 1275 0054 DA69     		ldr	r2, [r3, #28]
 1276 0056 9142     		cmp	r1, r2
 1277 0058 D9D2     		bcs	.L141
1096:lib/ff/ff.c   **** 			idx -= ic;
 1278              		.loc 1 1096 0 is_stmt 1
 1279 005a AD1B     		subs	r5, r5, r6
 1280              	.LVL177:
 1281 005c ADB2     		uxth	r5, r5
 1282              	.LVL178:
 1283 005e EEE7     		b	.L145
 1284              	.L148:
1098:lib/ff/ff.c   **** 		dj->clust = clst;
 1285              		.loc 1 1098 0
 1286 0060 E160     		str	r1, [r4, #12]
1099:lib/ff/ff.c   **** 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 1287              		.loc 1 1099 0
 1288 0062 2068     		ldr	r0, [r4, #0]
 1289 0064 FFF7FEFF 		bl	clust2sect
 1290              	.LVL179:
 1291 0068 00EB1511 		add	r1, r0, r5, lsr #4
 1292 006c 2161     		str	r1, [r4, #16]
 1293              	.LVL180:
 1294              	.L144:
1102:lib/ff/ff.c   **** 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector 
 1295              		.loc 1 1102 0
 1296 006e 05F00F05 		and	r5, r5, #15
 1297              	.LVL181:
 1298 0072 2068     		ldr	r0, [r4, #0]
 1299 0074 00EB4511 		add	r1, r0, r5, lsl #5
 1300 0078 3431     		adds	r1, r1, #52
 1301 007a 6161     		str	r1, [r4, #20]
1104:lib/ff/ff.c   **** 	return FR_OK;	/* Seek succeeded */
 1302              		.loc 1 1104 0
 1303 007c 0020     		movs	r0, #0
 1304 007e 70BD     		pop	{r4, r5, r6, pc}
 1305              	.LVL182:
 1306              	.L147:
1093:lib/ff/ff.c   **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1307              		.loc 1 1093 0
 1308 0080 0120     		movs	r0, #1
1105:lib/ff/ff.c   **** }
 1309              		.loc 1 1105 0
 1310 0082 70BD     		pop	{r4, r5, r6, pc}
 1311              		.cfi_endproc
 1312              	.LFE12:
 1314              		.section	.text.dir_remove,"ax",%progbits
 1315              		.align	1
 1316              		.thumb
 1317              		.thumb_func
 1319              	dir_remove:
 1320              	.LFB19:
1617:lib/ff/ff.c   **** {
 1321              		.loc 1 1617 0
 1322              		.cfi_startproc
 1323              		@ args = 0, pretend = 0, frame = 0
 1324              		@ frame_needed = 0, uses_anonymous_args = 0
 1325              	.LVL183:
 1326 0000 10B5     		push	{r4, lr}
 1327              	.LCFI9:
 1328              		.cfi_def_cfa_offset 8
 1329              		.cfi_offset 4, -8
 1330              		.cfi_offset 14, -4
 1331 0002 0446     		mov	r4, r0
1637:lib/ff/ff.c   **** 	res = dir_sdi(dj, dj->index);
 1332              		.loc 1 1637 0
 1333 0004 C188     		ldrh	r1, [r0, #6]
 1334 0006 FFF7FEFF 		bl	dir_sdi
 1335              	.LVL184:
1638:lib/ff/ff.c   **** 	if (res == FR_OK) {
 1336              		.loc 1 1638 0
 1337 000a 50B9     		cbnz	r0, .L150
 1338              	.LVL185:
 1339              	.LBB26:
 1340              	.LBB27:
1639:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
 1341              		.loc 1 1639 0
 1342 000c 2068     		ldr	r0, [r4, #0]
 1343              	.LVL186:
 1344 000e 2169     		ldr	r1, [r4, #16]
 1345 0010 FFF7FEFF 		bl	move_window
 1346              	.LVL187:
1640:lib/ff/ff.c   **** 		if (res == FR_OK) {
 1347              		.loc 1 1640 0
 1348 0014 28B9     		cbnz	r0, .L150
1641:lib/ff/ff.c   **** 			*dj->dir = DDE;			/* Mark the entry "deleted" */
 1349              		.loc 1 1641 0
 1350 0016 6369     		ldr	r3, [r4, #20]
 1351 0018 E522     		movs	r2, #229
 1352 001a 1A70     		strb	r2, [r3, #0]
1642:lib/ff/ff.c   **** 			dj->fs->wflag = 1;
 1353              		.loc 1 1642 0
 1354 001c 2168     		ldr	r1, [r4, #0]
 1355 001e 0123     		movs	r3, #1
 1356 0020 0B71     		strb	r3, [r1, #4]
 1357              	.LVL188:
 1358              	.L150:
 1359              	.LBE27:
 1360              	.LBE26:
1648:lib/ff/ff.c   **** }
 1361              		.loc 1 1648 0
 1362 0022 10BD     		pop	{r4, pc}
 1363              		.cfi_endproc
 1364              	.LFE19:
 1366              		.section	.text.put_fat,"ax",%progbits
 1367              		.align	1
 1368              		.global	put_fat
 1369              		.thumb
 1370              		.thumb_func
 1372              	put_fat:
 1373              	.LFB8:
 869:lib/ff/ff.c   **** {
 1374              		.loc 1 869 0
 1375              		.cfi_startproc
 1376              		@ args = 0, pretend = 0, frame = 0
 1377              		@ frame_needed = 0, uses_anonymous_args = 0
 1378              	.LVL189:
 1379 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1380              	.LCFI10:
 1381              		.cfi_def_cfa_offset 24
 1382              		.cfi_offset 3, -24
 1383              		.cfi_offset 4, -20
 1384              		.cfi_offset 5, -16
 1385              		.cfi_offset 6, -12
 1386              		.cfi_offset 7, -8
 1387              		.cfi_offset 14, -4
 1388 0002 0446     		mov	r4, r0
 1389 0004 0D46     		mov	r5, r1
 1390 0006 1646     		mov	r6, r2
 875:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 1391              		.loc 1 875 0
 1392 0008 0129     		cmp	r1, #1
 1393 000a 5ED9     		bls	.L163
 875:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 1394              		.loc 1 875 0 is_stmt 0 discriminator 1
 1395 000c C369     		ldr	r3, [r0, #28]
 1396 000e 9942     		cmp	r1, r3
 1397 0010 5BD2     		bcs	.L163
 1398              	.LVL190:
 1399              	.LBB30:
 1400              	.LBB31:
 879:lib/ff/ff.c   **** 		switch (fs->fs_type) {
 1401              		.loc 1 879 0 is_stmt 1
 1402 0012 0178     		ldrb	r1, [r0, #0]	@ zero_extendqisi2
 1403              	.LVL191:
 1404 0014 0229     		cmp	r1, #2
 1405 0016 39D0     		beq	.L156
 1406 0018 0329     		cmp	r1, #3
 1407 001a 42D0     		beq	.L157
 1408 001c 0129     		cmp	r1, #1
 1409 001e 50D1     		bne	.L165
 1410              	.LVL192:
 881:lib/ff/ff.c   **** 			bc = (UINT)clst; bc += bc / 2;
 1411              		.loc 1 881 0
 1412 0020 05EB5507 		add	r7, r5, r5, lsr #1
 1413              	.LVL193:
 882:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 1414              		.loc 1 882 0
 1415 0024 426A     		ldr	r2, [r0, #36]
 1416              	.LVL194:
 1417 0026 02EB5721 		add	r1, r2, r7, lsr #9
 1418 002a FFF7FEFF 		bl	move_window
 1419              	.LVL195:
 883:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 1420              		.loc 1 883 0
 1421 002e 0028     		cmp	r0, #0
 1422 0030 48D1     		bne	.L154
 884:lib/ff/ff.c   **** 			p = &fs->win[bc % SS(fs)];
 1423              		.loc 1 884 0
 1424 0032 F805     		lsls	r0, r7, #23
 1425              	.LVL196:
 1426 0034 C20D     		lsrs	r2, r0, #23
 1427              	.LVL197:
 885:lib/ff/ff.c   **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 1428              		.loc 1 885 0
 1429 0036 15F00105 		ands	r5, r5, #1
 1430              	.LVL198:
 1431 003a F3B2     		uxtb	r3, r6
 1432 003c 07D0     		beq	.L159
 1433 003e A118     		adds	r1, r4, r2
 1434              	.LBE31:
 1435 0040 91F83400 		ldrb	r0, [r1, #52]	@ zero_extendqisi2
 1436 0044 00F00F01 		and	r1, r0, #15
 1437              	.LBB32:
 1438 0048 41EA0313 		orr	r3, r1, r3, lsl #4
 1439 004c DBB2     		uxtb	r3, r3
 1440              	.L159:
 1441 004e A218     		adds	r2, r4, r2
 1442              	.LVL199:
 1443 0050 82F83430 		strb	r3, [r2, #52]
 886:lib/ff/ff.c   **** 			bc++;
 1444              		.loc 1 886 0
 1445 0054 0137     		adds	r7, r7, #1
 1446              	.LVL200:
 887:lib/ff/ff.c   **** 			fs->wflag = 1;
 1447              		.loc 1 887 0
 1448 0056 0120     		movs	r0, #1
 1449 0058 2071     		strb	r0, [r4, #4]
 888:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 1450              		.loc 1 888 0
 1451 005a 616A     		ldr	r1, [r4, #36]
 1452 005c 2046     		mov	r0, r4
 1453 005e 01EB5721 		add	r1, r1, r7, lsr #9
 1454 0062 FFF7FEFF 		bl	move_window
 1455              	.LVL201:
 889:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 1456              		.loc 1 889 0
 1457 0066 68BB     		cbnz	r0, .L154
 890:lib/ff/ff.c   **** 			p = &fs->win[bc % SS(fs)];
 1458              		.loc 1 890 0
 1459 0068 FF05     		lsls	r7, r7, #23
 1460              	.LVL202:
 1461 006a FA0D     		lsrs	r2, r7, #23
 1462              	.LVL203:
 891:lib/ff/ff.c   **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 1463              		.loc 1 891 0
 1464 006c 15B1     		cbz	r5, .L160
 1465 006e C6F30716 		ubfx	r6, r6, #4, #8
 1466              	.LVL204:
 1467 0072 07E0     		b	.L161
 1468              	.LVL205:
 1469              	.L160:
 1470 0074 A318     		adds	r3, r4, r2
 1471 0076 93F83410 		ldrb	r1, [r3, #52]	@ zero_extendqisi2
 1472 007a 21F00F07 		bic	r7, r1, #15
 1473              	.LBE32:
 1474 007e C6F30326 		ubfx	r6, r6, #8, #4
 1475              	.LVL206:
 1476              	.LBB33:
 1477 0082 3E43     		orrs	r6, r6, r7
 1478              	.L161:
 1479 0084 A718     		adds	r7, r4, r2
 1480 0086 87F83460 		strb	r6, [r7, #52]
 1481 008a 1BE0     		b	.L154
 1482              	.LVL207:
 1483              	.L156:
 895:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 1484              		.loc 1 895 0
 1485 008c 426A     		ldr	r2, [r0, #36]
 1486              	.LVL208:
 1487 008e 02EB1521 		add	r1, r2, r5, lsr #8
 1488 0092 FFF7FEFF 		bl	move_window
 1489              	.LVL209:
 896:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 1490              		.loc 1 896 0
 1491 0096 A8B9     		cbnz	r0, .L154
 1492              	.LVL210:
 897:lib/ff/ff.c   **** 			p = &fs->win[clst * 2 % SS(fs)];
 1493              		.loc 1 897 0
 1494 0098 2D06     		lsls	r5, r5, #24
 1495              	.LVL211:
 1496 009a 04EBD555 		add	r5, r4, r5, lsr #23
 898:lib/ff/ff.c   **** 			ST_WORD(p, (WORD)val);
 1497              		.loc 1 898 0
 1498 009e AE86     		strh	r6, [r5, #52]	@ movhi
 1499 00a0 10E0     		b	.L154
 1500              	.LVL212:
 1501              	.L157:
 902:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 1502              		.loc 1 902 0
 1503 00a2 426A     		ldr	r2, [r0, #36]
 1504              	.LVL213:
 1505 00a4 02EBD511 		add	r1, r2, r5, lsr #7
 1506 00a8 FFF7FEFF 		bl	move_window
 1507              	.LVL214:
 903:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 1508              		.loc 1 903 0
 1509 00ac 50B9     		cbnz	r0, .L154
 904:lib/ff/ff.c   **** 			p = &fs->win[clst * 4 % SS(fs)];
 1510              		.loc 1 904 0
 1511 00ae 6D06     		lsls	r5, r5, #25
 1512              	.LVL215:
 1513 00b0 04EBD555 		add	r5, r4, r5, lsr #23
 1514              	.LVL216:
 905:lib/ff/ff.c   **** 			val |= LD_DWORD(p) & 0xF0000000;
 1515              		.loc 1 905 0
 1516 00b4 6B6B     		ldr	r3, [r5, #52]
 1517 00b6 03F07041 		and	r1, r3, #-268435456
 1518 00ba 0E43     		orrs	r6, r6, r1
 1519              	.LVL217:
 906:lib/ff/ff.c   **** 			ST_DWORD(p, val);
 1520              		.loc 1 906 0
 1521 00bc 6E63     		str	r6, [r5, #52]
 904:lib/ff/ff.c   **** 			p = &fs->win[clst * 4 % SS(fs)];
 1522              		.loc 1 904 0
 1523 00be 3035     		adds	r5, r5, #48
 1524              	.LVL218:
 1525 00c0 00E0     		b	.L154
 1526              	.LVL219:
 1527              	.L165:
 910:lib/ff/ff.c   **** 			res = FR_INT_ERR;
 1528              		.loc 1 910 0
 1529 00c2 0220     		movs	r0, #2
 1530              	.LVL220:
 1531              	.L154:
 912:lib/ff/ff.c   **** 		fs->wflag = 1;
 1532              		.loc 1 912 0
 1533 00c4 0123     		movs	r3, #1
 1534 00c6 2371     		strb	r3, [r4, #4]
 1535 00c8 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1536              	.LVL221:
 1537              	.L163:
 1538              	.LBE33:
 1539              	.LBE30:
 876:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 1540              		.loc 1 876 0
 1541 00ca 0220     		movs	r0, #2
 1542              	.LVL222:
 916:lib/ff/ff.c   **** }
 1543              		.loc 1 916 0
 1544 00cc F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1545              		.cfi_endproc
 1546              	.LFE8:
 1548              		.section	.text.create_chain,"ax",%progbits
 1549              		.align	1
 1550              		.thumb
 1551              		.thumb_func
 1553              	create_chain:
 1554              	.LFB10:
 984:lib/ff/ff.c   **** {
 1555              		.loc 1 984 0
 1556              		.cfi_startproc
 1557              		@ args = 0, pretend = 0, frame = 0
 1558              		@ frame_needed = 0, uses_anonymous_args = 0
 1559              	.LVL223:
 1560 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1561              	.LCFI11:
 1562              		.cfi_def_cfa_offset 24
 1563              		.cfi_offset 3, -24
 1564              		.cfi_offset 4, -20
 1565              		.cfi_offset 5, -16
 1566              		.cfi_offset 6, -12
 1567              		.cfi_offset 7, -8
 1568              		.cfi_offset 14, -4
 1569 0002 0546     		mov	r5, r0
 989:lib/ff/ff.c   **** 	if (clst == 0) {		/* Create a new chain */
 1570              		.loc 1 989 0
 1571 0004 0F46     		mov	r7, r1
 1572 0006 31B9     		cbnz	r1, .L167
 990:lib/ff/ff.c   **** 		scl = fs->last_clust;			/* Get suggested start point */
 1573              		.loc 1 990 0
 1574 0008 C668     		ldr	r6, [r0, #12]
 1575              	.LVL224:
 991:lib/ff/ff.c   **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
 1576              		.loc 1 991 0
 1577 000a 6EB1     		cbz	r6, .L182
 991:lib/ff/ff.c   **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
 1578              		.loc 1 991 0 is_stmt 0 discriminator 2
 1579 000c C069     		ldr	r0, [r0, #28]
 1580              	.LVL225:
 1581 000e 8642     		cmp	r6, r0
 1582 0010 28BF     		it	cs
 1583 0012 0126     		movcs	r6, #1
 1584              	.LVL226:
 1585 0014 09E0     		b	.L168
 1586              	.LVL227:
 1587              	.L167:
 994:lib/ff/ff.c   **** 		cs = get_fat(fs, clst);			/* Check the cluster status */
 1588              		.loc 1 994 0 is_stmt 1
 1589 0016 FFF7FEFF 		bl	get_fat
 1590              	.LVL228:
 995:lib/ff/ff.c   **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
 1591              		.loc 1 995 0
 1592 001a 0128     		cmp	r0, #1
 1593 001c 3BD9     		bls	.L194
 1594              	.L169:
 996:lib/ff/ff.c   **** 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 1595              		.loc 1 996 0
 1596 001e EB69     		ldr	r3, [r5, #28]
 1597 0020 9842     		cmp	r0, r3
 1598 0022 39D3     		bcc	.L170
 1599 0024 3E46     		mov	r6, r7
 1600 0026 00E0     		b	.L168
 1601              	.LVL229:
 1602              	.L182:
 991:lib/ff/ff.c   **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
 1603              		.loc 1 991 0
 1604 0028 0126     		movs	r6, #1
 1605              	.LVL230:
 1606              	.L168:
 1607 002a 3446     		mov	r4, r6
 1608              	.L176:
 1609              	.LVL231:
1002:lib/ff/ff.c   **** 		ncl++;							/* Next cluster */
 1610              		.loc 1 1002 0
 1611 002c 0134     		adds	r4, r4, #1
 1612              	.LVL232:
1003:lib/ff/ff.c   **** 		if (ncl >= fs->n_fatent) {		/* Wrap around */
 1613              		.loc 1 1003 0
 1614 002e E969     		ldr	r1, [r5, #28]
 1615 0030 8C42     		cmp	r4, r1
 1616 0032 04D3     		bcc	.L171
 1617              	.LVL233:
1005:lib/ff/ff.c   **** 			if (ncl > scl) return 0;	/* No free cluster */
 1618              		.loc 1 1005 0
 1619 0034 012E     		cmp	r6, #1
 1620 0036 01D8     		bhi	.L184
 1621              	.LVL234:
 1622              	.L175:
 1623 0038 0020     		movs	r0, #0
 1624 003a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1625              	.LVL235:
 1626              	.L184:
1004:lib/ff/ff.c   **** 			ncl = 2;
 1627              		.loc 1 1004 0
 1628 003c 0224     		movs	r4, #2
 1629              	.LVL236:
 1630              	.L171:
1007:lib/ff/ff.c   **** 		cs = get_fat(fs, ncl);			/* Get the cluster status */
 1631              		.loc 1 1007 0
 1632 003e 2846     		mov	r0, r5
 1633 0040 2146     		mov	r1, r4
 1634 0042 FFF7FEFF 		bl	get_fat
 1635              	.LVL237:
1008:lib/ff/ff.c   **** 		if (cs == 0) break;				/* Found a free cluster */
 1636              		.loc 1 1008 0
 1637 0046 48B1     		cbz	r0, .L172
1009:lib/ff/ff.c   **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 1638              		.loc 1 1009 0
 1639 0048 411C     		adds	r1, r0, #1
 1640 004a 02D1     		bne	.L173
 1641              	.LVL238:
 1642              	.L181:
1025:lib/ff/ff.c   **** 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 1643              		.loc 1 1025 0
 1644 004c 4FF0FF30 		mov	r0, #-1
 1645 0050 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1646              	.LVL239:
 1647              	.L173:
1009:lib/ff/ff.c   **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 1648              		.loc 1 1009 0 discriminator 1
 1649 0052 0128     		cmp	r0, #1
 1650 0054 1FD0     		beq	.L194
1011:lib/ff/ff.c   **** 		if (ncl == scl) return 0;		/* No free cluster */
 1651              		.loc 1 1011 0
 1652 0056 B442     		cmp	r4, r6
 1653 0058 E8D1     		bne	.L176
 1654 005a EDE7     		b	.L175
 1655              	.L172:
1014:lib/ff/ff.c   **** 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
 1656              		.loc 1 1014 0
 1657 005c 2846     		mov	r0, r5
 1658              	.LVL240:
 1659 005e 2146     		mov	r1, r4
 1660 0060 6FF07042 		mvn	r2, #-268435456
 1661 0064 FFF7FEFF 		bl	put_fat
 1662              	.LVL241:
1015:lib/ff/ff.c   **** 	if (res == FR_OK && clst != 0) {
 1663              		.loc 1 1015 0
 1664 0068 98B9     		cbnz	r0, .L177
1015:lib/ff/ff.c   **** 	if (res == FR_OK && clst != 0) {
 1665              		.loc 1 1015 0 is_stmt 0 discriminator 1
 1666 006a 47B9     		cbnz	r7, .L178
 1667              	.L180:
1019:lib/ff/ff.c   **** 		fs->last_clust = ncl;			/* Update FSINFO */
 1668              		.loc 1 1019 0 is_stmt 1
 1669 006c EC60     		str	r4, [r5, #12]
1020:lib/ff/ff.c   **** 		if (fs->free_clust != 0xFFFFFFFF) {
 1670              		.loc 1 1020 0
 1671 006e 2B69     		ldr	r3, [r5, #16]
 1672 0070 5A1C     		adds	r2, r3, #1
 1673 0072 0CD0     		beq	.L195
 1674              	.L179:
1021:lib/ff/ff.c   **** 			fs->free_clust--;
 1675              		.loc 1 1021 0
 1676 0074 5A1E     		subs	r2, r3, #1
 1677 0076 2A61     		str	r2, [r5, #16]
1022:lib/ff/ff.c   **** 			fs->fsi_flag = 1;
 1678              		.loc 1 1022 0
 1679 0078 0120     		movs	r0, #1
 1680              	.LVL242:
 1681 007a 6871     		strb	r0, [r5, #5]
 1682 007c 07E0     		b	.L195
 1683              	.LVL243:
 1684              	.L178:
1016:lib/ff/ff.c   **** 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 1685              		.loc 1 1016 0
 1686 007e 2846     		mov	r0, r5
 1687              	.LVL244:
 1688 0080 3946     		mov	r1, r7
 1689 0082 2246     		mov	r2, r4
 1690 0084 FFF7FEFF 		bl	put_fat
 1691              	.LVL245:
1018:lib/ff/ff.c   **** 	if (res == FR_OK) {
 1692              		.loc 1 1018 0
 1693 0088 0028     		cmp	r0, #0
 1694 008a EFD0     		beq	.L180
 1695 008c 01E0     		b	.L177
 1696              	.LVL246:
 1697              	.L195:
1022:lib/ff/ff.c   **** 			fs->fsi_flag = 1;
 1698              		.loc 1 1022 0
 1699 008e 2046     		mov	r0, r4
 1700 0090 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1701              	.LVL247:
 1702              	.L177:
1025:lib/ff/ff.c   **** 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 1703              		.loc 1 1025 0
 1704 0092 0128     		cmp	r0, #1
 1705 0094 DAD0     		beq	.L181
 1706              	.LVL248:
 1707              	.L194:
 1708 0096 0120     		movs	r0, #1
 1709              	.L170:
1029:lib/ff/ff.c   **** }
 1710              		.loc 1 1029 0
 1711 0098 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1712              		.cfi_endproc
 1713              	.LFE10:
 1715              		.section	.text.dir_next,"ax",%progbits
 1716              		.align	1
 1717              		.thumb
 1718              		.thumb_func
 1720              	dir_next:
 1721              	.LFB13:
1119:lib/ff/ff.c   **** {
 1722              		.loc 1 1119 0
 1723              		.cfi_startproc
 1724              		@ args = 0, pretend = 0, frame = 0
 1725              		@ frame_needed = 0, uses_anonymous_args = 0
 1726              	.LVL249:
 1727 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1728              	.LCFI12:
 1729              		.cfi_def_cfa_offset 32
 1730              		.cfi_offset 3, -32
 1731              		.cfi_offset 4, -28
 1732              		.cfi_offset 5, -24
 1733              		.cfi_offset 6, -20
 1734              		.cfi_offset 7, -16
 1735              		.cfi_offset 8, -12
 1736              		.cfi_offset 9, -8
 1737              		.cfi_offset 14, -4
 1738 0004 0446     		mov	r4, r0
 1739 0006 0F46     		mov	r7, r1
1125:lib/ff/ff.c   **** 	i = dj->index + 1;
 1740              		.loc 1 1125 0
 1741 0008 C688     		ldrh	r6, [r0, #6]
 1742 000a 701C     		adds	r0, r6, #1
 1743              	.LVL250:
 1744 000c 86B2     		uxth	r6, r0
 1745              	.LVL251:
1126:lib/ff/ff.c   **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 1746              		.loc 1 1126 0
 1747 000e 16B9     		cbnz	r6, .L197
 1748              	.LVL252:
 1749              	.L199:
 1750              	.LBB34:
1127:lib/ff/ff.c   **** 		return FR_NO_FILE;
 1751              		.loc 1 1127 0
 1752 0010 0420     		movs	r0, #4
 1753 0012 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1754              	.LVL253:
 1755              	.L197:
 1756              	.LBE34:
1126:lib/ff/ff.c   **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 1757              		.loc 1 1126 0 discriminator 1
 1758 0016 2369     		ldr	r3, [r4, #16]
 1759 0018 002B     		cmp	r3, #0
 1760 001a F9D0     		beq	.L199
1129:lib/ff/ff.c   **** 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
 1761              		.loc 1 1129 0
 1762 001c 16F00F08 		ands	r8, r6, #15
 1763 0020 5CD1     		bne	.L201
1130:lib/ff/ff.c   **** 		dj->sect++;					/* Next sector */
 1764              		.loc 1 1130 0
 1765 0022 591C     		adds	r1, r3, #1
 1766              	.LVL254:
 1767 0024 2161     		str	r1, [r4, #16]
1132:lib/ff/ff.c   **** 		if (dj->clust == 0) {	/* Static table */
 1768              		.loc 1 1132 0
 1769 0026 E168     		ldr	r1, [r4, #12]
 1770 0028 2068     		ldr	r0, [r4, #0]
 1771              	.LVL255:
 1772 002a 19B9     		cbnz	r1, .L202
1133:lib/ff/ff.c   **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 1773              		.loc 1 1133 0
 1774 002c 0189     		ldrh	r1, [r0, #8]
 1775 002e B142     		cmp	r1, r6
 1776 0030 EED9     		bls	.L199
 1777 0032 53E0     		b	.L201
 1778              	.L202:
1137:lib/ff/ff.c   **** 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 1779              		.loc 1 1137 0
 1780 0034 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 1781 0036 531E     		subs	r3, r2, #1
 1782 0038 13EA1612 		ands	r2, r3, r6, lsr #4
 1783 003c 4ED1     		bne	.L201
1138:lib/ff/ff.c   **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 1784              		.loc 1 1138 0
 1785 003e FFF7FEFF 		bl	get_fat
 1786              	.LVL256:
 1787 0042 0546     		mov	r5, r0
 1788              	.LVL257:
1139:lib/ff/ff.c   **** 				if (clst <= 1) return FR_INT_ERR;
 1789              		.loc 1 1139 0
 1790 0044 0128     		cmp	r0, #1
 1791 0046 02D8     		bhi	.L204
 1792              	.L207:
 1793 0048 0220     		movs	r0, #2
 1794              	.LVL258:
 1795 004a BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1796              	.LVL259:
 1797              	.L204:
1140:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 1798              		.loc 1 1140 0
 1799 004e 431C     		adds	r3, r0, #1
 1800 0050 02D1     		bne	.L205
 1801              	.LVL260:
 1802              	.L208:
 1803 0052 0120     		movs	r0, #1
 1804 0054 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1805              	.LVL261:
 1806              	.L205:
1141:lib/ff/ff.c   **** 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 1807              		.loc 1 1141 0
 1808 0058 2068     		ldr	r0, [r4, #0]
 1809              	.LVL262:
 1810 005a C169     		ldr	r1, [r0, #28]
 1811 005c 8D42     		cmp	r5, r1
 1812 005e 37D3     		bcc	.L206
 1813              	.LBB35:
1144:lib/ff/ff.c   **** 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
 1814              		.loc 1 1144 0
 1815 0060 002F     		cmp	r7, #0
 1816 0062 D5D0     		beq	.L199
1145:lib/ff/ff.c   **** 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
 1817              		.loc 1 1145 0
 1818 0064 E168     		ldr	r1, [r4, #12]
 1819 0066 FFF7FEFF 		bl	create_chain
 1820              	.LVL263:
1146:lib/ff/ff.c   **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
 1821              		.loc 1 1146 0
 1822 006a 0546     		mov	r5, r0
 1823 006c 0028     		cmp	r0, #0
 1824 006e 3ED0     		beq	.L211
1147:lib/ff/ff.c   **** 					if (clst == 1) return FR_INT_ERR;
 1825              		.loc 1 1147 0
 1826 0070 0128     		cmp	r0, #1
 1827 0072 E9D0     		beq	.L207
1148:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 1828              		.loc 1 1148 0
 1829 0074 0130     		adds	r0, r0, #1
 1830              	.LVL264:
 1831 0076 ECD0     		beq	.L208
1150:lib/ff/ff.c   **** 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
 1832              		.loc 1 1150 0
 1833 0078 2068     		ldr	r0, [r4, #0]
 1834 007a 0021     		movs	r1, #0
 1835 007c FFF7FEFF 		bl	move_window
 1836              	.LVL265:
 1837 0080 0746     		mov	r7, r0
 1838              	.LVL266:
 1839 0082 0028     		cmp	r0, #0
 1840 0084 E5D1     		bne	.L208
1151:lib/ff/ff.c   **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 1841              		.loc 1 1151 0
 1842 0086 2068     		ldr	r0, [r4, #0]
 1843 0088 3430     		adds	r0, r0, #52
 1844 008a 3946     		mov	r1, r7
 1845 008c 4FF40072 		mov	r2, #512
 1846 0090 FFF7FEFF 		bl	mem_set
 1847              	.LVL267:
1152:lib/ff/ff.c   **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 1848              		.loc 1 1152 0
 1849 0094 D4F80090 		ldr	r9, [r4, #0]
 1850 0098 4846     		mov	r0, r9
 1851 009a 2946     		mov	r1, r5
 1852 009c FFF7FEFF 		bl	clust2sect
 1853              	.LVL268:
 1854 00a0 C9F83000 		str	r0, [r9, #48]
 1855              	.LVL269:
 1856              	.L209:
1153:lib/ff/ff.c   **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 1857              		.loc 1 1153 0 discriminator 1
 1858 00a4 2068     		ldr	r0, [r4, #0]
 1859 00a6 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 1860 00a8 BA42     		cmp	r2, r7
 1861 00aa 0ED9     		bls	.L224
 1862              	.L210:
1154:lib/ff/ff.c   **** 						dj->fs->wflag = 1;
 1863              		.loc 1 1154 0
 1864 00ac 0121     		movs	r1, #1
 1865 00ae 0171     		strb	r1, [r0, #4]
1155:lib/ff/ff.c   **** 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
 1866              		.loc 1 1155 0
 1867 00b0 2068     		ldr	r0, [r4, #0]
 1868 00b2 0021     		movs	r1, #0
 1869 00b4 FFF7FEFF 		bl	move_window
 1870              	.LVL270:
 1871 00b8 0028     		cmp	r0, #0
 1872 00ba CAD1     		bne	.L208
1156:lib/ff/ff.c   **** 						dj->fs->winsect++;
 1873              		.loc 1 1156 0
 1874 00bc 2068     		ldr	r0, [r4, #0]
 1875 00be 026B     		ldr	r2, [r0, #48]
 1876 00c0 531C     		adds	r3, r2, #1
 1877 00c2 0363     		str	r3, [r0, #48]
1153:lib/ff/ff.c   **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 1878              		.loc 1 1153 0
 1879 00c4 0137     		adds	r7, r7, #1
 1880              	.LVL271:
 1881 00c6 FFB2     		uxtb	r7, r7
 1882              	.LVL272:
 1883 00c8 ECE7     		b	.L209
 1884              	.L224:
1158:lib/ff/ff.c   **** 					dj->fs->winsect -= c;						/* Rewind window address */
 1885              		.loc 1 1158 0
 1886 00ca 036B     		ldr	r3, [r0, #48]
 1887 00cc DF1B     		subs	r7, r3, r7
 1888              	.LVL273:
 1889 00ce 0763     		str	r7, [r0, #48]
 1890              	.L206:
 1891              	.LBE35:
1163:lib/ff/ff.c   **** 				dj->clust = clst;				/* Initialize data for new cluster */
 1892              		.loc 1 1163 0
 1893 00d0 E560     		str	r5, [r4, #12]
1164:lib/ff/ff.c   **** 				dj->sect = clust2sect(dj->fs, clst);
 1894              		.loc 1 1164 0
 1895 00d2 2068     		ldr	r0, [r4, #0]
 1896 00d4 2946     		mov	r1, r5
 1897 00d6 FFF7FEFF 		bl	clust2sect
 1898              	.LVL274:
 1899 00da 2061     		str	r0, [r4, #16]
 1900              	.LVL275:
 1901              	.L201:
1169:lib/ff/ff.c   **** 	dj->index = i;
 1902              		.loc 1 1169 0
 1903 00dc E680     		strh	r6, [r4, #6]	@ movhi
1170:lib/ff/ff.c   **** 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 1904              		.loc 1 1170 0
 1905 00de 2068     		ldr	r0, [r4, #0]
 1906 00e0 00EB4812 		add	r2, r0, r8, lsl #5
 1907 00e4 3432     		adds	r2, r2, #52
 1908 00e6 6261     		str	r2, [r4, #20]
1172:lib/ff/ff.c   **** 	return FR_OK;
 1909              		.loc 1 1172 0
 1910 00e8 0020     		movs	r0, #0
 1911 00ea BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1912              	.LVL276:
 1913              	.L211:
 1914              	.LBB36:
1146:lib/ff/ff.c   **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
 1915              		.loc 1 1146 0
 1916 00ee 0720     		movs	r0, #7
 1917              	.LVL277:
 1918              	.LBE36:
1173:lib/ff/ff.c   **** }
 1919              		.loc 1 1173 0
 1920 00f0 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1921              		.cfi_endproc
 1922              	.LFE13:
 1924              		.section	.text.follow_path,"ax",%progbits
 1925              		.align	1
 1926              		.thumb
 1927              		.thumb_func
 1929              	follow_path:
 1930              	.LFB22:
1959:lib/ff/ff.c   **** {
 1931              		.loc 1 1959 0
 1932              		.cfi_startproc
 1933              		@ args = 0, pretend = 0, frame = 0
 1934              		@ frame_needed = 0, uses_anonymous_args = 0
 1935              	.LVL278:
 1936 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1937              	.LCFI13:
 1938              		.cfi_def_cfa_offset 24
 1939              		.cfi_offset 4, -24
 1940              		.cfi_offset 5, -20
 1941              		.cfi_offset 6, -16
 1942              		.cfi_offset 7, -12
 1943              		.cfi_offset 8, -8
 1944              		.cfi_offset 14, -4
 1945 0004 0446     		mov	r4, r0
 1946 0006 0F46     		mov	r7, r1
1965:lib/ff/ff.c   **** 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
 1947              		.loc 1 1965 0
 1948 0008 91F90030 		ldrsb	r3, [r1, #0]
 1949 000c 2F2B     		cmp	r3, #47
 1950 000e 01D0     		beq	.L226
1965:lib/ff/ff.c   **** 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
 1951              		.loc 1 1965 0 is_stmt 0 discriminator 1
 1952 0010 5C2B     		cmp	r3, #92
 1953 0012 02D1     		bne	.L227
 1954              	.L226:
1966:lib/ff/ff.c   **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 1955              		.loc 1 1966 0 is_stmt 1
 1956 0014 0137     		adds	r7, r7, #1
 1957              	.LVL279:
 1958 0016 0021     		movs	r1, #0
 1959 0018 01E0     		b	.L320
 1960              	.LVL280:
 1961              	.L227:
1968:lib/ff/ff.c   **** 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
 1962              		.loc 1 1968 0
 1963 001a 0068     		ldr	r0, [r0, #0]
 1964              	.LVL281:
 1965 001c 8169     		ldr	r1, [r0, #24]
 1966              	.LVL282:
 1967              	.L320:
 1968 001e A160     		str	r1, [r4, #8]
1976:lib/ff/ff.c   **** 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
 1969              		.loc 1 1976 0
 1970 0020 3A78     		ldrb	r2, [r7, #0]	@ zero_extendqisi2
 1971 0022 1F2A     		cmp	r2, #31
 1972 0024 4AD8     		bhi	.L316
1977:lib/ff/ff.c   **** 		res = dir_sdi(dj, 0);
 1973              		.loc 1 1977 0
 1974 0026 2046     		mov	r0, r4
 1975 0028 0021     		movs	r1, #0
 1976 002a FFF7FEFF 		bl	dir_sdi
 1977              	.LVL283:
1978:lib/ff/ff.c   **** 		dj->dir = 0;
 1978              		.loc 1 1978 0
 1979 002e 0022     		movs	r2, #0
 1980 0030 6261     		str	r2, [r4, #20]
 1981 0032 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1982              	.LVL284:
 1983              	.L315:
 1984 0036 0746     		mov	r7, r0
 1985              	.LVL285:
 1986              	.LBB47:
 1987              	.LBB48:
1795:lib/ff/ff.c   **** 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 1988              		.loc 1 1795 0
 1989 0038 0678     		ldrb	r6, [r0, #0]	@ zero_extendqisi2
 1990 003a 0130     		adds	r0, r0, #1
 1991              	.LVL286:
 1992 003c 73B2     		sxtb	r3, r6
 1993 003e 2F2B     		cmp	r3, #47
 1994 0040 F9D0     		beq	.L315
 1995 0042 5C2B     		cmp	r3, #92
 1996 0044 F7D0     		beq	.L315
1796:lib/ff/ff.c   **** 	sfn = dj->fn;
 1997              		.loc 1 1796 0
 1998 0046 A669     		ldr	r6, [r4, #24]
 1999              	.LVL287:
1797:lib/ff/ff.c   **** 	mem_set(sfn, ' ', 11);
 2000              		.loc 1 1797 0
 2001 0048 3046     		mov	r0, r6
 2002 004a 2021     		movs	r1, #32
 2003 004c 0B22     		movs	r2, #11
 2004 004e FFF7FEFF 		bl	mem_set
 2005              	.LVL288:
1800:lib/ff/ff.c   **** 	if (p[si] == '.') { /* Is this a dot entry? */
 2006              		.loc 1 1800 0
 2007 0052 97F90010 		ldrsb	r1, [r7, #0]
 2008 0056 2E29     		cmp	r1, #46
 2009 0058 3AD1     		bne	.L268
 2010              	.LVL289:
1804:lib/ff/ff.c   **** 			sfn[i++] = c;
 2011              		.loc 1 1804 0
 2012 005a 3170     		strb	r1, [r6, #0]
 2013              	.LVL290:
1802:lib/ff/ff.c   **** 			c = (BYTE)p[si++];
 2014              		.loc 1 1802 0
 2015 005c 7878     		ldrb	r0, [r7, #1]	@ zero_extendqisi2
 2016              	.LVL291:
1803:lib/ff/ff.c   **** 			if (c != '.' || si >= 3) break;
 2017              		.loc 1 1803 0
 2018 005e 2E28     		cmp	r0, #46
 2019 0060 2ED1     		bne	.L269
1804:lib/ff/ff.c   **** 			sfn[i++] = c;
 2020              		.loc 1 1804 0
 2021 0062 7070     		strb	r0, [r6, #1]
 2022              	.LVL292:
1802:lib/ff/ff.c   **** 			c = (BYTE)p[si++];
 2023              		.loc 1 1802 0
 2024 0064 B878     		ldrb	r0, [r7, #2]	@ zero_extendqisi2
 2025              	.LVL293:
 2026 0066 0323     		movs	r3, #3
 2027              	.LVL294:
 2028              	.L235:
1806:lib/ff/ff.c   **** 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
 2029              		.loc 1 1806 0
 2030 0068 2F28     		cmp	r0, #47
 2031 006a 2BD1     		bne	.L323
 2032              	.L236:
1807:lib/ff/ff.c   **** 		*path = &p[si];									/* Return pointer to the next segment */
 2033              		.loc 1 1807 0
 2034 006c FF18     		adds	r7, r7, r3
 2035              	.LVL295:
1808:lib/ff/ff.c   **** 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
 2036              		.loc 1 1808 0
 2037 006e 2028     		cmp	r0, #32
 2038 0070 8CBF     		ite	hi
 2039 0072 2023     		movhi	r3, #32
 2040 0074 2423     		movls	r3, #36
 2041              	.LVL296:
 2042              	.L322:
1859:lib/ff/ff.c   **** 	sfn[NS] = c;		/* Store NT flag, File name is created */
 2043              		.loc 1 1859 0
 2044 0076 F372     		strb	r3, [r6, #11]
 2045              	.LVL297:
 2046              	.LBE48:
 2047              	.LBE47:
 2048              	.LBB53:
 2049              	.LBB54:
1399:lib/ff/ff.c   **** 	res = dir_sdi(dj, 0);			/* Rewind directory object */
 2050              		.loc 1 1399 0
 2051 0078 2046     		mov	r0, r4
 2052 007a 0021     		movs	r1, #0
 2053 007c FFF7FEFF 		bl	dir_sdi
 2054              	.LVL298:
 2055              	.L321:
1400:lib/ff/ff.c   **** 	if (res != FR_OK) return res;
 2056              		.loc 1 1400 0
 2057 0080 30B9     		cbnz	r0, .L255
 2058              	.L300:
1406:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
 2059              		.loc 1 1406 0
 2060 0082 2068     		ldr	r0, [r4, #0]
 2061              	.LVL299:
 2062 0084 2169     		ldr	r1, [r4, #16]
 2063 0086 FFF7FEFF 		bl	move_window
 2064              	.LVL300:
1407:lib/ff/ff.c   **** 		if (res != FR_OK) break;
 2065              		.loc 1 1407 0
 2066 008a 0028     		cmp	r0, #0
 2067 008c 00F0A680 		beq	.L324
 2068              	.LVL301:
 2069              	.L255:
 2070              	.LBE54:
 2071              	.LBE53:
1984:lib/ff/ff.c   **** 			ns = *(dj->fn+NS);
 2072              		.loc 1 1984 0
 2073 0090 A169     		ldr	r1, [r4, #24]
 2074 0092 CB7A     		ldrb	r3, [r1, #11]	@ zero_extendqisi2
 2075              	.LVL302:
1985:lib/ff/ff.c   **** 			if (res != FR_OK) {				/* Failed to find the object */
 2076              		.loc 1 1985 0
 2077 0094 0028     		cmp	r0, #0
 2078 0096 00F0BA80 		beq	.L260
1986:lib/ff/ff.c   **** 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
 2079              		.loc 1 1986 0
 2080 009a 0428     		cmp	r0, #4
 2081 009c 40F0D880 		bne	.L290
1988:lib/ff/ff.c   **** 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
 2082              		.loc 1 1988 0
 2083 00a0 03F02002 		and	r2, r3, #32
 2084 00a4 D1B2     		uxtb	r1, r2
 2085              	.LVL303:
 2086 00a6 03F00400 		and	r0, r3, #4
 2087 00aa 0029     		cmp	r1, #0
 2088 00ac 00F0B680 		beq	.L261
1989:lib/ff/ff.c   **** 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
 2089              		.loc 1 1989 0
 2090 00b0 0023     		movs	r3, #0
 2091 00b2 A360     		str	r3, [r4, #8]
 2092 00b4 6361     		str	r3, [r4, #20]
 2093              	.LVL304:
1991:lib/ff/ff.c   **** 					if (!(ns & NS_LAST)) continue;
 2094              		.loc 1 1991 0
 2095 00b6 0028     		cmp	r0, #0
 2096 00b8 40F0AD80 		bne	.L263
 2097              	.LVL305:
 2098              	.L316:
 2099 00bc 3846     		mov	r0, r7
 2100 00be BAE7     		b	.L315
 2101              	.LVL306:
 2102              	.L269:
 2103              	.LBB59:
 2104              	.LBB51:
1802:lib/ff/ff.c   **** 			c = (BYTE)p[si++];
 2105              		.loc 1 1802 0
 2106 00c0 0223     		movs	r3, #2
 2107 00c2 D1E7     		b	.L235
 2108              	.LVL307:
 2109              	.L323:
1806:lib/ff/ff.c   **** 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
 2110              		.loc 1 1806 0
 2111 00c4 5C28     		cmp	r0, #92
 2112 00c6 D1D0     		beq	.L236
 2113 00c8 2028     		cmp	r0, #32
 2114 00ca 00F2C080 		bhi	.L237
 2115 00ce CDE7     		b	.L236
 2116              	.LVL308:
 2117              	.L268:
1800:lib/ff/ff.c   **** 	if (p[si] == '.') { /* Is this a dot entry? */
 2118              		.loc 1 1800 0
 2119 00d0 0022     		movs	r2, #0
 2120 00d2 9446     		mov	ip, r2
 2121 00d4 0821     		movs	r1, #8
 2122 00d6 1546     		mov	r5, r2
 2123              	.LVL309:
 2124              	.L234:
1813:lib/ff/ff.c   **** 		c = (BYTE)p[si++];
 2125              		.loc 1 1813 0
 2126 00d8 17F80C80 		ldrb	r8, [r7, ip]	@ zero_extendqisi2
 2127 00dc 5FFA88F3 		uxtb	r3, r8
 2128              	.LVL310:
 2129 00e0 0CF10100 		add	r0, ip, #1
 2130              	.LVL311:
1814:lib/ff/ff.c   **** 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 2131              		.loc 1 1814 0
 2132 00e4 202B     		cmp	r3, #32
 2133 00e6 42D9     		bls	.L271
 2134 00e8 2F2B     		cmp	r3, #47
 2135 00ea 42D0     		beq	.L273
 2136 00ec 5C2B     		cmp	r3, #92
 2137 00ee 40D0     		beq	.L273
1815:lib/ff/ff.c   **** 		if (c == '.' || i >= ni) {
 2138              		.loc 1 1815 0
 2139 00f0 2E2B     		cmp	r3, #46
 2140 00f2 6CD0     		beq	.L241
 2141 00f4 8A42     		cmp	r2, r1
 2142 00f6 80F0AA80 		bcs	.L237
1820:lib/ff/ff.c   **** 		if (c >= 0x80) {				/* Extended char? */
 2143              		.loc 1 1820 0
 2144 00fa 18F0800F 		tst	r8, #128
1821:lib/ff/ff.c   **** 			b |= 3;						/* Eliminate NT flag */
 2145              		.loc 1 1821 0
 2146 00fe 18BF     		it	ne
 2147 0100 45F00305 		orrne	r5, r5, #3
 2148              	.LVL312:
1830:lib/ff/ff.c   **** 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
 2149              		.loc 1 1830 0
 2150 0104 03F17F08 		add	r8, r3, #127
 2151              	.LVL313:
 2152 0108 5FFA88FE 		uxtb	lr, r8
 2153 010c BEF11E0F 		cmp	lr, #30
 2154 0110 06D9     		bls	.L245
 2155 0112 03F12008 		add	r8, r3, #32
 2156 0116 5FFA88FE 		uxtb	lr, r8
 2157 011a BEF11C0F 		cmp	lr, #28
 2158 011e 1AD8     		bhi	.L246
 2159              	.L245:
1831:lib/ff/ff.c   **** 			d = (BYTE)p[si++];			/* Get 2nd byte */
 2160              		.loc 1 1831 0
 2161 0120 17F80080 		ldrb	r8, [r7, r0]	@ zero_extendqisi2
 2162              	.LVL314:
 2163 0124 0CF10200 		add	r0, ip, #2
 2164              	.LVL315:
1832:lib/ff/ff.c   **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 2165              		.loc 1 1832 0
 2166 0128 A8F1400E 		sub	lr, r8, #64
 2167 012c BEF13E0F 		cmp	lr, #62
 2168 0130 05D9     		bls	.L247
 2169 0132 88F0800C 		eor	ip, r8, #128
 2170              	.LVL316:
 2171 0136 BCF17C0F 		cmp	ip, #124
 2172 013a 00F28880 		bhi	.L237
 2173              	.L247:
 2174 013e 01F1FF3E 		add	lr, r1, #-1
 2175 0142 7245     		cmp	r2, lr
 2176 0144 80F08380 		bcs	.L237
1834:lib/ff/ff.c   **** 			sfn[i++] = c;
 2177              		.loc 1 1834 0
 2178 0148 B354     		strb	r3, [r6, r2]
 2179              	.LVL317:
1835:lib/ff/ff.c   **** 			sfn[i++] = d;
 2180              		.loc 1 1835 0
 2181 014a B318     		adds	r3, r6, r2
 2182              	.LVL318:
 2183 014c 83F80180 		strb	r8, [r3, #1]
 2184 0150 0232     		adds	r2, r2, #2
 2185              	.LVL319:
 2186              	.L243:
1800:lib/ff/ff.c   **** 	if (p[si] == '.') { /* Is this a dot entry? */
 2187              		.loc 1 1800 0
 2188 0152 8446     		mov	ip, r0
 2189 0154 C0E7     		b	.L234
 2190              	.LVL320:
 2191              	.L246:
 2192 0156 DFF8FC80 		ldr	r8, .L327
 2193              	.LVL321:
 2194              	.L249:
 2195              	.LBB49:
 2196              	.LBB50:
 567:lib/ff/ff.c   **** 	while (*str && *str != chr) str++;
 2197              		.loc 1 567 0
 2198 015a 18F801CF 		ldrb	ip, [r8, #1]!	@ zero_extendqisi2
 2199 015e BCF1000F 		cmp	ip, #0
 2200 0162 20D0     		beq	.L248
 2201 0164 4FFA8CFC 		sxtb	ip, ip
 2202 0168 9C45     		cmp	ip, r3
 2203 016a F6D1     		bne	.L249
 2204 016c 6FE0     		b	.L237
 2205              	.LVL322:
 2206              	.L271:
 2207              	.LBE50:
 2208              	.LBE49:
1850:lib/ff/ff.c   **** 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 2209              		.loc 1 1850 0
 2210 016e 0423     		movs	r3, #4
 2211 0170 00E0     		b	.L240
 2212              	.L273:
 2213 0172 0023     		movs	r3, #0
 2214              	.L240:
 2215              	.LVL323:
1852:lib/ff/ff.c   **** 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
 2216              		.loc 1 1852 0
 2217 0174 002A     		cmp	r2, #0
 2218 0176 6AD0     		beq	.L237
1853:lib/ff/ff.c   **** 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
 2219              		.loc 1 1853 0
 2220 0178 3278     		ldrb	r2, [r6, #0]	@ zero_extendqisi2
 2221              	.LVL324:
 2222 017a E52A     		cmp	r2, #229
 2223 017c 01D1     		bne	.L251
 2224 017e 0522     		movs	r2, #5
 2225 0180 3270     		strb	r2, [r6, #0]
 2226              	.L251:
1855:lib/ff/ff.c   **** 	if (ni == 8) b <<= 2;
 2227              		.loc 1 1855 0
 2228 0182 0829     		cmp	r1, #8
 2229 0184 01D1     		bne	.L252
 2230 0186 A900     		lsls	r1, r5, #2
 2231              	.LVL325:
 2232 0188 CDB2     		uxtb	r5, r1
 2233              	.LVL326:
 2234              	.L252:
1856:lib/ff/ff.c   **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 2235              		.loc 1 1856 0
 2236 018a 05F00302 		and	r2, r5, #3
 2237 018e 012A     		cmp	r2, #1
 2238 0190 08BF     		it	eq
 2239 0192 43F01003 		orreq	r3, r3, #16
 2240              	.LVL327:
1857:lib/ff/ff.c   **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 2241              		.loc 1 1857 0
 2242 0196 05F00C05 		and	r5, r5, #12
 2243              	.LVL328:
 2244 019a 042D     		cmp	r5, #4
 2245 019c 08BF     		it	eq
 2246 019e 43F00803 		orreq	r3, r3, #8
 2247              	.LVL329:
1849:lib/ff/ff.c   **** 	*path = &p[si];						/* Return pointer to the next segment */
 2248              		.loc 1 1849 0
 2249 01a2 3F18     		adds	r7, r7, r0
 2250              	.LVL330:
 2251 01a4 67E7     		b	.L322
 2252              	.LVL331:
 2253              	.L248:
1839:lib/ff/ff.c   **** 			if (IsUpper(c)) {			/* ASCII large capital? */
 2254              		.loc 1 1839 0
 2255 01a6 A3F14108 		sub	r8, r3, #65
 2256 01aa B8F1190F 		cmp	r8, #25
 2257 01ae 02D8     		bhi	.L325
 2258              	.L265:
1840:lib/ff/ff.c   **** 				b |= 2;
 2259              		.loc 1 1840 0
 2260 01b0 45F00205 		orr	r5, r5, #2
 2261              	.LVL332:
 2262 01b4 08E0     		b	.L250
 2263              	.L325:
1842:lib/ff/ff.c   **** 				if (IsLower(c)) {		/* ASCII small capital? */
 2264              		.loc 1 1842 0
 2265 01b6 A3F1610E 		sub	lr, r3, #97
 2266 01ba BEF1190F 		cmp	lr, #25
 2267 01be 03D8     		bhi	.L250
1843:lib/ff/ff.c   **** 					b |= 1; c -= 0x20;
 2268              		.loc 1 1843 0
 2269 01c0 45F00105 		orr	r5, r5, #1
 2270              	.LVL333:
 2271 01c4 203B     		subs	r3, r3, #32
 2272              	.LVL334:
 2273 01c6 DBB2     		uxtb	r3, r3
 2274              	.LVL335:
 2275              	.L250:
1846:lib/ff/ff.c   **** 			sfn[i++] = c;
 2276              		.loc 1 1846 0
 2277 01c8 B354     		strb	r3, [r6, r2]
 2278 01ca 0132     		adds	r2, r2, #1
 2279              	.LVL336:
 2280 01cc C1E7     		b	.L243
 2281              	.LVL337:
 2282              	.L241:
1816:lib/ff/ff.c   **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 2283              		.loc 1 1816 0
 2284 01ce 0829     		cmp	r1, #8
 2285 01d0 3DD1     		bne	.L237
 2286              	.L319:
 2287              	.LVL338:
1818:lib/ff/ff.c   **** 			b <<= 2; continue;
 2288              		.loc 1 1818 0
 2289 01d2 AD00     		lsls	r5, r5, #2
 2290              	.LVL339:
 2291 01d4 EDB2     		uxtb	r5, r5
 2292              	.LVL340:
1817:lib/ff/ff.c   **** 			i = 8; ni = 11;
 2293              		.loc 1 1817 0
 2294 01d6 0A46     		mov	r2, r1
 2295 01d8 0B21     		movs	r1, #11
 2296 01da BAE7     		b	.L243
 2297              	.LVL341:
 2298              	.L324:
 2299              	.LBE51:
 2300              	.LBE59:
 2301              	.LBB60:
 2302              	.LBB57:
1408:lib/ff/ff.c   **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 2303              		.loc 1 1408 0
 2304 01dc 6269     		ldr	r2, [r4, #20]
 2305              	.LVL342:
1410:lib/ff/ff.c   **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 2306              		.loc 1 1410 0
 2307 01de 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 2308 01e0 99B1     		cbz	r1, .L275
 2309              	.LBE57:
1433:lib/ff/ff.c   **** 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 2310              		.loc 1 1433 0
 2311 01e2 D37A     		ldrb	r3, [r2, #11]	@ zero_extendqisi2
 2312              	.LBB58:
 2313 01e4 03F00801 		and	r1, r3, #8
 2314 01e8 CBB2     		uxtb	r3, r1
 2315 01ea 4BB9     		cbnz	r3, .L256
 2316 01ec A669     		ldr	r6, [r4, #24]
 2317              	.LVL343:
 2318 01ee 0346     		mov	r3, r0
 2319              	.L257:
 2320              	.LBB55:
 2321              	.LBB56:
 560:lib/ff/ff.c   **** 	while (cnt-- && (r = *d++ - *s++) == 0) ;
 2322              		.loc 1 560 0
 2323 01f0 D55C     		ldrb	r5, [r2, r3]	@ zero_extendqisi2
 2324 01f2 F15C     		ldrb	r1, [r6, r3]	@ zero_extendqisi2
 2325              	.LVL344:
 2326 01f4 0133     		adds	r3, r3, #1
 2327 01f6 8D42     		cmp	r5, r1
 2328 01f8 02D1     		bne	.L256
 2329              	.L258:
 2330              	.LVL345:
 2331 01fa 0B2B     		cmp	r3, #11
 2332 01fc F8D1     		bne	.L257
 2333 01fe 47E7     		b	.L255
 2334              	.LVL346:
 2335              	.L256:
 2336              	.LBE56:
 2337              	.LBE55:
1436:lib/ff/ff.c   **** 		res = dir_next(dj, 0);		/* Next entry */
 2338              		.loc 1 1436 0
 2339 0200 2046     		mov	r0, r4
 2340              	.LVL347:
 2341 0202 0021     		movs	r1, #0
 2342 0204 FFF7FEFF 		bl	dir_next
 2343              	.LVL348:
 2344 0208 3AE7     		b	.L321
 2345              	.LVL349:
 2346              	.L275:
1410:lib/ff/ff.c   **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 2347              		.loc 1 1410 0
 2348 020a 0420     		movs	r0, #4
 2349              	.LVL350:
 2350 020c 40E7     		b	.L255
 2351              	.LVL351:
 2352              	.L260:
 2353              	.LBE58:
 2354              	.LBE60:
1997:lib/ff/ff.c   **** 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
 2355              		.loc 1 1997 0
 2356 020e 03F00400 		and	r0, r3, #4
 2357 0212 C2B2     		uxtb	r2, r0
 2358 0214 42B1     		cbz	r2, .L326
 2359              	.LVL352:
 2360              	.L263:
1990:lib/ff/ff.c   **** 					res = FR_OK;
 2361              		.loc 1 1990 0
 2362 0216 0020     		movs	r0, #0
 2363 0218 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2364              	.L261:
1993:lib/ff/ff.c   **** 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
 2365              		.loc 1 1993 0
 2366 021c 0028     		cmp	r0, #0
 2367 021e 14BF     		ite	ne
 2368 0220 0420     		movne	r0, #4
 2369 0222 0520     		moveq	r0, #5
 2370 0224 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2371              	.LVL353:
 2372              	.L326:
1998:lib/ff/ff.c   **** 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
 2373              		.loc 1 1998 0
 2374 0228 6369     		ldr	r3, [r4, #20]
 2375              	.LVL354:
1999:lib/ff/ff.c   **** 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
 2376              		.loc 1 1999 0
 2377 022a D97A     		ldrb	r1, [r3, #11]	@ zero_extendqisi2
 2378              	.LVL355:
 2379 022c 01F01000 		and	r0, r1, #16
 2380 0230 C2B2     		uxtb	r2, r0
 2381 0232 4AB1     		cbz	r2, .L277
 2382              	.LVL356:
 2383              	.LBB61:
 2384              	.LBB62:
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 2385              		.loc 1 1190 0
 2386 0234 5E8B     		ldrh	r6, [r3, #26]
 2387              	.LVL357:
2228:lib/ff/ff.c   **** 
2229:lib/ff/ff.c   **** 
2230:lib/ff/ff.c   **** 
2231:lib/ff/ff.c   **** 
2232:lib/ff/ff.c   **** /*--------------------------------------------------------------------------
2233:lib/ff/ff.c   **** 
2234:lib/ff/ff.c   ****    Public Functions
2235:lib/ff/ff.c   **** 
2236:lib/ff/ff.c   **** --------------------------------------------------------------------------*/
2237:lib/ff/ff.c   **** 
2238:lib/ff/ff.c   **** 
2239:lib/ff/ff.c   **** 
2240:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2241:lib/ff/ff.c   **** /* Mount/Unmount a Logical Drive                                         */
2242:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2243:lib/ff/ff.c   **** 
2244:lib/ff/ff.c   **** FRESULT f_mount (
2245:lib/ff/ff.c   **** 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
2246:lib/ff/ff.c   **** 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
2247:lib/ff/ff.c   **** )
2248:lib/ff/ff.c   **** {
2249:lib/ff/ff.c   **** 	FATFS *rfs;
2250:lib/ff/ff.c   **** 
2251:lib/ff/ff.c   **** 
2252:lib/ff/ff.c   **** 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
2253:lib/ff/ff.c   **** 		return FR_INVALID_DRIVE;
2254:lib/ff/ff.c   **** 	rfs = FatFs[vol];			/* Get current fs object */
2255:lib/ff/ff.c   **** 
2256:lib/ff/ff.c   **** 	if (rfs) {
2257:lib/ff/ff.c   **** #if _FS_LOCK
2258:lib/ff/ff.c   **** 		clear_lock(rfs);
2259:lib/ff/ff.c   **** #endif
2260:lib/ff/ff.c   **** #if _FS_REENTRANT				/* Discard sync object of the current volume */
2261:lib/ff/ff.c   **** 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2262:lib/ff/ff.c   **** #endif
2263:lib/ff/ff.c   **** 		rfs->fs_type = 0;		/* Clear old fs object */
2264:lib/ff/ff.c   **** 	}
2265:lib/ff/ff.c   **** 
2266:lib/ff/ff.c   **** 	if (fs) {
2267:lib/ff/ff.c   **** 		fs->fs_type = 0;		/* Clear new fs object */
2268:lib/ff/ff.c   **** #if _FS_REENTRANT				/* Create sync object for the new volume */
2269:lib/ff/ff.c   **** 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2270:lib/ff/ff.c   **** #endif
2271:lib/ff/ff.c   **** 	}
2272:lib/ff/ff.c   **** 	FatFs[vol] = fs;			/* Register new fs object */
2273:lib/ff/ff.c   **** 
2274:lib/ff/ff.c   **** 	return FR_OK;
2275:lib/ff/ff.c   **** }
2276:lib/ff/ff.c   **** 
2277:lib/ff/ff.c   **** 
2278:lib/ff/ff.c   **** 
2279:lib/ff/ff.c   **** 
2280:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2281:lib/ff/ff.c   **** /* Open or Create a File                                                 */
2282:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2283:lib/ff/ff.c   **** 
2284:lib/ff/ff.c   **** FRESULT f_open (
2285:lib/ff/ff.c   **** 	FIL *fp,			/* Pointer to the blank file object */
2286:lib/ff/ff.c   **** 	const TCHAR *path,	/* Pointer to the file name */
2287:lib/ff/ff.c   **** 	BYTE mode			/* Access mode and file open mode flags */
2288:lib/ff/ff.c   **** )
2289:lib/ff/ff.c   **** {
2290:lib/ff/ff.c   **** 	FRESULT res;
2291:lib/ff/ff.c   **** 	DIR dj;
2292:lib/ff/ff.c   **** 	BYTE *dir;
2293:lib/ff/ff.c   **** 	DEF_NAMEBUF;
2294:lib/ff/ff.c   **** 
2295:lib/ff/ff.c   **** 
2296:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
2297:lib/ff/ff.c   **** 	fp->fs = 0;			/* Clear file object */
2298:lib/ff/ff.c   **** 
2299:lib/ff/ff.c   **** #if !_FS_READONLY
2300:lib/ff/ff.c   **** 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
2301:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
2302:lib/ff/ff.c   **** #else
2303:lib/ff/ff.c   **** 	mode &= FA_READ;
2304:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 0);
2305:lib/ff/ff.c   **** #endif
2306:lib/ff/ff.c   **** 	if (res == FR_OK) {
2307:lib/ff/ff.c   **** 		INIT_BUF(dj);
2308:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
2309:lib/ff/ff.c   **** 		dir = dj.dir;
2310:lib/ff/ff.c   **** #if !_FS_READONLY	/* R/W configuration */
2311:lib/ff/ff.c   **** 		if (res == FR_OK) {
2312:lib/ff/ff.c   **** 			if (!dir)	/* Current dir itself */
2313:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
2314:lib/ff/ff.c   **** #if _FS_LOCK
2315:lib/ff/ff.c   **** 			else
2316:lib/ff/ff.c   **** 				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2317:lib/ff/ff.c   **** #endif
2318:lib/ff/ff.c   **** 		}
2319:lib/ff/ff.c   **** 		/* Create or Open a file */
2320:lib/ff/ff.c   **** 		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
2321:lib/ff/ff.c   **** 			DWORD dw, cl;
2322:lib/ff/ff.c   **** 
2323:lib/ff/ff.c   **** 			if (res != FR_OK) {					/* No file, create new */
2324:lib/ff/ff.c   **** 				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
2325:lib/ff/ff.c   **** #if _FS_LOCK
2326:lib/ff/ff.c   **** 					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2327:lib/ff/ff.c   **** #else
2328:lib/ff/ff.c   **** 					res = dir_register(&dj);
2329:lib/ff/ff.c   **** #endif
2330:lib/ff/ff.c   **** 				mode |= FA_CREATE_ALWAYS;		/* File is created */
2331:lib/ff/ff.c   **** 				dir = dj.dir;					/* New entry */
2332:lib/ff/ff.c   **** 			}
2333:lib/ff/ff.c   **** 			else {								/* Any object is already existing */
2334:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
2335:lib/ff/ff.c   **** 					res = FR_DENIED;
2336:lib/ff/ff.c   **** 				} else {
2337:lib/ff/ff.c   **** 					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
2338:lib/ff/ff.c   **** 						res = FR_EXIST;
2339:lib/ff/ff.c   **** 				}
2340:lib/ff/ff.c   **** 			}
2341:lib/ff/ff.c   **** 			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
2342:lib/ff/ff.c   **** 				dw = get_fattime();					/* Created time */
2343:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_CrtTime, dw);
2344:lib/ff/ff.c   **** 				dir[DIR_Attr] = 0;					/* Reset attribute */
2345:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
2346:lib/ff/ff.c   **** 				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
2347:lib/ff/ff.c   **** 				st_clust(dir, 0);					/* cluster = 0 */
2348:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
2349:lib/ff/ff.c   **** 				if (cl) {							/* Remove the cluster chain if exist */
2350:lib/ff/ff.c   **** 					dw = dj.fs->winsect;
2351:lib/ff/ff.c   **** 					res = remove_chain(dj.fs, cl);
2352:lib/ff/ff.c   **** 					if (res == FR_OK) {
2353:lib/ff/ff.c   **** 						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
2354:lib/ff/ff.c   **** 						res = move_window(dj.fs, dw);
2355:lib/ff/ff.c   **** 					}
2356:lib/ff/ff.c   **** 				}
2357:lib/ff/ff.c   **** 			}
2358:lib/ff/ff.c   **** 		}
2359:lib/ff/ff.c   **** 		else {	/* Open an existing file */
2360:lib/ff/ff.c   **** 			if (res == FR_OK) {						/* Follow succeeded */
2361:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
2362:lib/ff/ff.c   **** 					res = FR_NO_FILE;
2363:lib/ff/ff.c   **** 				} else {
2364:lib/ff/ff.c   **** 					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
2365:lib/ff/ff.c   **** 						res = FR_DENIED;
2366:lib/ff/ff.c   **** 				}
2367:lib/ff/ff.c   **** 			}
2368:lib/ff/ff.c   **** 		}
2369:lib/ff/ff.c   **** 		if (res == FR_OK) {
2370:lib/ff/ff.c   **** 			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
2371:lib/ff/ff.c   **** 				mode |= FA__WRITTEN;
2372:lib/ff/ff.c   **** 			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
2373:lib/ff/ff.c   **** 			fp->dir_ptr = dir;
2374:lib/ff/ff.c   **** #if _FS_LOCK
2375:lib/ff/ff.c   **** 			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2376:lib/ff/ff.c   **** 			if (!fp->lockid) res = FR_INT_ERR;
2377:lib/ff/ff.c   **** #endif
2378:lib/ff/ff.c   **** 		}
2379:lib/ff/ff.c   **** 
2380:lib/ff/ff.c   **** #else				/* R/O configuration */
2381:lib/ff/ff.c   **** 		if (res == FR_OK) {					/* Follow succeeded */
2382:lib/ff/ff.c   **** 			dir = dj.dir;
2383:lib/ff/ff.c   **** 			if (!dir) {						/* Current dir itself */
2384:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
2385:lib/ff/ff.c   **** 			} else {
2386:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
2387:lib/ff/ff.c   **** 					res = FR_NO_FILE;
2388:lib/ff/ff.c   **** 			}
2389:lib/ff/ff.c   **** 		}
2390:lib/ff/ff.c   **** #endif
2391:lib/ff/ff.c   **** 		FREE_BUF();
2392:lib/ff/ff.c   **** 
2393:lib/ff/ff.c   **** 		if (res == FR_OK) {
2394:lib/ff/ff.c   **** 			fp->flag = mode;					/* File access mode */
2395:lib/ff/ff.c   **** 			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
2396:lib/ff/ff.c   **** 			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
2397:lib/ff/ff.c   **** 			fp->fptr = 0;						/* File pointer */
2398:lib/ff/ff.c   **** 			fp->dsect = 0;
2399:lib/ff/ff.c   **** #if _USE_FASTSEEK
2400:lib/ff/ff.c   **** 			fp->cltbl = 0;						/* Normal seek mode */
2401:lib/ff/ff.c   **** #endif
2402:lib/ff/ff.c   **** 			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
2403:lib/ff/ff.c   **** 		}
2404:lib/ff/ff.c   **** 	}
2405:lib/ff/ff.c   **** 
2406:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
2407:lib/ff/ff.c   **** }
2408:lib/ff/ff.c   **** 
2409:lib/ff/ff.c   **** 
2410:lib/ff/ff.c   **** 
2411:lib/ff/ff.c   **** 
2412:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2413:lib/ff/ff.c   **** /* Read File                                                             */
2414:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2415:lib/ff/ff.c   **** 
2416:lib/ff/ff.c   **** FRESULT f_read (
2417:lib/ff/ff.c   **** 	FIL *fp, 		/* Pointer to the file object */
2418:lib/ff/ff.c   **** 	void *buff,		/* Pointer to data buffer */
2419:lib/ff/ff.c   **** 	UINT btr,		/* Number of bytes to read */
2420:lib/ff/ff.c   **** 	UINT *br		/* Pointer to number of bytes read */
2421:lib/ff/ff.c   **** )
2422:lib/ff/ff.c   **** {
2423:lib/ff/ff.c   **** 	FRESULT res;
2424:lib/ff/ff.c   **** 	DWORD clst, sect, remain;
2425:lib/ff/ff.c   **** 	UINT rcnt, cc;
2426:lib/ff/ff.c   **** 	BYTE csect, *rbuff = buff;
2427:lib/ff/ff.c   **** 
2428:lib/ff/ff.c   **** 
2429:lib/ff/ff.c   **** 	*br = 0;	/* Clear read byte counter */
2430:lib/ff/ff.c   **** 
2431:lib/ff/ff.c   **** 	res = validate(fp);							/* Check validity */
2432:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2433:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)					/* Aborted file? */
2434:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2435:lib/ff/ff.c   **** 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
2436:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
2437:lib/ff/ff.c   **** 	remain = fp->fsize - fp->fptr;
2438:lib/ff/ff.c   **** 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
2439:lib/ff/ff.c   **** 
2440:lib/ff/ff.c   **** 	for ( ;  btr;								/* Repeat until all data read */
2441:lib/ff/ff.c   **** 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
2442:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
2443:lib/ff/ff.c   **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
2444:lib/ff/ff.c   **** 			if (!csect) {						/* On the cluster boundary? */
2445:lib/ff/ff.c   **** 				if (fp->fptr == 0) {			/* On the top of the file? */
2446:lib/ff/ff.c   **** 					clst = fp->sclust;			/* Follow from the origin */
2447:lib/ff/ff.c   **** 				} else {						/* Middle or end of the file */
2448:lib/ff/ff.c   **** #if _USE_FASTSEEK
2449:lib/ff/ff.c   **** 					if (fp->cltbl)
2450:lib/ff/ff.c   **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
2451:lib/ff/ff.c   **** 					else
2452:lib/ff/ff.c   **** #endif
2453:lib/ff/ff.c   **** 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
2454:lib/ff/ff.c   **** 				}
2455:lib/ff/ff.c   **** 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
2456:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2457:lib/ff/ff.c   **** 				fp->clust = clst;				/* Update current cluster */
2458:lib/ff/ff.c   **** 			}
2459:lib/ff/ff.c   **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
2460:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
2461:lib/ff/ff.c   **** 			sect += csect;
2462:lib/ff/ff.c   **** 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
2463:lib/ff/ff.c   **** 			if (cc) {							/* Read maximum contiguous sectors directly */
2464:lib/ff/ff.c   **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
2465:lib/ff/ff.c   **** 					cc = fp->fs->csize - csect;
2466:lib/ff/ff.c   **** 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
2467:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
2468:lib/ff/ff.c   **** #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it 
2469:lib/ff/ff.c   **** #if _FS_TINY
2470:lib/ff/ff.c   **** 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
2471:lib/ff/ff.c   **** 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
2472:lib/ff/ff.c   **** #else
2473:lib/ff/ff.c   **** 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2474:lib/ff/ff.c   **** 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
2475:lib/ff/ff.c   **** #endif
2476:lib/ff/ff.c   **** #endif
2477:lib/ff/ff.c   **** 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
2478:lib/ff/ff.c   **** 				continue;
2479:lib/ff/ff.c   **** 			}
2480:lib/ff/ff.c   **** #if !_FS_TINY
2481:lib/ff/ff.c   **** 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
2482:lib/ff/ff.c   **** #if !_FS_READONLY
2483:lib/ff/ff.c   **** 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
2484:lib/ff/ff.c   **** 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2485:lib/ff/ff.c   **** 						ABORT(fp->fs, FR_DISK_ERR);
2486:lib/ff/ff.c   **** 					fp->flag &= ~FA__DIRTY;
2487:lib/ff/ff.c   **** 				}
2488:lib/ff/ff.c   **** #endif
2489:lib/ff/ff.c   **** 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
2490:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
2491:lib/ff/ff.c   **** 			}
2492:lib/ff/ff.c   **** #endif
2493:lib/ff/ff.c   **** 			fp->dsect = sect;
2494:lib/ff/ff.c   **** 		}
2495:lib/ff/ff.c   **** 		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer 
2496:lib/ff/ff.c   **** 		if (rcnt > btr) rcnt = btr;
2497:lib/ff/ff.c   **** #if _FS_TINY
2498:lib/ff/ff.c   **** 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
2499:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
2500:lib/ff/ff.c   **** 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
2501:lib/ff/ff.c   **** #else
2502:lib/ff/ff.c   **** 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
2503:lib/ff/ff.c   **** #endif
2504:lib/ff/ff.c   **** 	}
2505:lib/ff/ff.c   **** 
2506:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, FR_OK);
2507:lib/ff/ff.c   **** }
2508:lib/ff/ff.c   **** 
2509:lib/ff/ff.c   **** 
2510:lib/ff/ff.c   **** 
2511:lib/ff/ff.c   **** 
2512:lib/ff/ff.c   **** #if !_FS_READONLY
2513:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2514:lib/ff/ff.c   **** /* Write File                                                            */
2515:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2516:lib/ff/ff.c   **** 
2517:lib/ff/ff.c   **** FRESULT f_write (
2518:lib/ff/ff.c   **** 	FIL *fp,			/* Pointer to the file object */
2519:lib/ff/ff.c   **** 	const void *buff,	/* Pointer to the data to be written */
2520:lib/ff/ff.c   **** 	UINT btw,			/* Number of bytes to write */
2521:lib/ff/ff.c   **** 	UINT *bw			/* Pointer to number of bytes written */
2522:lib/ff/ff.c   **** )
2523:lib/ff/ff.c   **** {
2524:lib/ff/ff.c   **** 	FRESULT res;
2525:lib/ff/ff.c   **** 	DWORD clst, sect;
2526:lib/ff/ff.c   **** 	UINT wcnt, cc;
2527:lib/ff/ff.c   **** 	const BYTE *wbuff = buff;
2528:lib/ff/ff.c   **** 	BYTE csect;
2529:lib/ff/ff.c   **** 
2530:lib/ff/ff.c   **** 
2531:lib/ff/ff.c   **** 	*bw = 0;	/* Clear write byte counter */
2532:lib/ff/ff.c   **** 
2533:lib/ff/ff.c   **** 	res = validate(fp);						/* Check validity */
2534:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2535:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)				/* Aborted file? */
2536:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2537:lib/ff/ff.c   **** 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
2538:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
2539:lib/ff/ff.c   **** 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
2540:lib/ff/ff.c   **** 
2541:lib/ff/ff.c   **** 	for ( ;  btw;							/* Repeat until all data written */
2542:lib/ff/ff.c   **** 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
2543:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
2544:lib/ff/ff.c   **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
2545:lib/ff/ff.c   **** 			if (!csect) {					/* On the cluster boundary? */
2546:lib/ff/ff.c   **** 				if (fp->fptr == 0) {		/* On the top of the file? */
2547:lib/ff/ff.c   **** 					clst = fp->sclust;		/* Follow from the origin */
2548:lib/ff/ff.c   **** 					if (clst == 0)			/* When no cluster is allocated, */
2549:lib/ff/ff.c   **** 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
2550:lib/ff/ff.c   **** 				} else {					/* Middle or end of the file */
2551:lib/ff/ff.c   **** #if _USE_FASTSEEK
2552:lib/ff/ff.c   **** 					if (fp->cltbl)
2553:lib/ff/ff.c   **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
2554:lib/ff/ff.c   **** 					else
2555:lib/ff/ff.c   **** #endif
2556:lib/ff/ff.c   **** 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
2557:lib/ff/ff.c   **** 				}
2558:lib/ff/ff.c   **** 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
2559:lib/ff/ff.c   **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
2560:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2561:lib/ff/ff.c   **** 				fp->clust = clst;			/* Update current cluster */
2562:lib/ff/ff.c   **** 			}
2563:lib/ff/ff.c   **** #if _FS_TINY
2564:lib/ff/ff.c   **** 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
2565:lib/ff/ff.c   **** 				ABORT(fp->fs, FR_DISK_ERR);
2566:lib/ff/ff.c   **** #else
2567:lib/ff/ff.c   **** 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
2568:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2569:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
2570:lib/ff/ff.c   **** 				fp->flag &= ~FA__DIRTY;
2571:lib/ff/ff.c   **** 			}
2572:lib/ff/ff.c   **** #endif
2573:lib/ff/ff.c   **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
2574:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
2575:lib/ff/ff.c   **** 			sect += csect;
2576:lib/ff/ff.c   **** 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
2577:lib/ff/ff.c   **** 			if (cc) {						/* Write maximum contiguous sectors directly */
2578:lib/ff/ff.c   **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
2579:lib/ff/ff.c   **** 					cc = fp->fs->csize - csect;
2580:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
2581:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
2582:lib/ff/ff.c   **** #if _FS_TINY
2583:lib/ff/ff.c   **** 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct 
2584:lib/ff/ff.c   **** 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
2585:lib/ff/ff.c   **** 					fp->fs->wflag = 0;
2586:lib/ff/ff.c   **** 				}
2587:lib/ff/ff.c   **** #else
2588:lib/ff/ff.c   **** 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write 
2589:lib/ff/ff.c   **** 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
2590:lib/ff/ff.c   **** 					fp->flag &= ~FA__DIRTY;
2591:lib/ff/ff.c   **** 				}
2592:lib/ff/ff.c   **** #endif
2593:lib/ff/ff.c   **** 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
2594:lib/ff/ff.c   **** 				continue;
2595:lib/ff/ff.c   **** 			}
2596:lib/ff/ff.c   **** #if _FS_TINY
2597:lib/ff/ff.c   **** 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
2598:lib/ff/ff.c   **** 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
2599:lib/ff/ff.c   **** 				fp->fs->winsect = sect;
2600:lib/ff/ff.c   **** 			}
2601:lib/ff/ff.c   **** #else
2602:lib/ff/ff.c   **** 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
2603:lib/ff/ff.c   **** 				if (fp->fptr < fp->fsize &&
2604:lib/ff/ff.c   **** 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
2605:lib/ff/ff.c   **** 						ABORT(fp->fs, FR_DISK_ERR);
2606:lib/ff/ff.c   **** 			}
2607:lib/ff/ff.c   **** #endif
2608:lib/ff/ff.c   **** 			fp->dsect = sect;
2609:lib/ff/ff.c   **** 		}
2610:lib/ff/ff.c   **** 		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
2611:lib/ff/ff.c   **** 		if (wcnt > btw) wcnt = btw;
2612:lib/ff/ff.c   **** #if _FS_TINY
2613:lib/ff/ff.c   **** 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
2614:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
2615:lib/ff/ff.c   **** 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
2616:lib/ff/ff.c   **** 		fp->fs->wflag = 1;
2617:lib/ff/ff.c   **** #else
2618:lib/ff/ff.c   **** 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
2619:lib/ff/ff.c   **** 		fp->flag |= FA__DIRTY;
2620:lib/ff/ff.c   **** #endif
2621:lib/ff/ff.c   **** 	}
2622:lib/ff/ff.c   **** 
2623:lib/ff/ff.c   **** 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
2624:lib/ff/ff.c   **** 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
2625:lib/ff/ff.c   **** 
2626:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, FR_OK);
2627:lib/ff/ff.c   **** }
2628:lib/ff/ff.c   **** 
2629:lib/ff/ff.c   **** 
2630:lib/ff/ff.c   **** 
2631:lib/ff/ff.c   **** 
2632:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2633:lib/ff/ff.c   **** /* Synchronize the File Object                                           */
2634:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2635:lib/ff/ff.c   **** 
2636:lib/ff/ff.c   **** FRESULT f_sync (
2637:lib/ff/ff.c   **** 	FIL *fp		/* Pointer to the file object */
2638:lib/ff/ff.c   **** )
2639:lib/ff/ff.c   **** {
2640:lib/ff/ff.c   **** 	FRESULT res;
2641:lib/ff/ff.c   **** 	DWORD tim;
2642:lib/ff/ff.c   **** 	BYTE *dir;
2643:lib/ff/ff.c   **** 
2644:lib/ff/ff.c   **** 
2645:lib/ff/ff.c   **** 	res = validate(fp);					/* Check validity of the object */
2646:lib/ff/ff.c   **** 	if (res == FR_OK) {
2647:lib/ff/ff.c   **** 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
2648:lib/ff/ff.c   **** #if !_FS_TINY	/* Write-back dirty buffer */
2649:lib/ff/ff.c   **** 			if (fp->flag & FA__DIRTY) {
2650:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2651:lib/ff/ff.c   **** 					LEAVE_FF(fp->fs, FR_DISK_ERR);
2652:lib/ff/ff.c   **** 				fp->flag &= ~FA__DIRTY;
2653:lib/ff/ff.c   **** 			}
2654:lib/ff/ff.c   **** #endif
2655:lib/ff/ff.c   **** 			/* Update the directory entry */
2656:lib/ff/ff.c   **** 			res = move_window(fp->fs, fp->dir_sect);
2657:lib/ff/ff.c   **** 			if (res == FR_OK) {
2658:lib/ff/ff.c   **** 				dir = fp->dir_ptr;
2659:lib/ff/ff.c   **** 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
2660:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
2661:lib/ff/ff.c   **** 				st_clust(dir, fp->sclust);					/* Update start cluster */
2662:lib/ff/ff.c   **** 				tim = get_fattime();						/* Update updated time */
2663:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tim);
2664:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_LstAccDate, 0);
2665:lib/ff/ff.c   **** 				fp->flag &= ~FA__WRITTEN;
2666:lib/ff/ff.c   **** 				fp->fs->wflag = 1;
2667:lib/ff/ff.c   **** 				res = sync(fp->fs);
2668:lib/ff/ff.c   **** 			}
2669:lib/ff/ff.c   **** 		}
2670:lib/ff/ff.c   **** 	}
2671:lib/ff/ff.c   **** 
2672:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, res);
2673:lib/ff/ff.c   **** }
2674:lib/ff/ff.c   **** 
2675:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
2676:lib/ff/ff.c   **** 
2677:lib/ff/ff.c   **** 
2678:lib/ff/ff.c   **** 
2679:lib/ff/ff.c   **** 
2680:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2681:lib/ff/ff.c   **** /* Close File                                                            */
2682:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2683:lib/ff/ff.c   **** 
2684:lib/ff/ff.c   **** FRESULT f_close (
2685:lib/ff/ff.c   **** 	FIL *fp		/* Pointer to the file object to be closed */
2686:lib/ff/ff.c   **** )
2687:lib/ff/ff.c   **** {
2688:lib/ff/ff.c   **** 	FRESULT res;
2689:lib/ff/ff.c   **** 
2690:lib/ff/ff.c   **** 
2691:lib/ff/ff.c   **** #if _FS_READONLY
2692:lib/ff/ff.c   **** 	res = validate(fp);
2693:lib/ff/ff.c   **** 	{
2694:lib/ff/ff.c   **** #if _FS_REENTRANT
2695:lib/ff/ff.c   **** 		FATFS *fs = fp->fs;
2696:lib/ff/ff.c   **** #endif
2697:lib/ff/ff.c   **** 		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
2698:lib/ff/ff.c   **** 		LEAVE_FF(fs, res);
2699:lib/ff/ff.c   **** 	}
2700:lib/ff/ff.c   **** #else
2701:lib/ff/ff.c   **** 	res = f_sync(fp);		/* Flush cached data */
2702:lib/ff/ff.c   **** #if _FS_LOCK
2703:lib/ff/ff.c   **** 	if (res == FR_OK) {		/* Decrement open counter */
2704:lib/ff/ff.c   **** #if _FS_REENTRANT
2705:lib/ff/ff.c   **** 		FATFS *fs = fp->fs;;
2706:lib/ff/ff.c   **** 		res = validate(fp);
2707:lib/ff/ff.c   **** 		if (res == FR_OK) {
2708:lib/ff/ff.c   **** 			res = dec_lock(fp->lockid);	
2709:lib/ff/ff.c   **** 			unlock_fs(fs, FR_OK);
2710:lib/ff/ff.c   **** 		}
2711:lib/ff/ff.c   **** #else
2712:lib/ff/ff.c   **** 		res = dec_lock(fp->lockid);
2713:lib/ff/ff.c   **** #endif
2714:lib/ff/ff.c   **** 	}
2715:lib/ff/ff.c   **** #endif
2716:lib/ff/ff.c   **** 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
2717:lib/ff/ff.c   **** 	return res;
2718:lib/ff/ff.c   **** #endif
2719:lib/ff/ff.c   **** }
2720:lib/ff/ff.c   **** 
2721:lib/ff/ff.c   **** 
2722:lib/ff/ff.c   **** 
2723:lib/ff/ff.c   **** 
2724:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2725:lib/ff/ff.c   **** /* Current Drive/Directory Handlings                                     */
2726:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2727:lib/ff/ff.c   **** 
2728:lib/ff/ff.c   **** #if _FS_RPATH >= 1
2729:lib/ff/ff.c   **** 
2730:lib/ff/ff.c   **** FRESULT f_chdrive (
2731:lib/ff/ff.c   **** 	BYTE drv		/* Drive number */
2732:lib/ff/ff.c   **** )
2733:lib/ff/ff.c   **** {
2734:lib/ff/ff.c   **** 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
2735:lib/ff/ff.c   **** 
2736:lib/ff/ff.c   **** 	CurrVol = drv;
2737:lib/ff/ff.c   **** 
2738:lib/ff/ff.c   **** 	return FR_OK;
2739:lib/ff/ff.c   **** }
2740:lib/ff/ff.c   **** 
2741:lib/ff/ff.c   **** 
2742:lib/ff/ff.c   **** 
2743:lib/ff/ff.c   **** FRESULT f_chdir (
2744:lib/ff/ff.c   **** 	const TCHAR *path	/* Pointer to the directory path */
2745:lib/ff/ff.c   **** )
2746:lib/ff/ff.c   **** {
2747:lib/ff/ff.c   **** 	FRESULT res;
2748:lib/ff/ff.c   **** 	DIR dj;
2749:lib/ff/ff.c   **** 	DEF_NAMEBUF;
2750:lib/ff/ff.c   **** 
2751:lib/ff/ff.c   **** 
2752:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 0);
2753:lib/ff/ff.c   **** 	if (res == FR_OK) {
2754:lib/ff/ff.c   **** 		INIT_BUF(dj);
2755:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the path */
2756:lib/ff/ff.c   **** 		FREE_BUF();
2757:lib/ff/ff.c   **** 		if (res == FR_OK) {					/* Follow completed */
2758:lib/ff/ff.c   **** 			if (!dj.dir) {
2759:lib/ff/ff.c   **** 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
2760:lib/ff/ff.c   **** 			} else {
2761:lib/ff/ff.c   **** 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
2762:lib/ff/ff.c   **** 					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
2763:lib/ff/ff.c   **** 				else
2764:lib/ff/ff.c   **** 					res = FR_NO_PATH;		/* Reached but a file */
2765:lib/ff/ff.c   **** 			}
2766:lib/ff/ff.c   **** 		}
2767:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
2768:lib/ff/ff.c   **** 	}
2769:lib/ff/ff.c   **** 
2770:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
2771:lib/ff/ff.c   **** }
2772:lib/ff/ff.c   **** 
2773:lib/ff/ff.c   **** 
2774:lib/ff/ff.c   **** #if _FS_RPATH >= 2
2775:lib/ff/ff.c   **** FRESULT f_getcwd (
2776:lib/ff/ff.c   **** 	TCHAR *path,	/* Pointer to the directory path */
2777:lib/ff/ff.c   **** 	UINT sz_path	/* Size of path */
2778:lib/ff/ff.c   **** )
2779:lib/ff/ff.c   **** {
2780:lib/ff/ff.c   **** 	FRESULT res;
2781:lib/ff/ff.c   **** 	DIR dj;
2782:lib/ff/ff.c   **** 	UINT i, n;
2783:lib/ff/ff.c   **** 	DWORD ccl;
2784:lib/ff/ff.c   **** 	TCHAR *tp;
2785:lib/ff/ff.c   **** 	FILINFO fno;
2786:lib/ff/ff.c   **** 	DEF_NAMEBUF;
2787:lib/ff/ff.c   **** 
2788:lib/ff/ff.c   **** 
2789:lib/ff/ff.c   **** 	*path = 0;
2790:lib/ff/ff.c   **** 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
2791:lib/ff/ff.c   **** 	if (res == FR_OK) {
2792:lib/ff/ff.c   **** 		INIT_BUF(dj);
2793:lib/ff/ff.c   **** 		i = sz_path;		/* Bottom of buffer (dir stack base) */
2794:lib/ff/ff.c   **** 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
2795:lib/ff/ff.c   **** 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
2796:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 1);			/* Get parent dir */
2797:lib/ff/ff.c   **** 			if (res != FR_OK) break;
2798:lib/ff/ff.c   **** 			res = dir_read(&dj);
2799:lib/ff/ff.c   **** 			if (res != FR_OK) break;
2800:lib/ff/ff.c   **** 			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
2801:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 0);
2802:lib/ff/ff.c   **** 			if (res != FR_OK) break;
2803:lib/ff/ff.c   **** 			do {							/* Find the entry links to the child dir */
2804:lib/ff/ff.c   **** 				res = dir_read(&dj);
2805:lib/ff/ff.c   **** 				if (res != FR_OK) break;
2806:lib/ff/ff.c   **** 				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
2807:lib/ff/ff.c   **** 				res = dir_next(&dj, 0);	
2808:lib/ff/ff.c   **** 			} while (res == FR_OK);
2809:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
2810:lib/ff/ff.c   **** 			if (res != FR_OK) break;
2811:lib/ff/ff.c   **** #if _USE_LFN
2812:lib/ff/ff.c   **** 			fno.lfname = path;
2813:lib/ff/ff.c   **** 			fno.lfsize = i;
2814:lib/ff/ff.c   **** #endif
2815:lib/ff/ff.c   **** 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
2816:lib/ff/ff.c   **** 			tp = fno.fname;
2817:lib/ff/ff.c   **** 			if (_USE_LFN && *path) tp = path;
2818:lib/ff/ff.c   **** 			for (n = 0; tp[n]; n++) ;
2819:lib/ff/ff.c   **** 			if (i < n + 3) {
2820:lib/ff/ff.c   **** 				res = FR_NOT_ENOUGH_CORE; break;
2821:lib/ff/ff.c   **** 			}
2822:lib/ff/ff.c   **** 			while (n) path[--i] = tp[--n];
2823:lib/ff/ff.c   **** 			path[--i] = '/';
2824:lib/ff/ff.c   **** 		}
2825:lib/ff/ff.c   **** 		tp = path;
2826:lib/ff/ff.c   **** 		if (res == FR_OK) {
2827:lib/ff/ff.c   **** 			*tp++ = '0' + CurrVol;			/* Put drive number */
2828:lib/ff/ff.c   **** 			*tp++ = ':';
2829:lib/ff/ff.c   **** 			if (i == sz_path) {				/* Root-dir */
2830:lib/ff/ff.c   **** 				*tp++ = '/';
2831:lib/ff/ff.c   **** 			} else {						/* Sub-dir */
2832:lib/ff/ff.c   **** 				do		/* Add stacked path str */
2833:lib/ff/ff.c   **** 					*tp++ = path[i++];
2834:lib/ff/ff.c   **** 				while (i < sz_path);
2835:lib/ff/ff.c   **** 			}
2836:lib/ff/ff.c   **** 		}
2837:lib/ff/ff.c   **** 		*tp = 0;
2838:lib/ff/ff.c   **** 		FREE_BUF();
2839:lib/ff/ff.c   **** 	}
2840:lib/ff/ff.c   **** 
2841:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
2842:lib/ff/ff.c   **** }
2843:lib/ff/ff.c   **** #endif /* _FS_RPATH >= 2 */
2844:lib/ff/ff.c   **** #endif /* _FS_RPATH >= 1 */
2845:lib/ff/ff.c   **** 
2846:lib/ff/ff.c   **** 
2847:lib/ff/ff.c   **** 
2848:lib/ff/ff.c   **** #if _FS_MINIMIZE <= 2
2849:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2850:lib/ff/ff.c   **** /* Seek File R/W Pointer                                                 */
2851:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2852:lib/ff/ff.c   **** 
2853:lib/ff/ff.c   **** FRESULT f_lseek (
2854:lib/ff/ff.c   **** 	FIL *fp,		/* Pointer to the file object */
2855:lib/ff/ff.c   **** 	DWORD ofs		/* File pointer from top of file */
2856:lib/ff/ff.c   **** )
2857:lib/ff/ff.c   **** {
2858:lib/ff/ff.c   **** 	FRESULT res;
2859:lib/ff/ff.c   **** 
2860:lib/ff/ff.c   **** 
2861:lib/ff/ff.c   **** 	res = validate(fp);					/* Check validity of the object */
2862:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2863:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)			/* Check abort flag */
2864:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2865:lib/ff/ff.c   **** 
2866:lib/ff/ff.c   **** #if _USE_FASTSEEK
2867:lib/ff/ff.c   **** 	if (fp->cltbl) {	/* Fast seek */
2868:lib/ff/ff.c   **** 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2869:lib/ff/ff.c   **** 
2870:lib/ff/ff.c   **** 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
2871:lib/ff/ff.c   **** 			tbl = fp->cltbl;
2872:lib/ff/ff.c   **** 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
2873:lib/ff/ff.c   **** 			cl = fp->sclust;			/* Top of the chain */
2874:lib/ff/ff.c   **** 			if (cl) {
2875:lib/ff/ff.c   **** 				do {
2876:lib/ff/ff.c   **** 					/* Get a fragment */
2877:lib/ff/ff.c   **** 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
2878:lib/ff/ff.c   **** 					do {
2879:lib/ff/ff.c   **** 						pcl = cl; ncl++;
2880:lib/ff/ff.c   **** 						cl = get_fat(fp->fs, cl);
2881:lib/ff/ff.c   **** 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
2882:lib/ff/ff.c   **** 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2883:lib/ff/ff.c   **** 					} while (cl == pcl + 1);
2884:lib/ff/ff.c   **** 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
2885:lib/ff/ff.c   **** 						*tbl++ = ncl; *tbl++ = tcl;
2886:lib/ff/ff.c   **** 					}
2887:lib/ff/ff.c   **** 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
2888:lib/ff/ff.c   **** 			}
2889:lib/ff/ff.c   **** 			*fp->cltbl = ulen;	/* Number of items used */
2890:lib/ff/ff.c   **** 			if (ulen <= tlen)
2891:lib/ff/ff.c   **** 				*tbl = 0;		/* Terminate table */
2892:lib/ff/ff.c   **** 			else
2893:lib/ff/ff.c   **** 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
2894:lib/ff/ff.c   **** 
2895:lib/ff/ff.c   **** 		} else {						/* Fast seek */
2896:lib/ff/ff.c   **** 			if (ofs > fp->fsize)		/* Clip offset at the file size */
2897:lib/ff/ff.c   **** 				ofs = fp->fsize;
2898:lib/ff/ff.c   **** 			fp->fptr = ofs;				/* Set file pointer */
2899:lib/ff/ff.c   **** 			if (ofs) {
2900:lib/ff/ff.c   **** 				fp->clust = clmt_clust(fp, ofs - 1);
2901:lib/ff/ff.c   **** 				dsc = clust2sect(fp->fs, fp->clust);
2902:lib/ff/ff.c   **** 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
2903:lib/ff/ff.c   **** 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
2904:lib/ff/ff.c   **** 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
2905:lib/ff/ff.c   **** #if !_FS_TINY
2906:lib/ff/ff.c   **** #if !_FS_READONLY
2907:lib/ff/ff.c   **** 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
2908:lib/ff/ff.c   **** 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2909:lib/ff/ff.c   **** 							ABORT(fp->fs, FR_DISK_ERR);
2910:lib/ff/ff.c   **** 						fp->flag &= ~FA__DIRTY;
2911:lib/ff/ff.c   **** 					}
2912:lib/ff/ff.c   **** #endif
2913:lib/ff/ff.c   **** 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
2914:lib/ff/ff.c   **** 						ABORT(fp->fs, FR_DISK_ERR);
2915:lib/ff/ff.c   **** #endif
2916:lib/ff/ff.c   **** 					fp->dsect = dsc;
2917:lib/ff/ff.c   **** 				}
2918:lib/ff/ff.c   **** 			}
2919:lib/ff/ff.c   **** 		}
2920:lib/ff/ff.c   **** 	} else
2921:lib/ff/ff.c   **** #endif
2922:lib/ff/ff.c   **** 
2923:lib/ff/ff.c   **** 	/* Normal Seek */
2924:lib/ff/ff.c   **** 	{
2925:lib/ff/ff.c   **** 		DWORD clst, bcs, nsect, ifptr;
2926:lib/ff/ff.c   **** 
2927:lib/ff/ff.c   **** 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
2928:lib/ff/ff.c   **** #if !_FS_READONLY
2929:lib/ff/ff.c   **** 			 && !(fp->flag & FA_WRITE)
2930:lib/ff/ff.c   **** #endif
2931:lib/ff/ff.c   **** 			) ofs = fp->fsize;
2932:lib/ff/ff.c   **** 
2933:lib/ff/ff.c   **** 		ifptr = fp->fptr;
2934:lib/ff/ff.c   **** 		fp->fptr = nsect = 0;
2935:lib/ff/ff.c   **** 		if (ofs) {
2936:lib/ff/ff.c   **** 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
2937:lib/ff/ff.c   **** 			if (ifptr > 0 &&
2938:lib/ff/ff.c   **** 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
2939:lib/ff/ff.c   **** 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
2940:lib/ff/ff.c   **** 				ofs -= fp->fptr;
2941:lib/ff/ff.c   **** 				clst = fp->clust;
2942:lib/ff/ff.c   **** 			} else {									/* When seek to back cluster, */
2943:lib/ff/ff.c   **** 				clst = fp->sclust;						/* start from the first cluster */
2944:lib/ff/ff.c   **** #if !_FS_READONLY
2945:lib/ff/ff.c   **** 				if (clst == 0) {						/* If no cluster chain, create a new chain */
2946:lib/ff/ff.c   **** 					clst = create_chain(fp->fs, 0);
2947:lib/ff/ff.c   **** 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
2948:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2949:lib/ff/ff.c   **** 					fp->sclust = clst;
2950:lib/ff/ff.c   **** 				}
2951:lib/ff/ff.c   **** #endif
2952:lib/ff/ff.c   **** 				fp->clust = clst;
2953:lib/ff/ff.c   **** 			}
2954:lib/ff/ff.c   **** 			if (clst != 0) {
2955:lib/ff/ff.c   **** 				while (ofs > bcs) {						/* Cluster following loop */
2956:lib/ff/ff.c   **** #if !_FS_READONLY
2957:lib/ff/ff.c   **** 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
2958:lib/ff/ff.c   **** 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
2959:lib/ff/ff.c   **** 						if (clst == 0) {				/* When disk gets full, clip file size */
2960:lib/ff/ff.c   **** 							ofs = bcs; break;
2961:lib/ff/ff.c   **** 						}
2962:lib/ff/ff.c   **** 					} else
2963:lib/ff/ff.c   **** #endif
2964:lib/ff/ff.c   **** 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
2965:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2966:lib/ff/ff.c   **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
2967:lib/ff/ff.c   **** 					fp->clust = clst;
2968:lib/ff/ff.c   **** 					fp->fptr += bcs;
2969:lib/ff/ff.c   **** 					ofs -= bcs;
2970:lib/ff/ff.c   **** 				}
2971:lib/ff/ff.c   **** 				fp->fptr += ofs;
2972:lib/ff/ff.c   **** 				if (ofs % SS(fp->fs)) {
2973:lib/ff/ff.c   **** 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
2974:lib/ff/ff.c   **** 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
2975:lib/ff/ff.c   **** 					nsect += ofs / SS(fp->fs);
2976:lib/ff/ff.c   **** 				}
2977:lib/ff/ff.c   **** 			}
2978:lib/ff/ff.c   **** 		}
2979:lib/ff/ff.c   **** 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
2980:lib/ff/ff.c   **** #if !_FS_TINY
2981:lib/ff/ff.c   **** #if !_FS_READONLY
2982:lib/ff/ff.c   **** 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
2983:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2984:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
2985:lib/ff/ff.c   **** 				fp->flag &= ~FA__DIRTY;
2986:lib/ff/ff.c   **** 			}
2987:lib/ff/ff.c   **** #endif
2988:lib/ff/ff.c   **** 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
2989:lib/ff/ff.c   **** 				ABORT(fp->fs, FR_DISK_ERR);
2990:lib/ff/ff.c   **** #endif
2991:lib/ff/ff.c   **** 			fp->dsect = nsect;
2992:lib/ff/ff.c   **** 		}
2993:lib/ff/ff.c   **** #if !_FS_READONLY
2994:lib/ff/ff.c   **** 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
2995:lib/ff/ff.c   **** 			fp->fsize = fp->fptr;
2996:lib/ff/ff.c   **** 			fp->flag |= FA__WRITTEN;
2997:lib/ff/ff.c   **** 		}
2998:lib/ff/ff.c   **** #endif
2999:lib/ff/ff.c   **** 	}
3000:lib/ff/ff.c   **** 
3001:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, res);
3002:lib/ff/ff.c   **** }
3003:lib/ff/ff.c   **** 
3004:lib/ff/ff.c   **** 
3005:lib/ff/ff.c   **** 
3006:lib/ff/ff.c   **** #if _FS_MINIMIZE <= 1
3007:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3008:lib/ff/ff.c   **** /* Create a Directory Object                                             */
3009:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3010:lib/ff/ff.c   **** 
3011:lib/ff/ff.c   **** FRESULT f_opendir (
3012:lib/ff/ff.c   **** 	DIR *dj,			/* Pointer to directory object to create */
3013:lib/ff/ff.c   **** 	const TCHAR *path	/* Pointer to the directory path */
3014:lib/ff/ff.c   **** )
3015:lib/ff/ff.c   **** {
3016:lib/ff/ff.c   **** 	FRESULT res;
3017:lib/ff/ff.c   **** 	FATFS *fs;
3018:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3019:lib/ff/ff.c   **** 
3020:lib/ff/ff.c   **** 
3021:lib/ff/ff.c   **** 	if (!dj) return FR_INVALID_OBJECT;
3022:lib/ff/ff.c   **** 
3023:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj->fs, 0);
3024:lib/ff/ff.c   **** 	fs = dj->fs;
3025:lib/ff/ff.c   **** 	if (res == FR_OK) {
3026:lib/ff/ff.c   **** 		INIT_BUF(*dj);
3027:lib/ff/ff.c   **** 		res = follow_path(dj, path);			/* Follow the path to the directory */
3028:lib/ff/ff.c   **** 		FREE_BUF();
3029:lib/ff/ff.c   **** 		if (res == FR_OK) {						/* Follow completed */
3030:lib/ff/ff.c   **** 			if (dj->dir) {						/* It is not the root dir */
3031:lib/ff/ff.c   **** 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
3032:lib/ff/ff.c   **** 					dj->sclust = ld_clust(fs, dj->dir);
3033:lib/ff/ff.c   **** 				} else {						/* The object is not a directory */
3034:lib/ff/ff.c   **** 					res = FR_NO_PATH;
3035:lib/ff/ff.c   **** 				}
3036:lib/ff/ff.c   **** 			}
3037:lib/ff/ff.c   **** 			if (res == FR_OK) {
3038:lib/ff/ff.c   **** 				dj->id = fs->id;
3039:lib/ff/ff.c   **** 				res = dir_sdi(dj, 0);			/* Rewind dir */
3040:lib/ff/ff.c   **** 			}
3041:lib/ff/ff.c   **** 		}
3042:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
3043:lib/ff/ff.c   **** 		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
3044:lib/ff/ff.c   **** 	} else {
3045:lib/ff/ff.c   **** 		dj->fs = 0;
3046:lib/ff/ff.c   **** 	}
3047:lib/ff/ff.c   **** 
3048:lib/ff/ff.c   **** 	LEAVE_FF(fs, res);
3049:lib/ff/ff.c   **** }
3050:lib/ff/ff.c   **** 
3051:lib/ff/ff.c   **** 
3052:lib/ff/ff.c   **** 
3053:lib/ff/ff.c   **** 
3054:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3055:lib/ff/ff.c   **** /* Read Directory Entry in Sequence                                      */
3056:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3057:lib/ff/ff.c   **** 
3058:lib/ff/ff.c   **** FRESULT f_readdir (
3059:lib/ff/ff.c   **** 	DIR *dj,			/* Pointer to the open directory object */
3060:lib/ff/ff.c   **** 	FILINFO *fno		/* Pointer to file information to return */
3061:lib/ff/ff.c   **** )
3062:lib/ff/ff.c   **** {
3063:lib/ff/ff.c   **** 	FRESULT res;
3064:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3065:lib/ff/ff.c   **** 
3066:lib/ff/ff.c   **** 
3067:lib/ff/ff.c   **** 	res = validate(dj);						/* Check validity of the object */
3068:lib/ff/ff.c   **** 	if (res == FR_OK) {
3069:lib/ff/ff.c   **** 		if (!fno) {
3070:lib/ff/ff.c   **** 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
3071:lib/ff/ff.c   **** 		} else {
3072:lib/ff/ff.c   **** 			INIT_BUF(*dj);
3073:lib/ff/ff.c   **** 			res = dir_read(dj);				/* Read an directory item */
3074:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) {		/* Reached end of dir */
3075:lib/ff/ff.c   **** 				dj->sect = 0;
3076:lib/ff/ff.c   **** 				res = FR_OK;
3077:lib/ff/ff.c   **** 			}
3078:lib/ff/ff.c   **** 			if (res == FR_OK) {				/* A valid entry is found */
3079:lib/ff/ff.c   **** 				get_fileinfo(dj, fno);		/* Get the object information */
3080:lib/ff/ff.c   **** 				res = dir_next(dj, 0);		/* Increment index for next */
3081:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) {
3082:lib/ff/ff.c   **** 					dj->sect = 0;
3083:lib/ff/ff.c   **** 					res = FR_OK;
3084:lib/ff/ff.c   **** 				}
3085:lib/ff/ff.c   **** 			}
3086:lib/ff/ff.c   **** 			FREE_BUF();
3087:lib/ff/ff.c   **** 		}
3088:lib/ff/ff.c   **** 	}
3089:lib/ff/ff.c   **** 
3090:lib/ff/ff.c   **** 	LEAVE_FF(dj->fs, res);
3091:lib/ff/ff.c   **** }
3092:lib/ff/ff.c   **** 
3093:lib/ff/ff.c   **** 
3094:lib/ff/ff.c   **** 
3095:lib/ff/ff.c   **** #if _FS_MINIMIZE == 0
3096:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3097:lib/ff/ff.c   **** /* Get File Status                                                       */
3098:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3099:lib/ff/ff.c   **** 
3100:lib/ff/ff.c   **** FRESULT f_stat (
3101:lib/ff/ff.c   **** 	const TCHAR *path,	/* Pointer to the file path */
3102:lib/ff/ff.c   **** 	FILINFO *fno		/* Pointer to file information to return */
3103:lib/ff/ff.c   **** )
3104:lib/ff/ff.c   **** {
3105:lib/ff/ff.c   **** 	FRESULT res;
3106:lib/ff/ff.c   **** 	DIR dj;
3107:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3108:lib/ff/ff.c   **** 
3109:lib/ff/ff.c   **** 
3110:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 0);
3111:lib/ff/ff.c   **** 	if (res == FR_OK) {
3112:lib/ff/ff.c   **** 		INIT_BUF(dj);
3113:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
3114:lib/ff/ff.c   **** 		if (res == FR_OK) {				/* Follow completed */
3115:lib/ff/ff.c   **** 			if (dj.dir)		/* Found an object */
3116:lib/ff/ff.c   **** 				get_fileinfo(&dj, fno);
3117:lib/ff/ff.c   **** 			else			/* It is root dir */
3118:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
3119:lib/ff/ff.c   **** 		}
3120:lib/ff/ff.c   **** 		FREE_BUF();
3121:lib/ff/ff.c   **** 	}
3122:lib/ff/ff.c   **** 
3123:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3124:lib/ff/ff.c   **** }
3125:lib/ff/ff.c   **** 
3126:lib/ff/ff.c   **** 
3127:lib/ff/ff.c   **** 
3128:lib/ff/ff.c   **** #if !_FS_READONLY
3129:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3130:lib/ff/ff.c   **** /* Get Number of Free Clusters                                           */
3131:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3132:lib/ff/ff.c   **** 
3133:lib/ff/ff.c   **** FRESULT f_getfree (
3134:lib/ff/ff.c   **** 	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
3135:lib/ff/ff.c   **** 	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
3136:lib/ff/ff.c   **** 	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
3137:lib/ff/ff.c   **** )
3138:lib/ff/ff.c   **** {
3139:lib/ff/ff.c   **** 	FRESULT res;
3140:lib/ff/ff.c   **** 	FATFS *fs;
3141:lib/ff/ff.c   **** 	DWORD n, clst, sect, stat;
3142:lib/ff/ff.c   **** 	UINT i;
3143:lib/ff/ff.c   **** 	BYTE fat, *p;
3144:lib/ff/ff.c   **** 
3145:lib/ff/ff.c   **** 
3146:lib/ff/ff.c   **** 	/* Get drive number */
3147:lib/ff/ff.c   **** 	res = chk_mounted(&path, fatfs, 0);
3148:lib/ff/ff.c   **** 	fs = *fatfs;
3149:lib/ff/ff.c   **** 	if (res == FR_OK) {
3150:lib/ff/ff.c   **** 		/* If free_clust is valid, return it without full cluster scan */
3151:lib/ff/ff.c   **** 		if (fs->free_clust <= fs->n_fatent - 2) {
3152:lib/ff/ff.c   **** 			*nclst = fs->free_clust;
3153:lib/ff/ff.c   **** 		} else {
3154:lib/ff/ff.c   **** 			/* Get number of free clusters */
3155:lib/ff/ff.c   **** 			fat = fs->fs_type;
3156:lib/ff/ff.c   **** 			n = 0;
3157:lib/ff/ff.c   **** 			if (fat == FS_FAT12) {
3158:lib/ff/ff.c   **** 				clst = 2;
3159:lib/ff/ff.c   **** 				do {
3160:lib/ff/ff.c   **** 					stat = get_fat(fs, clst);
3161:lib/ff/ff.c   **** 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
3162:lib/ff/ff.c   **** 					if (stat == 1) { res = FR_INT_ERR; break; }
3163:lib/ff/ff.c   **** 					if (stat == 0) n++;
3164:lib/ff/ff.c   **** 				} while (++clst < fs->n_fatent);
3165:lib/ff/ff.c   **** 			} else {
3166:lib/ff/ff.c   **** 				clst = fs->n_fatent;
3167:lib/ff/ff.c   **** 				sect = fs->fatbase;
3168:lib/ff/ff.c   **** 				i = 0; p = 0;
3169:lib/ff/ff.c   **** 				do {
3170:lib/ff/ff.c   **** 					if (!i) {
3171:lib/ff/ff.c   **** 						res = move_window(fs, sect++);
3172:lib/ff/ff.c   **** 						if (res != FR_OK) break;
3173:lib/ff/ff.c   **** 						p = fs->win;
3174:lib/ff/ff.c   **** 						i = SS(fs);
3175:lib/ff/ff.c   **** 					}
3176:lib/ff/ff.c   **** 					if (fat == FS_FAT16) {
3177:lib/ff/ff.c   **** 						if (LD_WORD(p) == 0) n++;
3178:lib/ff/ff.c   **** 						p += 2; i -= 2;
3179:lib/ff/ff.c   **** 					} else {
3180:lib/ff/ff.c   **** 						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
3181:lib/ff/ff.c   **** 						p += 4; i -= 4;
3182:lib/ff/ff.c   **** 					}
3183:lib/ff/ff.c   **** 				} while (--clst);
3184:lib/ff/ff.c   **** 			}
3185:lib/ff/ff.c   **** 			fs->free_clust = n;
3186:lib/ff/ff.c   **** 			if (fat == FS_FAT32) fs->fsi_flag = 1;
3187:lib/ff/ff.c   **** 			*nclst = n;
3188:lib/ff/ff.c   **** 		}
3189:lib/ff/ff.c   **** 	}
3190:lib/ff/ff.c   **** 	LEAVE_FF(fs, res);
3191:lib/ff/ff.c   **** }
3192:lib/ff/ff.c   **** 
3193:lib/ff/ff.c   **** 
3194:lib/ff/ff.c   **** 
3195:lib/ff/ff.c   **** 
3196:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3197:lib/ff/ff.c   **** /* Truncate File                                                         */
3198:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3199:lib/ff/ff.c   **** 
3200:lib/ff/ff.c   **** FRESULT f_truncate (
3201:lib/ff/ff.c   **** 	FIL *fp		/* Pointer to the file object */
3202:lib/ff/ff.c   **** )
3203:lib/ff/ff.c   **** {
3204:lib/ff/ff.c   **** 	FRESULT res;
3205:lib/ff/ff.c   **** 	DWORD ncl;
3206:lib/ff/ff.c   **** 
3207:lib/ff/ff.c   **** 
3208:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
3209:lib/ff/ff.c   **** 
3210:lib/ff/ff.c   **** 	res = validate(fp);						/* Check validity of the object */
3211:lib/ff/ff.c   **** 	if (res == FR_OK) {
3212:lib/ff/ff.c   **** 		if (fp->flag & FA__ERROR) {			/* Check abort flag */
3213:lib/ff/ff.c   **** 			res = FR_INT_ERR;
3214:lib/ff/ff.c   **** 		} else {
3215:lib/ff/ff.c   **** 			if (!(fp->flag & FA_WRITE))		/* Check access mode */
3216:lib/ff/ff.c   **** 				res = FR_DENIED;
3217:lib/ff/ff.c   **** 		}
3218:lib/ff/ff.c   **** 	}
3219:lib/ff/ff.c   **** 	if (res == FR_OK) {
3220:lib/ff/ff.c   **** 		if (fp->fsize > fp->fptr) {
3221:lib/ff/ff.c   **** 			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
3222:lib/ff/ff.c   **** 			fp->flag |= FA__WRITTEN;
3223:lib/ff/ff.c   **** 			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
3224:lib/ff/ff.c   **** 				res = remove_chain(fp->fs, fp->sclust);
3225:lib/ff/ff.c   **** 				fp->sclust = 0;
3226:lib/ff/ff.c   **** 			} else {				/* When truncate a part of the file, remove remaining clusters */
3227:lib/ff/ff.c   **** 				ncl = get_fat(fp->fs, fp->clust);
3228:lib/ff/ff.c   **** 				res = FR_OK;
3229:lib/ff/ff.c   **** 				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
3230:lib/ff/ff.c   **** 				if (ncl == 1) res = FR_INT_ERR;
3231:lib/ff/ff.c   **** 				if (res == FR_OK && ncl < fp->fs->n_fatent) {
3232:lib/ff/ff.c   **** 					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
3233:lib/ff/ff.c   **** 					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
3234:lib/ff/ff.c   **** 				}
3235:lib/ff/ff.c   **** 			}
3236:lib/ff/ff.c   **** 		}
3237:lib/ff/ff.c   **** 		if (res != FR_OK) fp->flag |= FA__ERROR;
3238:lib/ff/ff.c   **** 	}
3239:lib/ff/ff.c   **** 
3240:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, res);
3241:lib/ff/ff.c   **** }
3242:lib/ff/ff.c   **** 
3243:lib/ff/ff.c   **** 
3244:lib/ff/ff.c   **** 
3245:lib/ff/ff.c   **** 
3246:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3247:lib/ff/ff.c   **** /* Delete a File or Directory                                            */
3248:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3249:lib/ff/ff.c   **** 
3250:lib/ff/ff.c   **** FRESULT f_unlink (
3251:lib/ff/ff.c   **** 	const TCHAR *path		/* Pointer to the file or directory path */
3252:lib/ff/ff.c   **** )
3253:lib/ff/ff.c   **** {
3254:lib/ff/ff.c   **** 	FRESULT res;
3255:lib/ff/ff.c   **** 	DIR dj, sdj;
3256:lib/ff/ff.c   **** 	BYTE *dir;
3257:lib/ff/ff.c   **** 	DWORD dclst;
3258:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3259:lib/ff/ff.c   **** 
3260:lib/ff/ff.c   **** 
3261:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
3262:lib/ff/ff.c   **** 	if (res == FR_OK) {
3263:lib/ff/ff.c   **** 		INIT_BUF(dj);
3264:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the file path */
3265:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3266:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
3267:lib/ff/ff.c   **** #if _FS_LOCK
3268:lib/ff/ff.c   **** 		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
3269:lib/ff/ff.c   **** #endif
3270:lib/ff/ff.c   **** 		if (res == FR_OK) {					/* The object is accessible */
3271:lib/ff/ff.c   **** 			dir = dj.dir;
3272:lib/ff/ff.c   **** 			if (!dir) {
3273:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
3274:lib/ff/ff.c   **** 			} else {
3275:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & AM_RDO)
3276:lib/ff/ff.c   **** 					res = FR_DENIED;		/* Cannot remove R/O object */
3277:lib/ff/ff.c   **** 			}
3278:lib/ff/ff.c   **** 			dclst = ld_clust(dj.fs, dir);
3279:lib/ff/ff.c   **** 			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
3280:lib/ff/ff.c   **** 				if (dclst < 2) {
3281:lib/ff/ff.c   **** 					res = FR_INT_ERR;
3282:lib/ff/ff.c   **** 				} else {
3283:lib/ff/ff.c   **** 					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
3284:lib/ff/ff.c   **** 					sdj.sclust = dclst;
3285:lib/ff/ff.c   **** 					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
3286:lib/ff/ff.c   **** 					if (res == FR_OK) {
3287:lib/ff/ff.c   **** 						res = dir_read(&sdj);
3288:lib/ff/ff.c   **** 						if (res == FR_OK		/* Not empty dir */
3289:lib/ff/ff.c   **** #if _FS_RPATH
3290:lib/ff/ff.c   **** 						|| dclst == dj.fs->cdir	/* Current dir */
3291:lib/ff/ff.c   **** #endif
3292:lib/ff/ff.c   **** 						) res = FR_DENIED;
3293:lib/ff/ff.c   **** 						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
3294:lib/ff/ff.c   **** 					}
3295:lib/ff/ff.c   **** 				}
3296:lib/ff/ff.c   **** 			}
3297:lib/ff/ff.c   **** 			if (res == FR_OK) {
3298:lib/ff/ff.c   **** 				res = dir_remove(&dj);		/* Remove the directory entry */
3299:lib/ff/ff.c   **** 				if (res == FR_OK) {
3300:lib/ff/ff.c   **** 					if (dclst)				/* Remove the cluster chain if exist */
3301:lib/ff/ff.c   **** 						res = remove_chain(dj.fs, dclst);
3302:lib/ff/ff.c   **** 					if (res == FR_OK) res = sync(dj.fs);
3303:lib/ff/ff.c   **** 				}
3304:lib/ff/ff.c   **** 			}
3305:lib/ff/ff.c   **** 		}
3306:lib/ff/ff.c   **** 		FREE_BUF();
3307:lib/ff/ff.c   **** 	}
3308:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3309:lib/ff/ff.c   **** }
3310:lib/ff/ff.c   **** 
3311:lib/ff/ff.c   **** 
3312:lib/ff/ff.c   **** 
3313:lib/ff/ff.c   **** 
3314:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3315:lib/ff/ff.c   **** /* Create a Directory                                                    */
3316:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3317:lib/ff/ff.c   **** 
3318:lib/ff/ff.c   **** FRESULT f_mkdir (
3319:lib/ff/ff.c   **** 	const TCHAR *path		/* Pointer to the directory path */
3320:lib/ff/ff.c   **** )
3321:lib/ff/ff.c   **** {
3322:lib/ff/ff.c   **** 	FRESULT res;
3323:lib/ff/ff.c   **** 	DIR dj;
3324:lib/ff/ff.c   **** 	BYTE *dir, n;
3325:lib/ff/ff.c   **** 	DWORD dsc, dcl, pcl, tim = get_fattime();
3326:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3327:lib/ff/ff.c   **** 
3328:lib/ff/ff.c   **** 
3329:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
3330:lib/ff/ff.c   **** 	if (res == FR_OK) {
3331:lib/ff/ff.c   **** 		INIT_BUF(dj);
3332:lib/ff/ff.c   **** 		res = follow_path(&dj, path);			/* Follow the file path */
3333:lib/ff/ff.c   **** 		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
3334:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
3335:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
3336:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) {				/* Can create a new directory */
3337:lib/ff/ff.c   **** 			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
3338:lib/ff/ff.c   **** 			res = FR_OK;
3339:lib/ff/ff.c   **** 			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
3340:lib/ff/ff.c   **** 			if (dcl == 1) res = FR_INT_ERR;
3341:lib/ff/ff.c   **** 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
3342:lib/ff/ff.c   **** 			if (res == FR_OK)					/* Flush FAT */
3343:lib/ff/ff.c   **** 				res = move_window(dj.fs, 0);
3344:lib/ff/ff.c   **** 			if (res == FR_OK) {					/* Initialize the new directory table */
3345:lib/ff/ff.c   **** 				dsc = clust2sect(dj.fs, dcl);
3346:lib/ff/ff.c   **** 				dir = dj.fs->win;
3347:lib/ff/ff.c   **** 				mem_set(dir, 0, SS(dj.fs));
3348:lib/ff/ff.c   **** 				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
3349:lib/ff/ff.c   **** 				dir[DIR_Name] = '.';
3350:lib/ff/ff.c   **** 				dir[DIR_Attr] = AM_DIR;
3351:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tim);
3352:lib/ff/ff.c   **** 				st_clust(dir, dcl);
3353:lib/ff/ff.c   **** 				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
3354:lib/ff/ff.c   **** 				dir[33] = '.'; pcl = dj.sclust;
3355:lib/ff/ff.c   **** 				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
3356:lib/ff/ff.c   **** 					pcl = 0;
3357:lib/ff/ff.c   **** 				st_clust(dir+SZ_DIR, pcl);
3358:lib/ff/ff.c   **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
3359:lib/ff/ff.c   **** 					dj.fs->winsect = dsc++;
3360:lib/ff/ff.c   **** 					dj.fs->wflag = 1;
3361:lib/ff/ff.c   **** 					res = move_window(dj.fs, 0);
3362:lib/ff/ff.c   **** 					if (res != FR_OK) break;
3363:lib/ff/ff.c   **** 					mem_set(dir, 0, SS(dj.fs));
3364:lib/ff/ff.c   **** 				}
3365:lib/ff/ff.c   **** 			}
3366:lib/ff/ff.c   **** 			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
3367:lib/ff/ff.c   **** 			if (res != FR_OK) {
3368:lib/ff/ff.c   **** 				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
3369:lib/ff/ff.c   **** 			} else {
3370:lib/ff/ff.c   **** 				dir = dj.dir;
3371:lib/ff/ff.c   **** 				dir[DIR_Attr] = AM_DIR;				/* Attribute */
3372:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
3373:lib/ff/ff.c   **** 				st_clust(dir, dcl);					/* Table start cluster */
3374:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
3375:lib/ff/ff.c   **** 				res = sync(dj.fs);
3376:lib/ff/ff.c   **** 			}
3377:lib/ff/ff.c   **** 		}
3378:lib/ff/ff.c   **** 		FREE_BUF();
3379:lib/ff/ff.c   **** 	}
3380:lib/ff/ff.c   **** 
3381:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3382:lib/ff/ff.c   **** }
3383:lib/ff/ff.c   **** 
3384:lib/ff/ff.c   **** 
3385:lib/ff/ff.c   **** 
3386:lib/ff/ff.c   **** 
3387:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3388:lib/ff/ff.c   **** /* Change Attribute                                                      */
3389:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3390:lib/ff/ff.c   **** 
3391:lib/ff/ff.c   **** FRESULT f_chmod (
3392:lib/ff/ff.c   **** 	const TCHAR *path,	/* Pointer to the file path */
3393:lib/ff/ff.c   **** 	BYTE value,			/* Attribute bits */
3394:lib/ff/ff.c   **** 	BYTE mask			/* Attribute mask to change */
3395:lib/ff/ff.c   **** )
3396:lib/ff/ff.c   **** {
3397:lib/ff/ff.c   **** 	FRESULT res;
3398:lib/ff/ff.c   **** 	DIR dj;
3399:lib/ff/ff.c   **** 	BYTE *dir;
3400:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3401:lib/ff/ff.c   **** 
3402:lib/ff/ff.c   **** 
3403:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
3404:lib/ff/ff.c   **** 	if (res == FR_OK) {
3405:lib/ff/ff.c   **** 		INIT_BUF(dj);
3406:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the file path */
3407:lib/ff/ff.c   **** 		FREE_BUF();
3408:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3409:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
3410:lib/ff/ff.c   **** 		if (res == FR_OK) {
3411:lib/ff/ff.c   **** 			dir = dj.dir;
3412:lib/ff/ff.c   **** 			if (!dir) {						/* Is it a root directory? */
3413:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
3414:lib/ff/ff.c   **** 			} else {						/* File or sub directory */
3415:lib/ff/ff.c   **** 				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
3416:lib/ff/ff.c   **** 				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
3417:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
3418:lib/ff/ff.c   **** 				res = sync(dj.fs);
3419:lib/ff/ff.c   **** 			}
3420:lib/ff/ff.c   **** 		}
3421:lib/ff/ff.c   **** 	}
3422:lib/ff/ff.c   **** 
3423:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3424:lib/ff/ff.c   **** }
3425:lib/ff/ff.c   **** 
3426:lib/ff/ff.c   **** 
3427:lib/ff/ff.c   **** 
3428:lib/ff/ff.c   **** 
3429:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3430:lib/ff/ff.c   **** /* Change Timestamp                                                      */
3431:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3432:lib/ff/ff.c   **** 
3433:lib/ff/ff.c   **** FRESULT f_utime (
3434:lib/ff/ff.c   **** 	const TCHAR *path,	/* Pointer to the file/directory name */
3435:lib/ff/ff.c   **** 	const FILINFO *fno	/* Pointer to the time stamp to be set */
3436:lib/ff/ff.c   **** )
3437:lib/ff/ff.c   **** {
3438:lib/ff/ff.c   **** 	FRESULT res;
3439:lib/ff/ff.c   **** 	DIR dj;
3440:lib/ff/ff.c   **** 	BYTE *dir;
3441:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3442:lib/ff/ff.c   **** 
3443:lib/ff/ff.c   **** 
3444:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
3445:lib/ff/ff.c   **** 	if (res == FR_OK) {
3446:lib/ff/ff.c   **** 		INIT_BUF(dj);
3447:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
3448:lib/ff/ff.c   **** 		FREE_BUF();
3449:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3450:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
3451:lib/ff/ff.c   **** 		if (res == FR_OK) {
3452:lib/ff/ff.c   **** 			dir = dj.dir;
3453:lib/ff/ff.c   **** 			if (!dir) {					/* Root directory */
3454:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
3455:lib/ff/ff.c   **** 			} else {					/* File or sub-directory */
3456:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_WrtTime, fno->ftime);
3457:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
3458:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
3459:lib/ff/ff.c   **** 				res = sync(dj.fs);
3460:lib/ff/ff.c   **** 			}
3461:lib/ff/ff.c   **** 		}
3462:lib/ff/ff.c   **** 	}
3463:lib/ff/ff.c   **** 
3464:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3465:lib/ff/ff.c   **** }
3466:lib/ff/ff.c   **** 
3467:lib/ff/ff.c   **** 
3468:lib/ff/ff.c   **** 
3469:lib/ff/ff.c   **** 
3470:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3471:lib/ff/ff.c   **** /* Rename File/Directory                                                 */
3472:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3473:lib/ff/ff.c   **** 
3474:lib/ff/ff.c   **** FRESULT f_rename (
3475:lib/ff/ff.c   **** 	const TCHAR *path_old,	/* Pointer to the old name */
3476:lib/ff/ff.c   **** 	const TCHAR *path_new	/* Pointer to the new name */
3477:lib/ff/ff.c   **** )
3478:lib/ff/ff.c   **** {
3479:lib/ff/ff.c   **** 	FRESULT res;
3480:lib/ff/ff.c   **** 	DIR djo, djn;
3481:lib/ff/ff.c   **** 	BYTE buf[21], *dir;
3482:lib/ff/ff.c   **** 	DWORD dw;
3483:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3484:lib/ff/ff.c   **** 
3485:lib/ff/ff.c   **** 
3486:lib/ff/ff.c   **** 	res = chk_mounted(&path_old, &djo.fs, 1);
3487:lib/ff/ff.c   **** 	if (res == FR_OK) {
3488:lib/ff/ff.c   **** 		djn.fs = djo.fs;
3489:lib/ff/ff.c   **** 		INIT_BUF(djo);
3490:lib/ff/ff.c   **** 		res = follow_path(&djo, path_old);		/* Check old object */
3491:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
3492:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
3493:lib/ff/ff.c   **** #if _FS_LOCK
3494:lib/ff/ff.c   **** 		if (res == FR_OK) res = chk_lock(&djo, 2);
3495:lib/ff/ff.c   **** #endif
3496:lib/ff/ff.c   **** 		if (res == FR_OK) {						/* Old object is found */
3497:lib/ff/ff.c   **** 			if (!djo.dir) {						/* Is root dir? */
3498:lib/ff/ff.c   **** 				res = FR_NO_FILE;
3499:lib/ff/ff.c   **** 			} else {
3500:lib/ff/ff.c   **** 				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
3501:lib/ff/ff.c   **** 				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
3502:lib/ff/ff.c   **** 				res = follow_path(&djn, path_new);
3503:lib/ff/ff.c   **** 				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
3504:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
3505:lib/ff/ff.c   **** /* Start critical section that an interruption or error can cause cross-link */
3506:lib/ff/ff.c   **** 					res = dir_register(&djn);			/* Register the new entry */
3507:lib/ff/ff.c   **** 					if (res == FR_OK) {
3508:lib/ff/ff.c   **** 						dir = djn.dir;					/* Copy object information except for name */
3509:lib/ff/ff.c   **** 						mem_cpy(dir+13, buf+2, 19);
3510:lib/ff/ff.c   **** 						dir[DIR_Attr] = buf[0] | AM_ARC;
3511:lib/ff/ff.c   **** 						djo.fs->wflag = 1;
3512:lib/ff/ff.c   **** 						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the direct
3513:lib/ff/ff.c   **** 							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
3514:lib/ff/ff.c   **** 							if (!dw) {
3515:lib/ff/ff.c   **** 								res = FR_INT_ERR;
3516:lib/ff/ff.c   **** 							} else {
3517:lib/ff/ff.c   **** 								res = move_window(djo.fs, dw);
3518:lib/ff/ff.c   **** 								dir = djo.fs->win+SZ_DIR;	/* .. entry */
3519:lib/ff/ff.c   **** 								if (res == FR_OK && dir[1] == '.') {
3520:lib/ff/ff.c   **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
3521:lib/ff/ff.c   **** 									st_clust(dir, dw);
3522:lib/ff/ff.c   **** 									djo.fs->wflag = 1;
3523:lib/ff/ff.c   **** 								}
3524:lib/ff/ff.c   **** 							}
3525:lib/ff/ff.c   **** 						}
3526:lib/ff/ff.c   **** 						if (res == FR_OK) {
3527:lib/ff/ff.c   **** 							res = dir_remove(&djo);		/* Remove old entry */
3528:lib/ff/ff.c   **** 							if (res == FR_OK)
3529:lib/ff/ff.c   **** 								res = sync(djo.fs);
3530:lib/ff/ff.c   **** 						}
3531:lib/ff/ff.c   **** 					}
3532:lib/ff/ff.c   **** /* End critical section */
3533:lib/ff/ff.c   **** 				}
3534:lib/ff/ff.c   **** 			}
3535:lib/ff/ff.c   **** 		}
3536:lib/ff/ff.c   **** 		FREE_BUF();
3537:lib/ff/ff.c   **** 	}
3538:lib/ff/ff.c   **** 	LEAVE_FF(djo.fs, res);
3539:lib/ff/ff.c   **** }
3540:lib/ff/ff.c   **** 
3541:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
3542:lib/ff/ff.c   **** #endif /* _FS_MINIMIZE == 0 */
3543:lib/ff/ff.c   **** #endif /* _FS_MINIMIZE <= 1 */
3544:lib/ff/ff.c   **** #endif /* _FS_MINIMIZE <= 2 */
3545:lib/ff/ff.c   **** 
3546:lib/ff/ff.c   **** 
3547:lib/ff/ff.c   **** 
3548:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3549:lib/ff/ff.c   **** /* Forward data to the stream directly (available on only tiny cfg)      */
3550:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3551:lib/ff/ff.c   **** #if _USE_FORWARD && _FS_TINY
3552:lib/ff/ff.c   **** 
3553:lib/ff/ff.c   **** FRESULT f_forward (
3554:lib/ff/ff.c   **** 	FIL *fp, 						/* Pointer to the file object */
3555:lib/ff/ff.c   **** 	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
3556:lib/ff/ff.c   **** 	UINT btr,						/* Number of bytes to forward */
3557:lib/ff/ff.c   **** 	UINT *bf						/* Pointer to number of bytes forwarded */
3558:lib/ff/ff.c   **** )
3559:lib/ff/ff.c   **** {
3560:lib/ff/ff.c   **** 	FRESULT res;
3561:lib/ff/ff.c   **** 	DWORD remain, clst, sect;
3562:lib/ff/ff.c   **** 	UINT rcnt;
3563:lib/ff/ff.c   **** 	BYTE csect;
3564:lib/ff/ff.c   **** 
3565:lib/ff/ff.c   **** 
3566:lib/ff/ff.c   **** 	*bf = 0;	/* Clear transfer byte counter */
3567:lib/ff/ff.c   **** 
3568:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
3569:lib/ff/ff.c   **** 
3570:lib/ff/ff.c   **** 	res = validate(fp);								/* Check validity of the object */
3571:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
3572:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)						/* Check error flag */
3573:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
3574:lib/ff/ff.c   **** 	if (!(fp->flag & FA_READ))						/* Check access mode */
3575:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
3576:lib/ff/ff.c   **** 
3577:lib/ff/ff.c   **** 	remain = fp->fsize - fp->fptr;
3578:lib/ff/ff.c   **** 	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
3579:lib/ff/ff.c   **** 
3580:lib/ff/ff.c   **** 	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
3581:lib/ff/ff.c   **** 		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
3582:lib/ff/ff.c   **** 		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
3583:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
3584:lib/ff/ff.c   **** 			if (!csect) {							/* On the cluster boundary? */
3585:lib/ff/ff.c   **** 				clst = (fp->fptr == 0) ?			/* On the top of the file? */
3586:lib/ff/ff.c   **** 					fp->sclust : get_fat(fp->fs, fp->clust);
3587:lib/ff/ff.c   **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3588:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3589:lib/ff/ff.c   **** 				fp->clust = clst;					/* Update current cluster */
3590:lib/ff/ff.c   **** 			}
3591:lib/ff/ff.c   **** 		}
3592:lib/ff/ff.c   **** 		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
3593:lib/ff/ff.c   **** 		if (!sect) ABORT(fp->fs, FR_INT_ERR);
3594:lib/ff/ff.c   **** 		sect += csect;
3595:lib/ff/ff.c   **** 		if (move_window(fp->fs, sect))				/* Move sector window */
3596:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
3597:lib/ff/ff.c   **** 		fp->dsect = sect;
3598:lib/ff/ff.c   **** 		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
3599:lib/ff/ff.c   **** 		if (rcnt > btr) rcnt = btr;
3600:lib/ff/ff.c   **** 		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
3601:lib/ff/ff.c   **** 		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3602:lib/ff/ff.c   **** 	}
3603:lib/ff/ff.c   **** 
3604:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, FR_OK);
3605:lib/ff/ff.c   **** }
3606:lib/ff/ff.c   **** #endif /* _USE_FORWARD */
3607:lib/ff/ff.c   **** 
3608:lib/ff/ff.c   **** 
3609:lib/ff/ff.c   **** 
3610:lib/ff/ff.c   **** #if _USE_MKFS && !_FS_READONLY
3611:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3612:lib/ff/ff.c   **** /* Create File System on the Drive                                       */
3613:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3614:lib/ff/ff.c   **** #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3615:lib/ff/ff.c   **** #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3616:lib/ff/ff.c   **** 
3617:lib/ff/ff.c   **** 
3618:lib/ff/ff.c   **** FRESULT f_mkfs (
3619:lib/ff/ff.c   **** 	BYTE drv,		/* Logical drive number */
3620:lib/ff/ff.c   **** 	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
3621:lib/ff/ff.c   **** 	UINT au			/* Allocation unit size [bytes] */
3622:lib/ff/ff.c   **** )
3623:lib/ff/ff.c   **** {
3624:lib/ff/ff.c   **** 	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
3625:lib/ff/ff.c   **** 	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3626:lib/ff/ff.c   **** 	BYTE fmt, md, sys, *tbl, pdrv, part;
3627:lib/ff/ff.c   **** 	DWORD n_clst, vs, n, wsect;
3628:lib/ff/ff.c   **** 	UINT i;
3629:lib/ff/ff.c   **** 	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
3630:lib/ff/ff.c   **** 	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
3631:lib/ff/ff.c   **** 	FATFS *fs;
3632:lib/ff/ff.c   **** 	DSTATUS stat;
3633:lib/ff/ff.c   **** 
3634:lib/ff/ff.c   **** 
3635:lib/ff/ff.c   **** 	/* Check mounted drive and clear work area */
3636:lib/ff/ff.c   **** 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
3637:lib/ff/ff.c   **** 	if (sfd > 1) return FR_INVALID_PARAMETER;
3638:lib/ff/ff.c   **** 	if (au & (au - 1)) return FR_INVALID_PARAMETER;
3639:lib/ff/ff.c   **** 	fs = FatFs[drv];
3640:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;
3641:lib/ff/ff.c   **** 	fs->fs_type = 0;
3642:lib/ff/ff.c   **** 	pdrv = LD2PD(drv);	/* Physical drive */
3643:lib/ff/ff.c   **** 	part = LD2PT(drv);	/* Partition (0:auto detect, 1-4:get from partition table)*/
3644:lib/ff/ff.c   **** 
3645:lib/ff/ff.c   **** 	/* Get disk statics */
3646:lib/ff/ff.c   **** 	stat = disk_initialize(pdrv);
3647:lib/ff/ff.c   **** 	if (stat & STA_NOINIT) return FR_NOT_READY;
3648:lib/ff/ff.c   **** 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3649:lib/ff/ff.c   **** #if _MAX_SS != 512					/* Get disk sector size */
3650:lib/ff/ff.c   **** 	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3651:lib/ff/ff.c   **** 		return FR_DISK_ERR;
3652:lib/ff/ff.c   **** #endif
3653:lib/ff/ff.c   **** 	if (_MULTI_PARTITION && part) {
3654:lib/ff/ff.c   **** 		/* Get partition information from partition table in the MBR */
3655:lib/ff/ff.c   **** 		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3656:lib/ff/ff.c   **** 		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3657:lib/ff/ff.c   **** 		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3658:lib/ff/ff.c   **** 		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
3659:lib/ff/ff.c   **** 		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
3660:lib/ff/ff.c   **** 		n_vol = LD_DWORD(tbl+12);	/* Volume size */
3661:lib/ff/ff.c   **** 	} else {
3662:lib/ff/ff.c   **** 		/* Create a partition in this function */
3663:lib/ff/ff.c   **** 		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
3664:lib/ff/ff.c   **** 			return FR_DISK_ERR;
3665:lib/ff/ff.c   **** 		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
3666:lib/ff/ff.c   **** 		n_vol -= b_vol;				/* Volume size */
3667:lib/ff/ff.c   **** 	}
3668:lib/ff/ff.c   **** 
3669:lib/ff/ff.c   **** 	if (!au) {				/* AU auto selection */
3670:lib/ff/ff.c   **** 		vs = n_vol / (2000 / (SS(fs) / 512));
3671:lib/ff/ff.c   **** 		for (i = 0; vs < vst[i]; i++) ;
3672:lib/ff/ff.c   **** 		au = cst[i];
3673:lib/ff/ff.c   **** 	}
3674:lib/ff/ff.c   **** 	au /= SS(fs);		/* Number of sectors per cluster */
3675:lib/ff/ff.c   **** 	if (au == 0) au = 1;
3676:lib/ff/ff.c   **** 	if (au > 128) au = 128;
3677:lib/ff/ff.c   **** 
3678:lib/ff/ff.c   **** 	/* Pre-compute number of clusters and FAT sub-type */
3679:lib/ff/ff.c   **** 	n_clst = n_vol / au;
3680:lib/ff/ff.c   **** 	fmt = FS_FAT12;
3681:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
3682:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
3683:lib/ff/ff.c   **** 
3684:lib/ff/ff.c   **** 	/* Determine offset and size of FAT structure */
3685:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
3686:lib/ff/ff.c   **** 		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
3687:lib/ff/ff.c   **** 		n_rsv = 32;
3688:lib/ff/ff.c   **** 		n_dir = 0;
3689:lib/ff/ff.c   **** 	} else {
3690:lib/ff/ff.c   **** 		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
3691:lib/ff/ff.c   **** 		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
3692:lib/ff/ff.c   **** 		n_rsv = 1;
3693:lib/ff/ff.c   **** 		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
3694:lib/ff/ff.c   **** 	}
3695:lib/ff/ff.c   **** 	b_fat = b_vol + n_rsv;				/* FAT area start sector */
3696:lib/ff/ff.c   **** 	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
3697:lib/ff/ff.c   **** 	b_data = b_dir + n_dir;				/* Data area start sector */
3698:lib/ff/ff.c   **** 	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
3699:lib/ff/ff.c   **** 
3700:lib/ff/ff.c   **** 	/* Align data start sector to erase block boundary (for flash memory media) */
3701:lib/ff/ff.c   **** 	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
3702:lib/ff/ff.c   **** 	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
3703:lib/ff/ff.c   **** 	n = (n - b_data) / N_FATS;
3704:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
3705:lib/ff/ff.c   **** 		n_rsv += n;
3706:lib/ff/ff.c   **** 		b_fat += n;
3707:lib/ff/ff.c   **** 	} else {					/* FAT12/16: Expand FAT size */
3708:lib/ff/ff.c   **** 		n_fat += n;
3709:lib/ff/ff.c   **** 	}
3710:lib/ff/ff.c   **** 
3711:lib/ff/ff.c   **** 	/* Determine number of clusters and final check of validity of the FAT sub-type */
3712:lib/ff/ff.c   **** 	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
3713:lib/ff/ff.c   **** 	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
3714:lib/ff/ff.c   **** 		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
3715:lib/ff/ff.c   **** 		return FR_MKFS_ABORTED;
3716:lib/ff/ff.c   **** 
3717:lib/ff/ff.c   **** 	switch (fmt) {	/* Determine system ID for partition table */
3718:lib/ff/ff.c   **** 	case FS_FAT12:	sys = 0x01; break;
3719:lib/ff/ff.c   **** 	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
3720:lib/ff/ff.c   **** 	default: 		sys = 0x0C;
3721:lib/ff/ff.c   **** 	}
3722:lib/ff/ff.c   **** 
3723:lib/ff/ff.c   **** 	if (_MULTI_PARTITION && part) {
3724:lib/ff/ff.c   **** 		/* Update system ID in the partition table */
3725:lib/ff/ff.c   **** 		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3726:lib/ff/ff.c   **** 		tbl[4] = sys;
3727:lib/ff/ff.c   **** 		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3728:lib/ff/ff.c   **** 		md = 0xF8;
3729:lib/ff/ff.c   **** 	} else {
3730:lib/ff/ff.c   **** 		if (sfd) {	/* No partition table (SFD) */
3731:lib/ff/ff.c   **** 			md = 0xF0;
3732:lib/ff/ff.c   **** 		} else {	/* Create partition table (FDISK) */
3733:lib/ff/ff.c   **** 			mem_set(fs->win, 0, SS(fs));
3734:lib/ff/ff.c   **** 			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
3735:lib/ff/ff.c   **** 			tbl[1] = 1;						/* Partition start head */
3736:lib/ff/ff.c   **** 			tbl[2] = 1;						/* Partition start sector */
3737:lib/ff/ff.c   **** 			tbl[3] = 0;						/* Partition start cylinder */
3738:lib/ff/ff.c   **** 			tbl[4] = sys;					/* System type */
3739:lib/ff/ff.c   **** 			tbl[5] = 254;					/* Partition end head */
3740:lib/ff/ff.c   **** 			n = (b_vol + n_vol) / 63 / 255;
3741:lib/ff/ff.c   **** 			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partition end sector */
3742:lib/ff/ff.c   **** 			tbl[7] = (BYTE)n;				/* End cylinder */
3743:lib/ff/ff.c   **** 			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
3744:lib/ff/ff.c   **** 			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
3745:lib/ff/ff.c   **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
3746:lib/ff/ff.c   **** 			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
3747:lib/ff/ff.c   **** 				return FR_DISK_ERR;
3748:lib/ff/ff.c   **** 			md = 0xF8;
3749:lib/ff/ff.c   **** 		}
3750:lib/ff/ff.c   **** 	}
3751:lib/ff/ff.c   **** 
3752:lib/ff/ff.c   **** 	/* Create BPB in the VBR */
3753:lib/ff/ff.c   **** 	tbl = fs->win;							/* Clear sector */
3754:lib/ff/ff.c   **** 	mem_set(tbl, 0, SS(fs));
3755:lib/ff/ff.c   **** 	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
3756:lib/ff/ff.c   **** 	i = SS(fs);								/* Sector size */
3757:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_BytsPerSec, i);
3758:lib/ff/ff.c   **** 	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
3759:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
3760:lib/ff/ff.c   **** 	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
3761:lib/ff/ff.c   **** 	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
3762:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_RootEntCnt, i);
3763:lib/ff/ff.c   **** 	if (n_vol < 0x10000) {					/* Number of total sectors */
3764:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_TotSec16, n_vol);
3765:lib/ff/ff.c   **** 	} else {
3766:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_TotSec32, n_vol);
3767:lib/ff/ff.c   **** 	}
3768:lib/ff/ff.c   **** 	tbl[BPB_Media] = md;					/* Media descriptor */
3769:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
3770:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
3771:lib/ff/ff.c   **** 	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
3772:lib/ff/ff.c   **** 	n = get_fattime();						/* Use current time as VSN */
3773:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
3774:lib/ff/ff.c   **** 		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
3775:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
3776:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
3777:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
3778:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
3779:lib/ff/ff.c   **** 		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
3780:lib/ff/ff.c   **** 		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
3781:lib/ff/ff.c   **** 		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
3782:lib/ff/ff.c   **** 	} else {
3783:lib/ff/ff.c   **** 		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
3784:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
3785:lib/ff/ff.c   **** 		tbl[BS_DrvNum] = 0x80;				/* Drive number */
3786:lib/ff/ff.c   **** 		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
3787:lib/ff/ff.c   **** 		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
3788:lib/ff/ff.c   **** 	}
3789:lib/ff/ff.c   **** 	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
3790:lib/ff/ff.c   **** 	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
3791:lib/ff/ff.c   **** 		return FR_DISK_ERR;
3792:lib/ff/ff.c   **** 	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
3793:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 6, 1);
3794:lib/ff/ff.c   **** 
3795:lib/ff/ff.c   **** 	/* Initialize FAT area */
3796:lib/ff/ff.c   **** 	wsect = b_fat;
3797:lib/ff/ff.c   **** 	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
3798:lib/ff/ff.c   **** 		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
3799:lib/ff/ff.c   **** 		n = md;								/* Media descriptor byte */
3800:lib/ff/ff.c   **** 		if (fmt != FS_FAT32) {
3801:lib/ff/ff.c   **** 			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
3802:lib/ff/ff.c   **** 			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
3803:lib/ff/ff.c   **** 		} else {
3804:lib/ff/ff.c   **** 			n |= 0xFFFFFF00;
3805:lib/ff/ff.c   **** 			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
3806:lib/ff/ff.c   **** 			ST_DWORD(tbl+4, 0xFFFFFFFF);
3807:lib/ff/ff.c   **** 			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
3808:lib/ff/ff.c   **** 		}
3809:lib/ff/ff.c   **** 		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3810:lib/ff/ff.c   **** 			return FR_DISK_ERR;
3811:lib/ff/ff.c   **** 		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
3812:lib/ff/ff.c   **** 		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single se
3813:lib/ff/ff.c   **** 			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3814:lib/ff/ff.c   **** 				return FR_DISK_ERR;
3815:lib/ff/ff.c   **** 		}
3816:lib/ff/ff.c   **** 	}
3817:lib/ff/ff.c   **** 
3818:lib/ff/ff.c   **** 	/* Initialize root directory */
3819:lib/ff/ff.c   **** 	i = (fmt == FS_FAT32) ? au : n_dir;
3820:lib/ff/ff.c   **** 	do {
3821:lib/ff/ff.c   **** 		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3822:lib/ff/ff.c   **** 			return FR_DISK_ERR;
3823:lib/ff/ff.c   **** 	} while (--i);
3824:lib/ff/ff.c   **** 
3825:lib/ff/ff.c   **** #if _USE_ERASE	/* Erase data area if needed */
3826:lib/ff/ff.c   **** 	{
3827:lib/ff/ff.c   **** 		DWORD eb[2];
3828:lib/ff/ff.c   **** 
3829:lib/ff/ff.c   **** 		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
3830:lib/ff/ff.c   **** 		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
3831:lib/ff/ff.c   **** 	}
3832:lib/ff/ff.c   **** #endif
3833:lib/ff/ff.c   **** 
3834:lib/ff/ff.c   **** 	/* Create FSInfo if needed */
3835:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
3836:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
3837:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
3838:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
3839:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
3840:lib/ff/ff.c   **** 		ST_WORD(tbl+BS_55AA, 0xAA55);
3841:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
3842:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
3843:lib/ff/ff.c   **** 	}
3844:lib/ff/ff.c   **** 
3845:lib/ff/ff.c   **** 	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
3846:lib/ff/ff.c   **** }
3847:lib/ff/ff.c   **** 
3848:lib/ff/ff.c   **** 
3849:lib/ff/ff.c   **** #if _MULTI_PARTITION == 2
3850:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3851:lib/ff/ff.c   **** /* Divide Physical Drive                                                 */
3852:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3853:lib/ff/ff.c   **** 
3854:lib/ff/ff.c   **** FRESULT f_fdisk (
3855:lib/ff/ff.c   **** 	BYTE pdrv,			/* Physical drive number */
3856:lib/ff/ff.c   **** 	const DWORD szt[],	/* Pointer to the size table for each partitions */
3857:lib/ff/ff.c   **** 	void* work			/* Pointer to the working buffer */
3858:lib/ff/ff.c   **** )
3859:lib/ff/ff.c   **** {
3860:lib/ff/ff.c   **** 	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
3861:lib/ff/ff.c   **** 	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
3862:lib/ff/ff.c   **** 	DSTATUS stat;
3863:lib/ff/ff.c   **** 	DWORD sz_disk, sz_part, s_part;
3864:lib/ff/ff.c   **** 
3865:lib/ff/ff.c   **** 
3866:lib/ff/ff.c   **** 	stat = disk_initialize(pdrv);
3867:lib/ff/ff.c   **** 	if (stat & STA_NOINIT) return FR_NOT_READY;
3868:lib/ff/ff.c   **** 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3869:lib/ff/ff.c   **** 	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
3870:lib/ff/ff.c   **** 
3871:lib/ff/ff.c   **** 	/* Determine CHS in the table regardless of the drive geometry */
3872:lib/ff/ff.c   **** 	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
3873:lib/ff/ff.c   **** 	if (n == 256) n--;
3874:lib/ff/ff.c   **** 	e_hd = n - 1;
3875:lib/ff/ff.c   **** 	sz_cyl = 63 * n;
3876:lib/ff/ff.c   **** 	tot_cyl = sz_disk / sz_cyl;
3877:lib/ff/ff.c   **** 
3878:lib/ff/ff.c   **** 	/* Create partition table */
3879:lib/ff/ff.c   **** 	mem_set(buf, 0, _MAX_SS);
3880:lib/ff/ff.c   **** 	p = buf + MBR_Table; b_cyl = 0;
3881:lib/ff/ff.c   **** 	for (i = 0; i < 4; i++, p += SZ_PTE) {
3882:lib/ff/ff.c   **** 		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
3883:lib/ff/ff.c   **** 		if (!p_cyl) continue;
3884:lib/ff/ff.c   **** 		s_part = (DWORD)sz_cyl * b_cyl;
3885:lib/ff/ff.c   **** 		sz_part = (DWORD)sz_cyl * p_cyl;
3886:lib/ff/ff.c   **** 		if (i == 0) {	/* Exclude first track of cylinder 0 */
3887:lib/ff/ff.c   **** 			s_hd = 1;
3888:lib/ff/ff.c   **** 			s_part += 63; sz_part -= 63;
3889:lib/ff/ff.c   **** 		} else {
3890:lib/ff/ff.c   **** 			s_hd = 0;
3891:lib/ff/ff.c   **** 		}
3892:lib/ff/ff.c   **** 		e_cyl = b_cyl + p_cyl - 1;
3893:lib/ff/ff.c   **** 		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
3894:lib/ff/ff.c   **** 
3895:lib/ff/ff.c   **** 		/* Set partition table */
3896:lib/ff/ff.c   **** 		p[1] = s_hd;						/* Start head */
3897:lib/ff/ff.c   **** 		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
3898:lib/ff/ff.c   **** 		p[3] = (BYTE)b_cyl;					/* Start cylinder */
3899:lib/ff/ff.c   **** 		p[4] = 0x06;						/* System type (temporary setting) */
3900:lib/ff/ff.c   **** 		p[5] = e_hd;						/* End head */
3901:lib/ff/ff.c   **** 		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
3902:lib/ff/ff.c   **** 		p[7] = (BYTE)e_cyl;					/* End cylinder */
3903:lib/ff/ff.c   **** 		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
3904:lib/ff/ff.c   **** 		ST_DWORD(p + 12, sz_part);			/* Partition size */
3905:lib/ff/ff.c   **** 
3906:lib/ff/ff.c   **** 		/* Next partition */
3907:lib/ff/ff.c   **** 		b_cyl += p_cyl;
3908:lib/ff/ff.c   **** 	}
3909:lib/ff/ff.c   **** 	ST_WORD(p, 0xAA55);
3910:lib/ff/ff.c   **** 
3911:lib/ff/ff.c   **** 	/* Write it to the MBR */
3912:lib/ff/ff.c   **** 	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
3913:lib/ff/ff.c   **** }
3914:lib/ff/ff.c   **** 
3915:lib/ff/ff.c   **** 
3916:lib/ff/ff.c   **** #endif /* _MULTI_PARTITION == 2 */
3917:lib/ff/ff.c   **** #endif /* _USE_MKFS && !_FS_READONLY */
3918:lib/ff/ff.c   **** 
3919:lib/ff/ff.c   **** 
3920:lib/ff/ff.c   **** 
3921:lib/ff/ff.c   **** 
3922:lib/ff/ff.c   **** #if _USE_STRFUNC
3923:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3924:lib/ff/ff.c   **** /* Get a string from the file                                            */
3925:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3926:lib/ff/ff.c   **** TCHAR* f_gets (
3927:lib/ff/ff.c   **** 	TCHAR* buff,	/* Pointer to the string buffer to read */
3928:lib/ff/ff.c   **** 	int len,		/* Size of string buffer (characters) */
3929:lib/ff/ff.c   **** 	FIL* fil		/* Pointer to the file object */
3930:lib/ff/ff.c   **** )
3931:lib/ff/ff.c   **** {
3932:lib/ff/ff.c   **** 	int n = 0;
3933:lib/ff/ff.c   **** 	TCHAR c, *p = buff;
3934:lib/ff/ff.c   **** 	BYTE s[2];
3935:lib/ff/ff.c   **** 	UINT rc;
3936:lib/ff/ff.c   **** 
3937:lib/ff/ff.c   **** 
3938:lib/ff/ff.c   **** 	while (n < len - 1) {			/* Read bytes until buffer gets filled */
3939:lib/ff/ff.c   **** 		f_read(fil, s, 1, &rc);
3940:lib/ff/ff.c   **** 		if (rc != 1) break;			/* Break on EOF or error */
3941:lib/ff/ff.c   **** 		c = s[0];
3942:lib/ff/ff.c   **** #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
3943:lib/ff/ff.c   **** 		if (c >= 0x80) {
3944:lib/ff/ff.c   **** 			if (c < 0xC0) continue;	/* Skip stray trailer */
3945:lib/ff/ff.c   **** 			if (c < 0xE0) {			/* Two-byte sequence */
3946:lib/ff/ff.c   **** 				f_read(fil, s, 1, &rc);
3947:lib/ff/ff.c   **** 				if (rc != 1) break;
3948:lib/ff/ff.c   **** 				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
3949:lib/ff/ff.c   **** 				if (c < 0x80) c = '?';
3950:lib/ff/ff.c   **** 			} else {
3951:lib/ff/ff.c   **** 				if (c < 0xF0) {		/* Three-byte sequence */
3952:lib/ff/ff.c   **** 					f_read(fil, s, 2, &rc);
3953:lib/ff/ff.c   **** 					if (rc != 2) break;
3954:lib/ff/ff.c   **** 					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
3955:lib/ff/ff.c   **** 					if (c < 0x800) c = '?';
3956:lib/ff/ff.c   **** 				} else {			/* Reject four-byte sequence */
3957:lib/ff/ff.c   **** 					c = '?';
3958:lib/ff/ff.c   **** 				}
3959:lib/ff/ff.c   **** 			}
3960:lib/ff/ff.c   **** 		}
3961:lib/ff/ff.c   **** #endif
3962:lib/ff/ff.c   **** #if _USE_STRFUNC >= 2
3963:lib/ff/ff.c   **** 		if (c == '\r') continue;	/* Strip '\r' */
3964:lib/ff/ff.c   **** #endif
3965:lib/ff/ff.c   **** 		*p++ = c;
3966:lib/ff/ff.c   **** 		n++;
3967:lib/ff/ff.c   **** 		if (c == '\n') break;		/* Break on EOL */
3968:lib/ff/ff.c   **** 	}
3969:lib/ff/ff.c   **** 	*p = 0;
3970:lib/ff/ff.c   **** 	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
3971:lib/ff/ff.c   **** }
3972:lib/ff/ff.c   **** 
3973:lib/ff/ff.c   **** 
3974:lib/ff/ff.c   **** 
3975:lib/ff/ff.c   **** #if !_FS_READONLY
3976:lib/ff/ff.c   **** #include <stdarg.h>
3977:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3978:lib/ff/ff.c   **** /* Put a character to the file                                           */
3979:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3980:lib/ff/ff.c   **** int f_putc (
3981:lib/ff/ff.c   **** 	TCHAR c,	/* A character to be output */
3982:lib/ff/ff.c   **** 	FIL* fil	/* Pointer to the file object */
3983:lib/ff/ff.c   **** )
3984:lib/ff/ff.c   **** {
3985:lib/ff/ff.c   **** 	UINT bw, btw;
3986:lib/ff/ff.c   **** 	BYTE s[3];
3987:lib/ff/ff.c   **** 
3988:lib/ff/ff.c   **** 
3989:lib/ff/ff.c   **** #if _USE_STRFUNC >= 2
3990:lib/ff/ff.c   **** 	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
3991:lib/ff/ff.c   **** #endif
3992:lib/ff/ff.c   **** 
3993:lib/ff/ff.c   **** #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
3994:lib/ff/ff.c   **** 	if (c < 0x80) {			/* 7-bit */
3995:lib/ff/ff.c   **** 		s[0] = (BYTE)c;
3996:lib/ff/ff.c   **** 		btw = 1;
3997:lib/ff/ff.c   **** 	} else {
3998:lib/ff/ff.c   **** 		if (c < 0x800) {	/* 11-bit */
3999:lib/ff/ff.c   **** 			s[0] = (BYTE)(0xC0 | (c >> 6));
4000:lib/ff/ff.c   **** 			s[1] = (BYTE)(0x80 | (c & 0x3F));
4001:lib/ff/ff.c   **** 			btw = 2;
4002:lib/ff/ff.c   **** 		} else {			/* 16-bit */
4003:lib/ff/ff.c   **** 			s[0] = (BYTE)(0xE0 | (c >> 12));
4004:lib/ff/ff.c   **** 			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
4005:lib/ff/ff.c   **** 			s[2] = (BYTE)(0x80 | (c & 0x3F));
4006:lib/ff/ff.c   **** 			btw = 3;
4007:lib/ff/ff.c   **** 		}
4008:lib/ff/ff.c   **** 	}
4009:lib/ff/ff.c   **** #else				/* Write the character without conversion */
4010:lib/ff/ff.c   **** 	s[0] = (BYTE)c;
4011:lib/ff/ff.c   **** 	btw = 1;
4012:lib/ff/ff.c   **** #endif
4013:lib/ff/ff.c   **** 	f_write(fil, s, btw, &bw);		/* Write the char to the file */
4014:lib/ff/ff.c   **** 	return (bw == btw) ? 1 : EOF;	/* Return the result */
4015:lib/ff/ff.c   **** }
4016:lib/ff/ff.c   **** 
4017:lib/ff/ff.c   **** 
4018:lib/ff/ff.c   **** 
4019:lib/ff/ff.c   **** 
4020:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4021:lib/ff/ff.c   **** /* Put a string to the file                                              */
4022:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4023:lib/ff/ff.c   **** int f_puts (
4024:lib/ff/ff.c   **** 	const TCHAR* str,	/* Pointer to the string to be output */
4025:lib/ff/ff.c   **** 	FIL* fil			/* Pointer to the file object */
4026:lib/ff/ff.c   **** )
4027:lib/ff/ff.c   **** {
4028:lib/ff/ff.c   **** 	int n;
4029:lib/ff/ff.c   **** 
4030:lib/ff/ff.c   **** 
4031:lib/ff/ff.c   **** 	for (n = 0; *str; str++, n++) {
4032:lib/ff/ff.c   **** 		if (f_putc(*str, fil) == EOF) return EOF;
4033:lib/ff/ff.c   **** 	}
4034:lib/ff/ff.c   **** 	return n;
4035:lib/ff/ff.c   **** }
4036:lib/ff/ff.c   **** 
4037:lib/ff/ff.c   **** 
4038:lib/ff/ff.c   **** 
4039:lib/ff/ff.c   **** 
4040:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4041:lib/ff/ff.c   **** /* Put a formatted string to the file                                    */
4042:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4043:lib/ff/ff.c   **** int f_printf (
4044:lib/ff/ff.c   **** 	FIL* fil,			/* Pointer to the file object */
4045:lib/ff/ff.c   **** 	const TCHAR* str,	/* Pointer to the format string */
4046:lib/ff/ff.c   **** 	...					/* Optional arguments... */
4047:lib/ff/ff.c   **** )
4048:lib/ff/ff.c   **** {
4049:lib/ff/ff.c   **** 	va_list arp;
4050:lib/ff/ff.c   **** 	BYTE f, r;
4051:lib/ff/ff.c   **** 	UINT i, j, w;
4052:lib/ff/ff.c   **** 	ULONG v;
4053:lib/ff/ff.c   **** 	TCHAR c, d, s[16], *p;
4054:lib/ff/ff.c   **** 	int res, chc, cc;
4055:lib/ff/ff.c   **** 
4056:lib/ff/ff.c   **** 
4057:lib/ff/ff.c   **** 	va_start(arp, str);
4058:lib/ff/ff.c   **** 
4059:lib/ff/ff.c   **** 	for (cc = res = 0; cc != EOF; res += cc) {
4060:lib/ff/ff.c   **** 		c = *str++;
4061:lib/ff/ff.c   **** 		if (c == 0) break;			/* End of string */
4062:lib/ff/ff.c   **** 		if (c != '%') {				/* Non escape character */
4063:lib/ff/ff.c   **** 			cc = f_putc(c, fil);
4064:lib/ff/ff.c   **** 			if (cc != EOF) cc = 1;
4065:lib/ff/ff.c   **** 			continue;
4066:lib/ff/ff.c   **** 		}
4067:lib/ff/ff.c   **** 		w = f = 0;
4068:lib/ff/ff.c   **** 		c = *str++;
4069:lib/ff/ff.c   **** 		if (c == '0') {				/* Flag: '0' padding */
4070:lib/ff/ff.c   **** 			f = 1; c = *str++;
4071:lib/ff/ff.c   **** 		} else {
4072:lib/ff/ff.c   **** 			if (c == '-') {			/* Flag: left justified */
4073:lib/ff/ff.c   **** 				f = 2; c = *str++;
4074:lib/ff/ff.c   **** 			}
4075:lib/ff/ff.c   **** 		}
4076:lib/ff/ff.c   **** 		while (IsDigit(c)) {		/* Precision */
4077:lib/ff/ff.c   **** 			w = w * 10 + c - '0';
4078:lib/ff/ff.c   **** 			c = *str++;
4079:lib/ff/ff.c   **** 		}
4080:lib/ff/ff.c   **** 		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
4081:lib/ff/ff.c   **** 			f |= 4; c = *str++;
4082:lib/ff/ff.c   **** 		}
4083:lib/ff/ff.c   **** 		if (!c) break;
4084:lib/ff/ff.c   **** 		d = c;
4085:lib/ff/ff.c   **** 		if (IsLower(d)) d -= 0x20;
4086:lib/ff/ff.c   **** 		switch (d) {				/* Type is... */
4087:lib/ff/ff.c   **** 		case 'S' :					/* String */
4088:lib/ff/ff.c   **** 			p = va_arg(arp, TCHAR*);
4089:lib/ff/ff.c   **** 			for (j = 0; p[j]; j++) ;
4090:lib/ff/ff.c   **** 			chc = 0;
4091:lib/ff/ff.c   **** 			if (!(f & 2)) {
4092:lib/ff/ff.c   **** 				while (j++ < w) chc += (cc = f_putc(' ', fil));
4093:lib/ff/ff.c   **** 			}
4094:lib/ff/ff.c   **** 			chc += (cc = f_puts(p, fil));
4095:lib/ff/ff.c   **** 			while (j++ < w) chc += (cc = f_putc(' ', fil));
4096:lib/ff/ff.c   **** 			if (cc != EOF) cc = chc;
4097:lib/ff/ff.c   **** 			continue;
4098:lib/ff/ff.c   **** 		case 'C' :					/* Character */
4099:lib/ff/ff.c   **** 			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
4100:lib/ff/ff.c   **** 		case 'B' :					/* Binary */
4101:lib/ff/ff.c   **** 			r = 2; break;
4102:lib/ff/ff.c   **** 		case 'O' :					/* Octal */
4103:lib/ff/ff.c   **** 			r = 8; break;
4104:lib/ff/ff.c   **** 		case 'D' :					/* Signed decimal */
4105:lib/ff/ff.c   **** 		case 'U' :					/* Unsigned decimal */
4106:lib/ff/ff.c   **** 			r = 10; break;
4107:lib/ff/ff.c   **** 		case 'X' :					/* Hexdecimal */
4108:lib/ff/ff.c   **** 			r = 16; break;
4109:lib/ff/ff.c   **** 		default:					/* Unknown type (pass-through) */
4110:lib/ff/ff.c   **** 			cc = f_putc(c, fil); continue;
4111:lib/ff/ff.c   **** 		}
4112:lib/ff/ff.c   **** 
4113:lib/ff/ff.c   **** 		/* Get an argument and put it in numeral */
4114:lib/ff/ff.c   **** 		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_
4115:lib/ff/ff.c   **** 		if (d == 'D' && (v & 0x80000000)) {
4116:lib/ff/ff.c   **** 			v = 0 - v;
4117:lib/ff/ff.c   **** 			f |= 8;
4118:lib/ff/ff.c   **** 		}
4119:lib/ff/ff.c   **** 		i = 0;
4120:lib/ff/ff.c   **** 		do {
4121:lib/ff/ff.c   **** 			d = (TCHAR)(v % r); v /= r;
4122:lib/ff/ff.c   **** 			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
4123:lib/ff/ff.c   **** 			s[i++] = d + '0';
4124:lib/ff/ff.c   **** 		} while (v && i < sizeof s / sizeof s[0]);
4125:lib/ff/ff.c   **** 		if (f & 8) s[i++] = '-';
4126:lib/ff/ff.c   **** 		j = i; d = (f & 1) ? '0' : ' ';
4127:lib/ff/ff.c   **** 		res = 0;
4128:lib/ff/ff.c   **** 		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
4129:lib/ff/ff.c   **** 		do res += (cc = f_putc(s[--i], fil)); while(i);
4130:lib/ff/ff.c   **** 		while (j++ < w) res += (cc = f_putc(' ', fil));
4131:lib/ff/ff.c   **** 		if (cc != EOF) cc = res;
4132:lib/ff/ff.c   **** 	}
4133:lib/ff/ff.c   **** 
4134:lib/ff/ff.c   **** 	va_end(arp);
4135:lib/ff/ff.c   **** 	return (cc == EOF) ? cc : res;
4136:lib/ff/ff.c   **** }
 2388              		.loc 1 4136 0
 2389 0236 2168     		ldr	r1, [r4, #0]
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 2390              		.loc 1 1191 0
 2391 0238 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 2392 023a 0328     		cmp	r0, #3
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 2393              		.loc 1 1192 0
 2394 023c 04BF     		itt	eq
 2395 023e 9B8A     		ldrheq	r3, [r3, #20]
 2396              	.LVL358:
 2397 0240 46EA0346 		orreq	r6, r6, r3, lsl #16
 2398              	.LVL359:
 2399              	.LBE62:
 2400              	.LBE61:
2002:lib/ff/ff.c   **** 			dj->sclust = ld_clust(dj->fs, dir);
 2401              		.loc 1 2002 0
 2402 0244 A660     		str	r6, [r4, #8]
 2403 0246 39E7     		b	.L316
 2404              	.LVL360:
 2405              	.L277:
2000:lib/ff/ff.c   **** 				res = FR_NO_PATH; break;
 2406              		.loc 1 2000 0
 2407 0248 0520     		movs	r0, #5
 2408 024a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2409              	.LVL361:
 2410              	.L237:
 2411              	.LBB63:
 2412              	.LBB52:
1816:lib/ff/ff.c   **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 2413              		.loc 1 1816 0
 2414 024e 0620     		movs	r0, #6
 2415              	.LVL362:
 2416              	.L290:
 2417              	.LBE52:
 2418              	.LBE63:
2007:lib/ff/ff.c   **** }
 2419              		.loc 1 2007 0
 2420 0250 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2421              	.L328:
 2422              		.align	2
 2423              	.L327:
 2424 0254 FFFFFFFF 		.word	.LC0-1
 2425              		.cfi_endproc
 2426              	.LFE22:
 2428              		.section	.text.dir_register,"ax",%progbits
 2429              		.align	1
 2430              		.thumb
 2431              		.thumb_func
 2433              	dir_register:
 2434              	.LFB18:
1510:lib/ff/ff.c   **** {
 2435              		.loc 1 1510 0
 2436              		.cfi_startproc
 2437              		@ args = 0, pretend = 0, frame = 0
 2438              		@ frame_needed = 0, uses_anonymous_args = 0
 2439              	.LVL363:
 2440 0000 70B5     		push	{r4, r5, r6, lr}
 2441              	.LCFI14:
 2442              		.cfi_def_cfa_offset 16
 2443              		.cfi_offset 4, -16
 2444              		.cfi_offset 5, -12
 2445              		.cfi_offset 6, -8
 2446              		.cfi_offset 14, -4
 2447 0002 0446     		mov	r4, r0
1577:lib/ff/ff.c   **** 	res = dir_sdi(dj, 0);
 2448              		.loc 1 1577 0
 2449 0004 0021     		movs	r1, #0
 2450 0006 FFF7FEFF 		bl	dir_sdi
 2451              	.LVL364:
 2452              	.L348:
1578:lib/ff/ff.c   **** 	if (res == FR_OK) {
 2453              		.loc 1 1578 0
 2454 000a 0546     		mov	r5, r0
 2455 000c 18BB     		cbnz	r0, .L339
1580:lib/ff/ff.c   **** 			res = move_window(dj->fs, dj->sect);
 2456              		.loc 1 1580 0
 2457 000e 2068     		ldr	r0, [r4, #0]
 2458              	.LVL365:
 2459 0010 2169     		ldr	r1, [r4, #16]
 2460 0012 FFF7FEFF 		bl	move_window
 2461              	.LVL366:
1581:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 2462              		.loc 1 1581 0
 2463 0016 0546     		mov	r5, r0
 2464 0018 E8B9     		cbnz	r0, .L339
1582:lib/ff/ff.c   **** 			c = *dj->dir;
 2465              		.loc 1 1582 0
 2466 001a 6369     		ldr	r3, [r4, #20]
 2467 001c 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 2468              	.LVL367:
1583:lib/ff/ff.c   **** 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
 2469              		.loc 1 1583 0
 2470 001e E528     		cmp	r0, #229
 2471 0020 05D0     		beq	.L331
1583:lib/ff/ff.c   **** 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
 2472              		.loc 1 1583 0 is_stmt 0 discriminator 1
 2473 0022 20B1     		cbz	r0, .L331
1584:lib/ff/ff.c   **** 			res = dir_next(dj, 1);			/* Next entry with table stretch */
 2474              		.loc 1 1584 0 is_stmt 1
 2475 0024 2046     		mov	r0, r4
 2476 0026 0121     		movs	r1, #1
 2477 0028 FFF7FEFF 		bl	dir_next
 2478              	.LVL368:
 2479 002c EDE7     		b	.L348
 2480              	.LVL369:
 2481              	.L331:
 2482              	.LBB66:
 2483              	.LBB67:
1590:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
 2484              		.loc 1 1590 0
 2485 002e 2068     		ldr	r0, [r4, #0]
 2486 0030 2169     		ldr	r1, [r4, #16]
 2487 0032 FFF7FEFF 		bl	move_window
 2488              	.LVL370:
1591:lib/ff/ff.c   **** 		if (res == FR_OK) {
 2489              		.loc 1 1591 0
 2490 0036 0546     		mov	r5, r0
 2491 0038 68B9     		cbnz	r0, .L339
 2492              	.L333:
1592:lib/ff/ff.c   **** 			dir = dj->dir;
 2493              		.loc 1 1592 0
 2494 003a 6669     		ldr	r6, [r4, #20]
 2495              	.LVL371:
1593:lib/ff/ff.c   **** 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
 2496              		.loc 1 1593 0
 2497 003c 3046     		mov	r0, r6
 2498              	.LVL372:
 2499 003e 2946     		mov	r1, r5
 2500 0040 2022     		movs	r2, #32
 2501 0042 FFF7FEFF 		bl	mem_set
 2502              	.LVL373:
1594:lib/ff/ff.c   **** 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
 2503              		.loc 1 1594 0
 2504 0046 3046     		mov	r0, r6
 2505 0048 A169     		ldr	r1, [r4, #24]
 2506 004a 0B22     		movs	r2, #11
 2507 004c FFF7FEFF 		bl	mem_cpy
 2508              	.LVL374:
1598:lib/ff/ff.c   **** 			dj->fs->wflag = 1;
 2509              		.loc 1 1598 0
 2510 0050 2168     		ldr	r1, [r4, #0]
 2511 0052 0122     		movs	r2, #1
 2512 0054 0A71     		strb	r2, [r1, #4]
 2513              	.LVL375:
 2514              	.L339:
 2515              	.LBE67:
 2516              	.LBE66:
1603:lib/ff/ff.c   **** }
 2517              		.loc 1 1603 0
 2518 0056 2846     		mov	r0, r5
 2519 0058 70BD     		pop	{r4, r5, r6, pc}
 2520              		.cfi_endproc
 2521              	.LFE18:
 2523              		.section	.text.dir_read,"ax",%progbits
 2524              		.align	1
 2525              		.thumb
 2526              		.thumb_func
 2528              	dir_read:
 2529              	.LFB17:
1453:lib/ff/ff.c   **** {
 2530              		.loc 1 1453 0
 2531              		.cfi_startproc
 2532              		@ args = 0, pretend = 0, frame = 0
 2533              		@ frame_needed = 0, uses_anonymous_args = 0
 2534              	.LVL376:
 2535 0000 10B5     		push	{r4, lr}
 2536              	.LCFI15:
 2537              		.cfi_def_cfa_offset 8
 2538              		.cfi_offset 4, -8
 2539              		.cfi_offset 14, -4
 2540 0002 0446     		mov	r4, r0
 2541              	.LVL377:
1460:lib/ff/ff.c   **** 	res = FR_NO_FILE;
 2542              		.loc 1 1460 0
 2543 0004 0423     		movs	r3, #4
 2544              	.LVL378:
 2545              	.L350:
1461:lib/ff/ff.c   **** 	while (dj->sect) {
 2546              		.loc 1 1461 0 discriminator 1
 2547 0006 2169     		ldr	r1, [r4, #16]
 2548 0008 A9B1     		cbz	r1, .L368
 2549              	.L354:
1462:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
 2550              		.loc 1 1462 0
 2551 000a 2068     		ldr	r0, [r4, #0]
 2552 000c FFF7FEFF 		bl	move_window
 2553              	.LVL379:
1463:lib/ff/ff.c   **** 		if (res != FR_OK) break;
 2554              		.loc 1 1463 0
 2555 0010 C0B9     		cbnz	r0, .L351
1464:lib/ff/ff.c   **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 2556              		.loc 1 1464 0
 2557 0012 6369     		ldr	r3, [r4, #20]
 2558              	.LVL380:
1465:lib/ff/ff.c   **** 		c = dir[DIR_Name];
 2559              		.loc 1 1465 0
 2560 0014 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2561              	.LVL381:
1466:lib/ff/ff.c   **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 2562              		.loc 1 1466 0
 2563 0016 A2B1     		cbz	r2, .L356
1487:lib/ff/ff.c   **** 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
 2564              		.loc 1 1487 0
 2565 0018 E52A     		cmp	r2, #229
 2566 001a 04D0     		beq	.L352
1487:lib/ff/ff.c   **** 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
 2567              		.loc 1 1487 0 is_stmt 0 discriminator 1
 2568 001c D97A     		ldrb	r1, [r3, #11]	@ zero_extendqisi2
 2569 001e 01F00803 		and	r3, r1, #8
 2570              	.LVL382:
 2571 0022 DAB2     		uxtb	r2, r3
 2572 0024 82B1     		cbz	r2, .L361
 2573              	.L352:
1490:lib/ff/ff.c   **** 		res = dir_next(dj, 0);				/* Next entry */
 2574              		.loc 1 1490 0 is_stmt 1
 2575 0026 2046     		mov	r0, r4
 2576              	.LVL383:
 2577 0028 0021     		movs	r1, #0
 2578 002a FFF7FEFF 		bl	dir_next
 2579              	.LVL384:
 2580 002e 0346     		mov	r3, r0
 2581              	.LVL385:
1491:lib/ff/ff.c   **** 		if (res != FR_OK) break;
 2582              		.loc 1 1491 0
 2583 0030 0028     		cmp	r0, #0
 2584 0032 E8D0     		beq	.L350
 2585 0034 06E0     		b	.L351
 2586              	.LVL386:
 2587              	.L368:
1461:lib/ff/ff.c   **** 	while (dj->sect) {
 2588              		.loc 1 1461 0
 2589 0036 1846     		mov	r0, r3
 2590              	.LVL387:
1494:lib/ff/ff.c   **** 	if (res != FR_OK) dj->sect = 0;
 2591              		.loc 1 1494 0
 2592 0038 33B1     		cbz	r3, .L361
 2593              	.LVL388:
 2594              	.L355:
1494:lib/ff/ff.c   **** 	if (res != FR_OK) dj->sect = 0;
 2595              		.loc 1 1494 0 is_stmt 0 discriminator 1
 2596 003a 0020     		movs	r0, #0
 2597 003c 2061     		str	r0, [r4, #16]
 2598 003e 1846     		mov	r0, r3
 2599 0040 10BD     		pop	{r4, pc}
 2600              	.LVL389:
 2601              	.L356:
1466:lib/ff/ff.c   **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 2602              		.loc 1 1466 0 is_stmt 1
 2603 0042 0420     		movs	r0, #4
 2604              	.LVL390:
 2605              	.L351:
1461:lib/ff/ff.c   **** 	while (dj->sect) {
 2606              		.loc 1 1461 0
 2607 0044 0346     		mov	r3, r0
 2608 0046 F8E7     		b	.L355
 2609              	.LVL391:
 2610              	.L361:
1497:lib/ff/ff.c   **** }
 2611              		.loc 1 1497 0
 2612 0048 10BD     		pop	{r4, pc}
 2613              		.cfi_endproc
 2614              	.LFE17:
 2616              		.section	.text.remove_chain,"ax",%progbits
 2617              		.align	1
 2618              		.thumb
 2619              		.thumb_func
 2621              	remove_chain:
 2622              	.LFB9:
 931:lib/ff/ff.c   **** {
 2623              		.loc 1 931 0
 2624              		.cfi_startproc
 2625              		@ args = 0, pretend = 0, frame = 8
 2626              		@ frame_needed = 0, uses_anonymous_args = 0
 2627              	.LVL392:
 2628 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 2629              	.LCFI16:
 2630              		.cfi_def_cfa_offset 32
 2631              		.cfi_offset 0, -32
 2632              		.cfi_offset 1, -28
 2633              		.cfi_offset 2, -24
 2634              		.cfi_offset 4, -20
 2635              		.cfi_offset 5, -16
 2636              		.cfi_offset 6, -12
 2637              		.cfi_offset 7, -8
 2638              		.cfi_offset 14, -4
 2639 0002 0446     		mov	r4, r0
 2640 0004 0F46     		mov	r7, r1
 2641              	.LVL393:
 938:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 2642              		.loc 1 938 0
 2643 0006 0129     		cmp	r1, #1
 2644 0008 39D9     		bls	.L379
 938:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 2645              		.loc 1 938 0 is_stmt 0 discriminator 1
 2646 000a C369     		ldr	r3, [r0, #28]
 2647 000c 9942     		cmp	r1, r3
 2648 000e 36D2     		bcs	.L379
 938:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 2649              		.loc 1 938 0
 2650 0010 0D46     		mov	r5, r1
 2651              	.LVL394:
 2652              	.L371:
 2653              	.LBB70:
 2654              	.LBB71:
 943:lib/ff/ff.c   **** 		while (clst < fs->n_fatent) {			/* Not a last link? */
 2655              		.loc 1 943 0 is_stmt 1
 2656 0012 E069     		ldr	r0, [r4, #28]
 2657 0014 8542     		cmp	r5, r0
 2658 0016 05D2     		bcs	.L377
 2659              	.L376:
 944:lib/ff/ff.c   **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 2660              		.loc 1 944 0
 2661 0018 2046     		mov	r0, r4
 2662 001a 2946     		mov	r1, r5
 2663 001c FFF7FEFF 		bl	get_fat
 2664              	.LVL395:
 945:lib/ff/ff.c   **** 			if (nxt == 0) break;				/* Empty cluster? */
 2665              		.loc 1 945 0
 2666 0020 0646     		mov	r6, r0
 2667 0022 08B9     		cbnz	r0, .L372
 2668              	.LVL396:
 2669              	.L377:
 960:lib/ff/ff.c   **** 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
 2670              		.loc 1 960 0
 2671 0024 0020     		movs	r0, #0
 2672 0026 2BE0     		b	.L370
 2673              	.LVL397:
 2674              	.L372:
 946:lib/ff/ff.c   **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 2675              		.loc 1 946 0
 2676 0028 0128     		cmp	r0, #1
 2677 002a 28D0     		beq	.L379
 947:lib/ff/ff.c   **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 2678              		.loc 1 947 0
 2679 002c 411C     		adds	r1, r0, #1
 2680 002e 24D0     		beq	.L381
 948:lib/ff/ff.c   **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 2681              		.loc 1 948 0
 2682 0030 2046     		mov	r0, r4
 2683              	.LVL398:
 2684 0032 2946     		mov	r1, r5
 2685 0034 0022     		movs	r2, #0
 2686 0036 FFF7FEFF 		bl	put_fat
 2687              	.LVL399:
 949:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 2688              		.loc 1 949 0
 2689 003a 08BB     		cbnz	r0, .L370
 950:lib/ff/ff.c   **** 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 2690              		.loc 1 950 0
 2691 003c 2169     		ldr	r1, [r4, #16]
 2692 003e 4A1C     		adds	r2, r1, #1
 2693 0040 03D0     		beq	.L374
 951:lib/ff/ff.c   **** 				fs->free_clust++;
 2694              		.loc 1 951 0
 2695 0042 4A1C     		adds	r2, r1, #1
 2696 0044 2261     		str	r2, [r4, #16]
 952:lib/ff/ff.c   **** 				fs->fsi_flag = 1;
 2697              		.loc 1 952 0
 2698 0046 0123     		movs	r3, #1
 2699 0048 6371     		strb	r3, [r4, #5]
 2700              	.L374:
 955:lib/ff/ff.c   **** 			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
 2701              		.loc 1 955 0
 2702 004a 681C     		adds	r0, r5, #1
 2703              	.LVL400:
 2704 004c B042     		cmp	r0, r6
 2705 004e 12D0     		beq	.L375
 958:lib/ff/ff.c   **** 				rt[0] = clust2sect(fs, scl);					/* Start sector */
 2706              		.loc 1 958 0
 2707 0050 2046     		mov	r0, r4
 2708 0052 3946     		mov	r1, r7
 2709 0054 FFF7FEFF 		bl	clust2sect
 2710              	.LVL401:
 2711 0058 0090     		str	r0, [sp, #0]
 959:lib/ff/ff.c   **** 				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
 2712              		.loc 1 959 0
 2713 005a 2046     		mov	r0, r4
 2714 005c 2946     		mov	r1, r5
 2715 005e FFF7FEFF 		bl	clust2sect
 2716              	.LVL402:
 2717 0062 A578     		ldrb	r5, [r4, #2]	@ zero_extendqisi2
 2718              	.LVL403:
 2719 0064 6F1E     		subs	r7, r5, #1
 2720              	.LVL404:
 2721 0066 3918     		adds	r1, r7, r0
 2722 0068 0191     		str	r1, [sp, #4]
 960:lib/ff/ff.c   **** 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
 2723              		.loc 1 960 0
 2724 006a 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 2725 006c 0421     		movs	r1, #4
 2726 006e 6A46     		mov	r2, sp
 2727 0070 FFF7FEFF 		bl	disk_ioctl
 2728              	.LVL405:
 2729 0074 3746     		mov	r7, r6
 2730              	.LVL406:
 2731              	.L375:
 2732 0076 3546     		mov	r5, r6
 2733 0078 CBE7     		b	.L371
 2734              	.LVL407:
 2735              	.L381:
 947:lib/ff/ff.c   **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 2736              		.loc 1 947 0
 2737 007a 0120     		movs	r0, #1
 2738              	.LVL408:
 2739 007c 00E0     		b	.L370
 2740              	.LVL409:
 2741              	.L379:
 2742              	.LBE71:
 2743              	.LBE70:
 939:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 2744              		.loc 1 939 0
 2745 007e 0220     		movs	r0, #2
 2746              	.L370:
 2747              	.LVL410:
 969:lib/ff/ff.c   **** }
 2748              		.loc 1 969 0
 2749 0080 FEBD     		pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 2750              		.cfi_endproc
 2751              	.LFE9:
 2753              		.section	.text.f_mount,"ax",%progbits
 2754              		.align	1
 2755              		.global	f_mount
 2756              		.thumb
 2757              		.thumb_func
 2759              	f_mount:
 2760              	.LFB26:
2248:lib/ff/ff.c   **** {
 2761              		.loc 1 2248 0
 2762              		.cfi_startproc
 2763              		@ args = 0, pretend = 0, frame = 0
 2764              		@ frame_needed = 0, uses_anonymous_args = 0
 2765              		@ link register save eliminated.
 2766              	.LVL411:
2252:lib/ff/ff.c   **** 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
 2767              		.loc 1 2252 0
 2768 0000 48B9     		cbnz	r0, .L389
2254:lib/ff/ff.c   **** 	rfs = FatFs[vol];			/* Get current fs object */
 2769              		.loc 1 2254 0
 2770 0002 064A     		ldr	r2, .L396
 2771 0004 1368     		ldr	r3, [r2, #0]
 2772              	.LVL412:
2256:lib/ff/ff.c   **** 	if (rfs) {
 2773              		.loc 1 2256 0
 2774 0006 03B1     		cbz	r3, .L387
2263:lib/ff/ff.c   **** 		rfs->fs_type = 0;		/* Clear old fs object */
 2775              		.loc 1 2263 0
 2776 0008 1870     		strb	r0, [r3, #0]
 2777              	.L387:
2266:lib/ff/ff.c   **** 	if (fs) {
 2778              		.loc 1 2266 0
 2779 000a 09B1     		cbz	r1, .L388
2267:lib/ff/ff.c   **** 		fs->fs_type = 0;		/* Clear new fs object */
 2780              		.loc 1 2267 0
 2781 000c 0020     		movs	r0, #0
 2782              	.LVL413:
 2783 000e 0870     		strb	r0, [r1, #0]
 2784              	.L388:
2272:lib/ff/ff.c   **** 	FatFs[vol] = fs;			/* Register new fs object */
 2785              		.loc 1 2272 0
 2786 0010 1160     		str	r1, [r2, #0]
2274:lib/ff/ff.c   **** 	return FR_OK;
 2787              		.loc 1 2274 0
 2788 0012 0020     		movs	r0, #0
 2789 0014 7047     		bx	lr
 2790              	.LVL414:
 2791              	.L389:
2253:lib/ff/ff.c   **** 		return FR_INVALID_DRIVE;
 2792              		.loc 1 2253 0
 2793 0016 0B20     		movs	r0, #11
 2794              	.LVL415:
2275:lib/ff/ff.c   **** }
 2795              		.loc 1 2275 0
 2796 0018 7047     		bx	lr
 2797              	.L397:
 2798 001a 00BF     		.align	2
 2799              	.L396:
 2800 001c 00000000 		.word	.LANCHOR1
 2801              		.cfi_endproc
 2802              	.LFE26:
 2804              		.section	.text.f_open,"ax",%progbits
 2805              		.align	1
 2806              		.global	f_open
 2807              		.thumb
 2808              		.thumb_func
 2810              	f_open:
 2811              	.LFB27:
2289:lib/ff/ff.c   **** {
 2812              		.loc 1 2289 0
 2813              		.cfi_startproc
 2814              		@ args = 0, pretend = 0, frame = 48
 2815              		@ frame_needed = 0, uses_anonymous_args = 0
 2816              	.LVL416:
 2817 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 2818              	.LCFI17:
 2819              		.cfi_def_cfa_offset 28
 2820              		.cfi_offset 4, -28
 2821              		.cfi_offset 5, -24
 2822              		.cfi_offset 6, -20
 2823              		.cfi_offset 7, -16
 2824              		.cfi_offset 8, -12
 2825              		.cfi_offset 9, -8
 2826              		.cfi_offset 14, -4
 2827 0004 8DB0     		sub	sp, sp, #52
 2828              	.LCFI18:
 2829              		.cfi_def_cfa_offset 80
 2830 0006 0191     		str	r1, [sp, #4]
 2831 0008 1746     		mov	r7, r2
2296:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
 2832              		.loc 1 2296 0
 2833 000a 0546     		mov	r5, r0
 2834 000c 0028     		cmp	r0, #0
 2835 000e 00F08280 		beq	.L413
2297:lib/ff/ff.c   **** 	fp->fs = 0;			/* Clear file object */
 2836              		.loc 1 2297 0
 2837 0012 0023     		movs	r3, #0
 2838 0014 0360     		str	r3, [r0, #0]
 2839              	.LVL417:
2301:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
 2840              		.loc 1 2301 0
 2841 0016 01A8     		add	r0, sp, #4
 2842              	.LVL418:
 2843 0018 05A9     		add	r1, sp, #20
 2844 001a 02F01E02 		and	r2, r2, #30
 2845              	.LVL419:
 2846 001e FFF7FEFF 		bl	chk_mounted
 2847              	.LVL420:
2306:lib/ff/ff.c   **** 	if (res == FR_OK) {
 2848              		.loc 1 2306 0
 2849 0022 8046     		mov	r8, r0
 2850 0024 0028     		cmp	r0, #0
 2851 0026 7FD1     		bne	.L425
2307:lib/ff/ff.c   **** 		INIT_BUF(dj);
 2852              		.loc 1 2307 0
 2853 0028 02A8     		add	r0, sp, #8
 2854              	.LVL421:
 2855 002a 0B90     		str	r0, [sp, #44]
2308:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
 2856              		.loc 1 2308 0
 2857 002c 05A8     		add	r0, sp, #20
 2858 002e 0199     		ldr	r1, [sp, #4]
 2859 0030 FFF7FEFF 		bl	follow_path
 2860              	.LVL422:
2309:lib/ff/ff.c   **** 		dir = dj.dir;
 2861              		.loc 1 2309 0
 2862 0034 0A9C     		ldr	r4, [sp, #40]
 2863              	.LVL423:
2311:lib/ff/ff.c   **** 		if (res == FR_OK) {
 2864              		.loc 1 2311 0
 2865 0036 18B9     		cbnz	r0, .L400
2313:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
 2866              		.loc 1 2313 0
 2867 0038 002C     		cmp	r4, #0
 2868 003a 0CBF     		ite	eq
 2869 003c 0620     		moveq	r0, #6
 2870 003e 0020     		movne	r0, #0
 2871              	.LVL424:
 2872              	.L400:
2300:lib/ff/ff.c   **** 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 2873              		.loc 1 2300 0
 2874 0040 07F01F06 		and	r6, r7, #31
 2875              	.LVL425:
2320:lib/ff/ff.c   **** 		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 2876              		.loc 1 2320 0
 2877 0044 17F01C0F 		tst	r7, #28
 2878 0048 3BD0     		beq	.L401
 2879              	.LBB79:
2323:lib/ff/ff.c   **** 			if (res != FR_OK) {					/* No file, create new */
 2880              		.loc 1 2323 0
 2881 004a 48B1     		cbz	r0, .L402
2324:lib/ff/ff.c   **** 				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 2882              		.loc 1 2324 0
 2883 004c 0428     		cmp	r0, #4
 2884 004e 02D1     		bne	.L403
2328:lib/ff/ff.c   **** 					res = dir_register(&dj);
 2885              		.loc 1 2328 0
 2886 0050 05A8     		add	r0, sp, #20
 2887              	.LVL426:
 2888 0052 FFF7FEFF 		bl	dir_register
 2889              	.LVL427:
 2890              	.L403:
2330:lib/ff/ff.c   **** 				mode |= FA_CREATE_ALWAYS;		/* File is created */
 2891              		.loc 1 2330 0
 2892 0056 46F00806 		orr	r6, r6, #8
 2893              	.LVL428:
2331:lib/ff/ff.c   **** 				dir = dj.dir;					/* New entry */
 2894              		.loc 1 2331 0
 2895 005a 0A9C     		ldr	r4, [sp, #40]
 2896              	.LVL429:
2341:lib/ff/ff.c   **** 			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 2897              		.loc 1 2341 0
 2898 005c 48B1     		cbz	r0, .L404
 2899 005e 62E0     		b	.L410
 2900              	.LVL430:
 2901              	.L402:
2334:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 2902              		.loc 1 2334 0
 2903 0060 E07A     		ldrb	r0, [r4, #11]	@ zero_extendqisi2
 2904              	.LVL431:
 2905 0062 10F0110F 		tst	r0, #17
 2906 0066 5DD1     		bne	.L418
2337:lib/ff/ff.c   **** 					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 2907              		.loc 1 2337 0
 2908 0068 07F00401 		and	r1, r7, #4
 2909 006c CFB2     		uxtb	r7, r1
 2910              	.LVL432:
 2911 006e 002F     		cmp	r7, #0
 2912 0070 54D1     		bne	.L416
 2913              	.L404:
2341:lib/ff/ff.c   **** 			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 2914              		.loc 1 2341 0 discriminator 1
 2915 0072 06F00802 		and	r2, r6, #8
 2916 0076 D3B2     		uxtb	r3, r2
 2917 0078 002B     		cmp	r3, #0
 2918 007a 2FD0     		beq	.L409
2342:lib/ff/ff.c   **** 				dw = get_fattime();					/* Created time */
 2919              		.loc 1 2342 0
 2920 007c FFF7FEFF 		bl	get_fattime
 2921              	.LVL433:
2343:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_CrtTime, dw);
 2922              		.loc 1 2343 0
 2923 0080 C4F80E00 		str	r0, [r4, #14]
2344:lib/ff/ff.c   **** 				dir[DIR_Attr] = 0;					/* Reset attribute */
 2924              		.loc 1 2344 0
 2925 0084 0021     		movs	r1, #0
 2926 0086 E172     		strb	r1, [r4, #11]
2345:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
 2927              		.loc 1 2345 0
 2928 0088 E161     		str	r1, [r4, #28]
2346:lib/ff/ff.c   **** 				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
 2929              		.loc 1 2346 0
 2930 008a 0598     		ldr	r0, [sp, #20]
 2931              	.LVL434:
 2932              	.LBB80:
 2933              	.LBB81:
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 2934              		.loc 1 1190 0
 2935 008c 678B     		ldrh	r7, [r4, #26]
 2936              	.LVL435:
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 2937              		.loc 1 1191 0
 2938 008e 0278     		ldrb	r2, [r0, #0]	@ zero_extendqisi2
 2939 0090 032A     		cmp	r2, #3
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 2940              		.loc 1 1192 0
 2941 0092 04BF     		itt	eq
 2942 0094 A28A     		ldrheq	r2, [r4, #20]
 2943 0096 47EA0247 		orreq	r7, r7, r2, lsl #16
 2944              	.LVL436:
 2945              	.LBE81:
 2946              	.LBE80:
 2947              	.LBB82:
 2948              	.LBB83:
1205:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 2949              		.loc 1 1205 0
 2950 009a 6183     		strh	r1, [r4, #26]	@ movhi
1206:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 2951              		.loc 1 1206 0
 2952 009c A182     		strh	r1, [r4, #20]	@ movhi
 2953              	.LBE83:
 2954              	.LBE82:
2348:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
 2955              		.loc 1 2348 0
 2956 009e 0123     		movs	r3, #1
 2957 00a0 0371     		strb	r3, [r0, #4]
2349:lib/ff/ff.c   **** 				if (cl) {							/* Remove the cluster chain if exist */
 2958              		.loc 1 2349 0
 2959 00a2 DFB1     		cbz	r7, .L409
2350:lib/ff/ff.c   **** 					dw = dj.fs->winsect;
 2960              		.loc 1 2350 0
 2961 00a4 D0F83090 		ldr	r9, [r0, #48]
 2962              	.LVL437:
2351:lib/ff/ff.c   **** 					res = remove_chain(dj.fs, cl);
 2963              		.loc 1 2351 0
 2964 00a8 3946     		mov	r1, r7
 2965 00aa FFF7FEFF 		bl	remove_chain
 2966              	.LVL438:
2352:lib/ff/ff.c   **** 					if (res == FR_OK) {
 2967              		.loc 1 2352 0
 2968 00ae 0028     		cmp	r0, #0
 2969 00b0 39D1     		bne	.L410
2353:lib/ff/ff.c   **** 						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 2970              		.loc 1 2353 0
 2971 00b2 0598     		ldr	r0, [sp, #20]
 2972              	.LVL439:
 2973 00b4 013F     		subs	r7, r7, #1
 2974              	.LVL440:
 2975 00b6 C760     		str	r7, [r0, #12]
2354:lib/ff/ff.c   **** 						res = move_window(dj.fs, dw);
 2976              		.loc 1 2354 0
 2977 00b8 4946     		mov	r1, r9
 2978 00ba FFF7FEFF 		bl	move_window
 2979              	.LVL441:
 2980              	.LBE79:
2369:lib/ff/ff.c   **** 		if (res == FR_OK) {
 2981              		.loc 1 2369 0
 2982 00be 68B1     		cbz	r0, .L409
 2983 00c0 31E0     		b	.L410
 2984              	.LVL442:
 2985              	.L401:
2360:lib/ff/ff.c   **** 			if (res == FR_OK) {						/* Follow succeeded */
 2986              		.loc 1 2360 0
 2987 00c2 0028     		cmp	r0, #0
 2988 00c4 2FD1     		bne	.L410
2361:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
 2989              		.loc 1 2361 0
 2990 00c6 E17A     		ldrb	r1, [r4, #11]	@ zero_extendqisi2
 2991 00c8 01F01002 		and	r2, r1, #16
 2992 00cc D3B2     		uxtb	r3, r2
 2993 00ce 3BBB     		cbnz	r3, .L417
2364:lib/ff/ff.c   **** 					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 2994              		.loc 1 2364 0
 2995 00d0 07F00207 		and	r7, r7, #2
 2996              	.LVL443:
 2997 00d4 FFB2     		uxtb	r7, r7
 2998 00d6 0FB1     		cbz	r7, .L409
2364:lib/ff/ff.c   **** 					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 2999              		.loc 1 2364 0 is_stmt 0 discriminator 1
 3000 00d8 C807     		lsls	r0, r1, #31
 3001              	.LVL444:
 3002 00da 23D4     		bmi	.L418
 3003              	.L409:
2370:lib/ff/ff.c   **** 			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
 3004              		.loc 1 2370 0 is_stmt 1
 3005 00dc 06F00800 		and	r0, r6, #8
 3006 00e0 C1B2     		uxtb	r1, r0
 3007 00e2 09B1     		cbz	r1, .L411
2371:lib/ff/ff.c   **** 				mode |= FA__WRITTEN;
 3008              		.loc 1 2371 0
 3009 00e4 46F02006 		orr	r6, r6, #32
 3010              	.LVL445:
 3011              	.L411:
2372:lib/ff/ff.c   **** 			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
 3012              		.loc 1 2372 0
 3013 00e8 059B     		ldr	r3, [sp, #20]
 3014 00ea 1A6B     		ldr	r2, [r3, #48]
 3015 00ec EA61     		str	r2, [r5, #28]
2373:lib/ff/ff.c   **** 			fp->dir_ptr = dir;
 3016              		.loc 1 2373 0
 3017 00ee 2C62     		str	r4, [r5, #32]
2394:lib/ff/ff.c   **** 			fp->flag = mode;					/* File access mode */
 3018              		.loc 1 2394 0
 3019 00f0 AE71     		strb	r6, [r5, #6]
 3020              	.LVL446:
 3021              	.LBB84:
 3022              	.LBB85:
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 3023              		.loc 1 1190 0
 3024 00f2 608B     		ldrh	r0, [r4, #26]
 3025              	.LVL447:
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 3026              		.loc 1 1191 0
 3027 00f4 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 3028 00f6 0329     		cmp	r1, #3
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 3029              		.loc 1 1192 0
 3030 00f8 04BF     		itt	eq
 3031 00fa A18A     		ldrheq	r1, [r4, #20]
 3032 00fc 40EA0140 		orreq	r0, r0, r1, lsl #16
 3033              	.LVL448:
 3034              	.LBE85:
 3035              	.LBE84:
2395:lib/ff/ff.c   **** 			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 3036              		.loc 1 2395 0
 3037 0100 2861     		str	r0, [r5, #16]
2396:lib/ff/ff.c   **** 			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 3038              		.loc 1 2396 0
 3039 0102 E269     		ldr	r2, [r4, #28]
 3040 0104 EA60     		str	r2, [r5, #12]
2397:lib/ff/ff.c   **** 			fp->fptr = 0;						/* File pointer */
 3041              		.loc 1 2397 0
 3042 0106 0020     		movs	r0, #0
 3043              	.LVL449:
 3044 0108 A860     		str	r0, [r5, #8]
2398:lib/ff/ff.c   **** 			fp->dsect = 0;
 3045              		.loc 1 2398 0
 3046 010a A861     		str	r0, [r5, #24]
2400:lib/ff/ff.c   **** 			fp->cltbl = 0;						/* Normal seek mode */
 3047              		.loc 1 2400 0
 3048 010c 6862     		str	r0, [r5, #36]
2402:lib/ff/ff.c   **** 			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
 3049              		.loc 1 2402 0
 3050 010e 2B60     		str	r3, [r5, #0]
 3051 0110 DB88     		ldrh	r3, [r3, #6]
 3052 0112 AB80     		strh	r3, [r5, #4]	@ movhi
 3053 0114 08E0     		b	.L425
 3054              	.LVL450:
 3055              	.L413:
2296:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
 3056              		.loc 1 2296 0
 3057 0116 4FF00908 		mov	r8, #9
 3058 011a 05E0     		b	.L425
 3059              	.LVL451:
 3060              	.L416:
 3061              	.LBB86:
2338:lib/ff/ff.c   **** 						res = FR_EXIST;
 3062              		.loc 1 2338 0
 3063 011c 0820     		movs	r0, #8
 3064              	.LVL452:
 3065 011e 02E0     		b	.L410
 3066              	.LVL453:
 3067              	.L417:
 3068              	.LBE86:
2362:lib/ff/ff.c   **** 					res = FR_NO_FILE;
 3069              		.loc 1 2362 0
 3070 0120 0420     		movs	r0, #4
 3071              	.LVL454:
 3072 0122 00E0     		b	.L410
 3073              	.LVL455:
 3074              	.L418:
2365:lib/ff/ff.c   **** 						res = FR_DENIED;
 3075              		.loc 1 2365 0
 3076 0124 0720     		movs	r0, #7
 3077              	.LVL456:
 3078              	.L410:
2296:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
 3079              		.loc 1 2296 0
 3080 0126 8046     		mov	r8, r0
 3081              	.L425:
2407:lib/ff/ff.c   **** }
 3082              		.loc 1 2407 0
 3083 0128 4046     		mov	r0, r8
 3084 012a 0DB0     		add	sp, sp, #52
 3085 012c BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 3086              		.cfi_endproc
 3087              	.LFE27:
 3089              		.section	.text.f_read,"ax",%progbits
 3090              		.align	1
 3091              		.global	f_read
 3092              		.thumb
 3093              		.thumb_func
 3095              	f_read:
 3096              	.LFB28:
2422:lib/ff/ff.c   **** {
 3097              		.loc 1 2422 0
 3098              		.cfi_startproc
 3099              		@ args = 0, pretend = 0, frame = 8
 3100              		@ frame_needed = 0, uses_anonymous_args = 0
 3101              	.LVL457:
 3102 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3103              	.LCFI19:
 3104              		.cfi_def_cfa_offset 48
 3105              		.cfi_offset 0, -48
 3106              		.cfi_offset 1, -44
 3107              		.cfi_offset 2, -40
 3108              		.cfi_offset 4, -36
 3109              		.cfi_offset 5, -32
 3110              		.cfi_offset 6, -28
 3111              		.cfi_offset 7, -24
 3112              		.cfi_offset 8, -20
 3113              		.cfi_offset 9, -16
 3114              		.cfi_offset 10, -12
 3115              		.cfi_offset 11, -8
 3116              		.cfi_offset 14, -4
 3117 0004 0446     		mov	r4, r0
 3118 0006 8846     		mov	r8, r1
 3119 0008 1746     		mov	r7, r2
 3120 000a 9946     		mov	r9, r3
 3121              	.LVL458:
2429:lib/ff/ff.c   **** 	*br = 0;	/* Clear read byte counter */
 3122              		.loc 1 2429 0
 3123 000c 0023     		movs	r3, #0
 3124              	.LVL459:
 3125 000e C9F80030 		str	r3, [r9, #0]
2431:lib/ff/ff.c   **** 	res = validate(fp);							/* Check validity */
 3126              		.loc 1 2431 0
 3127 0012 FFF7FEFF 		bl	validate
 3128              	.LVL460:
2432:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 3129              		.loc 1 2432 0
 3130 0016 0546     		mov	r5, r0
 3131 0018 0028     		cmp	r0, #0
 3132 001a 40F08A80 		bne	.L439
2433:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)					/* Aborted file? */
 3133              		.loc 1 2433 0
 3134 001e A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3135              	.LVL461:
 3136 0020 0106     		lsls	r1, r0, #24
 3137 0022 00F18380 		bmi	.L456
2435:lib/ff/ff.c   **** 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
 3138              		.loc 1 2435 0
 3139 0026 C207     		lsls	r2, r0, #31
 3140 0028 40F18280 		bpl	.L457
 3141              	.LVL462:
2437:lib/ff/ff.c   **** 	remain = fp->fsize - fp->fptr;
 3142              		.loc 1 2437 0
 3143 002c E168     		ldr	r1, [r4, #12]
 3144 002e A268     		ldr	r2, [r4, #8]
 3145 0030 8E1A     		subs	r6, r1, r2
 3146              	.LVL463:
 3147 0032 B742     		cmp	r7, r6
 3148 0034 38BF     		it	cc
 3149 0036 3E46     		movcc	r6, r7
 3150              	.LVL464:
 3151              	.L440:
2440:lib/ff/ff.c   **** 	for ( ;  btr;								/* Repeat until all data read */
 3152              		.loc 1 2440 0 discriminator 1
 3153 0038 002E     		cmp	r6, #0
 3154 003a 7AD0     		beq	.L439
 3155              	.L455:
2442:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
 3156              		.loc 1 2442 0
 3157 003c A168     		ldr	r1, [r4, #8]
 3158 003e CB05     		lsls	r3, r1, #23
 3159 0040 4CD1     		bne	.L441
2443:lib/ff/ff.c   **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 3160              		.loc 1 2443 0
 3161 0042 2068     		ldr	r0, [r4, #0]
 3162 0044 90F802A0 		ldrb	sl, [r0, #2]	@ zero_extendqisi2
 3163 0048 0AF1FF33 		add	r3, sl, #-1
 3164 004c 03EA5122 		and	r2, r3, r1, lsr #9
 3165              	.LVL465:
2444:lib/ff/ff.c   **** 			if (!csect) {						/* On the cluster boundary? */
 3166              		.loc 1 2444 0
 3167 0050 12F0FF0A 		ands	sl, r2, #255
 3168 0054 10D1     		bne	.L442
2445:lib/ff/ff.c   **** 				if (fp->fptr == 0) {			/* On the top of the file? */
 3169              		.loc 1 2445 0
 3170 0056 09B9     		cbnz	r1, .L443
2446:lib/ff/ff.c   **** 					clst = fp->sclust;			/* Follow from the origin */
 3171              		.loc 1 2446 0
 3172 0058 2069     		ldr	r0, [r4, #16]
 3173              	.LVL466:
 3174 005a 08E0     		b	.L444
 3175              	.LVL467:
 3176              	.L443:
2449:lib/ff/ff.c   **** 					if (fp->cltbl)
 3177              		.loc 1 2449 0
 3178 005c 636A     		ldr	r3, [r4, #36]
 3179 005e 1BB1     		cbz	r3, .L445
2450:lib/ff/ff.c   **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 3180              		.loc 1 2450 0
 3181 0060 2046     		mov	r0, r4
 3182 0062 FFF7FEFF 		bl	clmt_clust
 3183              	.LVL468:
 3184 0066 02E0     		b	.L444
 3185              	.LVL469:
 3186              	.L445:
2453:lib/ff/ff.c   **** 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
 3187              		.loc 1 2453 0
 3188 0068 6169     		ldr	r1, [r4, #20]
 3189 006a FFF7FEFF 		bl	get_fat
 3190              	.LVL470:
 3191              	.L444:
2455:lib/ff/ff.c   **** 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
 3192              		.loc 1 2455 0
 3193 006e 0128     		cmp	r0, #1
 3194 0070 0AD9     		bls	.L461
 3195              	.L446:
2456:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 3196              		.loc 1 2456 0
 3197 0072 431C     		adds	r3, r0, #1
 3198 0074 3FD0     		beq	.L462
 3199              	.L447:
2457:lib/ff/ff.c   **** 				fp->clust = clst;				/* Update current cluster */
 3200              		.loc 1 2457 0
 3201 0076 6061     		str	r0, [r4, #20]
 3202              	.LVL471:
 3203              	.L442:
2459:lib/ff/ff.c   **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 3204              		.loc 1 2459 0
 3205 0078 2268     		ldr	r2, [r4, #0]
 3206 007a 1046     		mov	r0, r2
 3207 007c 6169     		ldr	r1, [r4, #20]
 3208 007e 0192     		str	r2, [sp, #4]
 3209 0080 FFF7FEFF 		bl	clust2sect
 3210              	.LVL472:
2460:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 3211              		.loc 1 2460 0
 3212 0084 019B     		ldr	r3, [sp, #4]
 3213 0086 20B9     		cbnz	r0, .L448
 3214              	.LVL473:
 3215              	.L461:
2460:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 3216              		.loc 1 2460 0 is_stmt 0 discriminator 1
 3217 0088 A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3218 008a 60F07F03 		orn	r3, r0, #127
 3219 008e A371     		strb	r3, [r4, #6]
 3220 0090 4CE0     		b	.L456
 3221              	.LVL474:
 3222              	.L448:
2461:lib/ff/ff.c   **** 			sect += csect;
 3223              		.loc 1 2461 0 is_stmt 1
 3224 0092 00EB0A0B 		add	fp, r0, sl
 3225              	.LVL475:
2463:lib/ff/ff.c   **** 			if (cc) {							/* Read maximum contiguous sectors directly */
 3226              		.loc 1 2463 0
 3227 0096 770A     		lsrs	r7, r6, #9
 3228              	.LVL476:
 3229 0098 1ED0     		beq	.L449
2464:lib/ff/ff.c   **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 3230              		.loc 1 2464 0
 3231 009a 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 3232 009c 07EB0A01 		add	r1, r7, sl
 3233 00a0 9142     		cmp	r1, r2
2465:lib/ff/ff.c   **** 					cc = fp->fs->csize - csect;
 3234              		.loc 1 2465 0
 3235 00a2 88BF     		it	hi
 3236 00a4 CAEB0207 		rsbhi	r7, sl, r2
 3237              	.LVL477:
2466:lib/ff/ff.c   **** 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
 3238              		.loc 1 2466 0
 3239 00a8 5878     		ldrb	r0, [r3, #1]	@ zero_extendqisi2
 3240 00aa 4146     		mov	r1, r8
 3241 00ac 5A46     		mov	r2, fp
 3242 00ae FBB2     		uxtb	r3, r7
 3243 00b0 FFF7FEFF 		bl	disk_read
 3244              	.LVL478:
 3245 00b4 F8B9     		cbnz	r0, .L462
 3246              	.L451:
2470:lib/ff/ff.c   **** 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
 3247              		.loc 1 2470 0
 3248 00b6 2168     		ldr	r1, [r4, #0]
 3249 00b8 0879     		ldrb	r0, [r1, #4]	@ zero_extendqisi2
 3250 00ba 58B1     		cbz	r0, .L452
2470:lib/ff/ff.c   **** 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
 3251              		.loc 1 2470 0 is_stmt 0 discriminator 1
 3252 00bc 0B6B     		ldr	r3, [r1, #48]
 3253 00be CBEB0302 		rsb	r2, fp, r3
 3254 00c2 BA42     		cmp	r2, r7
 3255 00c4 06D2     		bcs	.L452
2471:lib/ff/ff.c   **** 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
 3256              		.loc 1 2471 0 is_stmt 1
 3257 00c6 08EB4220 		add	r0, r8, r2, lsl #9
 3258 00ca 3431     		adds	r1, r1, #52
 3259 00cc 4FF40072 		mov	r2, #512
 3260 00d0 FFF7FEFF 		bl	mem_cpy
 3261              	.LVL479:
 3262              	.L452:
2477:lib/ff/ff.c   **** 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
 3263              		.loc 1 2477 0
 3264 00d4 7F02     		lsls	r7, r7, #9
 3265              	.LVL480:
2478:lib/ff/ff.c   **** 				continue;
 3266              		.loc 1 2478 0
 3267 00d6 1EE0     		b	.L453
 3268              	.LVL481:
 3269              	.L449:
2493:lib/ff/ff.c   **** 			fp->dsect = sect;
 3270              		.loc 1 2493 0
 3271 00d8 C4F818B0 		str	fp, [r4, #24]
 3272              	.LVL482:
 3273              	.L441:
2495:lib/ff/ff.c   **** 		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer 
 3274              		.loc 1 2495 0
 3275 00dc A768     		ldr	r7, [r4, #8]
 3276 00de F805     		lsls	r0, r7, #23
 3277 00e0 C10D     		lsrs	r1, r0, #23
 3278 00e2 C1F50077 		rsb	r7, r1, #512
 3279              	.LVL483:
 3280 00e6 BE42     		cmp	r6, r7
 3281 00e8 38BF     		it	cc
 3282 00ea 3746     		movcc	r7, r6
 3283              	.LVL484:
2498:lib/ff/ff.c   **** 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
 3284              		.loc 1 2498 0
 3285 00ec 2068     		ldr	r0, [r4, #0]
 3286 00ee A169     		ldr	r1, [r4, #24]
 3287 00f0 FFF7FEFF 		bl	move_window
 3288              	.LVL485:
 3289 00f4 28B1     		cbz	r0, .L454
 3290              	.LVL486:
 3291              	.L462:
2499:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
 3292              		.loc 1 2499 0
 3293 00f6 A579     		ldrb	r5, [r4, #6]	@ zero_extendqisi2
 3294 00f8 65F07F01 		orn	r1, r5, #127
 3295 00fc A171     		strb	r1, [r4, #6]
 3296 00fe 0125     		movs	r5, #1
 3297 0100 17E0     		b	.L439
 3298              	.LVL487:
 3299              	.L454:
2500:lib/ff/ff.c   **** 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 3300              		.loc 1 2500 0
 3301 0102 A268     		ldr	r2, [r4, #8]
 3302 0104 D005     		lsls	r0, r2, #23
 3303 0106 2368     		ldr	r3, [r4, #0]
 3304 0108 03EBD051 		add	r1, r3, r0, lsr #23
 3305 010c 4046     		mov	r0, r8
 3306 010e 3431     		adds	r1, r1, #52
 3307 0110 3A46     		mov	r2, r7
 3308 0112 FFF7FEFF 		bl	mem_cpy
 3309              	.LVL488:
 3310              	.L453:
2441:lib/ff/ff.c   **** 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 3311              		.loc 1 2441 0
 3312 0116 B844     		add	r8, r8, r7
 3313              	.LVL489:
 3314 0118 A168     		ldr	r1, [r4, #8]
 3315 011a C819     		adds	r0, r1, r7
 3316 011c A060     		str	r0, [r4, #8]
 3317 011e D9F80030 		ldr	r3, [r9, #0]
 3318 0122 DA19     		adds	r2, r3, r7
 3319 0124 C9F80020 		str	r2, [r9, #0]
 3320 0128 F61B     		subs	r6, r6, r7
 3321              	.LVL490:
 3322 012a 85E7     		b	.L440
 3323              	.LVL491:
 3324              	.L456:
2434:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 3325              		.loc 1 2434 0
 3326 012c 0225     		movs	r5, #2
 3327 012e 00E0     		b	.L439
 3328              	.LVL492:
 3329              	.L457:
2436:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
 3330              		.loc 1 2436 0
 3331 0130 0725     		movs	r5, #7
 3332              	.LVL493:
 3333              	.L439:
2507:lib/ff/ff.c   **** }
 3334              		.loc 1 2507 0
 3335 0132 2846     		mov	r0, r5
 3336 0134 BDE8FE8F 		pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3337              		.cfi_endproc
 3338              	.LFE28:
 3340              		.section	.text.f_write,"ax",%progbits
 3341              		.align	1
 3342              		.global	f_write
 3343              		.thumb
 3344              		.thumb_func
 3346              	f_write:
 3347              	.LFB29:
2523:lib/ff/ff.c   **** {
 3348              		.loc 1 2523 0
 3349              		.cfi_startproc
 3350              		@ args = 0, pretend = 0, frame = 8
 3351              		@ frame_needed = 0, uses_anonymous_args = 0
 3352              	.LVL494:
 3353 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3354              	.LCFI20:
 3355              		.cfi_def_cfa_offset 48
 3356              		.cfi_offset 0, -48
 3357              		.cfi_offset 1, -44
 3358              		.cfi_offset 2, -40
 3359              		.cfi_offset 4, -36
 3360              		.cfi_offset 5, -32
 3361              		.cfi_offset 6, -28
 3362              		.cfi_offset 7, -24
 3363              		.cfi_offset 8, -20
 3364              		.cfi_offset 9, -16
 3365              		.cfi_offset 10, -12
 3366              		.cfi_offset 11, -8
 3367              		.cfi_offset 14, -4
 3368 0004 0446     		mov	r4, r0
 3369 0006 8846     		mov	r8, r1
 3370 0008 1746     		mov	r7, r2
 3371 000a 9946     		mov	r9, r3
 3372              	.LVL495:
2531:lib/ff/ff.c   **** 	*bw = 0;	/* Clear write byte counter */
 3373              		.loc 1 2531 0
 3374 000c 0023     		movs	r3, #0
 3375              	.LVL496:
 3376 000e C9F80030 		str	r3, [r9, #0]
2533:lib/ff/ff.c   **** 	res = validate(fp);						/* Check validity */
 3377              		.loc 1 2533 0
 3378 0012 FFF7FEFF 		bl	validate
 3379              	.LVL497:
2534:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 3380              		.loc 1 2534 0
 3381 0016 0546     		mov	r5, r0
 3382 0018 0028     		cmp	r0, #0
 3383 001a 40F0B780 		bne	.L464
2535:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)				/* Aborted file? */
 3384              		.loc 1 2535 0
 3385 001e A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3386              	.LVL498:
 3387 0020 0206     		lsls	r2, r0, #24
 3388 0022 00F1B080 		bmi	.L489
2537:lib/ff/ff.c   **** 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 3389              		.loc 1 2537 0
 3390 0026 00F00201 		and	r1, r0, #2
 3391 002a CAB2     		uxtb	r2, r1
 3392 002c 002A     		cmp	r2, #0
 3393 002e 00F0AC80 		beq	.L490
2539:lib/ff/ff.c   **** 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
 3394              		.loc 1 2539 0
 3395 0032 E368     		ldr	r3, [r4, #12]
 3396 0034 DF42     		cmn	r7, r3
 3397 0036 28BF     		it	cs
 3398 0038 0027     		movcs	r7, #0
 3399              	.LVL499:
 3400              	.L466:
2541:lib/ff/ff.c   **** 	for ( ;  btw;							/* Repeat until all data written */
 3401              		.loc 1 2541 0 discriminator 1
 3402 003a FFB1     		cbz	r7, .L488
 3403              	.L487:
2543:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 3404              		.loc 1 2543 0
 3405 003c A168     		ldr	r1, [r4, #8]
 3406 003e CB05     		lsls	r3, r1, #23
 3407 0040 71D1     		bne	.L467
2544:lib/ff/ff.c   **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 3408              		.loc 1 2544 0
 3409 0042 2068     		ldr	r0, [r4, #0]
 3410 0044 90F802A0 		ldrb	sl, [r0, #2]	@ zero_extendqisi2
 3411 0048 0AF1FF32 		add	r2, sl, #-1
 3412 004c 02EA5123 		and	r3, r2, r1, lsr #9
 3413              	.LVL500:
2545:lib/ff/ff.c   **** 			if (!csect) {					/* On the cluster boundary? */
 3414              		.loc 1 2545 0
 3415 0050 13F0FF0A 		ands	sl, r3, #255
 3416 0054 1DD1     		bne	.L468
2546:lib/ff/ff.c   **** 				if (fp->fptr == 0) {		/* On the top of the file? */
 3417              		.loc 1 2546 0
 3418 0056 31B9     		cbnz	r1, .L469
2547:lib/ff/ff.c   **** 					clst = fp->sclust;		/* Follow from the origin */
 3419              		.loc 1 2547 0
 3420 0058 2169     		ldr	r1, [r4, #16]
 3421              	.LVL501:
2548:lib/ff/ff.c   **** 					if (clst == 0)			/* When no cluster is allocated, */
 3422              		.loc 1 2548 0
 3423 005a A9B9     		cbnz	r1, .L470
2549:lib/ff/ff.c   **** 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 3424              		.loc 1 2549 0
 3425 005c FFF7FEFF 		bl	create_chain
 3426              	.LVL502:
 3427 0060 0146     		mov	r1, r0
 3428              	.LVL503:
 3429 0062 2061     		str	r0, [r4, #16]
 3430 0064 09E0     		b	.L471
 3431              	.LVL504:
 3432              	.L469:
2552:lib/ff/ff.c   **** 					if (fp->cltbl)
 3433              		.loc 1 2552 0
 3434 0066 626A     		ldr	r2, [r4, #36]
 3435 0068 1AB1     		cbz	r2, .L472
2553:lib/ff/ff.c   **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 3436              		.loc 1 2553 0
 3437 006a 2046     		mov	r0, r4
 3438 006c FFF7FEFF 		bl	clmt_clust
 3439              	.LVL505:
 3440 0070 02E0     		b	.L495
 3441              	.LVL506:
 3442              	.L472:
2556:lib/ff/ff.c   **** 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 3443              		.loc 1 2556 0
 3444 0072 6169     		ldr	r1, [r4, #20]
 3445 0074 FFF7FEFF 		bl	create_chain
 3446              	.LVL507:
 3447              	.L495:
 3448 0078 0146     		mov	r1, r0
 3449              	.LVL508:
 3450              	.L471:
2558:lib/ff/ff.c   **** 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 3451              		.loc 1 2558 0
 3452 007a 29B9     		cbnz	r1, .L470
 3453              	.LVL509:
 3454              	.L488:
2623:lib/ff/ff.c   **** 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 3455              		.loc 1 2623 0
 3456 007c A068     		ldr	r0, [r4, #8]
 3457 007e E268     		ldr	r2, [r4, #12]
 3458 0080 9042     		cmp	r0, r2
 3459 0082 7BD9     		bls	.L474
 3460              	.L473:
2623:lib/ff/ff.c   **** 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 3461              		.loc 1 2623 0 is_stmt 0 discriminator 1
 3462 0084 E060     		str	r0, [r4, #12]
 3463 0086 79E0     		b	.L474
 3464              	.LVL510:
 3465              	.L470:
2559:lib/ff/ff.c   **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 3466              		.loc 1 2559 0 is_stmt 1
 3467 0088 0129     		cmp	r1, #1
 3468 008a 14D0     		beq	.L496
 3469              	.L475:
2560:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 3470              		.loc 1 2560 0
 3471 008c 481C     		adds	r0, r1, #1
 3472 008e 57D0     		beq	.L497
 3473              	.L476:
2561:lib/ff/ff.c   **** 				fp->clust = clst;			/* Update current cluster */
 3474              		.loc 1 2561 0
 3475 0090 6161     		str	r1, [r4, #20]
 3476              	.LVL511:
 3477              	.L468:
2564:lib/ff/ff.c   **** 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
 3478              		.loc 1 2564 0
 3479 0092 2068     		ldr	r0, [r4, #0]
 3480 0094 016B     		ldr	r1, [r0, #48]
 3481 0096 A369     		ldr	r3, [r4, #24]
 3482 0098 9942     		cmp	r1, r3
 3483 009a 04D1     		bne	.L477
2564:lib/ff/ff.c   **** 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
 3484              		.loc 1 2564 0 is_stmt 0 discriminator 1
 3485 009c 0021     		movs	r1, #0
 3486 009e FFF7FEFF 		bl	move_window
 3487              	.LVL512:
 3488 00a2 0028     		cmp	r0, #0
 3489 00a4 4CD1     		bne	.L497
 3490              	.L477:
2573:lib/ff/ff.c   **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 3491              		.loc 1 2573 0 is_stmt 1
 3492 00a6 2268     		ldr	r2, [r4, #0]
 3493 00a8 1046     		mov	r0, r2
 3494 00aa 6169     		ldr	r1, [r4, #20]
 3495 00ac 0192     		str	r2, [sp, #4]
 3496 00ae FFF7FEFF 		bl	clust2sect
 3497              	.LVL513:
2574:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 3498              		.loc 1 2574 0
 3499 00b2 019B     		ldr	r3, [sp, #4]
 3500 00b4 20B9     		cbnz	r0, .L478
 3501              	.LVL514:
 3502              	.L496:
2574:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 3503              		.loc 1 2574 0 is_stmt 0 discriminator 1
 3504 00b6 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3505 00b8 63F07F01 		orn	r1, r3, #127
 3506 00bc A171     		strb	r1, [r4, #6]
 3507 00be 62E0     		b	.L489
 3508              	.LVL515:
 3509              	.L478:
2575:lib/ff/ff.c   **** 			sect += csect;
 3510              		.loc 1 2575 0 is_stmt 1
 3511 00c0 00EB0A0B 		add	fp, r0, sl
 3512              	.LVL516:
2577:lib/ff/ff.c   **** 			if (cc) {						/* Write maximum contiguous sectors directly */
 3513              		.loc 1 2577 0
 3514 00c4 7E0A     		lsrs	r6, r7, #9
 3515              	.LVL517:
 3516 00c6 20D0     		beq	.L479
2578:lib/ff/ff.c   **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 3517              		.loc 1 2578 0
 3518 00c8 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 3519 00ca 06EB0A00 		add	r0, r6, sl
 3520 00ce 9042     		cmp	r0, r2
2579:lib/ff/ff.c   **** 					cc = fp->fs->csize - csect;
 3521              		.loc 1 2579 0
 3522 00d0 88BF     		it	hi
 3523 00d2 CAEB0206 		rsbhi	r6, sl, r2
 3524              	.LVL518:
2580:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
 3525              		.loc 1 2580 0
 3526 00d6 5878     		ldrb	r0, [r3, #1]	@ zero_extendqisi2
 3527 00d8 4146     		mov	r1, r8
 3528 00da 5A46     		mov	r2, fp
 3529 00dc F3B2     		uxtb	r3, r6
 3530 00de FFF7FEFF 		bl	disk_write
 3531              	.LVL519:
 3532 00e2 8246     		mov	sl, r0
 3533 00e4 60BB     		cbnz	r0, .L497
 3534              	.L481:
2583:lib/ff/ff.c   **** 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct 
 3535              		.loc 1 2583 0
 3536 00e6 2068     		ldr	r0, [r4, #0]
 3537 00e8 036B     		ldr	r3, [r0, #48]
 3538 00ea CBEB0301 		rsb	r1, fp, r3
 3539 00ee B142     		cmp	r1, r6
 3540 00f0 09D2     		bcs	.L482
2584:lib/ff/ff.c   **** 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
 3541              		.loc 1 2584 0
 3542 00f2 3430     		adds	r0, r0, #52
 3543 00f4 08EB4121 		add	r1, r8, r1, lsl #9
 3544 00f8 4FF40072 		mov	r2, #512
 3545 00fc FFF7FEFF 		bl	mem_cpy
 3546              	.LVL520:
2585:lib/ff/ff.c   **** 					fp->fs->wflag = 0;
 3547              		.loc 1 2585 0
 3548 0100 2268     		ldr	r2, [r4, #0]
 3549 0102 82F804A0 		strb	sl, [r2, #4]
 3550              	.L482:
2593:lib/ff/ff.c   **** 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
 3551              		.loc 1 2593 0
 3552 0106 7602     		lsls	r6, r6, #9
 3553              	.LVL521:
2594:lib/ff/ff.c   **** 				continue;
 3554              		.loc 1 2594 0
 3555 0108 2DE0     		b	.L483
 3556              	.LVL522:
 3557              	.L479:
2597:lib/ff/ff.c   **** 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
 3558              		.loc 1 2597 0
 3559 010a A068     		ldr	r0, [r4, #8]
 3560 010c E168     		ldr	r1, [r4, #12]
 3561 010e 8842     		cmp	r0, r1
 3562 0110 07D3     		bcc	.L484
2598:lib/ff/ff.c   **** 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
 3563              		.loc 1 2598 0
 3564 0112 1846     		mov	r0, r3
 3565 0114 3146     		mov	r1, r6
 3566 0116 FFF7FEFF 		bl	move_window
 3567              	.LVL523:
 3568 011a 88B9     		cbnz	r0, .L497
 3569              	.L485:
2599:lib/ff/ff.c   **** 				fp->fs->winsect = sect;
 3570              		.loc 1 2599 0
 3571 011c 2668     		ldr	r6, [r4, #0]
 3572              	.LVL524:
 3573 011e C6F830B0 		str	fp, [r6, #48]
 3574              	.L484:
2608:lib/ff/ff.c   **** 			fp->dsect = sect;
 3575              		.loc 1 2608 0
 3576 0122 C4F818B0 		str	fp, [r4, #24]
 3577              	.LVL525:
 3578              	.L467:
2610:lib/ff/ff.c   **** 		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 3579              		.loc 1 2610 0
 3580 0126 A268     		ldr	r2, [r4, #8]
 3581 0128 D305     		lsls	r3, r2, #23
 3582 012a D80D     		lsrs	r0, r3, #23
 3583 012c C0F50076 		rsb	r6, r0, #512
 3584              	.LVL526:
 3585 0130 B742     		cmp	r7, r6
 3586 0132 38BF     		it	cc
 3587 0134 3E46     		movcc	r6, r7
 3588              	.LVL527:
2613:lib/ff/ff.c   **** 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
 3589              		.loc 1 2613 0
 3590 0136 2068     		ldr	r0, [r4, #0]
 3591 0138 A169     		ldr	r1, [r4, #24]
 3592 013a FFF7FEFF 		bl	move_window
 3593              	.LVL528:
 3594 013e 28B1     		cbz	r0, .L486
 3595              	.LVL529:
 3596              	.L497:
2614:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
 3597              		.loc 1 2614 0
 3598 0140 A579     		ldrb	r5, [r4, #6]	@ zero_extendqisi2
 3599 0142 65F07F00 		orn	r0, r5, #127
 3600 0146 A071     		strb	r0, [r4, #6]
 3601 0148 0125     		movs	r5, #1
 3602 014a 1FE0     		b	.L464
 3603              	.LVL530:
 3604              	.L486:
2615:lib/ff/ff.c   **** 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 3605              		.loc 1 2615 0
 3606 014c A168     		ldr	r1, [r4, #8]
 3607 014e CA05     		lsls	r2, r1, #23
 3608 0150 2368     		ldr	r3, [r4, #0]
 3609 0152 03EBD250 		add	r0, r3, r2, lsr #23
 3610 0156 3430     		adds	r0, r0, #52
 3611 0158 4146     		mov	r1, r8
 3612 015a 3246     		mov	r2, r6
 3613 015c FFF7FEFF 		bl	mem_cpy
 3614              	.LVL531:
2616:lib/ff/ff.c   **** 		fp->fs->wflag = 1;
 3615              		.loc 1 2616 0
 3616 0160 2068     		ldr	r0, [r4, #0]
 3617 0162 0121     		movs	r1, #1
 3618 0164 0171     		strb	r1, [r0, #4]
 3619              	.L483:
2542:lib/ff/ff.c   **** 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 3620              		.loc 1 2542 0
 3621 0166 B044     		add	r8, r8, r6
 3622              	.LVL532:
 3623 0168 A068     		ldr	r0, [r4, #8]
 3624 016a 8319     		adds	r3, r0, r6
 3625 016c A360     		str	r3, [r4, #8]
 3626 016e D9F80010 		ldr	r1, [r9, #0]
 3627 0172 8A19     		adds	r2, r1, r6
 3628 0174 C9F80020 		str	r2, [r9, #0]
 3629 0178 BF1B     		subs	r7, r7, r6
 3630 017a 5EE7     		b	.L466
 3631              	.LVL533:
 3632              	.L474:
2624:lib/ff/ff.c   **** 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 3633              		.loc 1 2624 0
 3634 017c A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3635 017e 43F02001 		orr	r1, r3, #32
 3636 0182 A171     		strb	r1, [r4, #6]
2626:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, FR_OK);
 3637              		.loc 1 2626 0
 3638 0184 02E0     		b	.L464
 3639              	.L489:
2536:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 3640              		.loc 1 2536 0
 3641 0186 0225     		movs	r5, #2
 3642 0188 00E0     		b	.L464
 3643              	.LVL534:
 3644              	.L490:
2538:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
 3645              		.loc 1 2538 0
 3646 018a 0725     		movs	r5, #7
 3647              	.LVL535:
 3648              	.L464:
2627:lib/ff/ff.c   **** }
 3649              		.loc 1 2627 0
 3650 018c 2846     		mov	r0, r5
 3651 018e BDE8FE8F 		pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3652              		.cfi_endproc
 3653              	.LFE29:
 3655              		.section	.text.f_sync,"ax",%progbits
 3656              		.align	1
 3657              		.global	f_sync
 3658              		.thumb
 3659              		.thumb_func
 3661              	f_sync:
 3662              	.LFB30:
2639:lib/ff/ff.c   **** {
 3663              		.loc 1 2639 0
 3664              		.cfi_startproc
 3665              		@ args = 0, pretend = 0, frame = 0
 3666              		@ frame_needed = 0, uses_anonymous_args = 0
 3667              	.LVL536:
 3668 0000 70B5     		push	{r4, r5, r6, lr}
 3669              	.LCFI21:
 3670              		.cfi_def_cfa_offset 16
 3671              		.cfi_offset 4, -16
 3672              		.cfi_offset 5, -12
 3673              		.cfi_offset 6, -8
 3674              		.cfi_offset 14, -4
 3675 0002 0446     		mov	r4, r0
2645:lib/ff/ff.c   **** 	res = validate(fp);					/* Check validity of the object */
 3676              		.loc 1 2645 0
 3677 0004 FFF7FEFF 		bl	validate
 3678              	.LVL537:
2646:lib/ff/ff.c   **** 	if (res == FR_OK) {
 3679              		.loc 1 2646 0
 3680 0008 0028     		cmp	r0, #0
 3681 000a 27D1     		bne	.L499
2647:lib/ff/ff.c   **** 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 3682              		.loc 1 2647 0
 3683 000c A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3684 000e 03F02001 		and	r1, r3, #32
 3685 0012 CAB2     		uxtb	r2, r1
 3686 0014 002A     		cmp	r2, #0
 3687 0016 21D0     		beq	.L499
2656:lib/ff/ff.c   **** 			res = move_window(fp->fs, fp->dir_sect);
 3688              		.loc 1 2656 0
 3689 0018 2068     		ldr	r0, [r4, #0]
 3690              	.LVL538:
 3691 001a E169     		ldr	r1, [r4, #28]
 3692 001c FFF7FEFF 		bl	move_window
 3693              	.LVL539:
 3694 0020 0646     		mov	r6, r0
 3695              	.LVL540:
2657:lib/ff/ff.c   **** 			if (res == FR_OK) {
 3696              		.loc 1 2657 0
 3697 0022 DEB9     		cbnz	r6, .L499
2658:lib/ff/ff.c   **** 				dir = fp->dir_ptr;
 3698              		.loc 1 2658 0
 3699 0024 256A     		ldr	r5, [r4, #32]
 3700              	.LVL541:
2659:lib/ff/ff.c   **** 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 3701              		.loc 1 2659 0
 3702 0026 E87A     		ldrb	r0, [r5, #11]	@ zero_extendqisi2
 3703              	.LVL542:
 3704 0028 40F02003 		orr	r3, r0, #32
 3705 002c EB72     		strb	r3, [r5, #11]
2660:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 3706              		.loc 1 2660 0
 3707 002e E168     		ldr	r1, [r4, #12]
 3708 0030 E961     		str	r1, [r5, #28]
2661:lib/ff/ff.c   **** 				st_clust(dir, fp->sclust);					/* Update start cluster */
 3709              		.loc 1 2661 0
 3710 0032 2269     		ldr	r2, [r4, #16]
 3711              	.LVL543:
 3712              	.LBB87:
 3713              	.LBB88:
1205:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 3714              		.loc 1 1205 0
 3715 0034 6A83     		strh	r2, [r5, #26]	@ movhi
1206:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 3716              		.loc 1 1206 0
 3717 0036 100C     		lsrs	r0, r2, #16
 3718 0038 A882     		strh	r0, [r5, #20]	@ movhi
 3719              	.LBE88:
 3720              	.LBE87:
2662:lib/ff/ff.c   **** 				tim = get_fattime();						/* Update updated time */
 3721              		.loc 1 2662 0
 3722 003a FFF7FEFF 		bl	get_fattime
 3723              	.LVL544:
2663:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tim);
 3724              		.loc 1 2663 0
 3725 003e C5F81600 		str	r0, [r5, #22]
2664:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_LstAccDate, 0);
 3726              		.loc 1 2664 0
 3727 0042 6E82     		strh	r6, [r5, #18]	@ movhi
2665:lib/ff/ff.c   **** 				fp->flag &= ~FA__WRITTEN;
 3728              		.loc 1 2665 0
 3729 0044 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3730 0046 23F02001 		bic	r1, r3, #32
 3731 004a A171     		strb	r1, [r4, #6]
2666:lib/ff/ff.c   **** 				fp->fs->wflag = 1;
 3732              		.loc 1 2666 0
 3733 004c 2068     		ldr	r0, [r4, #0]
 3734              	.LVL545:
 3735 004e 0122     		movs	r2, #1
 3736 0050 0271     		strb	r2, [r0, #4]
2667:lib/ff/ff.c   **** 				res = sync(fp->fs);
 3737              		.loc 1 2667 0
 3738 0052 2068     		ldr	r0, [r4, #0]
2673:lib/ff/ff.c   **** }
 3739              		.loc 1 2673 0
 3740 0054 BDE87040 		pop	{r4, r5, r6, lr}
2667:lib/ff/ff.c   **** 				res = sync(fp->fs);
 3741              		.loc 1 2667 0
 3742 0058 FFF7FEBF 		b	sync
 3743              	.LVL546:
 3744              	.L499:
2673:lib/ff/ff.c   **** }
 3745              		.loc 1 2673 0
 3746 005c 70BD     		pop	{r4, r5, r6, pc}
 3747              		.cfi_endproc
 3748              	.LFE30:
 3750              		.section	.text.f_close,"ax",%progbits
 3751              		.align	1
 3752              		.global	f_close
 3753              		.thumb
 3754              		.thumb_func
 3756              	f_close:
 3757              	.LFB31:
2687:lib/ff/ff.c   **** {
 3758              		.loc 1 2687 0
 3759              		.cfi_startproc
 3760              		@ args = 0, pretend = 0, frame = 0
 3761              		@ frame_needed = 0, uses_anonymous_args = 0
 3762              	.LVL547:
 3763 0000 10B5     		push	{r4, lr}
 3764              	.LCFI22:
 3765              		.cfi_def_cfa_offset 8
 3766              		.cfi_offset 4, -8
 3767              		.cfi_offset 14, -4
 3768 0002 0446     		mov	r4, r0
2701:lib/ff/ff.c   **** 	res = f_sync(fp);		/* Flush cached data */
 3769              		.loc 1 2701 0
 3770 0004 FFF7FEFF 		bl	f_sync
 3771              	.LVL548:
2716:lib/ff/ff.c   **** 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
 3772              		.loc 1 2716 0
 3773 0008 00B9     		cbnz	r0, .L504
2716:lib/ff/ff.c   **** 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
 3774              		.loc 1 2716 0 is_stmt 0 discriminator 1
 3775 000a 2060     		str	r0, [r4, #0]
 3776              	.L504:
2719:lib/ff/ff.c   **** }
 3777              		.loc 1 2719 0 is_stmt 1
 3778 000c 10BD     		pop	{r4, pc}
 3779              		.cfi_endproc
 3780              	.LFE31:
 3782              		.section	.text.f_chdrive,"ax",%progbits
 3783              		.align	1
 3784              		.global	f_chdrive
 3785              		.thumb
 3786              		.thumb_func
 3788              	f_chdrive:
 3789              	.LFB32:
2733:lib/ff/ff.c   **** {
 3790              		.loc 1 2733 0
 3791              		.cfi_startproc
 3792              		@ args = 0, pretend = 0, frame = 0
 3793              		@ frame_needed = 0, uses_anonymous_args = 0
 3794              		@ link register save eliminated.
 3795              	.LVL549:
2734:lib/ff/ff.c   **** 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
 3796              		.loc 1 2734 0
 3797 0000 10B9     		cbnz	r0, .L507
2736:lib/ff/ff.c   **** 	CurrVol = drv;
 3798              		.loc 1 2736 0
 3799 0002 024B     		ldr	r3, .L508
 3800 0004 1870     		strb	r0, [r3, #0]
2738:lib/ff/ff.c   **** 	return FR_OK;
 3801              		.loc 1 2738 0
 3802 0006 7047     		bx	lr
 3803              	.L507:
2734:lib/ff/ff.c   **** 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
 3804              		.loc 1 2734 0
 3805 0008 0B20     		movs	r0, #11
 3806              	.LVL550:
2739:lib/ff/ff.c   **** }
 3807              		.loc 1 2739 0
 3808 000a 7047     		bx	lr
 3809              	.L509:
 3810              		.align	2
 3811              	.L508:
 3812 000c 00000000 		.word	.LANCHOR0
 3813              		.cfi_endproc
 3814              	.LFE32:
 3816              		.section	.text.f_chdir,"ax",%progbits
 3817              		.align	1
 3818              		.global	f_chdir
 3819              		.thumb
 3820              		.thumb_func
 3822              	f_chdir:
 3823              	.LFB33:
2746:lib/ff/ff.c   **** {
 3824              		.loc 1 2746 0
 3825              		.cfi_startproc
 3826              		@ args = 0, pretend = 0, frame = 48
 3827              		@ frame_needed = 0, uses_anonymous_args = 0
 3828              	.LVL551:
 3829 0000 10B5     		push	{r4, lr}
 3830              	.LCFI23:
 3831              		.cfi_def_cfa_offset 8
 3832              		.cfi_offset 4, -8
 3833              		.cfi_offset 14, -4
 3834 0002 8CB0     		sub	sp, sp, #48
 3835              	.LCFI24:
 3836              		.cfi_def_cfa_offset 56
 3837 0004 0CAB     		add	r3, sp, #48
 3838 0006 43F82C0D 		str	r0, [r3, #-44]!
2752:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 0);
 3839              		.loc 1 2752 0
 3840 000a 1846     		mov	r0, r3
 3841              	.LVL552:
 3842 000c 05A9     		add	r1, sp, #20
 3843 000e 0022     		movs	r2, #0
 3844 0010 FFF7FEFF 		bl	chk_mounted
 3845              	.LVL553:
2753:lib/ff/ff.c   **** 	if (res == FR_OK) {
 3846              		.loc 1 2753 0
 3847 0014 00BB     		cbnz	r0, .L519
2754:lib/ff/ff.c   **** 		INIT_BUF(dj);
 3848              		.loc 1 2754 0
 3849 0016 02A8     		add	r0, sp, #8
 3850              	.LVL554:
 3851 0018 0B90     		str	r0, [sp, #44]
2755:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the path */
 3852              		.loc 1 2755 0
 3853 001a 05A8     		add	r0, sp, #20
 3854              	.LVL555:
 3855 001c 0199     		ldr	r1, [sp, #4]
 3856 001e FFF7FEFF 		bl	follow_path
 3857              	.LVL556:
2757:lib/ff/ff.c   **** 		if (res == FR_OK) {					/* Follow completed */
 3858              		.loc 1 2757 0
 3859 0022 A0B9     		cbnz	r0, .L512
2758:lib/ff/ff.c   **** 			if (!dj.dir) {
 3860              		.loc 1 2758 0
 3861 0024 0A9B     		ldr	r3, [sp, #40]
 3862 0026 1BB9     		cbnz	r3, .L513
2759:lib/ff/ff.c   **** 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
 3863              		.loc 1 2759 0
 3864 0028 0799     		ldr	r1, [sp, #28]
 3865 002a 059B     		ldr	r3, [sp, #20]
 3866 002c 9961     		str	r1, [r3, #24]
 3867 002e 13E0     		b	.L519
 3868              	.L513:
2761:lib/ff/ff.c   **** 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
 3869              		.loc 1 2761 0
 3870 0030 DA7A     		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 3871 0032 02F01001 		and	r1, r2, #16
 3872 0036 CAB2     		uxtb	r2, r1
 3873 0038 6AB1     		cbz	r2, .L517
2762:lib/ff/ff.c   **** 					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
 3874              		.loc 1 2762 0
 3875 003a 0599     		ldr	r1, [sp, #20]
 3876              	.LVL557:
 3877              	.LBB91:
 3878              	.LBB92:
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 3879              		.loc 1 1190 0
 3880 003c 5A8B     		ldrh	r2, [r3, #26]
 3881              	.LVL558:
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 3882              		.loc 1 1191 0
 3883 003e 0C78     		ldrb	r4, [r1, #0]	@ zero_extendqisi2
 3884 0040 032C     		cmp	r4, #3
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 3885              		.loc 1 1192 0
 3886 0042 04BF     		itt	eq
 3887 0044 9B8A     		ldrheq	r3, [r3, #20]
 3888              	.LVL559:
 3889 0046 42EA0342 		orreq	r2, r2, r3, lsl #16
 3890              	.LVL560:
 3891              	.LBE92:
 3892              	.LBE91:
2762:lib/ff/ff.c   **** 					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
 3893              		.loc 1 2762 0
 3894 004a 8A61     		str	r2, [r1, #24]
 3895 004c 04E0     		b	.L519
 3896              	.LVL561:
 3897              	.L512:
2767:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
 3898              		.loc 1 2767 0
 3899 004e 0428     		cmp	r0, #4
 3900 0050 08BF     		it	eq
 3901 0052 0520     		moveq	r0, #5
 3902              	.LVL562:
 3903 0054 00E0     		b	.L519
 3904              	.LVL563:
 3905              	.L517:
2764:lib/ff/ff.c   **** 					res = FR_NO_PATH;		/* Reached but a file */
 3906              		.loc 1 2764 0
 3907 0056 0520     		movs	r0, #5
 3908              	.LVL564:
 3909              	.L519:
2771:lib/ff/ff.c   **** }
 3910              		.loc 1 2771 0
 3911 0058 0CB0     		add	sp, sp, #48
 3912 005a 10BD     		pop	{r4, pc}
 3913              		.cfi_endproc
 3914              	.LFE33:
 3916              		.section	.text.f_getcwd,"ax",%progbits
 3917              		.align	1
 3918              		.global	f_getcwd
 3919              		.thumb
 3920              		.thumb_func
 3922              	f_getcwd:
 3923              	.LFB34:
2779:lib/ff/ff.c   **** {
 3924              		.loc 1 2779 0
 3925              		.cfi_startproc
 3926              		@ args = 0, pretend = 0, frame = 72
 3927              		@ frame_needed = 0, uses_anonymous_args = 0
 3928              	.LVL565:
 3929 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 3930              	.LCFI25:
 3931              		.cfi_def_cfa_offset 20
 3932              		.cfi_offset 4, -20
 3933              		.cfi_offset 5, -16
 3934              		.cfi_offset 6, -12
 3935              		.cfi_offset 7, -8
 3936              		.cfi_offset 14, -4
 3937 0002 93B0     		sub	sp, sp, #76
 3938              	.LCFI26:
 3939              		.cfi_def_cfa_offset 96
 3940 0004 12AB     		add	r3, sp, #72
 3941 0006 43F8440D 		str	r0, [r3, #-68]!
 3942 000a 0E46     		mov	r6, r1
2789:lib/ff/ff.c   **** 	*path = 0;
 3943              		.loc 1 2789 0
 3944 000c 0022     		movs	r2, #0
 3945 000e 0270     		strb	r2, [r0, #0]
 3946              	.LVL566:
2790:lib/ff/ff.c   **** 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
 3947              		.loc 1 2790 0
 3948 0010 1846     		mov	r0, r3
 3949 0012 0BA9     		add	r1, sp, #44
 3950              	.LVL567:
 3951 0014 FFF7FEFF 		bl	chk_mounted
 3952              	.LVL568:
2791:lib/ff/ff.c   **** 	if (res == FR_OK) {
 3953              		.loc 1 2791 0
 3954 0018 0546     		mov	r5, r0
 3955 001a 0028     		cmp	r0, #0
 3956 001c 7BD1     		bne	.L521
2792:lib/ff/ff.c   **** 		INIT_BUF(dj);
 3957              		.loc 1 2792 0
 3958 001e 02A8     		add	r0, sp, #8
 3959              	.LVL569:
 3960 0020 1190     		str	r0, [sp, #68]
 3961              	.LVL570:
2794:lib/ff/ff.c   **** 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
 3962              		.loc 1 2794 0
 3963 0022 0B99     		ldr	r1, [sp, #44]
 3964 0024 8A69     		ldr	r2, [r1, #24]
 3965 0026 0D92     		str	r2, [sp, #52]
2795:lib/ff/ff.c   **** 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
 3966              		.loc 1 2795 0
 3967 0028 3446     		mov	r4, r6
 3968              	.LVL571:
 3969              	.L522:
2795:lib/ff/ff.c   **** 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
 3970              		.loc 1 2795 0 is_stmt 0 discriminator 1
 3971 002a 0D9F     		ldr	r7, [sp, #52]
 3972              	.LVL572:
 3973 002c 002F     		cmp	r7, #0
 3974 002e 59D0     		beq	.L523
 3975              	.L533:
2796:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 1);			/* Get parent dir */
 3976              		.loc 1 2796 0 is_stmt 1
 3977 0030 0BA8     		add	r0, sp, #44
 3978 0032 0121     		movs	r1, #1
 3979 0034 FFF7FEFF 		bl	dir_sdi
 3980              	.LVL573:
2797:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 3981              		.loc 1 2797 0
 3982 0038 0028     		cmp	r0, #0
 3983 003a 50D1     		bne	.L539
2798:lib/ff/ff.c   **** 			res = dir_read(&dj);
 3984              		.loc 1 2798 0
 3985 003c 0BA8     		add	r0, sp, #44
 3986              	.LVL574:
 3987 003e FFF7FEFF 		bl	dir_read
 3988              	.LVL575:
2799:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 3989              		.loc 1 2799 0
 3990 0042 0028     		cmp	r0, #0
 3991 0044 4BD1     		bne	.L539
2800:lib/ff/ff.c   **** 			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
 3992              		.loc 1 2800 0
 3993 0046 1098     		ldr	r0, [sp, #64]
 3994              	.LVL576:
 3995              	.LBB97:
 3996              	.LBB98:
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 3997              		.loc 1 1190 0
 3998 0048 438B     		ldrh	r3, [r0, #26]
 3999              	.LVL577:
 4000              		.loc 1 4136 0
 4001 004a 0B99     		ldr	r1, [sp, #44]
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 4002              		.loc 1 1191 0
 4003 004c 0A78     		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 4004 004e 032A     		cmp	r2, #3
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 4005              		.loc 1 1192 0
 4006 0050 04BF     		itt	eq
 4007 0052 808A     		ldrheq	r0, [r0, #20]
 4008              	.LVL578:
 4009 0054 43EA0043 		orreq	r3, r3, r0, lsl #16
 4010              	.LVL579:
 4011              	.LBE98:
 4012              	.LBE97:
2800:lib/ff/ff.c   **** 			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
 4013              		.loc 1 2800 0
 4014 0058 0D93     		str	r3, [sp, #52]
2801:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 0);
 4015              		.loc 1 2801 0
 4016 005a 0BA8     		add	r0, sp, #44
 4017 005c 0021     		movs	r1, #0
 4018 005e FFF7FEFF 		bl	dir_sdi
 4019              	.LVL580:
2802:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 4020              		.loc 1 2802 0
 4021 0062 0028     		cmp	r0, #0
 4022 0064 3BD1     		bne	.L539
 4023              	.L544:
2804:lib/ff/ff.c   **** 				res = dir_read(&dj);
 4024              		.loc 1 2804 0
 4025 0066 0BA8     		add	r0, sp, #44
 4026              	.LVL581:
 4027 0068 FFF7FEFF 		bl	dir_read
 4028              	.LVL582:
2805:lib/ff/ff.c   **** 				if (res != FR_OK) break;
 4029              		.loc 1 2805 0
 4030 006c A8B9     		cbnz	r0, .L525
2806:lib/ff/ff.c   **** 				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
 4031              		.loc 1 2806 0
 4032 006e 1098     		ldr	r0, [sp, #64]
 4033              	.LVL583:
 4034              	.LBB99:
 4035              	.LBB100:
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 4036              		.loc 1 1190 0
 4037 0070 438B     		ldrh	r3, [r0, #26]
 4038              	.LVL584:
 4039              		.loc 1 4136 0
 4040 0072 0B99     		ldr	r1, [sp, #44]
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 4041              		.loc 1 1191 0
 4042 0074 0A78     		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 4043 0076 032A     		cmp	r2, #3
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 4044              		.loc 1 1192 0
 4045 0078 04BF     		itt	eq
 4046 007a 808A     		ldrheq	r0, [r0, #20]
 4047              	.LVL585:
 4048 007c 43EA0043 		orreq	r3, r3, r0, lsl #16
 4049              	.LVL586:
 4050              	.LBE100:
 4051              	.LBE99:
2815:lib/ff/ff.c   **** 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
 4052              		.loc 1 2815 0
 4053 0080 0BA8     		add	r0, sp, #44
2806:lib/ff/ff.c   **** 				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
 4054              		.loc 1 2806 0
 4055 0082 9F42     		cmp	r7, r3
 4056 0084 04D1     		bne	.L527
2815:lib/ff/ff.c   **** 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
 4057              		.loc 1 2815 0
 4058 0086 05A9     		add	r1, sp, #20
 4059 0088 FFF7FEFF 		bl	get_fileinfo
 4060              	.LVL587:
2818:lib/ff/ff.c   **** 			for (n = 0; tp[n]; n++) ;
 4061              		.loc 1 2818 0
 4062 008c 0023     		movs	r3, #0
 4063 008e 09E0     		b	.L528
 4064              	.LVL588:
 4065              	.L527:
2807:lib/ff/ff.c   **** 				res = dir_next(&dj, 0);	
 4066              		.loc 1 2807 0
 4067 0090 0021     		movs	r1, #0
 4068 0092 FFF7FEFF 		bl	dir_next
 4069              	.LVL589:
2808:lib/ff/ff.c   **** 			} while (res == FR_OK);
 4070              		.loc 1 2808 0
 4071 0096 0028     		cmp	r0, #0
 4072 0098 E5D0     		beq	.L544
 4073              	.L525:
2809:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
 4074              		.loc 1 2809 0
 4075 009a 0428     		cmp	r0, #4
 4076 009c 14BF     		ite	ne
 4077 009e 0546     		movne	r5, r0
 4078 00a0 0225     		moveq	r5, #2
 4079 00a2 1FE0     		b	.L523
 4080              	.LVL590:
 4081              	.L528:
2775:lib/ff/ff.c   **** FRESULT f_getcwd (
 4082              		.loc 1 2775 0 discriminator 1
 4083 00a4 05A8     		add	r0, sp, #20
 4084 00a6 C118     		adds	r1, r0, r3
2818:lib/ff/ff.c   **** 			for (n = 0; tp[n]; n++) ;
 4085              		.loc 1 2818 0 discriminator 1
 4086 00a8 91F90920 		ldrsb	r2, [r1, #9]
 4087 00ac 0AB1     		cbz	r2, .L549
 4088              	.L530:
2818:lib/ff/ff.c   **** 			for (n = 0; tp[n]; n++) ;
 4089              		.loc 1 2818 0 is_stmt 0 discriminator 2
 4090 00ae 0133     		adds	r3, r3, #1
 4091              	.LVL591:
 4092 00b0 F8E7     		b	.L528
 4093              	.L549:
2818:lib/ff/ff.c   **** 			for (n = 0; tp[n]; n++) ;
 4094              		.loc 1 2818 0
 4095 00b2 1A46     		mov	r2, r3
2819:lib/ff/ff.c   **** 			if (i < n + 3) {
 4096              		.loc 1 2819 0 is_stmt 1
 4097 00b4 D81C     		adds	r0, r3, #3
 4098 00b6 8442     		cmp	r4, r0
 4099 00b8 13D3     		bcc	.L550
 4100              	.LVL592:
 4101              	.L548:
2822:lib/ff/ff.c   **** 			while (n) path[--i] = tp[--n];
 4102              		.loc 1 2822 0 discriminator 1
 4103 00ba 13F1FF33 		adds	r3, r3, #-1
 4104 00be 08D3     		bcc	.L551
 4105              	.L532:
 4106              	.LVL593:
2822:lib/ff/ff.c   **** 			while (n) path[--i] = tp[--n];
 4107              		.loc 1 2822 0 is_stmt 0 discriminator 2
 4108 00c0 12A8     		add	r0, sp, #72
 4109 00c2 C718     		adds	r7, r0, r3
 4110 00c4 17F82B7C 		ldrb	r7, [r7, #-43]	@ zero_extendqisi2
2775:lib/ff/ff.c   **** FRESULT f_getcwd (
 4111              		.loc 1 2775 0 is_stmt 1 discriminator 2
 4112 00c8 E118     		adds	r1, r4, r3
 4113 00ca 881A     		subs	r0, r1, r2
 4114              	.LVL594:
2822:lib/ff/ff.c   **** 			while (n) path[--i] = tp[--n];
 4115              		.loc 1 2822 0 discriminator 2
 4116 00cc 0199     		ldr	r1, [sp, #4]
 4117 00ce 0F54     		strb	r7, [r1, r0]
 4118 00d0 F3E7     		b	.L548
 4119              	.LVL595:
 4120              	.L551:
 4121 00d2 D743     		mvns	r7, r2
2823:lib/ff/ff.c   **** 			path[--i] = '/';
 4122              		.loc 1 2823 0
 4123 00d4 E419     		adds	r4, r4, r7
 4124              	.LVL596:
 4125 00d6 2F21     		movs	r1, #47
 4126 00d8 019A     		ldr	r2, [sp, #4]
 4127 00da 1155     		strb	r1, [r2, r4]
 4128 00dc A5E7     		b	.L522
 4129              	.LVL597:
 4130              	.L539:
2801:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 0);
 4131              		.loc 1 2801 0
 4132 00de 0546     		mov	r5, r0
 4133 00e0 00E0     		b	.L523
 4134              	.LVL598:
 4135              	.L550:
2820:lib/ff/ff.c   **** 				res = FR_NOT_ENOUGH_CORE; break;
 4136              		.loc 1 2820 0
 4137 00e2 1125     		movs	r5, #17
 4138              	.LVL599:
 4139              	.L523:
2825:lib/ff/ff.c   **** 		tp = path;
 4140              		.loc 1 2825 0
 4141 00e4 019B     		ldr	r3, [sp, #4]
 4142              	.LVL600:
2826:lib/ff/ff.c   **** 		if (res == FR_OK) {
 4143              		.loc 1 2826 0
 4144 00e6 A5B9     		cbnz	r5, .L534
2827:lib/ff/ff.c   **** 			*tp++ = '0' + CurrVol;			/* Put drive number */
 4145              		.loc 1 2827 0
 4146 00e8 0C4A     		ldr	r2, .L552
 4147 00ea 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 4148 00ec 3030     		adds	r0, r0, #48
 4149 00ee 1870     		strb	r0, [r3, #0]
 4150              	.LVL601:
2828:lib/ff/ff.c   **** 			*tp++ = ':';
 4151              		.loc 1 2828 0
 4152 00f0 3A21     		movs	r1, #58
 4153 00f2 5970     		strb	r1, [r3, #1]
 4154              	.LVL602:
2829:lib/ff/ff.c   **** 			if (i == sz_path) {				/* Root-dir */
 4155              		.loc 1 2829 0
 4156 00f4 B442     		cmp	r4, r6
 4157 00f6 03D1     		bne	.L535
2830:lib/ff/ff.c   **** 				*tp++ = '/';
 4158              		.loc 1 2830 0
 4159 00f8 2F21     		movs	r1, #47
 4160 00fa 9970     		strb	r1, [r3, #2]
 4161 00fc 0333     		adds	r3, r3, #3
 4162              	.LVL603:
 4163 00fe 08E0     		b	.L534
 4164              	.LVL604:
 4165              	.L535:
2828:lib/ff/ff.c   **** 			*tp++ = ':';
 4166              		.loc 1 2828 0
 4167 0100 9A1C     		adds	r2, r3, #2
 4168              	.LVL605:
 4169              	.L536:
2833:lib/ff/ff.c   **** 					*tp++ = path[i++];
 4170              		.loc 1 2833 0 discriminator 1
 4171 0102 019B     		ldr	r3, [sp, #4]
 4172              	.LVL606:
 4173 0104 185D     		ldrb	r0, [r3, r4]	@ zero_extendqisi2
 4174 0106 02F8010B 		strb	r0, [r2], #1
 4175 010a 1346     		mov	r3, r2
 4176              	.LVL607:
 4177 010c 0134     		adds	r4, r4, #1
 4178              	.LVL608:
2834:lib/ff/ff.c   **** 				while (i < sz_path);
 4179              		.loc 1 2834 0 discriminator 1
 4180 010e B442     		cmp	r4, r6
 4181 0110 F7D3     		bcc	.L536
 4182              	.LVL609:
 4183              	.L534:
2837:lib/ff/ff.c   **** 		*tp = 0;
 4184              		.loc 1 2837 0
 4185 0112 0022     		movs	r2, #0
 4186 0114 1A70     		strb	r2, [r3, #0]
 4187              	.LVL610:
 4188              	.L521:
2842:lib/ff/ff.c   **** }
 4189              		.loc 1 2842 0
 4190 0116 2846     		mov	r0, r5
 4191 0118 13B0     		add	sp, sp, #76
 4192 011a F0BD     		pop	{r4, r5, r6, r7, pc}
 4193              	.L553:
 4194              		.align	2
 4195              	.L552:
 4196 011c 00000000 		.word	.LANCHOR0
 4197              		.cfi_endproc
 4198              	.LFE34:
 4200              		.section	.text.f_lseek,"ax",%progbits
 4201              		.align	1
 4202              		.global	f_lseek
 4203              		.thumb
 4204              		.thumb_func
 4206              	f_lseek:
 4207              	.LFB35:
2857:lib/ff/ff.c   **** {
 4208              		.loc 1 2857 0
 4209              		.cfi_startproc
 4210              		@ args = 0, pretend = 0, frame = 0
 4211              		@ frame_needed = 0, uses_anonymous_args = 0
 4212              	.LVL611:
 4213 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4214              	.LCFI27:
 4215              		.cfi_def_cfa_offset 40
 4216              		.cfi_offset 3, -40
 4217              		.cfi_offset 4, -36
 4218              		.cfi_offset 5, -32
 4219              		.cfi_offset 6, -28
 4220              		.cfi_offset 7, -24
 4221              		.cfi_offset 8, -20
 4222              		.cfi_offset 9, -16
 4223              		.cfi_offset 10, -12
 4224              		.cfi_offset 11, -8
 4225              		.cfi_offset 14, -4
 4226 0004 0446     		mov	r4, r0
 4227 0006 0D46     		mov	r5, r1
2861:lib/ff/ff.c   **** 	res = validate(fp);					/* Check validity of the object */
 4228              		.loc 1 2861 0
 4229 0008 FFF7FEFF 		bl	validate
 4230              	.LVL612:
2862:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 4231              		.loc 1 2862 0
 4232 000c 0646     		mov	r6, r0
 4233 000e 0028     		cmp	r0, #0
 4234 0010 40F0DA80 		bne	.L555
2863:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)			/* Check abort flag */
 4235              		.loc 1 2863 0
 4236 0014 A779     		ldrb	r7, [r4, #6]	@ zero_extendqisi2
 4237 0016 3806     		lsls	r0, r7, #24
 4238              	.LVL613:
 4239 0018 00F1D380 		bmi	.L586
2867:lib/ff/ff.c   **** 	if (fp->cltbl) {	/* Fast seek */
 4240              		.loc 1 2867 0
 4241 001c 636A     		ldr	r3, [r4, #36]
 4242 001e 002B     		cmp	r3, #0
 4243 0020 5CD0     		beq	.L556
 4244              	.LBB101:
2870:lib/ff/ff.c   **** 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 4245              		.loc 1 2870 0
 4246 0022 691C     		adds	r1, r5, #1
 4247 0024 32D1     		bne	.L557
 4248              	.LVL614:
2872:lib/ff/ff.c   **** 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 4249              		.loc 1 2872 0
 4250 0026 1D46     		mov	r5, r3
 4251              	.LVL615:
 4252 0028 55F804BB 		ldr	fp, [r5], #4
 4253              	.LVL616:
2873:lib/ff/ff.c   **** 			cl = fp->sclust;			/* Top of the chain */
 4254              		.loc 1 2873 0
 4255 002c D4F81080 		ldr	r8, [r4, #16]
 4256              	.LVL617:
2874:lib/ff/ff.c   **** 			if (cl) {
 4257              		.loc 1 2874 0
 4258 0030 0227     		movs	r7, #2
 4259 0032 B8F1000F 		cmp	r8, #0
 4260 0036 21D0     		beq	.L558
 4261              	.LVL618:
 4262              	.L563:
2880:lib/ff/ff.c   **** 						cl = get_fat(fp->fs, cl);
 4263              		.loc 1 2880 0
 4264 0038 C146     		mov	r9, r8
2877:lib/ff/ff.c   **** 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 4265              		.loc 1 2877 0
 4266 003a 4FF0000A 		mov	sl, #0
 4267              	.LVL619:
 4268              	.L561:
2879:lib/ff/ff.c   **** 						pcl = cl; ncl++;
 4269              		.loc 1 2879 0
 4270 003e 0AF1010A 		add	sl, sl, #1
 4271              	.LVL620:
2880:lib/ff/ff.c   **** 						cl = get_fat(fp->fs, cl);
 4272              		.loc 1 2880 0
 4273 0042 2068     		ldr	r0, [r4, #0]
 4274 0044 4946     		mov	r1, r9
 4275 0046 FFF7FEFF 		bl	get_fat
 4276              	.LVL621:
2881:lib/ff/ff.c   **** 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
 4277              		.loc 1 2881 0
 4278 004a 0128     		cmp	r0, #1
 4279 004c 40F2A280 		bls	.L610
 4280              	.L559:
2882:lib/ff/ff.c   **** 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4281              		.loc 1 2882 0
 4282 0050 421C     		adds	r2, r0, #1
 4283 0052 00F08B80 		beq	.L609
 4284              	.L560:
2883:lib/ff/ff.c   **** 					} while (cl == pcl + 1);
 4285              		.loc 1 2883 0
 4286 0056 09F10102 		add	r2, r9, #1
 4287 005a 8146     		mov	r9, r0
 4288              	.LVL622:
 4289 005c 9042     		cmp	r0, r2
 4290 005e EED0     		beq	.L561
2877:lib/ff/ff.c   **** 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 4291              		.loc 1 2877 0
 4292 0060 0237     		adds	r7, r7, #2
 4293              	.LVL623:
2884:lib/ff/ff.c   **** 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 4294              		.loc 1 2884 0
 4295 0062 5F45     		cmp	r7, fp
 4296 0064 04D8     		bhi	.L562
2885:lib/ff/ff.c   **** 						*tbl++ = ncl; *tbl++ = tcl;
 4297              		.loc 1 2885 0
 4298 0066 C5F800A0 		str	sl, [r5, #0]
 4299              	.LVL624:
 4300 006a C5F80480 		str	r8, [r5, #4]
 4301 006e 0835     		adds	r5, r5, #8
 4302              	.LVL625:
 4303              	.L562:
2887:lib/ff/ff.c   **** 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
 4304              		.loc 1 2887 0
 4305 0070 2168     		ldr	r1, [r4, #0]
 4306 0072 CB69     		ldr	r3, [r1, #28]
 4307 0074 9842     		cmp	r0, r3
 4308 0076 01D2     		bcs	.L558
 4309              	.L588:
2880:lib/ff/ff.c   **** 						cl = get_fat(fp->fs, cl);
 4310              		.loc 1 2880 0
 4311 0078 8046     		mov	r8, r0
 4312              	.LVL626:
 4313 007a DDE7     		b	.L563
 4314              	.LVL627:
 4315              	.L558:
2889:lib/ff/ff.c   **** 			*fp->cltbl = ulen;	/* Number of items used */
 4316              		.loc 1 2889 0
 4317 007c 606A     		ldr	r0, [r4, #36]
 4318 007e 0760     		str	r7, [r0, #0]
2890:lib/ff/ff.c   **** 			if (ulen <= tlen)
 4319              		.loc 1 2890 0
 4320 0080 5F45     		cmp	r7, fp
 4321 0082 00F2A080 		bhi	.L589
2891:lib/ff/ff.c   **** 				*tbl = 0;		/* Terminate table */
 4322              		.loc 1 2891 0
 4323 0086 0022     		movs	r2, #0
 4324 0088 2A60     		str	r2, [r5, #0]
 4325 008a 9DE0     		b	.L555
 4326              	.LVL628:
 4327              	.L557:
2896:lib/ff/ff.c   **** 			if (ofs > fp->fsize)		/* Clip offset at the file size */
 4328              		.loc 1 2896 0
 4329 008c E068     		ldr	r0, [r4, #12]
 4330 008e 8542     		cmp	r5, r0
 4331 0090 28BF     		it	cs
 4332 0092 0546     		movcs	r5, r0
 4333              	.LVL629:
2898:lib/ff/ff.c   **** 			fp->fptr = ofs;				/* Set file pointer */
 4334              		.loc 1 2898 0
 4335 0094 A560     		str	r5, [r4, #8]
2899:lib/ff/ff.c   **** 			if (ofs) {
 4336              		.loc 1 2899 0
 4337 0096 002D     		cmp	r5, #0
 4338 0098 00F09680 		beq	.L555
2900:lib/ff/ff.c   **** 				fp->clust = clmt_clust(fp, ofs - 1);
 4339              		.loc 1 2900 0
 4340 009c 05F1FF38 		add	r8, r5, #-1
 4341 00a0 2046     		mov	r0, r4
 4342 00a2 4146     		mov	r1, r8
 4343 00a4 FFF7FEFF 		bl	clmt_clust
 4344              	.LVL630:
 4345 00a8 0146     		mov	r1, r0
 4346 00aa 6061     		str	r0, [r4, #20]
2901:lib/ff/ff.c   **** 				dsc = clust2sect(fp->fs, fp->clust);
 4347              		.loc 1 2901 0
 4348 00ac D4F80090 		ldr	r9, [r4, #0]
 4349 00b0 4846     		mov	r0, r9
 4350 00b2 FFF7FEFF 		bl	clust2sect
 4351              	.LVL631:
2902:lib/ff/ff.c   **** 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
 4352              		.loc 1 2902 0
 4353 00b6 18B9     		cbnz	r0, .L565
2902:lib/ff/ff.c   **** 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
 4354              		.loc 1 2902 0 is_stmt 0 discriminator 1
 4355 00b8 67F07F07 		orn	r7, r7, #127
 4356 00bc A771     		strb	r7, [r4, #6]
 4357 00be 80E0     		b	.L586
 4358              	.L565:
2903:lib/ff/ff.c   **** 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
 4359              		.loc 1 2903 0 is_stmt 1
 4360 00c0 99F80220 		ldrb	r2, [r9, #2]	@ zero_extendqisi2
 4361              	.LVL632:
2904:lib/ff/ff.c   **** 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
 4362              		.loc 1 2904 0
 4363 00c4 ED05     		lsls	r5, r5, #23
 4364              	.LVL633:
 4365 00c6 7FD0     		beq	.L555
2903:lib/ff/ff.c   **** 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
 4366              		.loc 1 2903 0 discriminator 1
 4367 00c8 551E     		subs	r5, r2, #1
 4368 00ca 05EA5828 		and	r8, r5, r8, lsr #9
 4369              	.LVL634:
 4370 00ce 00EB0801 		add	r1, r0, r8
2904:lib/ff/ff.c   **** 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
 4371              		.loc 1 2904 0 discriminator 1
 4372 00d2 A369     		ldr	r3, [r4, #24]
 4373 00d4 9942     		cmp	r1, r3
 4374 00d6 77D0     		beq	.L555
2916:lib/ff/ff.c   **** 					fp->dsect = dsc;
 4375              		.loc 1 2916 0
 4376 00d8 A161     		str	r1, [r4, #24]
 4377 00da 75E0     		b	.L555
 4378              	.LVL635:
 4379              	.L556:
 4380              	.LBE101:
 4381              	.LBB102:
2927:lib/ff/ff.c   **** 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 4382              		.loc 1 2927 0
 4383 00dc E068     		ldr	r0, [r4, #12]
 4384 00de 8542     		cmp	r5, r0
 4385 00e0 05D9     		bls	.L567
2929:lib/ff/ff.c   **** 			 && !(fp->flag & FA_WRITE)
 4386              		.loc 1 2929 0
 4387 00e2 07F00207 		and	r7, r7, #2
 4388 00e6 FFB2     		uxtb	r7, r7
 4389 00e8 002F     		cmp	r7, #0
 4390 00ea 08BF     		it	eq
 4391 00ec 0546     		moveq	r5, r0
 4392              	.LVL636:
 4393              	.L567:
2933:lib/ff/ff.c   **** 		ifptr = fp->fptr;
 4394              		.loc 1 2933 0
 4395 00ee A168     		ldr	r1, [r4, #8]
 4396              	.LVL637:
2934:lib/ff/ff.c   **** 		fp->fptr = nsect = 0;
 4397              		.loc 1 2934 0
 4398 00f0 0022     		movs	r2, #0
 4399 00f2 A260     		str	r2, [r4, #8]
2935:lib/ff/ff.c   **** 		if (ofs) {
 4400              		.loc 1 2935 0
 4401 00f4 0DB9     		cbnz	r5, .L568
 4402              	.LVL638:
 4403              	.L575:
2934:lib/ff/ff.c   **** 		fp->fptr = nsect = 0;
 4404              		.loc 1 2934 0
 4405 00f6 0025     		movs	r5, #0
 4406              	.LVL639:
 4407 00f8 53E0     		b	.L569
 4408              	.LVL640:
 4409              	.L568:
2936:lib/ff/ff.c   **** 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 4410              		.loc 1 2936 0
 4411 00fa 2068     		ldr	r0, [r4, #0]
 4412 00fc 8378     		ldrb	r3, [r0, #2]	@ zero_extendqisi2
 4413 00fe 5F02     		lsls	r7, r3, #9
 4414              	.LVL641:
2937:lib/ff/ff.c   **** 			if (ifptr > 0 &&
 4415              		.loc 1 2937 0
 4416 0100 69B1     		cbz	r1, .L570
2938:lib/ff/ff.c   **** 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 4417              		.loc 1 2938 0 discriminator 1
 4418 0102 4B1E     		subs	r3, r1, #1
 4419 0104 691E     		subs	r1, r5, #1
 4420              	.LVL642:
 4421 0106 B1FBF7F1 		udiv	r1, r1, r7
 4422 010a B3FBF7F2 		udiv	r2, r3, r7
2937:lib/ff/ff.c   **** 			if (ifptr > 0 &&
 4423              		.loc 1 2937 0 discriminator 1
 4424 010e 9142     		cmp	r1, r2
 4425 0110 05D3     		bcc	.L570
2939:lib/ff/ff.c   **** 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 4426              		.loc 1 2939 0
 4427 0112 7842     		negs	r0, r7
 4428 0114 0340     		ands	r3, r3, r0
 4429 0116 A360     		str	r3, [r4, #8]
2940:lib/ff/ff.c   **** 				ofs -= fp->fptr;
 4430              		.loc 1 2940 0
 4431 0118 ED1A     		subs	r5, r5, r3
 4432              	.LVL643:
2941:lib/ff/ff.c   **** 				clst = fp->clust;
 4433              		.loc 1 2941 0
 4434 011a 6169     		ldr	r1, [r4, #20]
 4435              	.LVL644:
 4436 011c 0AE0     		b	.L571
 4437              	.LVL645:
 4438              	.L570:
2943:lib/ff/ff.c   **** 				clst = fp->sclust;						/* start from the first cluster */
 4439              		.loc 1 2943 0
 4440 011e 2169     		ldr	r1, [r4, #16]
 4441              	.LVL646:
2945:lib/ff/ff.c   **** 				if (clst == 0) {						/* If no cluster chain, create a new chain */
 4442              		.loc 1 2945 0
 4443 0120 39B9     		cbnz	r1, .L572
2946:lib/ff/ff.c   **** 					clst = create_chain(fp->fs, 0);
 4444              		.loc 1 2946 0
 4445 0122 FFF7FEFF 		bl	create_chain
 4446              	.LVL647:
 4447 0126 0146     		mov	r1, r0
 4448              	.LVL648:
2947:lib/ff/ff.c   **** 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 4449              		.loc 1 2947 0
 4450 0128 0128     		cmp	r0, #1
 4451 012a 33D0     		beq	.L610
 4452              	.L573:
2948:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4453              		.loc 1 2948 0
 4454 012c 431C     		adds	r3, r0, #1
 4455 012e 1DD0     		beq	.L609
 4456              	.L574:
2949:lib/ff/ff.c   **** 					fp->sclust = clst;
 4457              		.loc 1 2949 0
 4458 0130 2061     		str	r0, [r4, #16]
 4459              	.LVL649:
 4460              	.L572:
2952:lib/ff/ff.c   **** 				fp->clust = clst;
 4461              		.loc 1 2952 0
 4462 0132 6161     		str	r1, [r4, #20]
 4463              	.L571:
2954:lib/ff/ff.c   **** 			if (clst != 0) {
 4464              		.loc 1 2954 0
 4465 0134 0029     		cmp	r1, #0
 4466 0136 DED0     		beq	.L575
 4467 0138 0AE0     		b	.L608
 4468              	.L580:
2966:lib/ff/ff.c   **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 4469              		.loc 1 2966 0
 4470 013a 0129     		cmp	r1, #1
 4471 013c 2AD9     		bls	.L610
2966:lib/ff/ff.c   **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 4472              		.loc 1 2966 0 is_stmt 0 discriminator 2
 4473 013e 2068     		ldr	r0, [r4, #0]
 4474 0140 C269     		ldr	r2, [r0, #28]
 4475 0142 9142     		cmp	r1, r2
 4476 0144 26D2     		bcs	.L610
 4477              	.L582:
2967:lib/ff/ff.c   **** 					fp->clust = clst;
 4478              		.loc 1 2967 0 is_stmt 1
 4479 0146 6161     		str	r1, [r4, #20]
2968:lib/ff/ff.c   **** 					fp->fptr += bcs;
 4480              		.loc 1 2968 0
 4481 0148 A368     		ldr	r3, [r4, #8]
 4482 014a D819     		adds	r0, r3, r7
 4483 014c A060     		str	r0, [r4, #8]
2969:lib/ff/ff.c   **** 					ofs -= bcs;
 4484              		.loc 1 2969 0
 4485 014e ED1B     		subs	r5, r5, r7
 4486              	.LVL650:
 4487              	.L608:
2955:lib/ff/ff.c   **** 				while (ofs > bcs) {						/* Cluster following loop */
 4488              		.loc 1 2955 0 discriminator 1
 4489 0150 BD42     		cmp	r5, r7
 4490 0152 16D9     		bls	.L578
 4491              	.L583:
2957:lib/ff/ff.c   **** 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 4492              		.loc 1 2957 0
 4493 0154 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4494 0156 03F00202 		and	r2, r3, #2
 4495 015a D3B2     		uxtb	r3, r2
2958:lib/ff/ff.c   **** 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 4496              		.loc 1 2958 0
 4497 015c 2068     		ldr	r0, [r4, #0]
2957:lib/ff/ff.c   **** 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 4498              		.loc 1 2957 0
 4499 015e 5BB1     		cbz	r3, .L577
2958:lib/ff/ff.c   **** 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 4500              		.loc 1 2958 0
 4501 0160 FFF7FEFF 		bl	create_chain
 4502              	.LVL651:
2959:lib/ff/ff.c   **** 						if (clst == 0) {				/* When disk gets full, clip file size */
 4503              		.loc 1 2959 0
 4504 0164 0146     		mov	r1, r0
 4505 0166 58B1     		cbz	r0, .L611
 4506              	.L579:
2965:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4507              		.loc 1 2965 0
 4508 0168 481C     		adds	r0, r1, #1
 4509              	.LVL652:
 4510 016a E6D1     		bne	.L580
 4511              	.LVL653:
 4512              	.L609:
2965:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4513              		.loc 1 2965 0 is_stmt 0 discriminator 1
 4514 016c A679     		ldrb	r6, [r4, #6]	@ zero_extendqisi2
 4515 016e 66F07F01 		orn	r1, r6, #127
 4516 0172 A171     		strb	r1, [r4, #6]
 4517 0174 0126     		movs	r6, #1
 4518 0176 27E0     		b	.L555
 4519              	.LVL654:
 4520              	.L577:
2964:lib/ff/ff.c   **** 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
 4521              		.loc 1 2964 0 is_stmt 1
 4522 0178 FFF7FEFF 		bl	get_fat
 4523              	.LVL655:
 4524 017c 0146     		mov	r1, r0
 4525              	.LVL656:
 4526 017e F3E7     		b	.L579
 4527              	.L611:
2959:lib/ff/ff.c   **** 						if (clst == 0) {				/* When disk gets full, clip file size */
 4528              		.loc 1 2959 0
 4529 0180 3D46     		mov	r5, r7
 4530              	.LVL657:
 4531              	.L578:
2971:lib/ff/ff.c   **** 				fp->fptr += ofs;
 4532              		.loc 1 2971 0
 4533 0182 A268     		ldr	r2, [r4, #8]
 4534 0184 5319     		adds	r3, r2, r5
 4535 0186 A360     		str	r3, [r4, #8]
2972:lib/ff/ff.c   **** 				if (ofs % SS(fp->fs)) {
 4536              		.loc 1 2972 0
 4537 0188 EA05     		lsls	r2, r5, #23
 4538 018a B4D0     		beq	.L575
2973:lib/ff/ff.c   **** 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
 4539              		.loc 1 2973 0
 4540 018c 2068     		ldr	r0, [r4, #0]
 4541 018e FFF7FEFF 		bl	clust2sect
 4542              	.LVL658:
2974:lib/ff/ff.c   **** 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 4543              		.loc 1 2974 0
 4544 0192 20B9     		cbnz	r0, .L584
 4545              	.LVL659:
 4546              	.L610:
2974:lib/ff/ff.c   **** 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 4547              		.loc 1 2974 0 is_stmt 0 discriminator 1
 4548 0194 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4549 0196 63F07F00 		orn	r0, r3, #127
 4550 019a A071     		strb	r0, [r4, #6]
 4551 019c 11E0     		b	.L586
 4552              	.LVL660:
 4553              	.L584:
2975:lib/ff/ff.c   **** 					nsect += ofs / SS(fp->fs);
 4554              		.loc 1 2975 0 is_stmt 1
 4555 019e 00EB5525 		add	r5, r0, r5, lsr #9
 4556              	.LVL661:
 4557              	.L569:
2979:lib/ff/ff.c   **** 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
 4558              		.loc 1 2979 0
 4559 01a2 A168     		ldr	r1, [r4, #8]
 4560 01a4 CA05     		lsls	r2, r1, #23
 4561 01a6 03D0     		beq	.L585
2979:lib/ff/ff.c   **** 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
 4562              		.loc 1 2979 0 is_stmt 0 discriminator 1
 4563 01a8 A069     		ldr	r0, [r4, #24]
 4564 01aa 8542     		cmp	r5, r0
2991:lib/ff/ff.c   **** 			fp->dsect = nsect;
 4565              		.loc 1 2991 0 is_stmt 1 discriminator 1
 4566 01ac 18BF     		it	ne
 4567 01ae A561     		strne	r5, [r4, #24]
 4568              	.L585:
2994:lib/ff/ff.c   **** 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
 4569              		.loc 1 2994 0
 4570 01b0 E268     		ldr	r2, [r4, #12]
 4571 01b2 9142     		cmp	r1, r2
 4572 01b4 08D9     		bls	.L555
2995:lib/ff/ff.c   **** 			fp->fsize = fp->fptr;
 4573              		.loc 1 2995 0
 4574 01b6 E160     		str	r1, [r4, #12]
2996:lib/ff/ff.c   **** 			fp->flag |= FA__WRITTEN;
 4575              		.loc 1 2996 0
 4576 01b8 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4577 01ba 43F02001 		orr	r1, r3, #32
 4578 01be A171     		strb	r1, [r4, #6]
 4579 01c0 02E0     		b	.L555
 4580              	.LVL662:
 4581              	.L586:
 4582              	.LBE102:
2864:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 4583              		.loc 1 2864 0
 4584 01c2 0226     		movs	r6, #2
 4585 01c4 00E0     		b	.L555
 4586              	.LVL663:
 4587              	.L589:
 4588              	.LBB103:
2893:lib/ff/ff.c   **** 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 4589              		.loc 1 2893 0
 4590 01c6 1126     		movs	r6, #17
 4591              	.LVL664:
 4592              	.L555:
 4593              	.LBE103:
3002:lib/ff/ff.c   **** }
 4594              		.loc 1 3002 0
 4595 01c8 3046     		mov	r0, r6
 4596 01ca BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 4597              		.cfi_endproc
 4598              	.LFE35:
 4600              		.section	.text.f_opendir,"ax",%progbits
 4601              		.align	1
 4602              		.global	f_opendir
 4603              		.thumb
 4604              		.thumb_func
 4606              	f_opendir:
 4607              	.LFB36:
3015:lib/ff/ff.c   **** {
 4608              		.loc 1 3015 0
 4609              		.cfi_startproc
 4610              		@ args = 0, pretend = 0, frame = 24
 4611              		@ frame_needed = 0, uses_anonymous_args = 0
 4612              	.LVL665:
 4613 0000 30B5     		push	{r4, r5, lr}
 4614              	.LCFI28:
 4615              		.cfi_def_cfa_offset 12
 4616              		.cfi_offset 4, -12
 4617              		.cfi_offset 5, -8
 4618              		.cfi_offset 14, -4
 4619 0002 87B0     		sub	sp, sp, #28
 4620              	.LCFI29:
 4621              		.cfi_def_cfa_offset 40
 4622 0004 0191     		str	r1, [sp, #4]
3021:lib/ff/ff.c   **** 	if (!dj) return FR_INVALID_OBJECT;
 4623              		.loc 1 3021 0
 4624 0006 0446     		mov	r4, r0
 4625 0008 50B3     		cbz	r0, .L619
3023:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj->fs, 0);
 4626              		.loc 1 3023 0
 4627 000a 01A8     		add	r0, sp, #4
 4628              	.LVL666:
 4629 000c 2146     		mov	r1, r4
 4630 000e 0022     		movs	r2, #0
 4631 0010 FFF7FEFF 		bl	chk_mounted
 4632              	.LVL667:
3024:lib/ff/ff.c   **** 	fs = dj->fs;
 4633              		.loc 1 3024 0
 4634 0014 2568     		ldr	r5, [r4, #0]
 4635              	.LVL668:
3025:lib/ff/ff.c   **** 	if (res == FR_OK) {
 4636              		.loc 1 3025 0
 4637 0016 00BB     		cbnz	r0, .L614
3026:lib/ff/ff.c   **** 		INIT_BUF(*dj);
 4638              		.loc 1 3026 0
 4639 0018 03AB     		add	r3, sp, #12
 4640 001a A361     		str	r3, [r4, #24]
3027:lib/ff/ff.c   **** 		res = follow_path(dj, path);			/* Follow the path to the directory */
 4641              		.loc 1 3027 0
 4642 001c 2046     		mov	r0, r4
 4643              	.LVL669:
 4644 001e 0199     		ldr	r1, [sp, #4]
 4645 0020 FFF7FEFF 		bl	follow_path
 4646              	.LVL670:
3029:lib/ff/ff.c   **** 		if (res == FR_OK) {						/* Follow completed */
 4647              		.loc 1 3029 0
 4648 0024 A0B9     		cbnz	r0, .L615
3030:lib/ff/ff.c   **** 			if (dj->dir) {						/* It is not the root dir */
 4649              		.loc 1 3030 0
 4650 0026 6069     		ldr	r0, [r4, #20]
 4651              	.LVL671:
 4652 0028 60B1     		cbz	r0, .L616
3031:lib/ff/ff.c   **** 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
 4653              		.loc 1 3031 0
 4654 002a C27A     		ldrb	r2, [r0, #11]	@ zero_extendqisi2
 4655 002c 02F01001 		and	r1, r2, #16
 4656 0030 CBB2     		uxtb	r3, r1
 4657 0032 8BB1     		cbz	r3, .L621
 4658              	.LVL672:
 4659              	.LBB106:
 4660              	.LBB107:
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 4661              		.loc 1 1190 0
 4662 0034 428B     		ldrh	r2, [r0, #26]
 4663              	.LVL673:
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 4664              		.loc 1 1191 0
 4665 0036 2978     		ldrb	r1, [r5, #0]	@ zero_extendqisi2
 4666 0038 0329     		cmp	r1, #3
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 4667              		.loc 1 1192 0
 4668 003a 04BF     		itt	eq
 4669 003c 808A     		ldrheq	r0, [r0, #20]
 4670              	.LVL674:
 4671 003e 42EA0042 		orreq	r2, r2, r0, lsl #16
 4672              	.LVL675:
 4673              	.LBE107:
 4674              	.LBE106:
3032:lib/ff/ff.c   **** 					dj->sclust = ld_clust(fs, dj->dir);
 4675              		.loc 1 3032 0
 4676 0042 A260     		str	r2, [r4, #8]
 4677              	.LVL676:
 4678              	.L616:
3038:lib/ff/ff.c   **** 				dj->id = fs->id;
 4679              		.loc 1 3038 0
 4680 0044 E888     		ldrh	r0, [r5, #6]
 4681 0046 A080     		strh	r0, [r4, #4]	@ movhi
3039:lib/ff/ff.c   **** 				res = dir_sdi(dj, 0);			/* Rewind dir */
 4682              		.loc 1 3039 0
 4683 0048 2046     		mov	r0, r4
 4684 004a 0021     		movs	r1, #0
 4685 004c FFF7FEFF 		bl	dir_sdi
 4686              	.LVL677:
 4687              	.L615:
3042:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
 4688              		.loc 1 3042 0
 4689 0050 0428     		cmp	r0, #4
 4690 0052 01D0     		beq	.L621
3043:lib/ff/ff.c   **** 		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
 4691              		.loc 1 3043 0
 4692 0054 28B1     		cbz	r0, .L624
 4693 0056 00E0     		b	.L614
 4694              	.LVL678:
 4695              	.L621:
3042:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
 4696              		.loc 1 3042 0
 4697 0058 0520     		movs	r0, #5
 4698              	.L614:
3045:lib/ff/ff.c   **** 		dj->fs = 0;
 4699              		.loc 1 3045 0
 4700 005a 0023     		movs	r3, #0
 4701 005c 2360     		str	r3, [r4, #0]
 4702 005e 00E0     		b	.L624
 4703              	.LVL679:
 4704              	.L619:
3021:lib/ff/ff.c   **** 	if (!dj) return FR_INVALID_OBJECT;
 4705              		.loc 1 3021 0
 4706 0060 0920     		movs	r0, #9
 4707              	.LVL680:
 4708              	.L624:
3049:lib/ff/ff.c   **** }
 4709              		.loc 1 3049 0
 4710 0062 07B0     		add	sp, sp, #28
 4711 0064 30BD     		pop	{r4, r5, pc}
 4712              		.cfi_endproc
 4713              	.LFE36:
 4715              		.section	.text.f_readdir,"ax",%progbits
 4716              		.align	1
 4717              		.global	f_readdir
 4718              		.thumb
 4719              		.thumb_func
 4721              	f_readdir:
 4722              	.LFB37:
3062:lib/ff/ff.c   **** {
 4723              		.loc 1 3062 0
 4724              		.cfi_startproc
 4725              		@ args = 0, pretend = 0, frame = 16
 4726              		@ frame_needed = 0, uses_anonymous_args = 0
 4727              	.LVL681:
 4728 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 4729              	.LCFI30:
 4730              		.cfi_def_cfa_offset 32
 4731              		.cfi_offset 0, -32
 4732              		.cfi_offset 1, -28
 4733              		.cfi_offset 2, -24
 4734              		.cfi_offset 3, -20
 4735              		.cfi_offset 4, -16
 4736              		.cfi_offset 5, -12
 4737              		.cfi_offset 6, -8
 4738              		.cfi_offset 14, -4
 4739 0002 0446     		mov	r4, r0
 4740 0004 0E46     		mov	r6, r1
3067:lib/ff/ff.c   **** 	res = validate(dj);						/* Check validity of the object */
 4741              		.loc 1 3067 0
 4742 0006 FFF7FEFF 		bl	validate
 4743              	.LVL682:
3068:lib/ff/ff.c   **** 	if (res == FR_OK) {
 4744              		.loc 1 3068 0
 4745 000a 0546     		mov	r5, r0
 4746 000c E8B9     		cbnz	r0, .L630
3069:lib/ff/ff.c   **** 		if (!fno) {
 4747              		.loc 1 3069 0
 4748 000e 26B9     		cbnz	r6, .L631
3070:lib/ff/ff.c   **** 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
 4749              		.loc 1 3070 0
 4750 0010 2046     		mov	r0, r4
 4751              	.LVL683:
 4752 0012 2946     		mov	r1, r5
 4753 0014 FFF7FEFF 		bl	dir_sdi
 4754              	.LVL684:
 4755 0018 16E0     		b	.L635
 4756              	.LVL685:
 4757              	.L631:
3072:lib/ff/ff.c   **** 			INIT_BUF(*dj);
 4758              		.loc 1 3072 0
 4759 001a 01AB     		add	r3, sp, #4
 4760 001c A361     		str	r3, [r4, #24]
3073:lib/ff/ff.c   **** 			res = dir_read(dj);				/* Read an directory item */
 4761              		.loc 1 3073 0
 4762 001e 2046     		mov	r0, r4
 4763              	.LVL686:
 4764 0020 FFF7FEFF 		bl	dir_read
 4765              	.LVL687:
3074:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) {		/* Reached end of dir */
 4766              		.loc 1 3074 0
 4767 0024 0428     		cmp	r0, #4
 4768 0026 01D1     		bne	.L632
3075:lib/ff/ff.c   **** 				dj->sect = 0;
 4769              		.loc 1 3075 0
 4770 0028 2561     		str	r5, [r4, #16]
 4771              	.LVL688:
 4772 002a 00E0     		b	.L633
 4773              	.LVL689:
 4774              	.L632:
3078:lib/ff/ff.c   **** 			if (res == FR_OK) {				/* A valid entry is found */
 4775              		.loc 1 3078 0
 4776 002c 60B9     		cbnz	r0, .L635
 4777              	.LVL690:
 4778              	.L633:
3079:lib/ff/ff.c   **** 				get_fileinfo(dj, fno);		/* Get the object information */
 4779              		.loc 1 3079 0
 4780 002e 2046     		mov	r0, r4
 4781 0030 3146     		mov	r1, r6
 4782 0032 FFF7FEFF 		bl	get_fileinfo
 4783              	.LVL691:
3080:lib/ff/ff.c   **** 				res = dir_next(dj, 0);		/* Increment index for next */
 4784              		.loc 1 3080 0
 4785 0036 2046     		mov	r0, r4
 4786 0038 0021     		movs	r1, #0
 4787 003a FFF7FEFF 		bl	dir_next
 4788              	.LVL692:
3081:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) {
 4789              		.loc 1 3081 0
 4790 003e 0428     		cmp	r0, #4
 4791 0040 02D1     		bne	.L635
3082:lib/ff/ff.c   **** 					dj->sect = 0;
 4792              		.loc 1 3082 0
 4793 0042 0020     		movs	r0, #0
 4794              	.LVL693:
 4795 0044 2061     		str	r0, [r4, #16]
 4796              	.LVL694:
 4797 0046 00E0     		b	.L630
 4798              	.LVL695:
 4799              	.L635:
3081:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) {
 4800              		.loc 1 3081 0
 4801 0048 0546     		mov	r5, r0
 4802              	.L630:
 4803              	.LVL696:
3091:lib/ff/ff.c   **** }
 4804              		.loc 1 3091 0
 4805 004a 2846     		mov	r0, r5
 4806 004c 04B0     		add	sp, sp, #16
 4807 004e 70BD     		pop	{r4, r5, r6, pc}
 4808              		.cfi_endproc
 4809              	.LFE37:
 4811              		.section	.text.f_stat,"ax",%progbits
 4812              		.align	1
 4813              		.global	f_stat
 4814              		.thumb
 4815              		.thumb_func
 4817              	f_stat:
 4818              	.LFB38:
3104:lib/ff/ff.c   **** {
 4819              		.loc 1 3104 0
 4820              		.cfi_startproc
 4821              		@ args = 0, pretend = 0, frame = 48
 4822              		@ frame_needed = 0, uses_anonymous_args = 0
 4823              	.LVL697:
 4824 0000 30B5     		push	{r4, r5, lr}
 4825              	.LCFI31:
 4826              		.cfi_def_cfa_offset 12
 4827              		.cfi_offset 4, -12
 4828              		.cfi_offset 5, -8
 4829              		.cfi_offset 14, -4
 4830 0002 8DB0     		sub	sp, sp, #52
 4831              	.LCFI32:
 4832              		.cfi_def_cfa_offset 64
 4833 0004 0CAB     		add	r3, sp, #48
 4834 0006 43F82C0D 		str	r0, [r3, #-44]!
 4835 000a 0D46     		mov	r5, r1
3110:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 0);
 4836              		.loc 1 3110 0
 4837 000c 1846     		mov	r0, r3
 4838              	.LVL698:
 4839 000e 05A9     		add	r1, sp, #20
 4840              	.LVL699:
 4841 0010 0022     		movs	r2, #0
 4842 0012 FFF7FEFF 		bl	chk_mounted
 4843              	.LVL700:
3111:lib/ff/ff.c   **** 	if (res == FR_OK) {
 4844              		.loc 1 3111 0
 4845 0016 0446     		mov	r4, r0
 4846 0018 78B9     		cbnz	r0, .L637
3112:lib/ff/ff.c   **** 		INIT_BUF(dj);
 4847              		.loc 1 3112 0
 4848 001a 02A8     		add	r0, sp, #8
 4849              	.LVL701:
 4850 001c 0B90     		str	r0, [sp, #44]
3113:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
 4851              		.loc 1 3113 0
 4852 001e 05A8     		add	r0, sp, #20
 4853              	.LVL702:
 4854 0020 0199     		ldr	r1, [sp, #4]
 4855 0022 FFF7FEFF 		bl	follow_path
 4856              	.LVL703:
3114:lib/ff/ff.c   **** 		if (res == FR_OK) {				/* Follow completed */
 4857              		.loc 1 3114 0
 4858 0026 0446     		mov	r4, r0
 4859 0028 38B9     		cbnz	r0, .L637
3115:lib/ff/ff.c   **** 			if (dj.dir)		/* Found an object */
 4860              		.loc 1 3115 0
 4861 002a 0A99     		ldr	r1, [sp, #40]
 4862 002c 21B1     		cbz	r1, .L638
3116:lib/ff/ff.c   **** 				get_fileinfo(&dj, fno);
 4863              		.loc 1 3116 0
 4864 002e 05A8     		add	r0, sp, #20
 4865              	.LVL704:
 4866 0030 2946     		mov	r1, r5
 4867 0032 FFF7FEFF 		bl	get_fileinfo
 4868              	.LVL705:
 4869 0036 00E0     		b	.L637
 4870              	.LVL706:
 4871              	.L638:
3118:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
 4872              		.loc 1 3118 0
 4873 0038 0624     		movs	r4, #6
 4874              	.LVL707:
 4875              	.L637:
3124:lib/ff/ff.c   **** }
 4876              		.loc 1 3124 0
 4877 003a 2046     		mov	r0, r4
 4878 003c 0DB0     		add	sp, sp, #52
 4879 003e 30BD     		pop	{r4, r5, pc}
 4880              		.cfi_endproc
 4881              	.LFE38:
 4883              		.section	.text.f_getfree,"ax",%progbits
 4884              		.align	1
 4885              		.global	f_getfree
 4886              		.thumb
 4887              		.thumb_func
 4889              	f_getfree:
 4890              	.LFB39:
3138:lib/ff/ff.c   **** {
 4891              		.loc 1 3138 0
 4892              		.cfi_startproc
 4893              		@ args = 0, pretend = 0, frame = 8
 4894              		@ frame_needed = 0, uses_anonymous_args = 0
 4895              	.LVL708:
 4896 0000 2DE9F347 		push	{r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 4897              	.LCFI33:
 4898              		.cfi_def_cfa_offset 40
 4899              		.cfi_offset 0, -40
 4900              		.cfi_offset 1, -36
 4901              		.cfi_offset 4, -32
 4902              		.cfi_offset 5, -28
 4903              		.cfi_offset 6, -24
 4904              		.cfi_offset 7, -20
 4905              		.cfi_offset 8, -16
 4906              		.cfi_offset 9, -12
 4907              		.cfi_offset 10, -8
 4908              		.cfi_offset 14, -4
 4909 0004 02AB     		add	r3, sp, #8
 4910 0006 43F8040D 		str	r0, [r3, #-4]!
 4911 000a 8846     		mov	r8, r1
 4912 000c 1446     		mov	r4, r2
3147:lib/ff/ff.c   **** 	res = chk_mounted(&path, fatfs, 0);
 4913              		.loc 1 3147 0
 4914 000e 1846     		mov	r0, r3
 4915              	.LVL709:
 4916 0010 1146     		mov	r1, r2
 4917              	.LVL710:
 4918 0012 0022     		movs	r2, #0
 4919              	.LVL711:
 4920 0014 FFF7FEFF 		bl	chk_mounted
 4921              	.LVL712:
3148:lib/ff/ff.c   **** 	fs = *fatfs;
 4922              		.loc 1 3148 0
 4923 0018 2468     		ldr	r4, [r4, #0]
 4924              	.LVL713:
3149:lib/ff/ff.c   **** 	if (res == FR_OK) {
 4925              		.loc 1 3149 0
 4926 001a 0546     		mov	r5, r0
 4927 001c 0028     		cmp	r0, #0
 4928 001e 4DD1     		bne	.L640
3151:lib/ff/ff.c   **** 		if (fs->free_clust <= fs->n_fatent - 2) {
 4929              		.loc 1 3151 0
 4930 0020 2069     		ldr	r0, [r4, #16]
 4931              	.LVL714:
 4932 0022 E769     		ldr	r7, [r4, #28]
 4933 0024 BA1E     		subs	r2, r7, #2
 4934 0026 9042     		cmp	r0, r2
 4935 0028 02D8     		bhi	.L641
3152:lib/ff/ff.c   **** 			*nclst = fs->free_clust;
 4936              		.loc 1 3152 0
 4937 002a C8F80000 		str	r0, [r8, #0]
 4938 002e 45E0     		b	.L640
 4939              	.L641:
3155:lib/ff/ff.c   **** 			fat = fs->fs_type;
 4940              		.loc 1 3155 0
 4941 0030 94F80090 		ldrb	r9, [r4, #0]	@ zero_extendqisi2
 4942              	.LVL715:
3157:lib/ff/ff.c   **** 			if (fat == FS_FAT12) {
 4943              		.loc 1 3157 0
 4944 0034 B9F1010F 		cmp	r9, #1
 4945 0038 10D1     		bne	.L642
 4946 003a 0227     		movs	r7, #2
 4947 003c 2E46     		mov	r6, r5
 4948              	.LVL716:
 4949              	.L645:
3160:lib/ff/ff.c   **** 					stat = get_fat(fs, clst);
 4950              		.loc 1 3160 0
 4951 003e 2046     		mov	r0, r4
 4952 0040 3946     		mov	r1, r7
 4953 0042 FFF7FEFF 		bl	get_fat
 4954              	.LVL717:
3161:lib/ff/ff.c   **** 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 4955              		.loc 1 3161 0
 4956 0046 431C     		adds	r3, r0, #1
 4957 0048 2BD0     		beq	.L653
3162:lib/ff/ff.c   **** 					if (stat == 1) { res = FR_INT_ERR; break; }
 4958              		.loc 1 3162 0
 4959 004a 0128     		cmp	r0, #1
 4960 004c 2BD0     		beq	.L654
3163:lib/ff/ff.c   **** 					if (stat == 0) n++;
 4961              		.loc 1 3163 0
 4962 004e 00B9     		cbnz	r0, .L644
3163:lib/ff/ff.c   **** 					if (stat == 0) n++;
 4963              		.loc 1 3163 0 is_stmt 0 discriminator 1
 4964 0050 0136     		adds	r6, r6, #1
 4965              	.LVL718:
 4966              	.L644:
3164:lib/ff/ff.c   **** 				} while (++clst < fs->n_fatent);
 4967              		.loc 1 3164 0 is_stmt 1
 4968 0052 0137     		adds	r7, r7, #1
 4969              	.LVL719:
 4970 0054 E169     		ldr	r1, [r4, #28]
 4971 0056 8F42     		cmp	r7, r1
 4972 0058 F1D3     		bcc	.L645
 4973 005a 27E0     		b	.L643
 4974              	.LVL720:
 4975              	.L642:
3167:lib/ff/ff.c   **** 				sect = fs->fatbase;
 4976              		.loc 1 3167 0
 4977 005c 616A     		ldr	r1, [r4, #36]
 4978              	.LVL721:
3168:lib/ff/ff.c   **** 				i = 0; p = 0;
 4979              		.loc 1 3168 0
 4980 005e 2B46     		mov	r3, r5
 4981 0060 2A46     		mov	r2, r5
3156:lib/ff/ff.c   **** 			n = 0;
 4982              		.loc 1 3156 0
 4983 0062 2E46     		mov	r6, r5
 4984              	.LVL722:
 4985              	.L651:
3170:lib/ff/ff.c   **** 					if (!i) {
 4986              		.loc 1 3170 0
 4987 0064 52B9     		cbnz	r2, .L646
3171:lib/ff/ff.c   **** 						res = move_window(fs, sect++);
 4988              		.loc 1 3171 0
 4989 0066 01F1010A 		add	sl, r1, #1
 4990              	.LVL723:
 4991 006a 2046     		mov	r0, r4
 4992 006c FFF7FEFF 		bl	move_window
 4993              	.LVL724:
3172:lib/ff/ff.c   **** 						if (res != FR_OK) break;
 4994              		.loc 1 3172 0
 4995 0070 D8B9     		cbnz	r0, .L655
3173:lib/ff/ff.c   **** 						p = fs->win;
 4996              		.loc 1 3173 0
 4997 0072 04F13403 		add	r3, r4, #52
 4998              	.LVL725:
3171:lib/ff/ff.c   **** 						res = move_window(fs, sect++);
 4999              		.loc 1 3171 0
 5000 0076 5146     		mov	r1, sl
3174:lib/ff/ff.c   **** 						i = SS(fs);
 5001              		.loc 1 3174 0
 5002 0078 4FF40072 		mov	r2, #512
 5003              	.LVL726:
 5004              	.L646:
3176:lib/ff/ff.c   **** 					if (fat == FS_FAT16) {
 5005              		.loc 1 3176 0
 5006 007c B9F1020F 		cmp	r9, #2
 5007 0080 05D1     		bne	.L647
3177:lib/ff/ff.c   **** 						if (LD_WORD(p) == 0) n++;
 5008              		.loc 1 3177 0
 5009 0082 1888     		ldrh	r0, [r3, #0]
 5010 0084 00B9     		cbnz	r0, .L648
3177:lib/ff/ff.c   **** 						if (LD_WORD(p) == 0) n++;
 5011              		.loc 1 3177 0 is_stmt 0 discriminator 1
 5012 0086 0136     		adds	r6, r6, #1
 5013              	.LVL727:
 5014              	.L648:
3178:lib/ff/ff.c   **** 						p += 2; i -= 2;
 5015              		.loc 1 3178 0 is_stmt 1
 5016 0088 0233     		adds	r3, r3, #2
 5017              	.LVL728:
 5018 008a 023A     		subs	r2, r2, #2
 5019              	.LVL729:
 5020 008c 06E0     		b	.L649
 5021              	.L647:
3180:lib/ff/ff.c   **** 						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
 5022              		.loc 1 3180 0
 5023 008e 1868     		ldr	r0, [r3, #0]
 5024 0090 20F07040 		bic	r0, r0, #-268435456
 5025 0094 00B9     		cbnz	r0, .L650
3180:lib/ff/ff.c   **** 						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
 5026              		.loc 1 3180 0 is_stmt 0 discriminator 1
 5027 0096 0136     		adds	r6, r6, #1
 5028              	.LVL730:
 5029              	.L650:
3181:lib/ff/ff.c   **** 						p += 4; i -= 4;
 5030              		.loc 1 3181 0 is_stmt 1
 5031 0098 0433     		adds	r3, r3, #4
 5032              	.LVL731:
 5033 009a 043A     		subs	r2, r2, #4
 5034              	.LVL732:
 5035              	.L649:
3183:lib/ff/ff.c   **** 				} while (--clst);
 5036              		.loc 1 3183 0
 5037 009c 013F     		subs	r7, r7, #1
 5038              	.LVL733:
 5039 009e E1D1     		bne	.L651
 5040 00a0 04E0     		b	.L643
 5041              	.LVL734:
 5042              	.L653:
3161:lib/ff/ff.c   **** 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 5043              		.loc 1 3161 0
 5044 00a2 0125     		movs	r5, #1
 5045 00a4 02E0     		b	.L643
 5046              	.L654:
3162:lib/ff/ff.c   **** 					if (stat == 1) { res = FR_INT_ERR; break; }
 5047              		.loc 1 3162 0
 5048 00a6 0225     		movs	r5, #2
 5049 00a8 00E0     		b	.L643
 5050              	.LVL735:
 5051              	.L655:
3171:lib/ff/ff.c   **** 						res = move_window(fs, sect++);
 5052              		.loc 1 3171 0
 5053 00aa 0546     		mov	r5, r0
 5054              	.LVL736:
 5055              	.L643:
3185:lib/ff/ff.c   **** 			fs->free_clust = n;
 5056              		.loc 1 3185 0
 5057 00ac 2661     		str	r6, [r4, #16]
3186:lib/ff/ff.c   **** 			if (fat == FS_FAT32) fs->fsi_flag = 1;
 5058              		.loc 1 3186 0
 5059 00ae B9F1030F 		cmp	r9, #3
 5060 00b2 01D1     		bne	.L652
3186:lib/ff/ff.c   **** 			if (fat == FS_FAT32) fs->fsi_flag = 1;
 5061              		.loc 1 3186 0 is_stmt 0 discriminator 1
 5062 00b4 0123     		movs	r3, #1
 5063 00b6 6371     		strb	r3, [r4, #5]
 5064              	.L652:
3187:lib/ff/ff.c   **** 			*nclst = n;
 5065              		.loc 1 3187 0 is_stmt 1
 5066 00b8 C8F80060 		str	r6, [r8, #0]
 5067              	.LVL737:
 5068              	.L640:
3191:lib/ff/ff.c   **** }
 5069              		.loc 1 3191 0
 5070 00bc 2846     		mov	r0, r5
 5071 00be BDE8FC87 		pop	{r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}
 5072              		.cfi_endproc
 5073              	.LFE39:
 5075              		.section	.text.f_truncate,"ax",%progbits
 5076              		.align	1
 5077              		.global	f_truncate
 5078              		.thumb
 5079              		.thumb_func
 5081              	f_truncate:
 5082              	.LFB40:
3203:lib/ff/ff.c   **** {
 5083              		.loc 1 3203 0
 5084              		.cfi_startproc
 5085              		@ args = 0, pretend = 0, frame = 0
 5086              		@ frame_needed = 0, uses_anonymous_args = 0
 5087              	.LVL738:
 5088 0000 70B5     		push	{r4, r5, r6, lr}
 5089              	.LCFI34:
 5090              		.cfi_def_cfa_offset 16
 5091              		.cfi_offset 4, -16
 5092              		.cfi_offset 5, -12
 5093              		.cfi_offset 6, -8
 5094              		.cfi_offset 14, -4
3208:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
 5095              		.loc 1 3208 0
 5096 0002 0446     		mov	r4, r0
 5097 0004 68B1     		cbz	r0, .L670
3210:lib/ff/ff.c   **** 	res = validate(fp);						/* Check validity of the object */
 5098              		.loc 1 3210 0
 5099 0006 FFF7FEFF 		bl	validate
 5100              	.LVL739:
3211:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5101              		.loc 1 3211 0
 5102 000a 0546     		mov	r5, r0
 5103 000c 0028     		cmp	r0, #0
 5104 000e 40D1     		bne	.L676
3212:lib/ff/ff.c   **** 		if (fp->flag & FA__ERROR) {			/* Check abort flag */
 5105              		.loc 1 3212 0
 5106 0010 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 5107 0012 1906     		lsls	r1, r3, #24
 5108 0014 37D4     		bmi	.L671
3215:lib/ff/ff.c   **** 			if (!(fp->flag & FA_WRITE))		/* Check access mode */
 5109              		.loc 1 3215 0
 5110 0016 03F00202 		and	r2, r3, #2
 5111 001a D0B2     		uxtb	r0, r2
 5112              	.LVL740:
 5113 001c 0028     		cmp	r0, #0
 5114 001e 34D0     		beq	.L672
 5115 0020 01E0     		b	.L681
 5116              	.LVL741:
 5117              	.L670:
3208:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
 5118              		.loc 1 3208 0
 5119 0022 0925     		movs	r5, #9
 5120 0024 35E0     		b	.L676
 5121              	.LVL742:
 5122              	.L681:
3220:lib/ff/ff.c   **** 		if (fp->fsize > fp->fptr) {
 5123              		.loc 1 3220 0
 5124 0026 A668     		ldr	r6, [r4, #8]
 5125 0028 E168     		ldr	r1, [r4, #12]
 5126 002a B142     		cmp	r1, r6
 5127 002c 31D9     		bls	.L676
 5128              	.L666:
3221:lib/ff/ff.c   **** 			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
 5129              		.loc 1 3221 0
 5130 002e E660     		str	r6, [r4, #12]
3222:lib/ff/ff.c   **** 			fp->flag |= FA__WRITTEN;
 5131              		.loc 1 3222 0
 5132 0030 43F02003 		orr	r3, r3, #32
 5133 0034 A371     		strb	r3, [r4, #6]
3224:lib/ff/ff.c   **** 				res = remove_chain(fp->fs, fp->sclust);
 5134              		.loc 1 3224 0
 5135 0036 2068     		ldr	r0, [r4, #0]
3223:lib/ff/ff.c   **** 			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 5136              		.loc 1 3223 0
 5137 0038 2EB9     		cbnz	r6, .L662
3224:lib/ff/ff.c   **** 				res = remove_chain(fp->fs, fp->sclust);
 5138              		.loc 1 3224 0
 5139 003a 2169     		ldr	r1, [r4, #16]
 5140 003c FFF7FEFF 		bl	remove_chain
 5141              	.LVL743:
 5142 0040 0546     		mov	r5, r0
 5143              	.LVL744:
3225:lib/ff/ff.c   **** 				fp->sclust = 0;
 5144              		.loc 1 3225 0
 5145 0042 2661     		str	r6, [r4, #16]
 5146 0044 19E0     		b	.L663
 5147              	.LVL745:
 5148              	.L662:
3227:lib/ff/ff.c   **** 				ncl = get_fat(fp->fs, fp->clust);
 5149              		.loc 1 3227 0
 5150 0046 6169     		ldr	r1, [r4, #20]
 5151 0048 FFF7FEFF 		bl	get_fat
 5152              	.LVL746:
 5153 004c 0646     		mov	r6, r0
 5154              	.LVL747:
3229:lib/ff/ff.c   **** 				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 5155              		.loc 1 3229 0
 5156 004e 421C     		adds	r2, r0, #1
 5157 0050 1DD0     		beq	.L673
3230:lib/ff/ff.c   **** 				if (ncl == 1) res = FR_INT_ERR;
 5158              		.loc 1 3230 0
 5159 0052 0128     		cmp	r0, #1
 5160 0054 01D1     		bne	.L680
 5161 0056 0225     		movs	r5, #2
 5162 0058 10E0     		b	.L668
 5163              	.L680:
3231:lib/ff/ff.c   **** 				if (res == FR_OK && ncl < fp->fs->n_fatent) {
 5164              		.loc 1 3231 0
 5165 005a 2068     		ldr	r0, [r4, #0]
 5166              	.LVL748:
 5167 005c C269     		ldr	r2, [r0, #28]
 5168 005e 9642     		cmp	r6, r2
 5169 0060 17D2     		bcs	.L676
 5170              	.L669:
3232:lib/ff/ff.c   **** 					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
 5171              		.loc 1 3232 0
 5172 0062 6169     		ldr	r1, [r4, #20]
 5173 0064 6FF07042 		mvn	r2, #-268435456
 5174 0068 FFF7FEFF 		bl	put_fat
 5175              	.LVL749:
3233:lib/ff/ff.c   **** 					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 5176              		.loc 1 3233 0
 5177 006c 0546     		mov	r5, r0
 5178 006e 28B9     		cbnz	r0, .L668
3233:lib/ff/ff.c   **** 					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 5179              		.loc 1 3233 0 is_stmt 0 discriminator 1
 5180 0070 2068     		ldr	r0, [r4, #0]
 5181              	.LVL750:
 5182 0072 3146     		mov	r1, r6
 5183 0074 FFF7FEFF 		bl	remove_chain
 5184              	.LVL751:
 5185 0078 0546     		mov	r5, r0
 5186              	.LVL752:
 5187              	.L663:
3237:lib/ff/ff.c   **** 		if (res != FR_OK) fp->flag |= FA__ERROR;
 5188              		.loc 1 3237 0 is_stmt 1
 5189 007a 55B1     		cbz	r5, .L676
 5190              	.LVL753:
 5191              	.L668:
3237:lib/ff/ff.c   **** 		if (res != FR_OK) fp->flag |= FA__ERROR;
 5192              		.loc 1 3237 0 is_stmt 0 discriminator 1
 5193 007c A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 5194 007e 60F07F01 		orn	r1, r0, #127
 5195 0082 A171     		strb	r1, [r4, #6]
 5196 0084 05E0     		b	.L676
 5197              	.LVL754:
 5198              	.L671:
3213:lib/ff/ff.c   **** 			res = FR_INT_ERR;
 5199              		.loc 1 3213 0 is_stmt 1
 5200 0086 0225     		movs	r5, #2
 5201 0088 03E0     		b	.L676
 5202              	.LVL755:
 5203              	.L672:
3216:lib/ff/ff.c   **** 				res = FR_DENIED;
 5204              		.loc 1 3216 0
 5205 008a 0725     		movs	r5, #7
 5206              	.LVL756:
 5207 008c 01E0     		b	.L676
 5208              	.LVL757:
 5209              	.L673:
3229:lib/ff/ff.c   **** 				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 5210              		.loc 1 3229 0
 5211 008e 0125     		movs	r5, #1
 5212 0090 F4E7     		b	.L668
 5213              	.LVL758:
 5214              	.L676:
3241:lib/ff/ff.c   **** }
 5215              		.loc 1 3241 0
 5216 0092 2846     		mov	r0, r5
 5217 0094 70BD     		pop	{r4, r5, r6, pc}
 5218              		.cfi_endproc
 5219              	.LFE40:
 5221              		.section	.text.f_unlink,"ax",%progbits
 5222              		.align	1
 5223              		.global	f_unlink
 5224              		.thumb
 5225              		.thumb_func
 5227              	f_unlink:
 5228              	.LFB41:
3253:lib/ff/ff.c   **** {
 5229              		.loc 1 3253 0
 5230              		.cfi_startproc
 5231              		@ args = 0, pretend = 0, frame = 80
 5232              		@ frame_needed = 0, uses_anonymous_args = 0
 5233              	.LVL759:
 5234 0000 10B5     		push	{r4, lr}
 5235              	.LCFI35:
 5236              		.cfi_def_cfa_offset 8
 5237              		.cfi_offset 4, -8
 5238              		.cfi_offset 14, -4
 5239 0002 94B0     		sub	sp, sp, #80
 5240              	.LCFI36:
 5241              		.cfi_def_cfa_offset 88
 5242 0004 14AB     		add	r3, sp, #80
 5243 0006 43F84C0D 		str	r0, [r3, #-76]!
3261:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
 5244              		.loc 1 3261 0
 5245 000a 1846     		mov	r0, r3
 5246              	.LVL760:
 5247 000c 06A9     		add	r1, sp, #24
 5248 000e 0122     		movs	r2, #1
 5249 0010 FFF7FEFF 		bl	chk_mounted
 5250              	.LVL761:
3262:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5251              		.loc 1 3262 0
 5252 0014 0028     		cmp	r0, #0
 5253 0016 52D1     		bne	.L703
3263:lib/ff/ff.c   **** 		INIT_BUF(dj);
 5254              		.loc 1 3263 0
 5255 0018 03A8     		add	r0, sp, #12
 5256              	.LVL762:
 5257 001a 0C90     		str	r0, [sp, #48]
3264:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the file path */
 5258              		.loc 1 3264 0
 5259 001c 06A8     		add	r0, sp, #24
 5260              	.LVL763:
 5261 001e 0199     		ldr	r1, [sp, #4]
 5262 0020 FFF7FEFF 		bl	follow_path
 5263              	.LVL764:
3265:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 5264              		.loc 1 3265 0
 5265 0024 0028     		cmp	r0, #0
 5266 0026 4AD1     		bne	.L703
3265:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 5267              		.loc 1 3265 0 is_stmt 0 discriminator 1
 5268 0028 0C99     		ldr	r1, [sp, #48]
 5269 002a CA7A     		ldrb	r2, [r1, #11]	@ zero_extendqisi2
 5270 002c 02F02003 		and	r3, r2, #32
 5271 0030 D8B2     		uxtb	r0, r3
 5272              	.LVL765:
 5273 0032 0028     		cmp	r0, #0
 5274 0034 2FD1     		bne	.L694
 5275              	.LVL766:
3271:lib/ff/ff.c   **** 			dir = dj.dir;
 5276              		.loc 1 3271 0 is_stmt 1
 5277 0036 0B99     		ldr	r1, [sp, #44]
 5278              	.LVL767:
3272:lib/ff/ff.c   **** 			if (!dir) {
 5279              		.loc 1 3272 0
 5280 0038 31B1     		cbz	r1, .L712
 5281              	.L711:
3275:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & AM_RDO)
 5282              		.loc 1 3275 0
 5283 003a CC7A     		ldrb	r4, [r1, #11]	@ zero_extendqisi2
3276:lib/ff/ff.c   **** 					res = FR_DENIED;		/* Cannot remove R/O object */
 5284              		.loc 1 3276 0
 5285 003c 14F0010F 		tst	r4, #1
 5286 0040 0CBF     		ite	eq
 5287 0042 0020     		moveq	r0, #0
 5288 0044 0720     		movne	r0, #7
 5289 0046 00E0     		b	.L686
 5290              	.L712:
3273:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
 5291              		.loc 1 3273 0
 5292 0048 0620     		movs	r0, #6
 5293              	.L686:
 5294              	.LVL768:
 5295              	.LBB110:
 5296              	.LBB111:
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 5297              		.loc 1 1190 0
 5298 004a 4C8B     		ldrh	r4, [r1, #26]
 5299              	.LVL769:
 5300              		.loc 1 4136 0
 5301 004c 069A     		ldr	r2, [sp, #24]
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 5302              		.loc 1 1191 0
 5303 004e 1378     		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 5304 0050 032B     		cmp	r3, #3
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 5305              		.loc 1 1192 0
 5306 0052 04BF     		itt	eq
 5307 0054 8B8A     		ldrheq	r3, [r1, #20]
 5308 0056 44EA0344 		orreq	r4, r4, r3, lsl #16
 5309              	.LVL770:
 5310              	.LBE111:
 5311              	.LBE110:
3279:lib/ff/ff.c   **** 			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
 5312              		.loc 1 3279 0
 5313 005a 80BB     		cbnz	r0, .L703
3279:lib/ff/ff.c   **** 			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
 5314              		.loc 1 3279 0 is_stmt 0 discriminator 1
 5315 005c C87A     		ldrb	r0, [r1, #11]	@ zero_extendqisi2
 5316              	.LVL771:
 5317 005e 00F01001 		and	r1, r0, #16
 5318              	.LVL772:
 5319 0062 CAB2     		uxtb	r2, r1
 5320 0064 CAB1     		cbz	r2, .L689
3280:lib/ff/ff.c   **** 				if (dclst < 2) {
 5321              		.loc 1 3280 0 is_stmt 1
 5322 0066 012C     		cmp	r4, #1
 5323 0068 26D9     		bls	.L696
3283:lib/ff/ff.c   **** 					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
 5324              		.loc 1 3283 0
 5325 006a 0DA8     		add	r0, sp, #52
 5326 006c 06A9     		add	r1, sp, #24
 5327 006e 1C22     		movs	r2, #28
 5328 0070 FFF7FEFF 		bl	mem_cpy
 5329              	.LVL773:
3284:lib/ff/ff.c   **** 					sdj.sclust = dclst;
 5330              		.loc 1 3284 0
 5331 0074 0F94     		str	r4, [sp, #60]
3285:lib/ff/ff.c   **** 					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
 5332              		.loc 1 3285 0
 5333 0076 0DA8     		add	r0, sp, #52
 5334 0078 0221     		movs	r1, #2
 5335 007a FFF7FEFF 		bl	dir_sdi
 5336              	.LVL774:
3286:lib/ff/ff.c   **** 					if (res == FR_OK) {
 5337              		.loc 1 3286 0
 5338 007e F0B9     		cbnz	r0, .L703
3287:lib/ff/ff.c   **** 						res = dir_read(&sdj);
 5339              		.loc 1 3287 0
 5340 0080 0DA8     		add	r0, sp, #52
 5341              	.LVL775:
 5342 0082 FFF7FEFF 		bl	dir_read
 5343              	.LVL776:
3288:lib/ff/ff.c   **** 						if (res == FR_OK		/* Not empty dir */
 5344              		.loc 1 3288 0
 5345 0086 C8B1     		cbz	r0, .L698
3290:lib/ff/ff.c   **** 						|| dclst == dj.fs->cdir	/* Current dir */
 5346              		.loc 1 3290 0
 5347 0088 069B     		ldr	r3, [sp, #24]
 5348 008a 9969     		ldr	r1, [r3, #24]
 5349 008c 8C42     		cmp	r4, r1
 5350 008e 15D0     		beq	.L698
3293:lib/ff/ff.c   **** 						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
 5351              		.loc 1 3293 0
 5352 0090 0428     		cmp	r0, #4
 5353 0092 02D0     		beq	.L689
 5354 0094 13E0     		b	.L703
 5355              	.LVL777:
 5356              	.L694:
3266:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
 5357              		.loc 1 3266 0
 5358 0096 0620     		movs	r0, #6
 5359              	.LVL778:
 5360 0098 11E0     		b	.L703
 5361              	.LVL779:
 5362              	.L689:
3298:lib/ff/ff.c   **** 				res = dir_remove(&dj);		/* Remove the directory entry */
 5363              		.loc 1 3298 0
 5364 009a 06A8     		add	r0, sp, #24
 5365 009c FFF7FEFF 		bl	dir_remove
 5366              	.LVL780:
3299:lib/ff/ff.c   **** 				if (res == FR_OK) {
 5367              		.loc 1 3299 0
 5368 00a0 68B9     		cbnz	r0, .L703
 5369              	.L693:
3300:lib/ff/ff.c   **** 					if (dclst)				/* Remove the cluster chain if exist */
 5370              		.loc 1 3300 0
 5371 00a2 1CB9     		cbnz	r4, .L690
 5372              	.L691:
3302:lib/ff/ff.c   **** 					if (res == FR_OK) res = sync(dj.fs);
 5373              		.loc 1 3302 0
 5374 00a4 0698     		ldr	r0, [sp, #24]
 5375              	.LVL781:
 5376 00a6 FFF7FEFF 		bl	sync
 5377              	.LVL782:
 5378 00aa 08E0     		b	.L703
 5379              	.L690:
3301:lib/ff/ff.c   **** 						res = remove_chain(dj.fs, dclst);
 5380              		.loc 1 3301 0
 5381 00ac 0698     		ldr	r0, [sp, #24]
 5382              	.LVL783:
 5383 00ae 2146     		mov	r1, r4
 5384 00b0 FFF7FEFF 		bl	remove_chain
 5385              	.LVL784:
3302:lib/ff/ff.c   **** 					if (res == FR_OK) res = sync(dj.fs);
 5386              		.loc 1 3302 0
 5387 00b4 18B9     		cbnz	r0, .L703
 5388 00b6 F5E7     		b	.L691
 5389              	.LVL785:
 5390              	.L696:
3281:lib/ff/ff.c   **** 					res = FR_INT_ERR;
 5391              		.loc 1 3281 0
 5392 00b8 0220     		movs	r0, #2
 5393 00ba 00E0     		b	.L703
 5394              	.LVL786:
 5395              	.L698:
3290:lib/ff/ff.c   **** 						|| dclst == dj.fs->cdir	/* Current dir */
 5396              		.loc 1 3290 0
 5397 00bc 0720     		movs	r0, #7
 5398              	.LVL787:
 5399              	.L703:
3309:lib/ff/ff.c   **** }
 5400              		.loc 1 3309 0
 5401 00be 14B0     		add	sp, sp, #80
 5402 00c0 10BD     		pop	{r4, pc}
 5403              		.cfi_endproc
 5404              	.LFE41:
 5406              		.section	.text.f_mkdir,"ax",%progbits
 5407              		.align	1
 5408              		.global	f_mkdir
 5409              		.thumb
 5410              		.thumb_func
 5412              	f_mkdir:
 5413              	.LFB42:
3321:lib/ff/ff.c   **** {
 5414              		.loc 1 3321 0
 5415              		.cfi_startproc
 5416              		@ args = 0, pretend = 0, frame = 48
 5417              		@ frame_needed = 0, uses_anonymous_args = 0
 5418              	.LVL788:
 5419 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5420              	.LCFI37:
 5421              		.cfi_def_cfa_offset 36
 5422              		.cfi_offset 4, -36
 5423              		.cfi_offset 5, -32
 5424              		.cfi_offset 6, -28
 5425              		.cfi_offset 7, -24
 5426              		.cfi_offset 8, -20
 5427              		.cfi_offset 9, -16
 5428              		.cfi_offset 10, -12
 5429              		.cfi_offset 11, -8
 5430              		.cfi_offset 14, -4
 5431 0004 8DB0     		sub	sp, sp, #52
 5432              	.LCFI38:
 5433              		.cfi_def_cfa_offset 88
 5434 0006 0CAC     		add	r4, sp, #48
 5435 0008 44F82C0D 		str	r0, [r4, #-44]!
3325:lib/ff/ff.c   **** 	DWORD dsc, dcl, pcl, tim = get_fattime();
 5436              		.loc 1 3325 0
 5437 000c FFF7FEFF 		bl	get_fattime
 5438              	.LVL789:
 5439 0010 8146     		mov	r9, r0
 5440              	.LVL790:
3329:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
 5441              		.loc 1 3329 0
 5442 0012 2046     		mov	r0, r4
 5443              	.LVL791:
 5444 0014 05A9     		add	r1, sp, #20
 5445 0016 0122     		movs	r2, #1
 5446 0018 FFF7FEFF 		bl	chk_mounted
 5447              	.LVL792:
3330:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5448              		.loc 1 3330 0
 5449 001c 0446     		mov	r4, r0
 5450 001e 0028     		cmp	r0, #0
 5451 0020 40F09680 		bne	.L733
3331:lib/ff/ff.c   **** 		INIT_BUF(dj);
 5452              		.loc 1 3331 0
 5453 0024 02AB     		add	r3, sp, #8
 5454 0026 0B93     		str	r3, [sp, #44]
3332:lib/ff/ff.c   **** 		res = follow_path(&dj, path);			/* Follow the file path */
 5455              		.loc 1 3332 0
 5456 0028 05A8     		add	r0, sp, #20
 5457              	.LVL793:
 5458 002a 0199     		ldr	r1, [sp, #4]
 5459 002c FFF7FEFF 		bl	follow_path
 5460              	.LVL794:
3333:lib/ff/ff.c   **** 		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 5461              		.loc 1 3333 0
 5462 0030 0446     		mov	r4, r0
 5463 0032 C0B1     		cbz	r0, .L727
3334:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
 5464              		.loc 1 3334 0
 5465 0034 0428     		cmp	r0, #4
 5466 0036 40F08B80 		bne	.L733
3334:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
 5467              		.loc 1 3334 0 is_stmt 0 discriminator 1
 5468 003a 0B98     		ldr	r0, [sp, #44]
 5469              	.LVL795:
 5470 003c C17A     		ldrb	r1, [r0, #11]	@ zero_extendqisi2
 5471 003e 01F02002 		and	r2, r1, #32
 5472 0042 D4B2     		uxtb	r4, r2
 5473              	.LVL796:
 5474 0044 8CB9     		cbnz	r4, .L728
 5475              	.LVL797:
3337:lib/ff/ff.c   **** 			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
 5476              		.loc 1 3337 0 is_stmt 1
 5477 0046 0598     		ldr	r0, [sp, #20]
 5478 0048 2146     		mov	r1, r4
 5479 004a FFF7FEFF 		bl	create_chain
 5480              	.LVL798:
3339:lib/ff/ff.c   **** 			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 5481              		.loc 1 3339 0
 5482 004e 0646     		mov	r6, r0
 5483 0050 78B1     		cbz	r0, .L732
3340:lib/ff/ff.c   **** 			if (dcl == 1) res = FR_INT_ERR;
 5484              		.loc 1 3340 0
 5485 0052 012E     		cmp	r6, #1
 5486 0054 0BD0     		beq	.L729
3341:lib/ff/ff.c   **** 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 5487              		.loc 1 3341 0
 5488 0056 701C     		adds	r0, r6, #1
 5489              	.LVL799:
 5490 0058 0DD1     		bne	.L737
 5491              	.L730:
 5492 005a 0124     		movs	r4, #1
 5493              	.LVL800:
 5494              	.L725:
3368:lib/ff/ff.c   **** 				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
 5495              		.loc 1 3368 0
 5496 005c 0598     		ldr	r0, [sp, #20]
 5497 005e 3146     		mov	r1, r6
 5498 0060 FFF7FEFF 		bl	remove_chain
 5499              	.LVL801:
 5500 0064 74E0     		b	.L733
 5501              	.LVL802:
 5502              	.L727:
3333:lib/ff/ff.c   **** 		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 5503              		.loc 1 3333 0
 5504 0066 0824     		movs	r4, #8
 5505 0068 72E0     		b	.L733
 5506              	.LVL803:
 5507              	.L728:
3335:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 5508              		.loc 1 3335 0
 5509 006a 0624     		movs	r4, #6
 5510              	.LVL804:
 5511 006c 70E0     		b	.L733
 5512              	.LVL805:
 5513              	.L729:
3340:lib/ff/ff.c   **** 			if (dcl == 1) res = FR_INT_ERR;
 5514              		.loc 1 3340 0
 5515 006e 0224     		movs	r4, #2
 5516 0070 F4E7     		b	.L725
 5517              	.L732:
3339:lib/ff/ff.c   **** 			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 5518              		.loc 1 3339 0
 5519 0072 0724     		movs	r4, #7
 5520 0074 F2E7     		b	.L725
 5521              	.LVL806:
 5522              	.L737:
3343:lib/ff/ff.c   **** 				res = move_window(dj.fs, 0);
 5523              		.loc 1 3343 0
 5524 0076 0598     		ldr	r0, [sp, #20]
 5525 0078 2146     		mov	r1, r4
 5526 007a FFF7FEFF 		bl	move_window
 5527              	.LVL807:
3344:lib/ff/ff.c   **** 			if (res == FR_OK) {					/* Initialize the new directory table */
 5528              		.loc 1 3344 0
 5529 007e 0446     		mov	r4, r0
 5530 0080 0028     		cmp	r0, #0
 5531 0082 EBD1     		bne	.L725
 5532              	.L726:
3345:lib/ff/ff.c   **** 				dsc = clust2sect(dj.fs, dcl);
 5533              		.loc 1 3345 0
 5534 0084 059D     		ldr	r5, [sp, #20]
 5535 0086 2846     		mov	r0, r5
 5536              	.LVL808:
 5537 0088 3146     		mov	r1, r6
 5538 008a FFF7FEFF 		bl	clust2sect
 5539              	.LVL809:
 5540 008e 8046     		mov	r8, r0
 5541              	.LVL810:
3346:lib/ff/ff.c   **** 				dir = dj.fs->win;
 5542              		.loc 1 3346 0
 5543 0090 05F13407 		add	r7, r5, #52
 5544              	.LVL811:
3347:lib/ff/ff.c   **** 				mem_set(dir, 0, SS(dj.fs));
 5545              		.loc 1 3347 0
 5546 0094 3846     		mov	r0, r7
 5547              	.LVL812:
 5548 0096 2146     		mov	r1, r4
 5549 0098 4FF40072 		mov	r2, #512
 5550 009c FFF7FEFF 		bl	mem_set
 5551              	.LVL813:
3348:lib/ff/ff.c   **** 				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
 5552              		.loc 1 3348 0
 5553 00a0 3846     		mov	r0, r7
 5554 00a2 2021     		movs	r1, #32
 5555 00a4 0B22     		movs	r2, #11
 5556 00a6 FFF7FEFF 		bl	mem_set
 5557              	.LVL814:
3349:lib/ff/ff.c   **** 				dir[DIR_Name] = '.';
 5558              		.loc 1 3349 0
 5559 00aa 2E24     		movs	r4, #46
 5560 00ac 85F83440 		strb	r4, [r5, #52]
3350:lib/ff/ff.c   **** 				dir[DIR_Attr] = AM_DIR;
 5561              		.loc 1 3350 0
 5562 00b0 1023     		movs	r3, #16
 5563 00b2 85F83F30 		strb	r3, [r5, #63]
3351:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tim);
 5564              		.loc 1 3351 0
 5565 00b6 C5F84A90 		str	r9, [r5, #74]
 5566              	.LVL815:
 5567              	.LBB112:
 5568              	.LBB113:
1205:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 5569              		.loc 1 1205 0
 5570 00ba 1FFA86FB 		uxth	fp, r6
 5571 00be A5F84EB0 		strh	fp, [r5, #78]	@ movhi
1206:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 5572              		.loc 1 1206 0
 5573 00c2 26FA03FA 		lsr	sl, r6, r3
 5574 00c6 A5F848A0 		strh	sl, [r5, #72]	@ movhi
 5575              	.LBE113:
 5576              	.LBE112:
3353:lib/ff/ff.c   **** 				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
 5577              		.loc 1 3353 0
 5578 00ca 05F15400 		add	r0, r5, #84
 5579 00ce 3946     		mov	r1, r7
 5580 00d0 2022     		movs	r2, #32
 5581 00d2 FFF7FEFF 		bl	mem_cpy
 5582              	.LVL816:
3354:lib/ff/ff.c   **** 				dir[33] = '.'; pcl = dj.sclust;
 5583              		.loc 1 3354 0
 5584 00d6 85F85540 		strb	r4, [r5, #85]
 5585 00da 0798     		ldr	r0, [sp, #28]
 5586              	.LVL817:
3355:lib/ff/ff.c   **** 				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 5587              		.loc 1 3355 0
 5588 00dc 059A     		ldr	r2, [sp, #20]
 5589 00de 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 5590 00e0 0329     		cmp	r1, #3
 5591 00e2 03D1     		bne	.L719
3355:lib/ff/ff.c   **** 				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 5592              		.loc 1 3355 0 is_stmt 0 discriminator 1
 5593 00e4 946A     		ldr	r4, [r2, #40]
3356:lib/ff/ff.c   **** 					pcl = 0;
 5594              		.loc 1 3356 0 is_stmt 1 discriminator 1
 5595 00e6 A042     		cmp	r0, r4
 5596 00e8 08BF     		it	eq
 5597 00ea 0020     		moveq	r0, #0
 5598              	.LVL818:
 5599              	.L719:
 5600              	.LBB114:
 5601              	.LBB115:
1205:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 5602              		.loc 1 1205 0
 5603 00ec A5F86E00 		strh	r0, [r5, #110]	@ movhi
1206:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 5604              		.loc 1 1206 0
 5605 00f0 030C     		lsrs	r3, r0, #16
 5606 00f2 A5F86830 		strh	r3, [r5, #104]	@ movhi
 5607              	.LBE115:
 5608              	.LBE114:
3358:lib/ff/ff.c   **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 5609              		.loc 1 3358 0
 5610 00f6 9578     		ldrb	r5, [r2, #2]	@ zero_extendqisi2
 5611              	.LVL819:
 5612              	.L720:
3358:lib/ff/ff.c   **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 5613              		.loc 1 3358 0 is_stmt 0 discriminator 1
 5614 00f8 ADB1     		cbz	r5, .L738
 5615              	.L722:
3359:lib/ff/ff.c   **** 					dj.fs->winsect = dsc++;
 5616              		.loc 1 3359 0 is_stmt 1
 5617 00fa 0598     		ldr	r0, [sp, #20]
 5618 00fc C0F83080 		str	r8, [r0, #48]
 5619 0100 08F10108 		add	r8, r8, #1
 5620              	.LVL820:
3360:lib/ff/ff.c   **** 					dj.fs->wflag = 1;
 5621              		.loc 1 3360 0
 5622 0104 0124     		movs	r4, #1
 5623 0106 0471     		strb	r4, [r0, #4]
3361:lib/ff/ff.c   **** 					res = move_window(dj.fs, 0);
 5624              		.loc 1 3361 0
 5625 0108 0021     		movs	r1, #0
 5626 010a FFF7FEFF 		bl	move_window
 5627              	.LVL821:
3362:lib/ff/ff.c   **** 					if (res != FR_OK) break;
 5628              		.loc 1 3362 0
 5629 010e 0446     		mov	r4, r0
 5630 0110 0028     		cmp	r0, #0
 5631 0112 A3D1     		bne	.L725
3363:lib/ff/ff.c   **** 					mem_set(dir, 0, SS(dj.fs));
 5632              		.loc 1 3363 0
 5633 0114 3846     		mov	r0, r7
 5634              	.LVL822:
 5635 0116 2146     		mov	r1, r4
 5636 0118 4FF40072 		mov	r2, #512
 5637 011c FFF7FEFF 		bl	mem_set
 5638              	.LVL823:
3358:lib/ff/ff.c   **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 5639              		.loc 1 3358 0
 5640 0120 013D     		subs	r5, r5, #1
 5641              	.LVL824:
 5642 0122 EDB2     		uxtb	r5, r5
 5643              	.LVL825:
 5644 0124 E8E7     		b	.L720
 5645              	.LVL826:
 5646              	.L738:
3366:lib/ff/ff.c   **** 			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
 5647              		.loc 1 3366 0 discriminator 1
 5648 0126 05A8     		add	r0, sp, #20
 5649 0128 FFF7FEFF 		bl	dir_register
 5650              	.LVL827:
3367:lib/ff/ff.c   **** 			if (res != FR_OK) {
 5651              		.loc 1 3367 0 discriminator 1
 5652 012c 0446     		mov	r4, r0
 5653 012e 0028     		cmp	r0, #0
 5654 0130 94D1     		bne	.L725
 5655              	.L723:
3370:lib/ff/ff.c   **** 				dir = dj.dir;
 5656              		.loc 1 3370 0
 5657 0132 0A98     		ldr	r0, [sp, #40]
 5658              	.LVL828:
3371:lib/ff/ff.c   **** 				dir[DIR_Attr] = AM_DIR;				/* Attribute */
 5659              		.loc 1 3371 0
 5660 0134 1022     		movs	r2, #16
 5661 0136 C272     		strb	r2, [r0, #11]
3372:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
 5662              		.loc 1 3372 0
 5663 0138 C0F81690 		str	r9, [r0, #22]
 5664              	.LVL829:
 5665              	.LBB116:
 5666              	.LBB117:
1205:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 5667              		.loc 1 1205 0
 5668 013c A0F81AB0 		strh	fp, [r0, #26]	@ movhi
1206:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 5669              		.loc 1 1206 0
 5670 0140 A0F814A0 		strh	sl, [r0, #20]	@ movhi
 5671              	.LBE117:
 5672              	.LBE116:
3374:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
 5673              		.loc 1 3374 0
 5674 0144 0598     		ldr	r0, [sp, #20]
 5675              	.LVL830:
 5676 0146 0121     		movs	r1, #1
 5677 0148 0171     		strb	r1, [r0, #4]
3375:lib/ff/ff.c   **** 				res = sync(dj.fs);
 5678              		.loc 1 3375 0
 5679 014a FFF7FEFF 		bl	sync
 5680              	.LVL831:
 5681 014e 0446     		mov	r4, r0
 5682              	.LVL832:
 5683              	.L733:
3382:lib/ff/ff.c   **** }
 5684              		.loc 1 3382 0
 5685 0150 2046     		mov	r0, r4
 5686 0152 0DB0     		add	sp, sp, #52
 5687 0154 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
 5688              		.cfi_endproc
 5689              	.LFE42:
 5691              		.section	.text.f_chmod,"ax",%progbits
 5692              		.align	1
 5693              		.global	f_chmod
 5694              		.thumb
 5695              		.thumb_func
 5697              	f_chmod:
 5698              	.LFB43:
3396:lib/ff/ff.c   **** {
 5699              		.loc 1 3396 0
 5700              		.cfi_startproc
 5701              		@ args = 0, pretend = 0, frame = 48
 5702              		@ frame_needed = 0, uses_anonymous_args = 0
 5703              	.LVL833:
 5704 0000 30B5     		push	{r4, r5, lr}
 5705              	.LCFI39:
 5706              		.cfi_def_cfa_offset 12
 5707              		.cfi_offset 4, -12
 5708              		.cfi_offset 5, -8
 5709              		.cfi_offset 14, -4
 5710 0002 8DB0     		sub	sp, sp, #52
 5711              	.LCFI40:
 5712              		.cfi_def_cfa_offset 64
 5713 0004 0CAB     		add	r3, sp, #48
 5714 0006 43F82C0D 		str	r0, [r3, #-44]!
 5715 000a 0C46     		mov	r4, r1
 5716 000c 1546     		mov	r5, r2
3403:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
 5717              		.loc 1 3403 0
 5718 000e 1846     		mov	r0, r3
 5719              	.LVL834:
 5720 0010 05A9     		add	r1, sp, #20
 5721              	.LVL835:
 5722 0012 0122     		movs	r2, #1
 5723              	.LVL836:
 5724 0014 FFF7FEFF 		bl	chk_mounted
 5725              	.LVL837:
3404:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5726              		.loc 1 3404 0
 5727 0018 F0B9     		cbnz	r0, .L746
3405:lib/ff/ff.c   **** 		INIT_BUF(dj);
 5728              		.loc 1 3405 0
 5729 001a 02A8     		add	r0, sp, #8
 5730              	.LVL838:
 5731 001c 0B90     		str	r0, [sp, #44]
3406:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the file path */
 5732              		.loc 1 3406 0
 5733 001e 05A8     		add	r0, sp, #20
 5734              	.LVL839:
 5735 0020 0199     		ldr	r1, [sp, #4]
 5736 0022 FFF7FEFF 		bl	follow_path
 5737              	.LVL840:
3408:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 5738              		.loc 1 3408 0
 5739 0026 B8B9     		cbnz	r0, .L746
3408:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 5740              		.loc 1 3408 0 is_stmt 0 discriminator 1
 5741 0028 0B99     		ldr	r1, [sp, #44]
 5742 002a CA7A     		ldrb	r2, [r1, #11]	@ zero_extendqisi2
 5743 002c 02F02003 		and	r3, r2, #32
 5744 0030 D8B2     		uxtb	r0, r3
 5745              	.LVL841:
 5746 0032 80B9     		cbnz	r0, .L744
 5747              	.LVL842:
3411:lib/ff/ff.c   **** 			dir = dj.dir;
 5748              		.loc 1 3411 0 is_stmt 1
 5749 0034 0A9B     		ldr	r3, [sp, #40]
 5750              	.LVL843:
3412:lib/ff/ff.c   **** 			if (!dir) {						/* Is it a root directory? */
 5751              		.loc 1 3412 0
 5752 0036 73B1     		cbz	r3, .L744
 5753              	.L748:
3415:lib/ff/ff.c   **** 				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
 5754              		.loc 1 3415 0
 5755 0038 05F02702 		and	r2, r5, #39
 5756              	.LVL844:
3416:lib/ff/ff.c   **** 				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 5757              		.loc 1 3416 0
 5758 003c D97A     		ldrb	r1, [r3, #11]	@ zero_extendqisi2
 5759 003e 21EA0201 		bic	r1, r1, r2
 5760 0042 1440     		ands	r4, r4, r2
 5761 0044 41EA0400 		orr	r0, r1, r4
 5762 0048 D872     		strb	r0, [r3, #11]
3417:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
 5763              		.loc 1 3417 0
 5764 004a 0598     		ldr	r0, [sp, #20]
 5765 004c 0123     		movs	r3, #1
 5766              	.LVL845:
 5767 004e 0371     		strb	r3, [r0, #4]
3418:lib/ff/ff.c   **** 				res = sync(dj.fs);
 5768              		.loc 1 3418 0
 5769 0050 FFF7FEFF 		bl	sync
 5770              	.LVL846:
 5771 0054 00E0     		b	.L746
 5772              	.LVL847:
 5773              	.L744:
3409:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 5774              		.loc 1 3409 0
 5775 0056 0620     		movs	r0, #6
 5776              	.LVL848:
 5777              	.L746:
3424:lib/ff/ff.c   **** }
 5778              		.loc 1 3424 0
 5779 0058 0DB0     		add	sp, sp, #52
 5780 005a 30BD     		pop	{r4, r5, pc}
 5781              		.cfi_endproc
 5782              	.LFE43:
 5784              		.section	.text.f_utime,"ax",%progbits
 5785              		.align	1
 5786              		.global	f_utime
 5787              		.thumb
 5788              		.thumb_func
 5790              	f_utime:
 5791              	.LFB44:
3437:lib/ff/ff.c   **** {
 5792              		.loc 1 3437 0
 5793              		.cfi_startproc
 5794              		@ args = 0, pretend = 0, frame = 48
 5795              		@ frame_needed = 0, uses_anonymous_args = 0
 5796              	.LVL849:
 5797 0000 10B5     		push	{r4, lr}
 5798              	.LCFI41:
 5799              		.cfi_def_cfa_offset 8
 5800              		.cfi_offset 4, -8
 5801              		.cfi_offset 14, -4
 5802 0002 8CB0     		sub	sp, sp, #48
 5803              	.LCFI42:
 5804              		.cfi_def_cfa_offset 56
 5805 0004 0CAB     		add	r3, sp, #48
 5806 0006 43F82C0D 		str	r0, [r3, #-44]!
 5807 000a 0C46     		mov	r4, r1
3444:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
 5808              		.loc 1 3444 0
 5809 000c 1846     		mov	r0, r3
 5810              	.LVL850:
 5811 000e 05A9     		add	r1, sp, #20
 5812              	.LVL851:
 5813 0010 0122     		movs	r2, #1
 5814 0012 FFF7FEFF 		bl	chk_mounted
 5815              	.LVL852:
3445:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5816              		.loc 1 3445 0
 5817 0016 C8B9     		cbnz	r0, .L756
3446:lib/ff/ff.c   **** 		INIT_BUF(dj);
 5818              		.loc 1 3446 0
 5819 0018 02A8     		add	r0, sp, #8
 5820              	.LVL853:
 5821 001a 0B90     		str	r0, [sp, #44]
3447:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
 5822              		.loc 1 3447 0
 5823 001c 05A8     		add	r0, sp, #20
 5824              	.LVL854:
 5825 001e 0199     		ldr	r1, [sp, #4]
 5826 0020 FFF7FEFF 		bl	follow_path
 5827              	.LVL855:
3449:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 5828              		.loc 1 3449 0
 5829 0024 90B9     		cbnz	r0, .L756
3449:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 5830              		.loc 1 3449 0 is_stmt 0 discriminator 1
 5831 0026 0B99     		ldr	r1, [sp, #44]
 5832 0028 CA7A     		ldrb	r2, [r1, #11]	@ zero_extendqisi2
 5833 002a 02F02003 		and	r3, r2, #32
 5834 002e D8B2     		uxtb	r0, r3
 5835              	.LVL856:
 5836 0030 58B9     		cbnz	r0, .L754
 5837              	.LVL857:
3452:lib/ff/ff.c   **** 			dir = dj.dir;
 5838              		.loc 1 3452 0 is_stmt 1
 5839 0032 0A99     		ldr	r1, [sp, #40]
 5840              	.LVL858:
3453:lib/ff/ff.c   **** 			if (!dir) {					/* Root directory */
 5841              		.loc 1 3453 0
 5842 0034 49B1     		cbz	r1, .L754
 5843              	.L758:
3456:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_WrtTime, fno->ftime);
 5844              		.loc 1 3456 0
 5845 0036 E288     		ldrh	r2, [r4, #6]
 5846 0038 CA82     		strh	r2, [r1, #22]	@ movhi
3457:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 5847              		.loc 1 3457 0
 5848 003a A388     		ldrh	r3, [r4, #4]
 5849 003c 0B83     		strh	r3, [r1, #24]	@ movhi
3458:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
 5850              		.loc 1 3458 0
 5851 003e 0598     		ldr	r0, [sp, #20]
 5852 0040 0121     		movs	r1, #1
 5853              	.LVL859:
 5854 0042 0171     		strb	r1, [r0, #4]
3459:lib/ff/ff.c   **** 				res = sync(dj.fs);
 5855              		.loc 1 3459 0
 5856 0044 FFF7FEFF 		bl	sync
 5857              	.LVL860:
 5858 0048 00E0     		b	.L756
 5859              	.LVL861:
 5860              	.L754:
3450:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 5861              		.loc 1 3450 0
 5862 004a 0620     		movs	r0, #6
 5863              	.LVL862:
 5864              	.L756:
3465:lib/ff/ff.c   **** }
 5865              		.loc 1 3465 0
 5866 004c 0CB0     		add	sp, sp, #48
 5867 004e 10BD     		pop	{r4, pc}
 5868              		.cfi_endproc
 5869              	.LFE44:
 5871              		.section	.text.f_rename,"ax",%progbits
 5872              		.align	1
 5873              		.global	f_rename
 5874              		.thumb
 5875              		.thumb_func
 5877              	f_rename:
 5878              	.LFB45:
3478:lib/ff/ff.c   **** {
 5879              		.loc 1 3478 0
 5880              		.cfi_startproc
 5881              		@ args = 0, pretend = 0, frame = 104
 5882              		@ frame_needed = 0, uses_anonymous_args = 0
 5883              	.LVL863:
 5884 0000 30B5     		push	{r4, r5, lr}
 5885              	.LCFI43:
 5886              		.cfi_def_cfa_offset 12
 5887              		.cfi_offset 4, -12
 5888              		.cfi_offset 5, -8
 5889              		.cfi_offset 14, -4
 5890 0002 9BB0     		sub	sp, sp, #108
 5891              	.LCFI44:
 5892              		.cfi_def_cfa_offset 120
 5893 0004 1AAB     		add	r3, sp, #104
 5894 0006 43F8640D 		str	r0, [r3, #-100]!
 5895 000a 0C46     		mov	r4, r1
3486:lib/ff/ff.c   **** 	res = chk_mounted(&path_old, &djo.fs, 1);
 5896              		.loc 1 3486 0
 5897 000c 1846     		mov	r0, r3
 5898              	.LVL864:
 5899 000e 0CA9     		add	r1, sp, #48
 5900              	.LVL865:
 5901 0010 0122     		movs	r2, #1
 5902 0012 FFF7FEFF 		bl	chk_mounted
 5903              	.LVL866:
3487:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5904              		.loc 1 3487 0
 5905 0016 0028     		cmp	r0, #0
 5906 0018 77D1     		bne	.L777
3488:lib/ff/ff.c   **** 		djn.fs = djo.fs;
 5907              		.loc 1 3488 0
 5908 001a 0C98     		ldr	r0, [sp, #48]
 5909              	.LVL867:
 5910 001c 1390     		str	r0, [sp, #76]
3489:lib/ff/ff.c   **** 		INIT_BUF(djo);
 5911              		.loc 1 3489 0
 5912 001e 03A9     		add	r1, sp, #12
 5913 0020 1291     		str	r1, [sp, #72]
3490:lib/ff/ff.c   **** 		res = follow_path(&djo, path_old);		/* Check old object */
 5914              		.loc 1 3490 0
 5915 0022 0CA8     		add	r0, sp, #48
 5916              	.LVL868:
 5917 0024 0199     		ldr	r1, [sp, #4]
 5918 0026 FFF7FEFF 		bl	follow_path
 5919              	.LVL869:
3491:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
 5920              		.loc 1 3491 0
 5921 002a 0028     		cmp	r0, #0
 5922 002c 6DD1     		bne	.L777
3491:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
 5923              		.loc 1 3491 0 is_stmt 0 discriminator 1
 5924 002e 129A     		ldr	r2, [sp, #72]
 5925 0030 D37A     		ldrb	r3, [r2, #11]	@ zero_extendqisi2
 5926 0032 03F02000 		and	r0, r3, #32
 5927              	.LVL870:
 5928 0036 C1B2     		uxtb	r1, r0
 5929 0038 0029     		cmp	r1, #0
 5930 003a 5BD1     		bne	.L771
 5931              	.LVL871:
3497:lib/ff/ff.c   **** 			if (!djo.dir) {						/* Is root dir? */
 5932              		.loc 1 3497 0 is_stmt 1
 5933 003c 1199     		ldr	r1, [sp, #68]
 5934 003e 0029     		cmp	r1, #0
 5935 0040 56D0     		beq	.L782
 5936              	.L781:
3500:lib/ff/ff.c   **** 				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
 5937              		.loc 1 3500 0
 5938 0042 06A8     		add	r0, sp, #24
 5939 0044 0B31     		adds	r1, r1, #11
 5940 0046 1522     		movs	r2, #21
 5941 0048 FFF7FEFF 		bl	mem_cpy
 5942              	.LVL872:
3501:lib/ff/ff.c   **** 				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
 5943              		.loc 1 3501 0
 5944 004c 13A8     		add	r0, sp, #76
 5945 004e 0CA9     		add	r1, sp, #48
 5946 0050 1C22     		movs	r2, #28
 5947 0052 FFF7FEFF 		bl	mem_cpy
 5948              	.LVL873:
3502:lib/ff/ff.c   **** 				res = follow_path(&djn, path_new);
 5949              		.loc 1 3502 0
 5950 0056 13A8     		add	r0, sp, #76
 5951 0058 2146     		mov	r1, r4
 5952 005a FFF7FEFF 		bl	follow_path
 5953              	.LVL874:
3503:lib/ff/ff.c   **** 				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
 5954              		.loc 1 3503 0
 5955 005e 0028     		cmp	r0, #0
 5956 0060 44D0     		beq	.L772
3504:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
 5957              		.loc 1 3504 0
 5958 0062 0428     		cmp	r0, #4
 5959 0064 51D1     		bne	.L777
3506:lib/ff/ff.c   **** 					res = dir_register(&djn);			/* Register the new entry */
 5960              		.loc 1 3506 0
 5961 0066 13A8     		add	r0, sp, #76
 5962              	.LVL875:
 5963 0068 FFF7FEFF 		bl	dir_register
 5964              	.LVL876:
3507:lib/ff/ff.c   **** 					if (res == FR_OK) {
 5965              		.loc 1 3507 0
 5966 006c 0028     		cmp	r0, #0
 5967 006e 4CD1     		bne	.L777
3508:lib/ff/ff.c   **** 						dir = djn.dir;					/* Copy object information except for name */
 5968              		.loc 1 3508 0
 5969 0070 189C     		ldr	r4, [sp, #96]
 5970              	.LVL877:
3509:lib/ff/ff.c   **** 						mem_cpy(dir+13, buf+2, 19);
 5971              		.loc 1 3509 0
 5972 0072 04F10D00 		add	r0, r4, #13
 5973              	.LVL878:
 5974 0076 0DF11A01 		add	r1, sp, #26
 5975 007a 1322     		movs	r2, #19
 5976 007c FFF7FEFF 		bl	mem_cpy
 5977              	.LVL879:
3510:lib/ff/ff.c   **** 						dir[DIR_Attr] = buf[0] | AM_ARC;
 5978              		.loc 1 3510 0
 5979 0080 9DF81850 		ldrb	r5, [sp, #24]	@ zero_extendqisi2
 5980 0084 45F02002 		orr	r2, r5, #32
 5981 0088 E272     		strb	r2, [r4, #11]
3511:lib/ff/ff.c   **** 						djo.fs->wflag = 1;
 5982              		.loc 1 3511 0
 5983 008a 0C9D     		ldr	r5, [sp, #48]
 5984 008c 0123     		movs	r3, #1
 5985 008e 2B71     		strb	r3, [r5, #4]
3512:lib/ff/ff.c   **** 						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the direct
 5986              		.loc 1 3512 0
 5987 0090 1598     		ldr	r0, [sp, #84]
 5988 0092 0E99     		ldr	r1, [sp, #56]
 5989 0094 8142     		cmp	r1, r0
 5990 0096 2FD0     		beq	.L768
3512:lib/ff/ff.c   **** 						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the direct
 5991              		.loc 1 3512 0 is_stmt 0 discriminator 1
 5992 0098 E27A     		ldrb	r2, [r4, #11]	@ zero_extendqisi2
 5993 009a 02F01003 		and	r3, r2, #16
 5994 009e D8B2     		uxtb	r0, r3
 5995 00a0 50B3     		cbz	r0, .L768
 5996              	.LVL880:
 5997              	.LBB122:
 5998              	.LBB123:
1190:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
 5999              		.loc 1 1190 0 is_stmt 1
 6000 00a2 618B     		ldrh	r1, [r4, #26]
 6001              	.LVL881:
1191:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 6002              		.loc 1 1191 0
 6003 00a4 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 6004 00a6 032A     		cmp	r2, #3
1192:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 6005              		.loc 1 1192 0
 6006 00a8 04BF     		itt	eq
 6007 00aa A28A     		ldrheq	r2, [r4, #20]
 6008 00ac 41EA0241 		orreq	r1, r1, r2, lsl #16
 6009              	.LVL882:
 6010              	.LBE123:
 6011              	.LBE122:
3513:lib/ff/ff.c   **** 							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
 6012              		.loc 1 3513 0
 6013 00b0 2846     		mov	r0, r5
 6014 00b2 FFF7FEFF 		bl	clust2sect
 6015              	.LVL883:
3514:lib/ff/ff.c   **** 							if (!dw) {
 6016              		.loc 1 3514 0
 6017 00b6 0146     		mov	r1, r0
 6018 00b8 30B3     		cbz	r0, .L773
3517:lib/ff/ff.c   **** 								res = move_window(djo.fs, dw);
 6019              		.loc 1 3517 0
 6020 00ba 2846     		mov	r0, r5
 6021              	.LVL884:
 6022 00bc FFF7FEFF 		bl	move_window
 6023              	.LVL885:
3518:lib/ff/ff.c   **** 								dir = djo.fs->win+SZ_DIR;	/* .. entry */
 6024              		.loc 1 3518 0
 6025 00c0 0C9B     		ldr	r3, [sp, #48]
 6026              	.LVL886:
3519:lib/ff/ff.c   **** 								if (res == FR_OK && dir[1] == '.') {
 6027              		.loc 1 3519 0
 6028 00c2 10BB     		cbnz	r0, .L777
3519:lib/ff/ff.c   **** 								if (res == FR_OK && dir[1] == '.') {
 6029              		.loc 1 3519 0 is_stmt 0 discriminator 1
 6030 00c4 93F85510 		ldrb	r1, [r3, #85]	@ zero_extendqisi2
 6031 00c8 2E29     		cmp	r1, #46
 6032 00ca 15D1     		bne	.L768
3520:lib/ff/ff.c   **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 6033              		.loc 1 3520 0 is_stmt 1
 6034 00cc 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6035 00ce 032A     		cmp	r2, #3
 6036 00d0 03D1     		bne	.L766
3520:lib/ff/ff.c   **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 6037              		.loc 1 3520 0 is_stmt 0 discriminator 2
 6038 00d2 9A6A     		ldr	r2, [r3, #40]
 6039 00d4 1599     		ldr	r1, [sp, #84]
 6040 00d6 9142     		cmp	r1, r2
 6041 00d8 00D0     		beq	.L767
 6042              	.L766:
3520:lib/ff/ff.c   **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 6043              		.loc 1 3520 0 discriminator 1
 6044 00da 1598     		ldr	r0, [sp, #84]
 6045              	.LVL887:
 6046              	.L767:
 6047              	.LBB124:
 6048              	.LBB125:
1205:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusLO, cl);
 6049              		.loc 1 1205 0 is_stmt 1 discriminator 3
 6050 00dc A3F86E00 		strh	r0, [r3, #110]	@ movhi
1206:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 6051              		.loc 1 1206 0 discriminator 3
 6052 00e0 000C     		lsrs	r0, r0, #16
 6053              	.LVL888:
 6054 00e2 A3F86800 		strh	r0, [r3, #104]	@ movhi
 6055              	.LBE125:
 6056              	.LBE124:
3522:lib/ff/ff.c   **** 									djo.fs->wflag = 1;
 6057              		.loc 1 3522 0 discriminator 3
 6058 00e6 0122     		movs	r2, #1
 6059 00e8 1A71     		strb	r2, [r3, #4]
 6060 00ea 05E0     		b	.L768
 6061              	.LVL889:
 6062              	.L772:
3503:lib/ff/ff.c   **** 				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
 6063              		.loc 1 3503 0
 6064 00ec 0820     		movs	r0, #8
 6065              	.LVL890:
 6066 00ee 0CE0     		b	.L777
 6067              	.LVL891:
 6068              	.L782:
3498:lib/ff/ff.c   **** 				res = FR_NO_FILE;
 6069              		.loc 1 3498 0
 6070 00f0 0420     		movs	r0, #4
 6071 00f2 0AE0     		b	.L777
 6072              	.LVL892:
 6073              	.L771:
3492:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 6074              		.loc 1 3492 0
 6075 00f4 0620     		movs	r0, #6
 6076              	.LVL893:
 6077 00f6 08E0     		b	.L777
 6078              	.LVL894:
 6079              	.L768:
3527:lib/ff/ff.c   **** 							res = dir_remove(&djo);		/* Remove old entry */
 6080              		.loc 1 3527 0
 6081 00f8 0CA8     		add	r0, sp, #48
 6082 00fa FFF7FEFF 		bl	dir_remove
 6083              	.LVL895:
3528:lib/ff/ff.c   **** 							if (res == FR_OK)
 6084              		.loc 1 3528 0
 6085 00fe 20B9     		cbnz	r0, .L777
3529:lib/ff/ff.c   **** 								res = sync(djo.fs);
 6086              		.loc 1 3529 0
 6087 0100 0C98     		ldr	r0, [sp, #48]
 6088              	.LVL896:
 6089 0102 FFF7FEFF 		bl	sync
 6090              	.LVL897:
 6091 0106 00E0     		b	.L777
 6092              	.LVL898:
 6093              	.L773:
3515:lib/ff/ff.c   **** 								res = FR_INT_ERR;
 6094              		.loc 1 3515 0
 6095 0108 0220     		movs	r0, #2
 6096              	.LVL899:
 6097              	.L777:
3539:lib/ff/ff.c   **** }
 6098              		.loc 1 3539 0
 6099 010a 1BB0     		add	sp, sp, #108
 6100 010c 30BD     		pop	{r4, r5, pc}
 6101              		.cfi_endproc
 6102              	.LFE45:
 6104              		.section	.text.f_forward,"ax",%progbits
 6105              		.align	1
 6106              		.global	f_forward
 6107              		.thumb
 6108              		.thumb_func
 6110              	f_forward:
 6111              	.LFB46:
3559:lib/ff/ff.c   **** {
 6112              		.loc 1 3559 0
 6113              		.cfi_startproc
 6114              		@ args = 0, pretend = 0, frame = 0
 6115              		@ frame_needed = 0, uses_anonymous_args = 0
 6116              	.LVL900:
 6117 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
 6118              	.LCFI45:
 6119              		.cfi_def_cfa_offset 32
 6120              		.cfi_offset 4, -32
 6121              		.cfi_offset 5, -28
 6122              		.cfi_offset 6, -24
 6123              		.cfi_offset 7, -20
 6124              		.cfi_offset 8, -16
 6125              		.cfi_offset 9, -12
 6126              		.cfi_offset 10, -8
 6127              		.cfi_offset 14, -4
 6128 0004 8846     		mov	r8, r1
 6129 0006 9146     		mov	r9, r2
 6130 0008 1F46     		mov	r7, r3
3566:lib/ff/ff.c   **** 	*bf = 0;	/* Clear transfer byte counter */
 6131              		.loc 1 3566 0
 6132 000a 0023     		movs	r3, #0
 6133              	.LVL901:
 6134 000c 3B60     		str	r3, [r7, #0]
3568:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
 6135              		.loc 1 3568 0
 6136 000e 0446     		mov	r4, r0
 6137 0010 0028     		cmp	r0, #0
 6138 0012 5FD0     		beq	.L797
3570:lib/ff/ff.c   **** 	res = validate(fp);								/* Check validity of the object */
 6139              		.loc 1 3570 0
 6140 0014 FFF7FEFF 		bl	validate
 6141              	.LVL902:
3571:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 6142              		.loc 1 3571 0
 6143 0018 0546     		mov	r5, r0
 6144 001a 0028     		cmp	r0, #0
 6145 001c 5FD1     		bne	.L784
3572:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)						/* Check error flag */
 6146              		.loc 1 3572 0
 6147 001e A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 6148              	.LVL903:
 6149 0020 0106     		lsls	r1, r0, #24
 6150 0022 59D4     		bmi	.L798
3574:lib/ff/ff.c   **** 	if (!(fp->flag & FA_READ))						/* Check access mode */
 6151              		.loc 1 3574 0
 6152 0024 C207     		lsls	r2, r0, #31
 6153 0026 59D5     		bpl	.L799
 6154              	.LVL904:
3577:lib/ff/ff.c   **** 	remain = fp->fsize - fp->fptr;
 6155              		.loc 1 3577 0
 6156 0028 E168     		ldr	r1, [r4, #12]
 6157 002a A268     		ldr	r2, [r4, #8]
 6158 002c 8E1A     		subs	r6, r1, r2
 6159              	.LVL905:
 6160 002e B145     		cmp	r9, r6
 6161 0030 38BF     		it	cc
 6162 0032 4E46     		movcc	r6, r9
 6163              	.LVL906:
 6164              	.L785:
3580:lib/ff/ff.c   **** 	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
 6165              		.loc 1 3580 0 discriminator 1
 6166 0034 002E     		cmp	r6, #0
 6167 0036 52D0     		beq	.L784
3580:lib/ff/ff.c   **** 	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
 6168              		.loc 1 3580 0 is_stmt 0 discriminator 2
 6169 0038 0020     		movs	r0, #0
 6170 003a 0146     		mov	r1, r0
 6171 003c C047     		blx	r8
 6172              	.LVL907:
 6173 003e 0028     		cmp	r0, #0
 6174 0040 4DD0     		beq	.L784
 6175              	.L795:
3582:lib/ff/ff.c   **** 		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 6176              		.loc 1 3582 0 is_stmt 1
 6177 0042 A368     		ldr	r3, [r4, #8]
 6178 0044 2068     		ldr	r0, [r4, #0]
 6179 0046 90F80290 		ldrb	r9, [r0, #2]	@ zero_extendqisi2
 6180 004a 09F1FF31 		add	r1, r9, #-1
 6181 004e 01EA5322 		and	r2, r1, r3, lsr #9
 6182 0052 5FFA82F9 		uxtb	r9, r2
 6183              	.LVL908:
3583:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 6184              		.loc 1 3583 0
 6185 0056 DA05     		lsls	r2, r3, #23
 6186              	.LVL909:
 6187 0058 0DD1     		bne	.L786
3584:lib/ff/ff.c   **** 			if (!csect) {							/* On the cluster boundary? */
 6188              		.loc 1 3584 0
 6189 005a B9F1000F 		cmp	r9, #0
 6190 005e 0AD1     		bne	.L786
3586:lib/ff/ff.c   **** 					fp->sclust : get_fat(fp->fs, fp->clust);
 6191              		.loc 1 3586 0
 6192 0060 0BB9     		cbnz	r3, .L787
3586:lib/ff/ff.c   **** 					fp->sclust : get_fat(fp->fs, fp->clust);
 6193              		.loc 1 3586 0 is_stmt 0 discriminator 1
 6194 0062 2069     		ldr	r0, [r4, #16]
 6195 0064 02E0     		b	.L788
 6196              	.L787:
3586:lib/ff/ff.c   **** 					fp->sclust : get_fat(fp->fs, fp->clust);
 6197              		.loc 1 3586 0 discriminator 2
 6198 0066 6169     		ldr	r1, [r4, #20]
 6199 0068 FFF7FEFF 		bl	get_fat
 6200              	.LVL910:
 6201              	.L788:
3587:lib/ff/ff.c   **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
 6202              		.loc 1 3587 0 is_stmt 1
 6203 006c 0128     		cmp	r0, #1
 6204 006e 24D9     		bls	.L801
 6205              	.L789:
3588:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 6206              		.loc 1 3588 0
 6207 0070 431C     		adds	r3, r0, #1
 6208 0072 0DD0     		beq	.L800
 6209              	.L790:
3589:lib/ff/ff.c   **** 				fp->clust = clst;					/* Update current cluster */
 6210              		.loc 1 3589 0
 6211 0074 6061     		str	r0, [r4, #20]
 6212              	.LVL911:
 6213              	.L786:
3592:lib/ff/ff.c   **** 		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
 6214              		.loc 1 3592 0
 6215 0076 D4F800A0 		ldr	sl, [r4, #0]
 6216 007a 5046     		mov	r0, sl
 6217 007c 6169     		ldr	r1, [r4, #20]
 6218 007e FFF7FEFF 		bl	clust2sect
 6219              	.LVL912:
3593:lib/ff/ff.c   **** 		if (!sect) ABORT(fp->fs, FR_INT_ERR);
 6220              		.loc 1 3593 0
 6221 0082 D0B1     		cbz	r0, .L801
 6222              	.L791:
3594:lib/ff/ff.c   **** 		sect += csect;
 6223              		.loc 1 3594 0
 6224 0084 8144     		add	r9, r0, r9
 6225              	.LVL913:
3595:lib/ff/ff.c   **** 		if (move_window(fp->fs, sect))				/* Move sector window */
 6226              		.loc 1 3595 0
 6227 0086 5046     		mov	r0, sl
 6228 0088 4946     		mov	r1, r9
 6229 008a FFF7FEFF 		bl	move_window
 6230              	.LVL914:
 6231 008e 28B1     		cbz	r0, .L792
 6232              	.LVL915:
 6233              	.L800:
3596:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
 6234              		.loc 1 3596 0
 6235 0090 A579     		ldrb	r5, [r4, #6]	@ zero_extendqisi2
 6236 0092 65F07F00 		orn	r0, r5, #127
 6237 0096 A071     		strb	r0, [r4, #6]
 6238 0098 0125     		movs	r5, #1
 6239 009a 20E0     		b	.L784
 6240              	.LVL916:
 6241              	.L792:
3597:lib/ff/ff.c   **** 		fp->dsect = sect;
 6242              		.loc 1 3597 0
 6243 009c C4F81890 		str	r9, [r4, #24]
3598:lib/ff/ff.c   **** 		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
 6244              		.loc 1 3598 0
 6245 00a0 A068     		ldr	r0, [r4, #8]
 6246 00a2 C305     		lsls	r3, r0, #23
 6247 00a4 DA0D     		lsrs	r2, r3, #23
 6248 00a6 C2F50071 		rsb	r1, r2, #512
 6249              	.LVL917:
3600:lib/ff/ff.c   **** 		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
 6250              		.loc 1 3600 0
 6251 00aa 2068     		ldr	r0, [r4, #0]
 6252 00ac 8018     		adds	r0, r0, r2
 6253 00ae 3430     		adds	r0, r0, #52
 6254 00b0 8E42     		cmp	r6, r1
 6255 00b2 38BF     		it	cc
 6256 00b4 3146     		movcc	r1, r6
 6257              	.LVL918:
 6258 00b6 C047     		blx	r8
 6259              	.LVL919:
3601:lib/ff/ff.c   **** 		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
 6260              		.loc 1 3601 0
 6261 00b8 20B9     		cbnz	r0, .L793
 6262              	.LVL920:
 6263              	.L801:
3601:lib/ff/ff.c   **** 		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
 6264              		.loc 1 3601 0 is_stmt 0 discriminator 1
 6265 00ba A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 6266 00bc 63F07F02 		orn	r2, r3, #127
 6267 00c0 A271     		strb	r2, [r4, #6]
 6268 00c2 09E0     		b	.L798
 6269              	.LVL921:
 6270              	.L793:
3581:lib/ff/ff.c   **** 		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
 6271              		.loc 1 3581 0 is_stmt 1
 6272 00c4 A168     		ldr	r1, [r4, #8]
 6273 00c6 0B18     		adds	r3, r1, r0
 6274 00c8 A360     		str	r3, [r4, #8]
 6275 00ca 3A68     		ldr	r2, [r7, #0]
 6276 00cc 1118     		adds	r1, r2, r0
 6277 00ce 3960     		str	r1, [r7, #0]
 6278 00d0 361A     		subs	r6, r6, r0
 6279              	.LVL922:
 6280 00d2 AFE7     		b	.L785
 6281              	.LVL923:
 6282              	.L797:
3568:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
 6283              		.loc 1 3568 0
 6284 00d4 0925     		movs	r5, #9
 6285 00d6 02E0     		b	.L784
 6286              	.LVL924:
 6287              	.L798:
3573:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 6288              		.loc 1 3573 0
 6289 00d8 0225     		movs	r5, #2
 6290 00da 00E0     		b	.L784
 6291              	.LVL925:
 6292              	.L799:
3575:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
 6293              		.loc 1 3575 0
 6294 00dc 0725     		movs	r5, #7
 6295              	.LVL926:
 6296              	.L784:
3605:lib/ff/ff.c   **** }
 6297              		.loc 1 3605 0
 6298 00de 2846     		mov	r0, r5
 6299 00e0 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 6300              		.cfi_endproc
 6301              	.LFE46:
 6303              		.section	.text.f_mkfs,"ax",%progbits
 6304              		.align	1
 6305              		.global	f_mkfs
 6306              		.thumb
 6307              		.thumb_func
 6309              	f_mkfs:
 6310              	.LFB47:
3623:lib/ff/ff.c   **** {
 6311              		.loc 1 3623 0
 6312              		.cfi_startproc
 6313              		@ args = 0, pretend = 0, frame = 32
 6314              		@ frame_needed = 0, uses_anonymous_args = 0
 6315              	.LVL927:
 6316 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 6317              	.LCFI46:
 6318              		.cfi_def_cfa_offset 36
 6319              		.cfi_offset 4, -36
 6320              		.cfi_offset 5, -32
 6321              		.cfi_offset 6, -28
 6322              		.cfi_offset 7, -24
 6323              		.cfi_offset 8, -20
 6324              		.cfi_offset 9, -16
 6325              		.cfi_offset 10, -12
 6326              		.cfi_offset 11, -8
 6327              		.cfi_offset 14, -4
 6328 0004 89B0     		sub	sp, sp, #36
 6329              	.LCFI47:
 6330              		.cfi_def_cfa_offset 72
 6331 0006 0E46     		mov	r6, r1
 6332 0008 1746     		mov	r7, r2
3636:lib/ff/ff.c   **** 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
 6333              		.loc 1 3636 0
 6334 000a 0028     		cmp	r0, #0
 6335 000c 40F0FE81 		bne	.L842
3637:lib/ff/ff.c   **** 	if (sfd > 1) return FR_INVALID_PARAMETER;
 6336              		.loc 1 3637 0
 6337 0010 0129     		cmp	r1, #1
 6338 0012 00F2FD81 		bhi	.L844
3638:lib/ff/ff.c   **** 	if (au & (au - 1)) return FR_INVALID_PARAMETER;
 6339              		.loc 1 3638 0
 6340 0016 531E     		subs	r3, r2, #1
 6341 0018 13EA0201 		ands	r1, r3, r2
 6342              	.LVL928:
 6343 001c 40F0F881 		bne	.L844
3639:lib/ff/ff.c   **** 	fs = FatFs[drv];
 6344              		.loc 1 3639 0
 6345 0020 B14A     		ldr	r2, .L874
 6346              	.LVL929:
 6347 0022 1468     		ldr	r4, [r2, #0]
 6348              	.LVL930:
3640:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;
 6349              		.loc 1 3640 0
 6350 0024 002C     		cmp	r4, #0
 6351 0026 00F0F581 		beq	.L845
3641:lib/ff/ff.c   **** 	fs->fs_type = 0;
 6352              		.loc 1 3641 0
 6353 002a 2170     		strb	r1, [r4, #0]
 6354              	.LVL931:
3646:lib/ff/ff.c   **** 	stat = disk_initialize(pdrv);
 6355              		.loc 1 3646 0
 6356 002c FFF7FEFF 		bl	disk_initialize
 6357              	.LVL932:
3647:lib/ff/ff.c   **** 	if (stat & STA_NOINIT) return FR_NOT_READY;
 6358              		.loc 1 3647 0
 6359 0030 C307     		lsls	r3, r0, #31
 6360 0032 00F1F181 		bmi	.L846
3648:lib/ff/ff.c   **** 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 6361              		.loc 1 3648 0
 6362 0036 00F00400 		and	r0, r0, #4
 6363              	.LVL933:
 6364 003a C0B2     		uxtb	r0, r0
 6365 003c 0028     		cmp	r0, #0
 6366 003e 40F0ED81 		bne	.L847
3663:lib/ff/ff.c   **** 		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
 6367              		.loc 1 3663 0
 6368 0042 0121     		movs	r1, #1
 6369 0044 05AA     		add	r2, sp, #20
 6370 0046 FFF7FEFF 		bl	disk_ioctl
 6371              	.LVL934:
 6372 004a 08B1     		cbz	r0, .L804
 6373              	.LVL935:
 6374              	.L805:
3664:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 6375              		.loc 1 3664 0
 6376 004c 0120     		movs	r0, #1
 6377 004e 00E2     		b	.L867
 6378              	.LVL936:
 6379              	.L804:
3663:lib/ff/ff.c   **** 		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
 6380              		.loc 1 3663 0 discriminator 1
 6381 0050 059B     		ldr	r3, [sp, #20]
 6382 0052 7F2B     		cmp	r3, #127
 6383 0054 FAD9     		bls	.L805
3665:lib/ff/ff.c   **** 		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
 6384              		.loc 1 3665 0
 6385 0056 002E     		cmp	r6, #0
 6386 0058 0CBF     		ite	eq
 6387 005a 4FF03F08 		moveq	r8, #63
 6388 005e 4FF00008 		movne	r8, #0
 6389              	.LVL937:
3666:lib/ff/ff.c   **** 		n_vol -= b_vol;				/* Volume size */
 6390              		.loc 1 3666 0
 6391 0062 C8EB0303 		rsb	r3, r8, r3
 6392              	.LVL938:
 6393 0066 0593     		str	r3, [sp, #20]
 6394              	.LVL939:
3669:lib/ff/ff.c   **** 	if (!au) {				/* AU auto selection */
 6395              		.loc 1 3669 0
 6396 0068 6FB9     		cbnz	r7, .L807
3670:lib/ff/ff.c   **** 		vs = n_vol / (2000 / (SS(fs) / 512));
 6397              		.loc 1 3670 0
 6398 006a 4FF4FA65 		mov	r5, #2000
 6399 006e B3FBF5F5 		udiv	r5, r3, r5
 6400              	.LVL940:
 6401              	.L808:
3671:lib/ff/ff.c   **** 		for (i = 0; vs < vst[i]; i++) ;
 6402              		.loc 1 3671 0 discriminator 1
 6403 0072 9E4A     		ldr	r2, .L874+4
 6404 0074 32F81700 		ldrh	r0, [r2, r7, lsl #1]
 6405 0078 8542     		cmp	r5, r0
 6406 007a 01D2     		bcs	.L871
 6407              	.L809:
3671:lib/ff/ff.c   **** 		for (i = 0; vs < vst[i]; i++) ;
 6408              		.loc 1 3671 0 is_stmt 0 discriminator 2
 6409 007c 0137     		adds	r7, r7, #1
 6410              	.LVL941:
 6411 007e F8E7     		b	.L808
 6412              	.L871:
3672:lib/ff/ff.c   **** 		au = cst[i];
 6413              		.loc 1 3672 0 is_stmt 1
 6414 0080 9B49     		ldr	r1, .L874+8
 6415 0082 31F81770 		ldrh	r7, [r1, r7, lsl #1]
 6416              	.LVL942:
 6417              	.L807:
3675:lib/ff/ff.c   **** 	if (au == 0) au = 1;
 6418              		.loc 1 3675 0
 6419 0086 7F0A     		lsrs	r7, r7, #9
 6420              	.LVL943:
 6421 0088 04D0     		beq	.L849
3676:lib/ff/ff.c   **** 	if (au > 128) au = 128;
 6422              		.loc 1 3676 0
 6423 008a 802F     		cmp	r7, #128
 6424 008c 28BF     		it	cs
 6425 008e 8027     		movcs	r7, #128
 6426              	.LVL944:
 6427 0090 0197     		str	r7, [sp, #4]
 6428 0092 01E0     		b	.L811
 6429              	.LVL945:
 6430              	.L849:
3675:lib/ff/ff.c   **** 	if (au == 0) au = 1;
 6431              		.loc 1 3675 0
 6432 0094 0125     		movs	r5, #1
 6433 0096 0195     		str	r5, [sp, #4]
 6434              	.LVL946:
 6435              	.L811:
3679:lib/ff/ff.c   **** 	n_clst = n_vol / au;
 6436              		.loc 1 3679 0
 6437 0098 019A     		ldr	r2, [sp, #4]
 6438 009a B3FBF2F9 		udiv	r9, r3, r2
 6439              	.LVL947:
3681:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
 6440              		.loc 1 3681 0
 6441 009e 40F6F570 		movw	r0, #4085
 6442 00a2 8145     		cmp	r9, r0
 6443 00a4 40F2BC81 		bls	.L812
 6444              	.LVL948:
3682:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
 6445              		.loc 1 3682 0
 6446 00a8 00F57040 		add	r0, r0, #61440
 6447 00ac 8145     		cmp	r9, r0
 6448 00ae 40F2CA81 		bls	.L872
 6449              	.L813:
 6450              	.LVL949:
3686:lib/ff/ff.c   **** 		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
 6451              		.loc 1 3686 0
 6452 00b2 09F1820E 		add	lr, r9, #130
 6453 00b6 4FEA8E09 		lsl	r9, lr, #2
 6454              	.LVL950:
 6455 00ba 09F1FF37 		add	r7, r9, #-1
 6456 00be 4FEA5729 		lsr	r9, r7, #9
 6457              	.LVL951:
3682:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
 6458              		.loc 1 3682 0
 6459 00c2 0325     		movs	r5, #3
3688:lib/ff/ff.c   **** 		n_dir = 0;
 6460              		.loc 1 3688 0
 6461 00c4 0022     		movs	r2, #0
 6462 00c6 0292     		str	r2, [sp, #8]
3687:lib/ff/ff.c   **** 		n_rsv = 32;
 6463              		.loc 1 3687 0
 6464 00c8 4FF0200B 		mov	fp, #32
 6465              	.LVL952:
 6466              	.L840:
3695:lib/ff/ff.c   **** 	b_fat = b_vol + n_rsv;				/* FAT area start sector */
 6467              		.loc 1 3695 0
 6468 00cc 0BEB080A 		add	sl, fp, r8
 6469              	.LVL953:
3696:lib/ff/ff.c   **** 	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
 6470              		.loc 1 3696 0
 6471 00d0 0298     		ldr	r0, [sp, #8]
 6472 00d2 00EB0901 		add	r1, r0, r9
3697:lib/ff/ff.c   **** 	b_data = b_dir + n_dir;				/* Data area start sector */
 6473              		.loc 1 3697 0
 6474 00d6 01EB0A07 		add	r7, r1, sl
 6475              	.LVL954:
3698:lib/ff/ff.c   **** 	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
 6476              		.loc 1 3698 0
 6477 00da 019A     		ldr	r2, [sp, #4]
 6478 00dc C8EB0200 		rsb	r0, r8, r2
 6479 00e0 C119     		adds	r1, r0, r7
 6480 00e2 8B42     		cmp	r3, r1
 6481 00e4 01D2     		bcs	.L815
 6482              	.LVL955:
 6483              	.L821:
 6484 00e6 0E20     		movs	r0, #14
 6485 00e8 B3E1     		b	.L867
 6486              	.LVL956:
 6487              	.L815:
3701:lib/ff/ff.c   **** 	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
 6488              		.loc 1 3701 0
 6489 00ea 0020     		movs	r0, #0
 6490 00ec 0321     		movs	r1, #3
 6491 00ee 04AA     		add	r2, sp, #16
 6492 00f0 FFF7FEFF 		bl	disk_ioctl
 6493              	.LVL957:
 6494 00f4 20B9     		cbnz	r0, .L816
 6495              	.LVL958:
3701:lib/ff/ff.c   **** 	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
 6496              		.loc 1 3701 0 is_stmt 0 discriminator 2
 6497 00f6 049B     		ldr	r3, [sp, #16]
 6498 00f8 13B1     		cbz	r3, .L816
3701:lib/ff/ff.c   **** 	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
 6499              		.loc 1 3701 0 discriminator 1
 6500 00fa B3F5004F 		cmp	r3, #32768
 6501 00fe 01D9     		bls	.L817
 6502              	.L816:
 6503 0100 0122     		movs	r2, #1
 6504 0102 0492     		str	r2, [sp, #16]
 6505              	.L817:
3702:lib/ff/ff.c   **** 	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
 6506              		.loc 1 3702 0 is_stmt 1
 6507 0104 0498     		ldr	r0, [sp, #16]
 6508 0106 411E     		subs	r1, r0, #1
 6509 0108 CA19     		adds	r2, r1, r7
 6510 010a 4342     		negs	r3, r0
 6511 010c 1340     		ands	r3, r3, r2
3703:lib/ff/ff.c   **** 	n = (n - b_data) / N_FATS;
 6512              		.loc 1 3703 0
 6513 010e DF1B     		subs	r7, r3, r7
 6514              	.LVL959:
 6515 0110 0497     		str	r7, [sp, #16]
 6516              	.LVL960:
3704:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
 6517              		.loc 1 3704 0
 6518 0112 032D     		cmp	r5, #3
3705:lib/ff/ff.c   **** 		n_rsv += n;
 6519              		.loc 1 3705 0
 6520 0114 06BF     		itte	eq
 6521 0116 BB44     		addeq	fp, fp, r7
 6522              	.LVL961:
3706:lib/ff/ff.c   **** 		b_fat += n;
 6523              		.loc 1 3706 0
 6524 0118 BA44     		addeq	sl, sl, r7
 6525              	.LVL962:
3708:lib/ff/ff.c   **** 		n_fat += n;
 6526              		.loc 1 3708 0
 6527 011a B944     		addne	r9, r9, r7
 6528              	.LVL963:
3712:lib/ff/ff.c   **** 	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
 6529              		.loc 1 3712 0
 6530 011c 059F     		ldr	r7, [sp, #20]
 6531              	.LVL964:
 6532 011e CBEB0700 		rsb	r0, fp, r7
 6533 0122 C9EB0001 		rsb	r1, r9, r0
 6534 0126 029A     		ldr	r2, [sp, #8]
 6535 0128 8B1A     		subs	r3, r1, r2
 6536 012a 0198     		ldr	r0, [sp, #4]
 6537 012c B3FBF0F1 		udiv	r1, r3, r0
 6538 0130 0391     		str	r1, [sp, #12]
 6539              	.LVL965:
3713:lib/ff/ff.c   **** 	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
 6540              		.loc 1 3713 0
 6541 0132 022D     		cmp	r5, #2
 6542 0134 05D1     		bne	.L820
3713:lib/ff/ff.c   **** 	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
 6543              		.loc 1 3713 0 is_stmt 0 discriminator 1
 6544 0136 40F6F570 		movw	r0, #4085
 6545 013a 0399     		ldr	r1, [sp, #12]
 6546 013c 8142     		cmp	r1, r0
 6547 013e D2D9     		bls	.L821
 6548 0140 0AE0     		b	.L822
 6549              	.L820:
3714:lib/ff/ff.c   **** 		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
 6550              		.loc 1 3714 0 is_stmt 1
 6551 0142 032D     		cmp	r5, #3
 6552 0144 06D1     		bne	.L823
3714:lib/ff/ff.c   **** 		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
 6553              		.loc 1 3714 0 is_stmt 0 discriminator 1
 6554 0146 4FF6F572 		movw	r2, #65525
 6555 014a 039B     		ldr	r3, [sp, #12]
 6556 014c 9342     		cmp	r3, r2
 6557 014e CAD9     		bls	.L821
3720:lib/ff/ff.c   **** 	default: 		sys = 0x0C;
 6558              		.loc 1 3720 0 is_stmt 1
 6559 0150 0C27     		movs	r7, #12
 6560 0152 08E0     		b	.L824
 6561              	.L823:
3717:lib/ff/ff.c   **** 	switch (fmt) {	/* Determine system ID for partition table */
 6562              		.loc 1 3717 0
 6563 0154 022D     		cmp	r5, #2
 6564 0156 05D1     		bne	.L869
 6565              	.L822:
3719:lib/ff/ff.c   **** 	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
 6566              		.loc 1 3719 0
 6567 0158 B7F5803F 		cmp	r7, #65536
 6568 015c 2CBF     		ite	cs
 6569 015e 0627     		movcs	r7, #6
 6570 0160 0427     		movcc	r7, #4
 6571 0162 00E0     		b	.L824
 6572              	.L869:
3718:lib/ff/ff.c   **** 	case FS_FAT12:	sys = 0x01; break;
 6573              		.loc 1 3718 0
 6574 0164 0127     		movs	r7, #1
 6575              	.L824:
 6576              	.LVL966:
3730:lib/ff/ff.c   **** 		if (sfd) {	/* No partition table (SFD) */
 6577              		.loc 1 3730 0
 6578 0166 002E     		cmp	r6, #0
 6579 0168 39D1     		bne	.L853
3733:lib/ff/ff.c   **** 			mem_set(fs->win, 0, SS(fs));
 6580              		.loc 1 3733 0
 6581 016a 04F1340C 		add	ip, r4, #52
 6582 016e 6046     		mov	r0, ip
 6583 0170 3146     		mov	r1, r6
 6584              	.LVL967:
 6585 0172 4FF40072 		mov	r2, #512
 6586 0176 CDF800C0 		str	ip, [sp, #0]
 6587 017a FFF7FEFF 		bl	mem_set
 6588              	.LVL968:
3735:lib/ff/ff.c   **** 			tbl[1] = 1;						/* Partition start head */
 6589              		.loc 1 3735 0
 6590 017e 0123     		movs	r3, #1
 6591 0180 84F8F331 		strb	r3, [r4, #499]
3736:lib/ff/ff.c   **** 			tbl[2] = 1;						/* Partition start sector */
 6592              		.loc 1 3736 0
 6593 0184 84F8F431 		strb	r3, [r4, #500]
3737:lib/ff/ff.c   **** 			tbl[3] = 0;						/* Partition start cylinder */
 6594              		.loc 1 3737 0
 6595 0188 84F8F561 		strb	r6, [r4, #501]
3738:lib/ff/ff.c   **** 			tbl[4] = sys;					/* System type */
 6596              		.loc 1 3738 0
 6597 018c 84F8F671 		strb	r7, [r4, #502]
3739:lib/ff/ff.c   **** 			tbl[5] = 254;					/* Partition end head */
 6598              		.loc 1 3739 0
 6599 0190 FE22     		movs	r2, #254
 6600 0192 84F8F721 		strb	r2, [r4, #503]
3740:lib/ff/ff.c   **** 			n = (b_vol + n_vol) / 63 / 255;
 6601              		.loc 1 3740 0
 6602 0196 0599     		ldr	r1, [sp, #20]
 6603 0198 08EB0100 		add	r0, r8, r1
 6604 019c 43F6C162 		movw	r2, #16065
 6605 01a0 B0FBF2F2 		udiv	r2, r0, r2
 6606              	.LVL969:
 6607 01a4 0492     		str	r2, [sp, #16]
 6608              	.LVL970:
3741:lib/ff/ff.c   **** 			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partition end sector */
 6609              		.loc 1 3741 0
 6610 01a6 9008     		lsrs	r0, r2, #2
 6611 01a8 40F03F00 		orr	r0, r0, #63
 6612 01ac 84F8F801 		strb	r0, [r4, #504]
3742:lib/ff/ff.c   **** 			tbl[7] = (BYTE)n;				/* End cylinder */
 6613              		.loc 1 3742 0
 6614 01b0 84F8F921 		strb	r2, [r4, #505]
3743:lib/ff/ff.c   **** 			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
 6615              		.loc 1 3743 0
 6616 01b4 3F22     		movs	r2, #63
 6617              	.LVL971:
 6618 01b6 C4F8FA21 		str	r2, [r4, #506]
3744:lib/ff/ff.c   **** 			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
 6619              		.loc 1 3744 0
 6620 01ba C4F8FE11 		str	r1, [r4, #510]
3745:lib/ff/ff.c   **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
 6621              		.loc 1 3745 0
 6622 01be 4AF65521 		movw	r1, #43605
 6623 01c2 A4F83212 		strh	r1, [r4, #562]	@ movhi
3746:lib/ff/ff.c   **** 			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
 6624              		.loc 1 3746 0
 6625 01c6 3046     		mov	r0, r6
 6626 01c8 DDF800C0 		ldr	ip, [sp, #0]
 6627 01cc 6146     		mov	r1, ip
 6628 01ce 3246     		mov	r2, r6
 6629 01d0 FFF7FEFF 		bl	disk_write
 6630              	.LVL972:
 6631 01d4 0028     		cmp	r0, #0
 6632 01d6 7FF439AF 		bne	.L805
3748:lib/ff/ff.c   **** 			md = 0xF8;
 6633              		.loc 1 3748 0
 6634 01da F827     		movs	r7, #248
 6635              	.LVL973:
 6636 01dc 00E0     		b	.L825
 6637              	.LVL974:
 6638              	.L853:
3731:lib/ff/ff.c   **** 			md = 0xF0;
 6639              		.loc 1 3731 0
 6640 01de F027     		movs	r7, #240
 6641              	.LVL975:
 6642              	.L825:
3753:lib/ff/ff.c   **** 	tbl = fs->win;							/* Clear sector */
 6643              		.loc 1 3753 0
 6644 01e0 04F13406 		add	r6, r4, #52
 6645              	.LVL976:
3754:lib/ff/ff.c   **** 	mem_set(tbl, 0, SS(fs));
 6646              		.loc 1 3754 0
 6647 01e4 3046     		mov	r0, r6
 6648 01e6 0021     		movs	r1, #0
 6649 01e8 4FF40072 		mov	r2, #512
 6650 01ec FFF7FEFF 		bl	mem_set
 6651              	.LVL977:
3755:lib/ff/ff.c   **** 	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
 6652              		.loc 1 3755 0
 6653 01f0 3046     		mov	r0, r6
 6654 01f2 4049     		ldr	r1, .L874+12
 6655 01f4 0B22     		movs	r2, #11
 6656 01f6 FFF7FEFF 		bl	mem_cpy
 6657              	.LVL978:
3757:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_BytsPerSec, i);
 6658              		.loc 1 3757 0
 6659 01fa 4FF40073 		mov	r3, #512
 6660 01fe A4F83F30 		strh	r3, [r4, #63]	@ movhi
3758:lib/ff/ff.c   **** 	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
 6661              		.loc 1 3758 0
 6662 0202 0198     		ldr	r0, [sp, #4]
 6663 0204 84F84100 		strb	r0, [r4, #65]
3759:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
 6664              		.loc 1 3759 0
 6665 0208 A4F842B0 		strh	fp, [r4, #66]	@ movhi
3760:lib/ff/ff.c   **** 	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
 6666              		.loc 1 3760 0
 6667 020c 0122     		movs	r2, #1
 6668 020e 84F84420 		strb	r2, [r4, #68]
3761:lib/ff/ff.c   **** 	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
 6669              		.loc 1 3761 0
 6670 0212 032D     		cmp	r5, #3
 6671 0214 14BF     		ite	ne
 6672 0216 4FF40071 		movne	r1, #512
 6673 021a 0021     		moveq	r1, #0
 6674              	.LVL979:
3762:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_RootEntCnt, i);
 6675              		.loc 1 3762 0
 6676 021c A4F84510 		strh	r1, [r4, #69]	@ movhi
3763:lib/ff/ff.c   **** 	if (n_vol < 0x10000) {					/* Number of total sectors */
 6677              		.loc 1 3763 0
 6678 0220 059B     		ldr	r3, [sp, #20]
 6679 0222 B3F5803F 		cmp	r3, #65536
3764:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_TotSec16, n_vol);
 6680              		.loc 1 3764 0
 6681 0226 34BF     		ite	cc
 6682 0228 A4F84730 		strhcc	r3, [r4, #71]	@ movhi
3766:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_TotSec32, n_vol);
 6683              		.loc 1 3766 0
 6684 022c 6365     		strcs	r3, [r4, #84]
3768:lib/ff/ff.c   **** 	tbl[BPB_Media] = md;					/* Media descriptor */
 6685              		.loc 1 3768 0
 6686 022e 84F84970 		strb	r7, [r4, #73]
3769:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
 6687              		.loc 1 3769 0
 6688 0232 3F20     		movs	r0, #63
 6689 0234 A4F84C00 		strh	r0, [r4, #76]	@ movhi
3770:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
 6690              		.loc 1 3770 0
 6691 0238 FF22     		movs	r2, #255
 6692 023a A4F84E20 		strh	r2, [r4, #78]	@ movhi
3771:lib/ff/ff.c   **** 	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
 6693              		.loc 1 3771 0
 6694 023e C4F85080 		str	r8, [r4, #80]
3772:lib/ff/ff.c   **** 	n = get_fattime();						/* Use current time as VSN */
 6695              		.loc 1 3772 0
 6696 0242 FFF7FEFF 		bl	get_fattime
 6697              	.LVL980:
 6698 0246 0490     		str	r0, [sp, #16]
3773:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
 6699              		.loc 1 3773 0
 6700 0248 032D     		cmp	r5, #3
 6701 024a 15D1     		bne	.L829
3774:lib/ff/ff.c   **** 		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
 6702              		.loc 1 3774 0
 6703 024c C4F87700 		str	r0, [r4, #119]
3775:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
 6704              		.loc 1 3775 0
 6705 0250 C4F85890 		str	r9, [r4, #88]
3776:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
 6706              		.loc 1 3776 0
 6707 0254 0220     		movs	r0, #2
 6708              	.LVL981:
 6709 0256 2066     		str	r0, [r4, #96]
3777:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
 6710              		.loc 1 3777 0
 6711 0258 0122     		movs	r2, #1
 6712 025a A4F86420 		strh	r2, [r4, #100]	@ movhi
3778:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
 6713              		.loc 1 3778 0
 6714 025e 0621     		movs	r1, #6
 6715 0260 A4F86610 		strh	r1, [r4, #102]	@ movhi
3779:lib/ff/ff.c   **** 		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
 6716              		.loc 1 3779 0
 6717 0264 8023     		movs	r3, #128
 6718 0266 84F87430 		strb	r3, [r4, #116]
3780:lib/ff/ff.c   **** 		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
 6719              		.loc 1 3780 0
 6720 026a 2920     		movs	r0, #41
 6721 026c 84F87600 		strb	r0, [r4, #118]
3781:lib/ff/ff.c   **** 		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
 6722              		.loc 1 3781 0
 6723 0270 04F17B00 		add	r0, r4, #123
 6724 0274 2049     		ldr	r1, .L874+16
 6725 0276 0CE0     		b	.L870
 6726              	.L829:
3783:lib/ff/ff.c   **** 		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
 6727              		.loc 1 3783 0
 6728 0278 C4F85B00 		str	r0, [r4, #91]
3784:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
 6729              		.loc 1 3784 0
 6730 027c A4F84A90 		strh	r9, [r4, #74]	@ movhi
3785:lib/ff/ff.c   **** 		tbl[BS_DrvNum] = 0x80;				/* Drive number */
 6731              		.loc 1 3785 0
 6732 0280 8021     		movs	r1, #128
 6733 0282 84F85810 		strb	r1, [r4, #88]
3786:lib/ff/ff.c   **** 		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
 6734              		.loc 1 3786 0
 6735 0286 2923     		movs	r3, #41
 6736 0288 84F85A30 		strb	r3, [r4, #90]
3787:lib/ff/ff.c   **** 		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
 6737              		.loc 1 3787 0
 6738 028c 04F15F00 		add	r0, r4, #95
 6739 0290 1A49     		ldr	r1, .L874+20
 6740              	.L870:
 6741 0292 1322     		movs	r2, #19
 6742 0294 FFF7FEFF 		bl	mem_cpy
 6743              	.LVL982:
3789:lib/ff/ff.c   **** 	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
 6744              		.loc 1 3789 0
 6745 0298 4AF65522 		movw	r2, #43605
 6746 029c A4F83222 		strh	r2, [r4, #562]	@ movhi
3790:lib/ff/ff.c   **** 	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
 6747              		.loc 1 3790 0
 6748 02a0 0020     		movs	r0, #0
 6749 02a2 3146     		mov	r1, r6
 6750 02a4 4246     		mov	r2, r8
 6751 02a6 0123     		movs	r3, #1
 6752 02a8 FFF7FEFF 		bl	disk_write
 6753              	.LVL983:
 6754 02ac 0028     		cmp	r0, #0
 6755 02ae 7FF4CDAE 		bne	.L805
3792:lib/ff/ff.c   **** 	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
 6756              		.loc 1 3792 0
 6757 02b2 032D     		cmp	r5, #3
 6758 02b4 05D1     		bne	.L831
3793:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 6, 1);
 6759              		.loc 1 3793 0
 6760 02b6 3146     		mov	r1, r6
 6761 02b8 08F10602 		add	r2, r8, #6
 6762 02bc 0123     		movs	r3, #1
 6763 02be FFF7FEFF 		bl	disk_write
 6764              	.LVL984:
 6765              	.L831:
3798:lib/ff/ff.c   **** 		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
 6766              		.loc 1 3798 0 discriminator 1
 6767 02c2 3046     		mov	r0, r6
 6768 02c4 0021     		movs	r1, #0
 6769 02c6 4FF40072 		mov	r2, #512
 6770 02ca FFF7FEFF 		bl	mem_set
 6771              	.LVL985:
3800:lib/ff/ff.c   **** 		if (fmt != FS_FAT32) {
 6772              		.loc 1 3800 0 discriminator 1
 6773 02ce 032D     		cmp	r5, #3
 6774 02d0 18D0     		beq	.L832
3801:lib/ff/ff.c   **** 			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
 6775              		.loc 1 3801 0
 6776 02d2 012D     		cmp	r5, #1
 6777 02d4 0A48     		ldr	r0, .L874+24
 6778 02d6 18BF     		it	ne
 6779 02d8 6FF0FF00 		mvnne	r0, #255
 6780 02dc 40EA0702 		orr	r2, r0, r7
 6781              	.LVL986:
 6782 02e0 0492     		str	r2, [sp, #16]
 6783              	.LVL987:
3802:lib/ff/ff.c   **** 			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
 6784              		.loc 1 3802 0
 6785 02e2 6263     		str	r2, [r4, #52]
 6786 02e4 18E0     		b	.L834
 6787              	.L875:
 6788 02e6 00BF     		.align	2
 6789              	.L874:
 6790 02e8 00000000 		.word	.LANCHOR1
 6791 02ec 00000000 		.word	.LANCHOR3
 6792 02f0 00000000 		.word	.LANCHOR4
 6793 02f4 0F000000 		.word	.LC1
 6794 02f8 1B000000 		.word	.LC2
 6795 02fc 2F000000 		.word	.LC3
 6796 0300 00FFFF00 		.word	16776960
 6797              	.LVL988:
 6798              	.L832:
3804:lib/ff/ff.c   **** 			n |= 0xFFFFFF00;
 6799              		.loc 1 3804 0
 6800 0304 67F0FF07 		orn	r7, r7, #255
 6801              	.LVL989:
 6802 0308 0497     		str	r7, [sp, #16]
 6803              	.LVL990:
3805:lib/ff/ff.c   **** 			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
 6804              		.loc 1 3805 0
 6805 030a 6763     		str	r7, [r4, #52]
3806:lib/ff/ff.c   **** 			ST_DWORD(tbl+4, 0xFFFFFFFF);
 6806              		.loc 1 3806 0
 6807 030c 4FF0FF31 		mov	r1, #-1
 6808 0310 A163     		str	r1, [r4, #56]
3807:lib/ff/ff.c   **** 			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
 6809              		.loc 1 3807 0
 6810 0312 6FF07043 		mvn	r3, #-268435456
 6811 0316 E363     		str	r3, [r4, #60]
 6812              	.LVL991:
 6813              	.L834:
3809:lib/ff/ff.c   **** 		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 6814              		.loc 1 3809 0
 6815 0318 0AF10107 		add	r7, sl, #1
 6816              	.LVL992:
 6817 031c 0020     		movs	r0, #0
 6818 031e 3146     		mov	r1, r6
 6819 0320 5246     		mov	r2, sl
 6820 0322 0123     		movs	r3, #1
 6821 0324 FFF7FEFF 		bl	disk_write
 6822              	.LVL993:
 6823 0328 0146     		mov	r1, r0
 6824 032a 0028     		cmp	r0, #0
 6825 032c 7FF48EAE 		bne	.L805
3811:lib/ff/ff.c   **** 		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
 6826              		.loc 1 3811 0
 6827 0330 3046     		mov	r0, r6
 6828 0332 4FF40072 		mov	r2, #512
 6829 0336 FFF7FEFF 		bl	mem_set
 6830              	.LVL994:
3812:lib/ff/ff.c   **** 		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single se
 6831              		.loc 1 3812 0
 6832 033a 0121     		movs	r1, #1
 6833 033c 0491     		str	r1, [sp, #16]
 6834              	.LVL995:
 6835              	.L835:
3812:lib/ff/ff.c   **** 		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single se
 6836              		.loc 1 3812 0 is_stmt 0 discriminator 1
 6837 033e 049B     		ldr	r3, [sp, #16]
 6838 0340 4B45     		cmp	r3, r9
 6839 0342 0FD2     		bcs	.L873
 6840              	.L836:
3813:lib/ff/ff.c   **** 			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 6841              		.loc 1 3813 0 is_stmt 1
 6842 0344 07F1010A 		add	sl, r7, #1
 6843              	.LVL996:
 6844 0348 0020     		movs	r0, #0
 6845 034a 3146     		mov	r1, r6
 6846 034c 3A46     		mov	r2, r7
 6847 034e 0123     		movs	r3, #1
 6848 0350 FFF7FEFF 		bl	disk_write
 6849              	.LVL997:
 6850 0354 0028     		cmp	r0, #0
 6851 0356 7FF479AE 		bne	.L805
3812:lib/ff/ff.c   **** 		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single se
 6852              		.loc 1 3812 0
 6853 035a 049F     		ldr	r7, [sp, #16]
 6854 035c 791C     		adds	r1, r7, #1
 6855 035e 0491     		str	r1, [sp, #16]
3813:lib/ff/ff.c   **** 			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 6856              		.loc 1 3813 0
 6857 0360 5746     		mov	r7, sl
 6858 0362 ECE7     		b	.L835
 6859              	.LVL998:
 6860              	.L873:
3812:lib/ff/ff.c   **** 		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single se
 6861              		.loc 1 3812 0
 6862 0364 BA46     		mov	sl, r7
 6863              	.LVL999:
3819:lib/ff/ff.c   **** 	i = (fmt == FS_FAT32) ? au : n_dir;
 6864              		.loc 1 3819 0
 6865 0366 DDF808B0 		ldr	fp, [sp, #8]
 6866              	.LVL1000:
 6867 036a 0198     		ldr	r0, [sp, #4]
 6868 036c 032D     		cmp	r5, #3
 6869 036e 08BF     		it	eq
 6870 0370 8346     		moveq	fp, r0
 6871              	.LVL1001:
 6872              	.L838:
3821:lib/ff/ff.c   **** 		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 6873              		.loc 1 3821 0
 6874 0372 07F1010E 		add	lr, r7, #1
 6875              	.LVL1002:
 6876 0376 0020     		movs	r0, #0
 6877 0378 3146     		mov	r1, r6
 6878 037a 3A46     		mov	r2, r7
 6879 037c 0123     		movs	r3, #1
 6880 037e CDF800E0 		str	lr, [sp, #0]
 6881 0382 FFF7FEFF 		bl	disk_write
 6882              	.LVL1003:
 6883 0386 8146     		mov	r9, r0
 6884 0388 DDF800C0 		ldr	ip, [sp, #0]
 6885 038c 0028     		cmp	r0, #0
 6886 038e 7FF45DAE 		bne	.L805
 6887 0392 6746     		mov	r7, ip
 6888              	.LVL1004:
3618:lib/ff/ff.c   **** FRESULT f_mkfs (
 6889              		.loc 1 3618 0
 6890 0394 0BEB0A02 		add	r2, fp, sl
3823:lib/ff/ff.c   **** 	} while (--i);
 6891              		.loc 1 3823 0
 6892 0398 6245     		cmp	r2, ip
 6893 039a EAD1     		bne	.L838
 6894              	.LBB126:
3829:lib/ff/ff.c   **** 		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
 6895              		.loc 1 3829 0
 6896 039c CDF818C0 		str	ip, [sp, #24]
 6897 03a0 E91E     		subs	r1, r5, #3
 6898 03a2 4D42     		rsbs	r5, r1, #0
 6899 03a4 4D41     		adcs	r5, r5, r1
 6900 03a6 039B     		ldr	r3, [sp, #12]
 6901 03a8 591B     		subs	r1, r3, r5
 6902 03aa 019A     		ldr	r2, [sp, #4]
 6903 03ac 02FB01C7 		mla	r7, r2, r1, ip
 6904 03b0 013F     		subs	r7, r7, #1
 6905 03b2 0797     		str	r7, [sp, #28]
3830:lib/ff/ff.c   **** 		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
 6906              		.loc 1 3830 0
 6907 03b4 0421     		movs	r1, #4
 6908 03b6 06AA     		add	r2, sp, #24
 6909 03b8 FFF7FEFF 		bl	disk_ioctl
 6910              	.LVL1005:
 6911              	.LBE126:
3835:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
 6912              		.loc 1 3835 0
 6913 03bc EDB1     		cbz	r5, .L839
3836:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
 6914              		.loc 1 3836 0
 6915 03be 2648     		ldr	r0, .L876
 6916 03c0 6063     		str	r0, [r4, #52]
3837:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
 6917              		.loc 1 3837 0
 6918 03c2 264B     		ldr	r3, .L876+4
 6919 03c4 C4F81832 		str	r3, [r4, #536]
3838:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
 6920              		.loc 1 3838 0
 6921 03c8 0399     		ldr	r1, [sp, #12]
 6922 03ca 4A1E     		subs	r2, r1, #1
 6923 03cc C4F81C22 		str	r2, [r4, #540]
3839:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
 6924              		.loc 1 3839 0
 6925 03d0 0220     		movs	r0, #2
 6926 03d2 C4F82002 		str	r0, [r4, #544]
3840:lib/ff/ff.c   **** 		ST_WORD(tbl+BS_55AA, 0xAA55);
 6927              		.loc 1 3840 0
 6928 03d6 4AF65523 		movw	r3, #43605
 6929 03da A4F83232 		strh	r3, [r4, #562]	@ movhi
3841:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
 6930              		.loc 1 3841 0
 6931 03de 4846     		mov	r0, r9
 6932 03e0 3146     		mov	r1, r6
 6933 03e2 08F10102 		add	r2, r8, #1
 6934 03e6 0123     		movs	r3, #1
 6935 03e8 FFF7FEFF 		bl	disk_write
 6936              	.LVL1006:
3842:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
 6937              		.loc 1 3842 0
 6938 03ec 4846     		mov	r0, r9
 6939 03ee 3146     		mov	r1, r6
 6940 03f0 08F10702 		add	r2, r8, #7
 6941 03f4 0123     		movs	r3, #1
 6942 03f6 FFF7FEFF 		bl	disk_write
 6943              	.LVL1007:
 6944              	.L839:
3845:lib/ff/ff.c   **** 	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
 6945              		.loc 1 3845 0
 6946 03fa 0020     		movs	r0, #0
 6947 03fc 0146     		mov	r1, r0
 6948 03fe 0246     		mov	r2, r0
 6949 0400 FFF7FEFF 		bl	disk_ioctl
 6950              	.LVL1008:
 6951 0404 0030     		adds	r0, r0, #0
 6952 0406 18BF     		it	ne
 6953 0408 0120     		movne	r0, #1
 6954 040a 22E0     		b	.L867
 6955              	.LVL1009:
 6956              	.L842:
3636:lib/ff/ff.c   **** 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
 6957              		.loc 1 3636 0
 6958 040c 0B20     		movs	r0, #11
 6959              	.LVL1010:
 6960 040e 20E0     		b	.L867
 6961              	.LVL1011:
 6962              	.L844:
3637:lib/ff/ff.c   **** 	if (sfd > 1) return FR_INVALID_PARAMETER;
 6963              		.loc 1 3637 0
 6964 0410 1320     		movs	r0, #19
 6965              	.LVL1012:
 6966 0412 1EE0     		b	.L867
 6967              	.LVL1013:
 6968              	.L845:
3640:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;
 6969              		.loc 1 3640 0
 6970 0414 0C20     		movs	r0, #12
 6971              	.LVL1014:
 6972 0416 1CE0     		b	.L867
 6973              	.LVL1015:
 6974              	.L846:
3647:lib/ff/ff.c   **** 	if (stat & STA_NOINIT) return FR_NOT_READY;
 6975              		.loc 1 3647 0
 6976 0418 0320     		movs	r0, #3
 6977              	.LVL1016:
 6978 041a 1AE0     		b	.L867
 6979              	.L847:
3648:lib/ff/ff.c   **** 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 6980              		.loc 1 3648 0
 6981 041c 0A20     		movs	r0, #10
 6982 041e 18E0     		b	.L867
 6983              	.LVL1017:
 6984              	.L812:
3690:lib/ff/ff.c   **** 		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
 6985              		.loc 1 3690 0
 6986 0420 0321     		movs	r1, #3
 6987 0422 01FB09F7 		mul	r7, r1, r9
 6988 0426 07F10105 		add	r5, r7, #1
 6989 042a 4FEA5502 		lsr	r2, r5, #1
 6990 042e 02EB010B 		add	fp, r2, r1
3680:lib/ff/ff.c   **** 	fmt = FS_FAT12;
 6991              		.loc 1 3680 0
 6992 0432 0125     		movs	r5, #1
 6993              	.LVL1018:
 6994              	.L841:
3691:lib/ff/ff.c   **** 		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
 6995              		.loc 1 3691 0 discriminator 3
 6996 0434 0BF2FF1C 		addw	ip, fp, #511
 6997 0438 4FEA5C29 		lsr	r9, ip, #9
 6998              	.LVL1019:
3693:lib/ff/ff.c   **** 		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
 6999              		.loc 1 3693 0 discriminator 3
 7000 043c 2021     		movs	r1, #32
 7001 043e 0291     		str	r1, [sp, #8]
3692:lib/ff/ff.c   **** 		n_rsv = 1;
 7002              		.loc 1 3692 0 discriminator 3
 7003 0440 4FF0010B 		mov	fp, #1
 7004 0444 42E6     		b	.L840
 7005              	.LVL1020:
 7006              	.L872:
3690:lib/ff/ff.c   **** 		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
 7007              		.loc 1 3690 0
 7008 0446 09F1020A 		add	sl, r9, #2
 7009 044a 4FEA4A0B 		lsl	fp, sl, #1
3681:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
 7010              		.loc 1 3681 0
 7011 044e 0225     		movs	r5, #2
 7012 0450 F0E7     		b	.L841
 7013              	.LVL1021:
 7014              	.L867:
3846:lib/ff/ff.c   **** }
 7015              		.loc 1 3846 0
 7016 0452 09B0     		add	sp, sp, #36
 7017 0454 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7018              	.L877:
 7019              		.align	2
 7020              	.L876:
 7021 0458 52526141 		.word	1096897106
 7022 045c 72724161 		.word	1631679090
 7023              		.cfi_endproc
 7024              	.LFE47:
 7026              		.section	.text.f_gets,"ax",%progbits
 7027              		.align	1
 7028              		.global	f_gets
 7029              		.thumb
 7030              		.thumb_func
 7032              	f_gets:
 7033              	.LFB48:
3931:lib/ff/ff.c   **** {
 7034              		.loc 1 3931 0
 7035              		.cfi_startproc
 7036              		@ args = 0, pretend = 0, frame = 8
 7037              		@ frame_needed = 0, uses_anonymous_args = 0
 7038              	.LVL1022:
 7039 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 7040              	.LCFI48:
 7041              		.cfi_def_cfa_offset 32
 7042              		.cfi_offset 0, -32
 7043              		.cfi_offset 1, -28
 7044              		.cfi_offset 4, -24
 7045              		.cfi_offset 5, -20
 7046              		.cfi_offset 6, -16
 7047              		.cfi_offset 7, -12
 7048              		.cfi_offset 8, -8
 7049              		.cfi_offset 14, -4
 7050 0004 0646     		mov	r6, r0
 7051 0006 0F46     		mov	r7, r1
 7052 0008 9046     		mov	r8, r2
 7053              	.LVL1023:
 7054 000a 0546     		mov	r5, r0
3932:lib/ff/ff.c   **** 	int n = 0;
 7055              		.loc 1 3932 0
 7056 000c 0024     		movs	r4, #0
 7057              	.LVL1024:
 7058              	.L879:
3938:lib/ff/ff.c   **** 	while (n < len - 1) {			/* Read bytes until buffer gets filled */
 7059              		.loc 1 3938 0 discriminator 1
 7060 000e 7B1E     		subs	r3, r7, #1
 7061 0010 9C42     		cmp	r4, r3
 7062 0012 0FDA     		bge	.L880
 7063              	.L881:
3939:lib/ff/ff.c   **** 		f_read(fil, s, 1, &rc);
 7064              		.loc 1 3939 0
 7065 0014 4046     		mov	r0, r8
 7066 0016 6946     		mov	r1, sp
 7067 0018 0122     		movs	r2, #1
 7068 001a 01AB     		add	r3, sp, #4
 7069 001c FFF7FEFF 		bl	f_read
 7070              	.LVL1025:
3940:lib/ff/ff.c   **** 		if (rc != 1) break;			/* Break on EOF or error */
 7071              		.loc 1 3940 0
 7072 0020 0198     		ldr	r0, [sp, #4]
 7073              	.LVL1026:
 7074 0022 0128     		cmp	r0, #1
 7075 0024 06D1     		bne	.L880
3941:lib/ff/ff.c   **** 		c = s[0];
 7076              		.loc 1 3941 0
 7077 0026 9DF80010 		ldrb	r1, [sp, #0]	@ zero_extendqisi2
 7078              	.LVL1027:
3965:lib/ff/ff.c   **** 		*p++ = c;
 7079              		.loc 1 3965 0
 7080 002a 05F8011B 		strb	r1, [r5], #1
 7081              	.LVL1028:
3966:lib/ff/ff.c   **** 		n++;
 7082              		.loc 1 3966 0
 7083 002e 0134     		adds	r4, r4, #1
 7084              	.LVL1029:
3967:lib/ff/ff.c   **** 		if (c == '\n') break;		/* Break on EOL */
 7085              		.loc 1 3967 0
 7086 0030 0A29     		cmp	r1, #10
 7087 0032 ECD1     		bne	.L879
 7088              	.LVL1030:
 7089              	.L880:
3969:lib/ff/ff.c   **** 	*p = 0;
 7090              		.loc 1 3969 0
 7091 0034 0022     		movs	r2, #0
 7092 0036 2A70     		strb	r2, [r5, #0]
3971:lib/ff/ff.c   **** }
 7093              		.loc 1 3971 0
 7094 0038 9442     		cmp	r4, r2
 7095 003a 14BF     		ite	ne
 7096 003c 3046     		movne	r0, r6
 7097 003e 1046     		moveq	r0, r2
 7098 0040 BDE8FC81 		pop	{r2, r3, r4, r5, r6, r7, r8, pc}
 7099              		.cfi_endproc
 7100              	.LFE48:
 7102              		.section	.text.f_putc,"ax",%progbits
 7103              		.align	1
 7104              		.global	f_putc
 7105              		.thumb
 7106              		.thumb_func
 7108              	f_putc:
 7109              	.LFB49:
3984:lib/ff/ff.c   **** {
 7110              		.loc 1 3984 0
 7111              		.cfi_startproc
 7112              		@ args = 0, pretend = 0, frame = 8
 7113              		@ frame_needed = 0, uses_anonymous_args = 0
 7114              	.LVL1031:
 7115 0000 07B5     		push	{r0, r1, r2, lr}
 7116              	.LCFI49:
 7117              		.cfi_def_cfa_offset 16
 7118              		.cfi_offset 0, -16
 7119              		.cfi_offset 1, -12
 7120              		.cfi_offset 2, -8
 7121              		.cfi_offset 14, -4
4010:lib/ff/ff.c   **** 	s[0] = (BYTE)c;
 7122              		.loc 1 4010 0
 7123 0002 02AB     		add	r3, sp, #8
 7124 0004 03F8080D 		strb	r0, [r3, #-8]!
 7125              	.LVL1032:
4013:lib/ff/ff.c   **** 	f_write(fil, s, btw, &bw);		/* Write the char to the file */
 7126              		.loc 1 4013 0
 7127 0008 0846     		mov	r0, r1
 7128              	.LVL1033:
 7129 000a 6946     		mov	r1, sp
 7130              	.LVL1034:
 7131 000c 0122     		movs	r2, #1
 7132 000e 01AB     		add	r3, sp, #4
 7133              	.LVL1035:
 7134 0010 FFF7FEFF 		bl	f_write
 7135              	.LVL1036:
4015:lib/ff/ff.c   **** }
 7136              		.loc 1 4015 0
 7137 0014 0198     		ldr	r0, [sp, #4]
 7138 0016 0128     		cmp	r0, #1
 7139 0018 14BF     		ite	ne
 7140 001a 4FF0FF30 		movne	r0, #-1
 7141 001e 0120     		moveq	r0, #1
 7142 0020 0EBD     		pop	{r1, r2, r3, pc}
 7143              		.cfi_endproc
 7144              	.LFE49:
 7146              		.section	.text.f_puts,"ax",%progbits
 7147              		.align	1
 7148              		.global	f_puts
 7149              		.thumb
 7150              		.thumb_func
 7152              	f_puts:
 7153              	.LFB50:
4027:lib/ff/ff.c   **** {
 7154              		.loc 1 4027 0
 7155              		.cfi_startproc
 7156              		@ args = 0, pretend = 0, frame = 0
 7157              		@ frame_needed = 0, uses_anonymous_args = 0
 7158              	.LVL1037:
 7159 0000 70B5     		push	{r4, r5, r6, lr}
 7160              	.LCFI50:
 7161              		.cfi_def_cfa_offset 16
 7162              		.cfi_offset 4, -16
 7163              		.cfi_offset 5, -12
 7164              		.cfi_offset 6, -8
 7165              		.cfi_offset 14, -4
 7166 0002 0546     		mov	r5, r0
 7167 0004 0E46     		mov	r6, r1
 7168              	.LVL1038:
4031:lib/ff/ff.c   **** 	for (n = 0; *str; str++, n++) {
 7169              		.loc 1 4031 0
 7170 0006 0024     		movs	r4, #0
 7171              	.LVL1039:
 7172              	.L890:
4031:lib/ff/ff.c   **** 	for (n = 0; *str; str++, n++) {
 7173              		.loc 1 4031 0 is_stmt 0 discriminator 1
 7174 0008 285D     		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 7175 000a 40B1     		cbz	r0, .L891
 7176              	.L892:
4032:lib/ff/ff.c   **** 		if (f_putc(*str, fil) == EOF) return EOF;
 7177              		.loc 1 4032 0 is_stmt 1
 7178 000c 40B2     		sxtb	r0, r0
 7179 000e 3146     		mov	r1, r6
 7180 0010 FFF7FEFF 		bl	f_putc
 7181              	.LVL1040:
 7182 0014 421C     		adds	r2, r0, #1
 7183 0016 01D0     		beq	.L893
4031:lib/ff/ff.c   **** 	for (n = 0; *str; str++, n++) {
 7184              		.loc 1 4031 0
 7185 0018 0134     		adds	r4, r4, #1
 7186              	.LVL1041:
 7187 001a F5E7     		b	.L890
 7188              	.L893:
4032:lib/ff/ff.c   **** 		if (f_putc(*str, fil) == EOF) return EOF;
 7189              		.loc 1 4032 0
 7190 001c 0446     		mov	r4, r0
 7191              	.LVL1042:
 7192              	.L891:
4035:lib/ff/ff.c   **** }
 7193              		.loc 1 4035 0
 7194 001e 2046     		mov	r0, r4
 7195 0020 70BD     		pop	{r4, r5, r6, pc}
 7196              		.cfi_endproc
 7197              	.LFE50:
 7199              		.section	.text.f_printf,"ax",%progbits
 7200              		.align	1
 7201              		.global	f_printf
 7202              		.thumb
 7203              		.thumb_func
 7205              	f_printf:
 7206              	.LFB51:
4048:lib/ff/ff.c   **** {
 7207              		.loc 1 4048 0
 7208              		.cfi_startproc
 7209              		@ args = 4, pretend = 12, frame = 32
 7210              		@ frame_needed = 0, uses_anonymous_args = 1
 7211              	.LVL1043:
 7212 0000 0EB4     		push	{r1, r2, r3}
 7213              	.LCFI51:
 7214              		.cfi_def_cfa_offset 12
 7215              		.cfi_offset 1, -12
 7216              		.cfi_offset 2, -8
 7217              		.cfi_offset 3, -4
 7218 0002 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7219              	.LCFI52:
 7220              		.cfi_def_cfa_offset 48
 7221              		.cfi_offset 4, -48
 7222              		.cfi_offset 5, -44
 7223              		.cfi_offset 6, -40
 7224              		.cfi_offset 7, -36
 7225              		.cfi_offset 8, -32
 7226              		.cfi_offset 9, -28
 7227              		.cfi_offset 10, -24
 7228              		.cfi_offset 11, -20
 7229              		.cfi_offset 14, -16
 7230 0006 88B0     		sub	sp, sp, #32
 7231              	.LCFI53:
 7232              		.cfi_def_cfa_offset 80
 7233 0008 8046     		mov	r8, r0
 7234 000a 11AB     		add	r3, sp, #68
 7235 000c 53F8042B 		ldr	r2, [r3], #4
4057:lib/ff/ff.c   **** 	va_start(arp, str);
 7236              		.loc 1 4057 0
 7237 0010 0393     		str	r3, [sp, #12]
 7238              	.LVL1044:
4059:lib/ff/ff.c   **** 	for (cc = res = 0; cc != EOF; res += cc) {
 7239              		.loc 1 4059 0
 7240 0012 0020     		movs	r0, #0
 7241              	.LVL1045:
 7242 0014 0446     		mov	r4, r0
 7243              	.LVL1046:
 7244              	.L937:
4060:lib/ff/ff.c   **** 		c = *str++;
 7245              		.loc 1 4060 0
 7246 0016 1646     		mov	r6, r2
 7247 0018 16F8011B 		ldrb	r1, [r6], #1	@ zero_extendqisi2
 7248              	.LVL1047:
4061:lib/ff/ff.c   **** 		if (c == 0) break;			/* End of string */
 7249              		.loc 1 4061 0
 7250 001c 0029     		cmp	r1, #0
 7251 001e 00F00B81 		beq	.L895
4062:lib/ff/ff.c   **** 		if (c != '%') {				/* Non escape character */
 7252              		.loc 1 4062 0
 7253 0022 4BB2     		sxtb	r3, r1
 7254 0024 252B     		cmp	r3, #37
 7255 0026 0AD0     		beq	.L896
4063:lib/ff/ff.c   **** 			cc = f_putc(c, fil);
 7256              		.loc 1 4063 0
 7257 0028 1846     		mov	r0, r3
 7258 002a 4146     		mov	r1, r8
 7259 002c FFF7FEFF 		bl	f_putc
 7260              	.LVL1048:
4064:lib/ff/ff.c   **** 			if (cc != EOF) cc = 1;
 7261              		.loc 1 4064 0
 7262 0030 B0F1FF3F 		cmp	r0, #-1
 7263 0034 0CBF     		ite	eq
 7264 0036 4FF0FF30 		moveq	r0, #-1
 7265 003a 0120     		movne	r0, #1
 7266 003c F7E0     		b	.L897
 7267              	.LVL1049:
 7268              	.L896:
4068:lib/ff/ff.c   **** 		c = *str++;
 7269              		.loc 1 4068 0
 7270 003e 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 7271              	.LVL1050:
4069:lib/ff/ff.c   **** 		if (c == '0') {				/* Flag: '0' padding */
 7272              		.loc 1 4069 0
 7273 0040 5DB2     		sxtb	r5, r3
 7274 0042 302D     		cmp	r5, #48
 7275 0044 03D1     		bne	.L898
 7276              	.LVL1051:
4070:lib/ff/ff.c   **** 			f = 1; c = *str++;
 7277              		.loc 1 4070 0
 7278 0046 9378     		ldrb	r3, [r2, #2]	@ zero_extendqisi2
 7279              	.LVL1052:
 7280 0048 D61C     		adds	r6, r2, #3
 7281              	.LVL1053:
 7282 004a 0125     		movs	r5, #1
 7283 004c 07E0     		b	.L899
 7284              	.LVL1054:
 7285              	.L898:
4072:lib/ff/ff.c   **** 			if (c == '-') {			/* Flag: left justified */
 7286              		.loc 1 4072 0
 7287 004e 2D2D     		cmp	r5, #45
 7288 0050 02D0     		beq	.L900
4068:lib/ff/ff.c   **** 		c = *str++;
 7289              		.loc 1 4068 0
 7290 0052 961C     		adds	r6, r2, #2
4067:lib/ff/ff.c   **** 		w = f = 0;
 7291              		.loc 1 4067 0
 7292 0054 0025     		movs	r5, #0
 7293 0056 02E0     		b	.L899
 7294              	.L900:
 7295              	.LVL1055:
4073:lib/ff/ff.c   **** 				f = 2; c = *str++;
 7296              		.loc 1 4073 0
 7297 0058 9378     		ldrb	r3, [r2, #2]	@ zero_extendqisi2
 7298              	.LVL1056:
 7299 005a D61C     		adds	r6, r2, #3
 7300              	.LVL1057:
 7301 005c 0225     		movs	r5, #2
 7302              	.LVL1058:
 7303              	.L899:
4070:lib/ff/ff.c   **** 			f = 1; c = *str++;
 7304              		.loc 1 4070 0 discriminator 1
 7305 005e 4FF00009 		mov	r9, #0
 7306              	.LVL1059:
 7307              	.L901:
4076:lib/ff/ff.c   **** 		while (IsDigit(c)) {		/* Precision */
 7308              		.loc 1 4076 0 discriminator 1
 7309 0062 A3F13002 		sub	r2, r3, #48
 7310 0066 092A     		cmp	r2, #9
 7311 0068 59B2     		sxtb	r1, r3
 7312 006a 07D8     		bhi	.L984
 7313              	.L902:
4077:lib/ff/ff.c   **** 			w = w * 10 + c - '0';
 7314              		.loc 1 4077 0
 7315 006c 0A22     		movs	r2, #10
 7316 006e 02FB0919 		mla	r9, r2, r9, r1
 7317              	.LVL1060:
 7318 0072 A9F13009 		sub	r9, r9, #48
 7319              	.LVL1061:
4078:lib/ff/ff.c   **** 			c = *str++;
 7320              		.loc 1 4078 0
 7321 0076 16F8013B 		ldrb	r3, [r6], #1	@ zero_extendqisi2
 7322              	.LVL1062:
 7323 007a F2E7     		b	.L901
 7324              	.LVL1063:
 7325              	.L984:
4080:lib/ff/ff.c   **** 		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
 7326              		.loc 1 4080 0
 7327 007c 6C29     		cmp	r1, #108
 7328 007e 01D0     		beq	.L903
4080:lib/ff/ff.c   **** 		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
 7329              		.loc 1 4080 0 is_stmt 0 discriminator 1
 7330 0080 4C29     		cmp	r1, #76
 7331 0082 03D1     		bne	.L904
 7332              	.L903:
4081:lib/ff/ff.c   **** 			f |= 4; c = *str++;
 7333              		.loc 1 4081 0 is_stmt 1
 7334 0084 45F00405 		orr	r5, r5, #4
 7335              	.LVL1064:
 7336 0088 16F8013B 		ldrb	r3, [r6], #1	@ zero_extendqisi2
 7337              	.LVL1065:
 7338              	.L904:
4083:lib/ff/ff.c   **** 		if (!c) break;
 7339              		.loc 1 4083 0
 7340 008c 002B     		cmp	r3, #0
 7341 008e 00F0D380 		beq	.L895
 7342              	.LVL1066:
4085:lib/ff/ff.c   **** 		if (IsLower(d)) d -= 0x20;
 7343              		.loc 1 4085 0
 7344 0092 D8B2     		uxtb	r0, r3
 7345 0094 A0F16102 		sub	r2, r0, #97
 7346 0098 192A     		cmp	r2, #25
 7347 009a 02D8     		bhi	.L939
4085:lib/ff/ff.c   **** 		if (IsLower(d)) d -= 0x20;
 7348              		.loc 1 4085 0 is_stmt 0 discriminator 1
 7349 009c 2038     		subs	r0, r0, #32
 7350 009e C1B2     		uxtb	r1, r0
 7351              	.LVL1067:
 7352 00a0 00E0     		b	.L905
 7353              	.LVL1068:
 7354              	.L939:
4085:lib/ff/ff.c   **** 		if (IsLower(d)) d -= 0x20;
 7355              		.loc 1 4085 0
 7356 00a2 1946     		mov	r1, r3
 7357              	.LVL1069:
 7358              	.L905:
4086:lib/ff/ff.c   **** 		switch (d) {				/* Type is... */
 7359              		.loc 1 4086 0 is_stmt 1
 7360 00a4 48B2     		sxtb	r0, r1
 7361 00a6 4F28     		cmp	r0, #79
 7362 00a8 51D0     		beq	.L940
 7363 00aa 06DC     		bgt	.L913
 7364 00ac 4328     		cmp	r0, #67
 7365 00ae 3FD0     		beq	.L908
 7366 00b0 4428     		cmp	r0, #68
 7367 00b2 0FD0     		beq	.L909
 7368 00b4 4228     		cmp	r0, #66
 7369 00b6 43D1     		bne	.L906
 7370 00b8 47E0     		b	.L985
 7371              	.L913:
 7372 00ba 5528     		cmp	r0, #85
 7373 00bc 0AD0     		beq	.L909
 7374 00be 5828     		cmp	r0, #88
 7375 00c0 3CD0     		beq	.L912
 7376 00c2 5328     		cmp	r0, #83
 7377 00c4 3CD1     		bne	.L906
4088:lib/ff/ff.c   **** 			p = va_arg(arp, TCHAR*);
 7378              		.loc 1 4088 0
 7379 00c6 039F     		ldr	r7, [sp, #12]
 7380 00c8 391D     		adds	r1, r7, #4
 7381              	.LVL1070:
 7382 00ca 0391     		str	r1, [sp, #12]
 7383 00cc D7F800A0 		ldr	sl, [r7, #0]
 7384              	.LVL1071:
4089:lib/ff/ff.c   **** 			for (j = 0; p[j]; j++) ;
 7385              		.loc 1 4089 0
 7386 00d0 0027     		movs	r7, #0
 7387 00d2 01E0     		b	.L914
 7388              	.LVL1072:
 7389              	.L909:
4106:lib/ff/ff.c   **** 			r = 10; break;
 7390              		.loc 1 4106 0
 7391 00d4 0A20     		movs	r0, #10
 7392 00d6 3BE0     		b	.L910
 7393              	.LVL1073:
 7394              	.L914:
4089:lib/ff/ff.c   **** 			for (j = 0; p[j]; j++) ;
 7395              		.loc 1 4089 0 discriminator 1
 7396 00d8 1AF90700 		ldrsb	r0, [sl, r7]
 7397 00dc 08B1     		cbz	r0, .L986
 7398              	.L915:
4089:lib/ff/ff.c   **** 			for (j = 0; p[j]; j++) ;
 7399              		.loc 1 4089 0 is_stmt 0 discriminator 2
 7400 00de 0137     		adds	r7, r7, #1
 7401              	.LVL1074:
 7402 00e0 FAE7     		b	.L914
 7403              	.L986:
 7404              	.LVL1075:
4091:lib/ff/ff.c   **** 			if (!(f & 2)) {
 7405              		.loc 1 4091 0 is_stmt 1
 7406 00e2 05F00205 		and	r5, r5, #2
 7407              	.LVL1076:
 7408 00e6 EDB2     		uxtb	r5, r5
 7409 00e8 0DB1     		cbz	r5, .L916
4090:lib/ff/ff.c   **** 			chc = 0;
 7410              		.loc 1 4090 0
 7411 00ea 0546     		mov	r5, r0
 7412 00ec 0BE0     		b	.L917
 7413              	.LVL1077:
 7414              	.L916:
4092:lib/ff/ff.c   **** 				while (j++ < w) chc += (cc = f_putc(' ', fil));
 7415              		.loc 1 4092 0 discriminator 1
 7416 00ee 07F1010B 		add	fp, r7, #1
 7417              	.LVL1078:
 7418 00f2 4F45     		cmp	r7, r9
 7419 00f4 06D2     		bcs	.L987
 7420              	.L918:
4092:lib/ff/ff.c   **** 				while (j++ < w) chc += (cc = f_putc(' ', fil));
 7421              		.loc 1 4092 0 is_stmt 0 discriminator 2
 7422 00f6 2020     		movs	r0, #32
 7423 00f8 4146     		mov	r1, r8
 7424 00fa FFF7FEFF 		bl	f_putc
 7425              	.LVL1079:
 7426 00fe 2D18     		adds	r5, r5, r0
 7427              	.LVL1080:
 7428 0100 5F46     		mov	r7, fp
 7429 0102 F4E7     		b	.L916
 7430              	.LVL1081:
 7431              	.L987:
4092:lib/ff/ff.c   **** 				while (j++ < w) chc += (cc = f_putc(' ', fil));
 7432              		.loc 1 4092 0
 7433 0104 5F46     		mov	r7, fp
 7434              	.LVL1082:
 7435              	.L917:
4094:lib/ff/ff.c   **** 			chc += (cc = f_puts(p, fil));
 7436              		.loc 1 4094 0 is_stmt 1
 7437 0106 5046     		mov	r0, sl
 7438 0108 4146     		mov	r1, r8
 7439 010a FFF7FEFF 		bl	f_puts
 7440              	.LVL1083:
 7441 010e 2D18     		adds	r5, r5, r0
 7442              	.LVL1084:
 7443              	.L919:
4095:lib/ff/ff.c   **** 			while (j++ < w) chc += (cc = f_putc(' ', fil));
 7444              		.loc 1 4095 0 discriminator 1
 7445 0110 4F45     		cmp	r7, r9
 7446 0112 06D2     		bcs	.L988
 7447              	.L920:
4095:lib/ff/ff.c   **** 			while (j++ < w) chc += (cc = f_putc(' ', fil));
 7448              		.loc 1 4095 0 is_stmt 0 discriminator 2
 7449 0114 2020     		movs	r0, #32
 7450 0116 4146     		mov	r1, r8
 7451 0118 FFF7FEFF 		bl	f_putc
 7452              	.LVL1085:
 7453 011c 2D18     		adds	r5, r5, r0
 7454              	.LVL1086:
 7455 011e 0137     		adds	r7, r7, #1
 7456 0120 F6E7     		b	.L919
 7457              	.L988:
4096:lib/ff/ff.c   **** 			if (cc != EOF) cc = chc;
 7458              		.loc 1 4096 0 is_stmt 1
 7459 0122 B0F1FF3F 		cmp	r0, #-1
 7460 0126 14BF     		ite	ne
 7461 0128 2846     		movne	r0, r5
 7462 012a 4FF0FF30 		moveq	r0, #-1
 7463 012e 7EE0     		b	.L897
 7464              	.LVL1087:
 7465              	.L908:
4099:lib/ff/ff.c   **** 			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
 7466              		.loc 1 4099 0
 7467 0130 039B     		ldr	r3, [sp, #12]
 7468              	.LVL1088:
 7469 0132 1A1D     		adds	r2, r3, #4
 7470 0134 0392     		str	r2, [sp, #12]
 7471 0136 93F90000 		ldrsb	r0, [r3, #0]
 7472 013a 02E0     		b	.L981
 7473              	.LVL1089:
 7474              	.L912:
4108:lib/ff/ff.c   **** 			r = 16; break;
 7475              		.loc 1 4108 0
 7476 013c 1020     		movs	r0, #16
 7477 013e 07E0     		b	.L910
 7478              	.LVL1090:
 7479              	.L906:
4110:lib/ff/ff.c   **** 			cc = f_putc(c, fil); continue;
 7480              		.loc 1 4110 0
 7481 0140 58B2     		sxtb	r0, r3
 7482              	.LVL1091:
 7483              	.L981:
 7484 0142 4146     		mov	r1, r8
 7485              	.LVL1092:
 7486 0144 FFF7FEFF 		bl	f_putc
 7487              	.LVL1093:
 7488 0148 71E0     		b	.L897
 7489              	.LVL1094:
 7490              	.L985:
4101:lib/ff/ff.c   **** 			r = 2; break;
 7491              		.loc 1 4101 0
 7492 014a 0220     		movs	r0, #2
 7493 014c 00E0     		b	.L910
 7494              	.L940:
4103:lib/ff/ff.c   **** 			r = 8; break;
 7495              		.loc 1 4103 0
 7496 014e 0820     		movs	r0, #8
 7497              	.L910:
 7498              	.LVL1095:
4114:lib/ff/ff.c   **** 		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_
 7499              		.loc 1 4114 0
 7500 0150 05F00404 		and	r4, r5, #4
 7501 0154 E7B2     		uxtb	r7, r4
 7502 0156 039A     		ldr	r2, [sp, #12]
 7503 0158 2FB1     		cbz	r7, .L921
4114:lib/ff/ff.c   **** 		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_
 7504              		.loc 1 4114 0 is_stmt 0 discriminator 1
 7505 015a 171D     		adds	r7, r2, #4
 7506 015c 0397     		str	r7, [sp, #12]
 7507 015e 1268     		ldr	r2, [r2, #0]
 7508              	.LVL1096:
4115:lib/ff/ff.c   **** 		if (d == 'D' && (v & 0x80000000)) {
 7509              		.loc 1 4115 0 is_stmt 1 discriminator 1
 7510 0160 49B2     		sxtb	r1, r1
 7511              	.LVL1097:
 7512 0162 4429     		cmp	r1, #68
 7513 0164 05E0     		b	.L983
 7514              	.LVL1098:
 7515              	.L921:
4114:lib/ff/ff.c   **** 		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_
 7516              		.loc 1 4114 0 discriminator 2
 7517 0166 49B2     		sxtb	r1, r1
 7518              	.LVL1099:
 7519 0168 4429     		cmp	r1, #68
 7520 016a 02F10404 		add	r4, r2, #4
 7521 016e 0394     		str	r4, [sp, #12]
 7522 0170 1268     		ldr	r2, [r2, #0]
 7523              	.L983:
 7524 0172 04D1     		bne	.L923
4115:lib/ff/ff.c   **** 		if (d == 'D' && (v & 0x80000000)) {
 7525              		.loc 1 4115 0 discriminator 1
 7526 0174 002A     		cmp	r2, #0
 7527 0176 02DA     		bge	.L923
4116:lib/ff/ff.c   **** 			v = 0 - v;
 7528              		.loc 1 4116 0
 7529 0178 5242     		negs	r2, r2
 7530              	.LVL1100:
4117:lib/ff/ff.c   **** 			f |= 8;
 7531              		.loc 1 4117 0
 7532 017a 45F00805 		orr	r5, r5, #8
 7533              	.LVL1101:
 7534              	.L923:
4119:lib/ff/ff.c   **** 		i = 0;
 7535              		.loc 1 4119 0
 7536 017e 0021     		movs	r1, #0
 7537              	.LVL1102:
 7538              	.L928:
4121:lib/ff/ff.c   **** 			d = (TCHAR)(v % r); v /= r;
 7539              		.loc 1 4121 0
 7540 0180 B2FBF0FE 		udiv	lr, r2, r0
 7541 0184 00FB1E22 		mls	r2, r0, lr, r2
 7542              	.LVL1103:
 7543 0188 D4B2     		uxtb	r4, r2
 7544              	.LVL1104:
 7545 018a 7246     		mov	r2, lr
 7546              	.LVL1105:
4122:lib/ff/ff.c   **** 			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 7547              		.loc 1 4122 0
 7548 018c 67B2     		sxtb	r7, r4
 7549 018e 092F     		cmp	r7, #9
 7550 0190 05DD     		ble	.L925
4122:lib/ff/ff.c   **** 			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 7551              		.loc 1 4122 0 is_stmt 0 discriminator 1
 7552 0192 782B     		cmp	r3, #120
 7553 0194 14BF     		ite	ne
 7554 0196 0727     		movne	r7, #7
 7555 0198 2727     		moveq	r7, #39
 7556 019a 3C19     		adds	r4, r7, r4
 7557              	.LVL1106:
 7558 019c E4B2     		uxtb	r4, r4
 7559              	.LVL1107:
 7560              	.L925:
4123:lib/ff/ff.c   **** 			s[i++] = d + '0';
 7561              		.loc 1 4123 0 is_stmt 1
 7562 019e 3034     		adds	r4, r4, #48
 7563              	.LVL1108:
 7564 01a0 04AF     		add	r7, sp, #16
 7565 01a2 CC55     		strb	r4, [r1, r7]
 7566 01a4 4F1C     		adds	r7, r1, #1
 7567              	.LVL1109:
4124:lib/ff/ff.c   **** 		} while (v && i < sizeof s / sizeof s[0]);
 7568              		.loc 1 4124 0
 7569 01a6 BEF1000F 		cmp	lr, #0
 7570 01aa 04D0     		beq	.L927
4124:lib/ff/ff.c   **** 		} while (v && i < sizeof s / sizeof s[0]);
 7571              		.loc 1 4124 0 is_stmt 0 discriminator 1
 7572 01ac 102F     		cmp	r7, #16
 7573 01ae 01D0     		beq	.L989
 7574              	.L943:
4123:lib/ff/ff.c   **** 			s[i++] = d + '0';
 7575              		.loc 1 4123 0 is_stmt 1
 7576 01b0 3946     		mov	r1, r7
 7577 01b2 E5E7     		b	.L928
 7578              	.L989:
4124:lib/ff/ff.c   **** 		} while (v && i < sizeof s / sizeof s[0]);
 7579              		.loc 1 4124 0
 7580 01b4 0F21     		movs	r1, #15
 7581              	.L927:
4125:lib/ff/ff.c   **** 		if (f & 8) s[i++] = '-';
 7582              		.loc 1 4125 0
 7583 01b6 05F00803 		and	r3, r5, #8
 7584              	.LVL1110:
 7585 01ba D8B2     		uxtb	r0, r3
 7586              	.LVL1111:
 7587 01bc 28B1     		cbz	r0, .L929
4125:lib/ff/ff.c   **** 		if (f & 8) s[i++] = '-';
 7588              		.loc 1 4125 0 is_stmt 0 discriminator 1
 7589 01be 08AA     		add	r2, sp, #32
 7590              	.LVL1112:
 7591 01c0 D419     		adds	r4, r2, r7
 7592              	.LVL1113:
 7593 01c2 2D27     		movs	r7, #45
 7594              	.LVL1114:
 7595 01c4 04F8107C 		strb	r7, [r4, #-16]
 7596 01c8 8F1C     		adds	r7, r1, #2
 7597              	.LVL1115:
 7598              	.L929:
4126:lib/ff/ff.c   **** 		j = i; d = (f & 1) ? '0' : ' ';
 7599              		.loc 1 4126 0 is_stmt 1
 7600 01ca 15F0010F 		tst	r5, #1
 7601 01ce 0CBF     		ite	eq
 7602 01d0 2022     		moveq	r2, #32
 7603 01d2 3022     		movne	r2, #48
 7604              	.LVL1116:
 7605 01d4 BA46     		mov	sl, r7
4127:lib/ff/ff.c   **** 		res = 0;
 7606              		.loc 1 4127 0
 7607 01d6 0024     		movs	r4, #0
 7608              	.LVL1117:
 7609              	.L931:
4128:lib/ff/ff.c   **** 		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
 7610              		.loc 1 4128 0 discriminator 1
 7611 01d8 05F00201 		and	r1, r5, #2
 7612 01dc C8B2     		uxtb	r0, r1
 7613 01de 68B9     		cbnz	r0, .L970
4128:lib/ff/ff.c   **** 		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
 7614              		.loc 1 4128 0 is_stmt 0 discriminator 2
 7615 01e0 0AF1010B 		add	fp, sl, #1
 7616              	.LVL1118:
 7617 01e4 CA45     		cmp	sl, r9
 7618 01e6 08D2     		bcs	.L990
 7619              	.L933:
4128:lib/ff/ff.c   **** 		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
 7620              		.loc 1 4128 0 discriminator 1
 7621 01e8 1046     		mov	r0, r2
 7622 01ea 4146     		mov	r1, r8
 7623 01ec 0192     		str	r2, [sp, #4]
 7624 01ee FFF7FEFF 		bl	f_putc
 7625              	.LVL1119:
 7626 01f2 2418     		adds	r4, r4, r0
 7627              	.LVL1120:
 7628 01f4 DA46     		mov	sl, fp
 7629 01f6 019A     		ldr	r2, [sp, #4]
 7630 01f8 EEE7     		b	.L931
 7631              	.LVL1121:
 7632              	.L990:
4128:lib/ff/ff.c   **** 		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
 7633              		.loc 1 4128 0
 7634 01fa DA46     		mov	sl, fp
 7635              	.LVL1122:
 7636              	.L970:
4129:lib/ff/ff.c   **** 		do res += (cc = f_putc(s[--i], fil)); while(i);
 7637              		.loc 1 4129 0 is_stmt 1 discriminator 1
 7638 01fc 013F     		subs	r7, r7, #1
 7639              	.LVL1123:
 7640 01fe 04AB     		add	r3, sp, #16
 7641 0200 D857     		ldrsb	r0, [r3, r7]
 7642 0202 4146     		mov	r1, r8
 7643 0204 FFF7FEFF 		bl	f_putc
 7644              	.LVL1124:
 7645 0208 2418     		adds	r4, r4, r0
 7646              	.LVL1125:
 7647 020a 002F     		cmp	r7, #0
 7648 020c F6D1     		bne	.L970
 7649              	.L980:
4130:lib/ff/ff.c   **** 		while (j++ < w) res += (cc = f_putc(' ', fil));
 7650              		.loc 1 4130 0 discriminator 1
 7651 020e CA45     		cmp	sl, r9
 7652 0210 07D2     		bcs	.L991
 7653              	.L936:
4130:lib/ff/ff.c   **** 		while (j++ < w) res += (cc = f_putc(' ', fil));
 7654              		.loc 1 4130 0 is_stmt 0 discriminator 2
 7655 0212 2020     		movs	r0, #32
 7656 0214 4146     		mov	r1, r8
 7657 0216 FFF7FEFF 		bl	f_putc
 7658              	.LVL1126:
 7659 021a 2418     		adds	r4, r4, r0
 7660              	.LVL1127:
 7661 021c 0AF1010A 		add	sl, sl, #1
 7662 0220 F5E7     		b	.L980
 7663              	.L991:
4131:lib/ff/ff.c   **** 		if (cc != EOF) cc = res;
 7664              		.loc 1 4131 0 is_stmt 1
 7665 0222 B0F1FF3F 		cmp	r0, #-1
 7666 0226 14BF     		ite	ne
 7667 0228 2046     		movne	r0, r4
 7668 022a 4FF0FF30 		moveq	r0, #-1
 7669              	.LVL1128:
 7670              	.L897:
4059:lib/ff/ff.c   **** 	for (cc = res = 0; cc != EOF; res += cc) {
 7671              		.loc 1 4059 0
 7672 022e 2418     		adds	r4, r4, r0
 7673              	.LVL1129:
 7674 0230 411C     		adds	r1, r0, #1
 7675 0232 07D0     		beq	.L938
 7676              	.L945:
 7677 0234 3246     		mov	r2, r6
 7678 0236 EEE6     		b	.L937
 7679              	.LVL1130:
 7680              	.L895:
4135:lib/ff/ff.c   **** 	return (cc == EOF) ? cc : res;
 7681              		.loc 1 4135 0
 7682 0238 B0F1FF3F 		cmp	r0, #-1
 7683 023c 14BF     		ite	ne
 7684 023e 2046     		movne	r0, r4
 7685 0240 4FF0FF30 		moveq	r0, #-1
 7686              	.L938:
 7687              		.loc 1 4136 0 discriminator 3
 7688 0244 08B0     		add	sp, sp, #32
 7689 0246 BDE8F04F 		pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7690 024a 03B0     		add	sp, sp, #12
 7691 024c 7047     		bx	lr
 7692              		.cfi_endproc
 7693              	.LFE51:
 7695              		.section	.rodata.cst.4292,"a",%progbits
 7696              		.align	1
 7697              		.set	.LANCHOR4,. + 0
 7700              	cst.4292:
 7701 0000 0080     		.short	-32768
 7702 0002 0040     		.short	16384
 7703 0004 0020     		.short	8192
 7704 0006 0010     		.short	4096
 7705 0008 0008     		.short	2048
 7706 000a 0040     		.short	16384
 7707 000c 0020     		.short	8192
 7708 000e 0010     		.short	4096
 7709 0010 0008     		.short	2048
 7710 0012 0004     		.short	1024
 7711 0014 0002     		.short	512
 7712              		.section	.bss.CurrVol,"aw",%nobits
 7713              		.set	.LANCHOR0,. + 0
 7716              	CurrVol:
 7717 0000 00       		.space	1
 7718              		.section	.rodata.str1.1,"aMS",%progbits,1
 7719              	.LC0:
 7720 0000 222A2B2C 		.ascii	"\"*+,:;<=>?[]|\177\000"
 7720      3A3B3C3D 
 7720      3E3F5B5D 
 7720      7C7F00
 7721              	.LC1:
 7722 000f EBFE904D 		.ascii	"\353\376\220MSDOS5.0\000"
 7722      53444F53 
 7722      352E3000 
 7723              	.LC2:
 7724 001b 4E4F204E 		.ascii	"NO NAME    FAT32   \000"
 7724      414D4520 
 7724      20202046 
 7724      41543332 
 7724      20202000 
 7725              	.LC3:
 7726 002f 4E4F204E 		.ascii	"NO NAME    FAT     \000"
 7726      414D4520 
 7726      20202046 
 7726      41542020 
 7726      20202000 
 7727              		.section	.bss.Fsid,"aw",%nobits
 7728              		.align	1
 7729              		.set	.LANCHOR2,. + 0
 7732              	Fsid:
 7733 0000 0000     		.space	2
 7734              		.section	.rodata.vst.4291,"a",%progbits
 7735              		.align	1
 7736              		.set	.LANCHOR3,. + 0
 7739              	vst.4291:
 7740 0000 0004     		.short	1024
 7741 0002 0002     		.short	512
 7742 0004 0001     		.short	256
 7743 0006 8000     		.short	128
 7744 0008 4000     		.short	64
 7745 000a 2000     		.short	32
 7746 000c 1000     		.short	16
 7747 000e 0800     		.short	8
 7748 0010 0400     		.short	4
 7749 0012 0200     		.short	2
 7750 0014 0000     		.short	0
 7751              		.section	.bss.FatFs,"aw",%nobits
 7752              		.align	2
 7753              		.set	.LANCHOR1,. + 0
 7756              	FatFs:
 7757 0000 00000000 		.space	4
 7758              		.text
 7759              	.Letext0:
 7760              		.file 2 "lib/ff/integer.h"
 7761              		.file 3 "lib/ff/ff.h"
 7762              		.file 4 "lib/ff/diskio.h"
 7763              		.file 5 "c:\\devz\\arm\\launchpad\\bin\\../lib/gcc/arm-none-eabi/4.7.3/include/stdarg.h"
 7764              		.file 6 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:00000000 ff.c
  R:\TEMP\ccNrR4Y3.s:19     .text.mem_cpy:00000000 $t
  R:\TEMP\ccNrR4Y3.s:23     .text.mem_cpy:00000000 mem_cpy
  R:\TEMP\ccNrR4Y3.s:77     .text.mem_set:00000000 $t
  R:\TEMP\ccNrR4Y3.s:81     .text.mem_set:00000000 mem_set
  R:\TEMP\ccNrR4Y3.s:109    .text.clmt_clust:00000000 $t
  R:\TEMP\ccNrR4Y3.s:113    .text.clmt_clust:00000000 clmt_clust
  R:\TEMP\ccNrR4Y3.s:164    .text.get_fileinfo:00000000 $t
  R:\TEMP\ccNrR4Y3.s:168    .text.get_fileinfo:00000000 get_fileinfo
  R:\TEMP\ccNrR4Y3.s:275    .text.validate:00000000 $t
  R:\TEMP\ccNrR4Y3.s:279    .text.validate:00000000 validate
  R:\TEMP\ccNrR4Y3.s:322    .text.move_window:00000000 $t
  R:\TEMP\ccNrR4Y3.s:326    .text.move_window:00000000 move_window
  R:\TEMP\ccNrR4Y3.s:438    .text.sync:00000000 $t
  R:\TEMP\ccNrR4Y3.s:442    .text.sync:00000000 sync
  R:\TEMP\ccNrR4Y3.s:523    .text.sync:00000068 $d
  R:\TEMP\ccNrR4Y3.s:529    .text.check_fs:00000000 $t
  R:\TEMP\ccNrR4Y3.s:533    .text.check_fs:00000000 check_fs
  R:\TEMP\ccNrR4Y3.s:594    .text.check_fs:00000048 $d
  R:\TEMP\ccNrR4Y3.s:599    .text.chk_mounted:00000000 $t
  R:\TEMP\ccNrR4Y3.s:603    .text.chk_mounted:00000000 chk_mounted
  R:\TEMP\ccNrR4Y3.s:995    .text.chk_mounted:00000200 $d
  R:\TEMP\ccNrR4Y3.s:1004   .text.clust2sect:00000000 $t
  R:\TEMP\ccNrR4Y3.s:1009   .text.clust2sect:00000000 clust2sect
  R:\TEMP\ccNrR4Y3.s:1042   .text.get_fat:00000000 $t
  R:\TEMP\ccNrR4Y3.s:1047   .text.get_fat:00000000 get_fat
  R:\TEMP\ccNrR4Y3.s:1183   .text.dir_sdi:00000000 $t
  R:\TEMP\ccNrR4Y3.s:1187   .text.dir_sdi:00000000 dir_sdi
  R:\TEMP\ccNrR4Y3.s:1315   .text.dir_remove:00000000 $t
  R:\TEMP\ccNrR4Y3.s:1319   .text.dir_remove:00000000 dir_remove
  R:\TEMP\ccNrR4Y3.s:1367   .text.put_fat:00000000 $t
  R:\TEMP\ccNrR4Y3.s:1372   .text.put_fat:00000000 put_fat
  R:\TEMP\ccNrR4Y3.s:1549   .text.create_chain:00000000 $t
  R:\TEMP\ccNrR4Y3.s:1553   .text.create_chain:00000000 create_chain
  R:\TEMP\ccNrR4Y3.s:1716   .text.dir_next:00000000 $t
  R:\TEMP\ccNrR4Y3.s:1720   .text.dir_next:00000000 dir_next
  R:\TEMP\ccNrR4Y3.s:1925   .text.follow_path:00000000 $t
  R:\TEMP\ccNrR4Y3.s:1929   .text.follow_path:00000000 follow_path
  R:\TEMP\ccNrR4Y3.s:2424   .text.follow_path:00000254 $d
  R:\TEMP\ccNrR4Y3.s:2429   .text.dir_register:00000000 $t
  R:\TEMP\ccNrR4Y3.s:2433   .text.dir_register:00000000 dir_register
  R:\TEMP\ccNrR4Y3.s:2524   .text.dir_read:00000000 $t
  R:\TEMP\ccNrR4Y3.s:2528   .text.dir_read:00000000 dir_read
  R:\TEMP\ccNrR4Y3.s:2617   .text.remove_chain:00000000 $t
  R:\TEMP\ccNrR4Y3.s:2621   .text.remove_chain:00000000 remove_chain
  R:\TEMP\ccNrR4Y3.s:2754   .text.f_mount:00000000 $t
  R:\TEMP\ccNrR4Y3.s:2759   .text.f_mount:00000000 f_mount
  R:\TEMP\ccNrR4Y3.s:2800   .text.f_mount:0000001c $d
  R:\TEMP\ccNrR4Y3.s:2805   .text.f_open:00000000 $t
  R:\TEMP\ccNrR4Y3.s:2810   .text.f_open:00000000 f_open
  R:\TEMP\ccNrR4Y3.s:3090   .text.f_read:00000000 $t
  R:\TEMP\ccNrR4Y3.s:3095   .text.f_read:00000000 f_read
  R:\TEMP\ccNrR4Y3.s:3341   .text.f_write:00000000 $t
  R:\TEMP\ccNrR4Y3.s:3346   .text.f_write:00000000 f_write
  R:\TEMP\ccNrR4Y3.s:3656   .text.f_sync:00000000 $t
  R:\TEMP\ccNrR4Y3.s:3661   .text.f_sync:00000000 f_sync
  R:\TEMP\ccNrR4Y3.s:3751   .text.f_close:00000000 $t
  R:\TEMP\ccNrR4Y3.s:3756   .text.f_close:00000000 f_close
  R:\TEMP\ccNrR4Y3.s:3783   .text.f_chdrive:00000000 $t
  R:\TEMP\ccNrR4Y3.s:3788   .text.f_chdrive:00000000 f_chdrive
  R:\TEMP\ccNrR4Y3.s:3812   .text.f_chdrive:0000000c $d
  R:\TEMP\ccNrR4Y3.s:3817   .text.f_chdir:00000000 $t
  R:\TEMP\ccNrR4Y3.s:3822   .text.f_chdir:00000000 f_chdir
  R:\TEMP\ccNrR4Y3.s:3917   .text.f_getcwd:00000000 $t
  R:\TEMP\ccNrR4Y3.s:3922   .text.f_getcwd:00000000 f_getcwd
  R:\TEMP\ccNrR4Y3.s:4196   .text.f_getcwd:0000011c $d
  R:\TEMP\ccNrR4Y3.s:4201   .text.f_lseek:00000000 $t
  R:\TEMP\ccNrR4Y3.s:4206   .text.f_lseek:00000000 f_lseek
  R:\TEMP\ccNrR4Y3.s:4601   .text.f_opendir:00000000 $t
  R:\TEMP\ccNrR4Y3.s:4606   .text.f_opendir:00000000 f_opendir
  R:\TEMP\ccNrR4Y3.s:4716   .text.f_readdir:00000000 $t
  R:\TEMP\ccNrR4Y3.s:4721   .text.f_readdir:00000000 f_readdir
  R:\TEMP\ccNrR4Y3.s:4812   .text.f_stat:00000000 $t
  R:\TEMP\ccNrR4Y3.s:4817   .text.f_stat:00000000 f_stat
  R:\TEMP\ccNrR4Y3.s:4884   .text.f_getfree:00000000 $t
  R:\TEMP\ccNrR4Y3.s:4889   .text.f_getfree:00000000 f_getfree
  R:\TEMP\ccNrR4Y3.s:5076   .text.f_truncate:00000000 $t
  R:\TEMP\ccNrR4Y3.s:5081   .text.f_truncate:00000000 f_truncate
  R:\TEMP\ccNrR4Y3.s:5222   .text.f_unlink:00000000 $t
  R:\TEMP\ccNrR4Y3.s:5227   .text.f_unlink:00000000 f_unlink
  R:\TEMP\ccNrR4Y3.s:5407   .text.f_mkdir:00000000 $t
  R:\TEMP\ccNrR4Y3.s:5412   .text.f_mkdir:00000000 f_mkdir
  R:\TEMP\ccNrR4Y3.s:5692   .text.f_chmod:00000000 $t
  R:\TEMP\ccNrR4Y3.s:5697   .text.f_chmod:00000000 f_chmod
  R:\TEMP\ccNrR4Y3.s:5785   .text.f_utime:00000000 $t
  R:\TEMP\ccNrR4Y3.s:5790   .text.f_utime:00000000 f_utime
  R:\TEMP\ccNrR4Y3.s:5872   .text.f_rename:00000000 $t
  R:\TEMP\ccNrR4Y3.s:5877   .text.f_rename:00000000 f_rename
  R:\TEMP\ccNrR4Y3.s:6105   .text.f_forward:00000000 $t
  R:\TEMP\ccNrR4Y3.s:6110   .text.f_forward:00000000 f_forward
  R:\TEMP\ccNrR4Y3.s:6304   .text.f_mkfs:00000000 $t
  R:\TEMP\ccNrR4Y3.s:6309   .text.f_mkfs:00000000 f_mkfs
  R:\TEMP\ccNrR4Y3.s:6790   .text.f_mkfs:000002e8 $d
  R:\TEMP\ccNrR4Y3.s:6800   .text.f_mkfs:00000304 $t
  R:\TEMP\ccNrR4Y3.s:7021   .text.f_mkfs:00000458 $d
  R:\TEMP\ccNrR4Y3.s:7027   .text.f_gets:00000000 $t
  R:\TEMP\ccNrR4Y3.s:7032   .text.f_gets:00000000 f_gets
  R:\TEMP\ccNrR4Y3.s:7103   .text.f_putc:00000000 $t
  R:\TEMP\ccNrR4Y3.s:7108   .text.f_putc:00000000 f_putc
  R:\TEMP\ccNrR4Y3.s:7147   .text.f_puts:00000000 $t
  R:\TEMP\ccNrR4Y3.s:7152   .text.f_puts:00000000 f_puts
  R:\TEMP\ccNrR4Y3.s:7200   .text.f_printf:00000000 $t
  R:\TEMP\ccNrR4Y3.s:7205   .text.f_printf:00000000 f_printf
  R:\TEMP\ccNrR4Y3.s:7696   .rodata.cst.4292:00000000 $d
  R:\TEMP\ccNrR4Y3.s:7700   .rodata.cst.4292:00000000 cst.4292
  R:\TEMP\ccNrR4Y3.s:7716   .bss.CurrVol:00000000 CurrVol
  R:\TEMP\ccNrR4Y3.s:7717   .bss.CurrVol:00000000 $d
  R:\TEMP\ccNrR4Y3.s:7719   .rodata.str1.1:00000000 .LC0
  R:\TEMP\ccNrR4Y3.s:7728   .bss.Fsid:00000000 $d
  R:\TEMP\ccNrR4Y3.s:7732   .bss.Fsid:00000000 Fsid
  R:\TEMP\ccNrR4Y3.s:7735   .rodata.vst.4291:00000000 $d
  R:\TEMP\ccNrR4Y3.s:7739   .rodata.vst.4291:00000000 vst.4291
  R:\TEMP\ccNrR4Y3.s:7752   .bss.FatFs:00000000 $d
  R:\TEMP\ccNrR4Y3.s:7756   .bss.FatFs:00000000 FatFs
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
disk_status
disk_write
disk_read
disk_ioctl
disk_initialize
get_fattime
