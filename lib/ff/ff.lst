   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"ff.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.mem_cpy,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	mem_cpy:
  24              	.LFB0:
  25              		.file 1 "lib/ff/ff.c"
   1:lib/ff/ff.c   **** /*----------------------------------------------------------------------------/
   2:lib/ff/ff.c   **** /  FatFs - FAT file system module  R0.09b                 (C)ChaN, 2013
   3:lib/ff/ff.c   **** /-----------------------------------------------------------------------------/
   4:lib/ff/ff.c   **** / FatFs module is a generic FAT file system module for small embedded systems.
   5:lib/ff/ff.c   **** / This is a free software that opened for education, research and commercial
   6:lib/ff/ff.c   **** / developments under license policy of following terms.
   7:lib/ff/ff.c   **** /
   8:lib/ff/ff.c   **** /  Copyright (C) 2013, ChaN, all right reserved.
   9:lib/ff/ff.c   **** /
  10:lib/ff/ff.c   **** / * The FatFs module is a free software and there is NO WARRANTY.
  11:lib/ff/ff.c   **** / * No restriction on use. You can use, modify and redistribute it for
  12:lib/ff/ff.c   **** /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
  13:lib/ff/ff.c   **** / * Redistributions of source code must retain the above copyright notice.
  14:lib/ff/ff.c   **** /
  15:lib/ff/ff.c   **** /-----------------------------------------------------------------------------/
  16:lib/ff/ff.c   **** / Feb 26,'06 R0.00  Prototype.
  17:lib/ff/ff.c   **** /
  18:lib/ff/ff.c   **** / Apr 29,'06 R0.01  First stable version.
  19:lib/ff/ff.c   **** /
  20:lib/ff/ff.c   **** / Jun 01,'06 R0.02  Added FAT12 support.
  21:lib/ff/ff.c   **** /                   Removed unbuffered mode.
  22:lib/ff/ff.c   **** /                   Fixed a problem on small (<32M) partition.
  23:lib/ff/ff.c   **** / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
  24:lib/ff/ff.c   **** /
  25:lib/ff/ff.c   **** / Sep 22,'06 R0.03  Added f_rename().
  26:lib/ff/ff.c   **** /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
  27:lib/ff/ff.c   **** / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
  28:lib/ff/ff.c   **** /                   Fixed f_mkdir() creates incorrect directory on FAT32.
  29:lib/ff/ff.c   **** /
  30:lib/ff/ff.c   **** / Feb 04,'07 R0.04  Supported multiple drive system.
  31:lib/ff/ff.c   **** /                   Changed some interfaces for multiple drive system.
  32:lib/ff/ff.c   **** /                   Changed f_mountdrv() to f_mount().
  33:lib/ff/ff.c   **** /                   Added f_mkfs().
  34:lib/ff/ff.c   **** / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
  35:lib/ff/ff.c   **** /                   Added a capability of extending file size to f_lseek().
  36:lib/ff/ff.c   **** /                   Added minimization level 3.
  37:lib/ff/ff.c   **** /                   Fixed an endian sensitive code in f_mkfs().
  38:lib/ff/ff.c   **** / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
  39:lib/ff/ff.c   **** /                   Added FSInfo support.
  40:lib/ff/ff.c   **** /                   Fixed DBCS name can result FR_INVALID_NAME.
  41:lib/ff/ff.c   **** /                   Fixed short seek (<= csize) collapses the file object.
  42:lib/ff/ff.c   **** /
  43:lib/ff/ff.c   **** / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
  44:lib/ff/ff.c   **** /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
  45:lib/ff/ff.c   **** /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
  46:lib/ff/ff.c   **** / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
  47:lib/ff/ff.c   **** /                   Fixed off by one error at FAT sub-type determination.
  48:lib/ff/ff.c   **** /                   Fixed btr in f_read() can be mistruncated.
  49:lib/ff/ff.c   **** /                   Fixed cached sector is not flushed when create and close without write.
  50:lib/ff/ff.c   **** /
  51:lib/ff/ff.c   **** / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
  52:lib/ff/ff.c   **** /                   Improved performance of f_lseek() on moving to the same or following cluster.
  53:lib/ff/ff.c   **** /
  54:lib/ff/ff.c   **** / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
  55:lib/ff/ff.c   **** /                   Added long file name feature.
  56:lib/ff/ff.c   **** /                   Added multiple code page feature.
  57:lib/ff/ff.c   **** /                   Added re-entrancy for multitask operation.
  58:lib/ff/ff.c   **** /                   Added auto cluster size selection to f_mkfs().
  59:lib/ff/ff.c   **** /                   Added rewind option to f_readdir().
  60:lib/ff/ff.c   **** /                   Changed result code of critical errors.
  61:lib/ff/ff.c   **** /                   Renamed string functions to avoid name collision.
  62:lib/ff/ff.c   **** / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
  63:lib/ff/ff.c   **** /                   Added multiple sector size feature.
  64:lib/ff/ff.c   **** / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
  65:lib/ff/ff.c   **** /                   Fixed wrong cache control in f_lseek().
  66:lib/ff/ff.c   **** /                   Added relative path feature.
  67:lib/ff/ff.c   **** /                   Added f_chdir() and f_chdrive().
  68:lib/ff/ff.c   **** /                   Added proper case conversion to extended char.
  69:lib/ff/ff.c   **** / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
  70:lib/ff/ff.c   **** /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
  71:lib/ff/ff.c   **** /                   Fixed name matching error on the 13 char boundary.
  72:lib/ff/ff.c   **** /                   Added a configuration option, _LFN_UNICODE.
  73:lib/ff/ff.c   **** /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
  74:lib/ff/ff.c   **** /
  75:lib/ff/ff.c   **** / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
  76:lib/ff/ff.c   **** /                   Added file lock feature. (_FS_SHARE)
  77:lib/ff/ff.c   **** /                   Added fast seek feature. (_USE_FASTSEEK)
  78:lib/ff/ff.c   **** /                   Changed some types on the API, XCHAR->TCHAR.
  79:lib/ff/ff.c   **** /                   Changed fname member in the FILINFO structure on Unicode cfg.
  80:lib/ff/ff.c   **** /                   String functions support UTF-8 encoding files on Unicode cfg.
  81:lib/ff/ff.c   **** / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
  82:lib/ff/ff.c   **** /                   Added sector erase feature. (_USE_ERASE)
  83:lib/ff/ff.c   **** /                   Moved file lock semaphore table from fs object to the bss.
  84:lib/ff/ff.c   **** /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name con
  85:lib/ff/ff.c   **** /                   Fixed f_mkfs() creates wrong FAT32 volume.
  86:lib/ff/ff.c   **** / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
  87:lib/ff/ff.c   **** /                   f_lseek() reports required table size on creating CLMP.
  88:lib/ff/ff.c   **** /                   Extended format syntax of f_printf function.
  89:lib/ff/ff.c   **** /                   Ignores duplicated directory separators in given path name.
  90:lib/ff/ff.c   **** /
  91:lib/ff/ff.c   **** / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
  92:lib/ff/ff.c   **** /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
  93:lib/ff/ff.c   **** / Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
  94:lib/ff/ff.c   **** /                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
  95:lib/ff/ff.c   **** /                   Changed option name _FS_SHARE to _FS_LOCK.
  96:lib/ff/ff.c   **** / Jan 24,'13 R0.09b Added f_setlabel() and f_getlabel(). (_USE_LABEL = 1)
  97:lib/ff/ff.c   **** /---------------------------------------------------------------------------*/
  98:lib/ff/ff.c   **** 
  99:lib/ff/ff.c   **** #include "ff.h"			/* FatFs configurations and declarations */
 100:lib/ff/ff.c   **** #include "diskio.h"		/* Declarations of low level disk I/O functions */
 101:lib/ff/ff.c   **** 
 102:lib/ff/ff.c   **** 
 103:lib/ff/ff.c   **** /*--------------------------------------------------------------------------
 104:lib/ff/ff.c   **** 
 105:lib/ff/ff.c   ****    Module Private Definitions
 106:lib/ff/ff.c   **** 
 107:lib/ff/ff.c   **** ---------------------------------------------------------------------------*/
 108:lib/ff/ff.c   **** 
 109:lib/ff/ff.c   **** #if _FATFS != 82786	/* Revision ID */
 110:lib/ff/ff.c   **** #error Wrong include file (ff.h).
 111:lib/ff/ff.c   **** #endif
 112:lib/ff/ff.c   **** 
 113:lib/ff/ff.c   **** 
 114:lib/ff/ff.c   **** /* Definitions on sector size */
 115:lib/ff/ff.c   **** #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
 116:lib/ff/ff.c   **** #error Wrong sector size.
 117:lib/ff/ff.c   **** #endif
 118:lib/ff/ff.c   **** #if _MAX_SS != 512
 119:lib/ff/ff.c   **** #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
 120:lib/ff/ff.c   **** #else
 121:lib/ff/ff.c   **** #define	SS(fs)	512U			/* Fixed sector size */
 122:lib/ff/ff.c   **** #endif
 123:lib/ff/ff.c   **** 
 124:lib/ff/ff.c   **** 
 125:lib/ff/ff.c   **** /* Reentrancy related */
 126:lib/ff/ff.c   **** #if _FS_REENTRANT
 127:lib/ff/ff.c   **** #if _USE_LFN == 1
 128:lib/ff/ff.c   **** #error Static LFN work area must not be used in re-entrant configuration.
 129:lib/ff/ff.c   **** #endif
 130:lib/ff/ff.c   **** #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
 131:lib/ff/ff.c   **** #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
 132:lib/ff/ff.c   **** #else
 133:lib/ff/ff.c   **** #define	ENTER_FF(fs)
 134:lib/ff/ff.c   **** #define LEAVE_FF(fs, res)	return res
 135:lib/ff/ff.c   **** #endif
 136:lib/ff/ff.c   **** 
 137:lib/ff/ff.c   **** #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
 138:lib/ff/ff.c   **** 
 139:lib/ff/ff.c   **** 
 140:lib/ff/ff.c   **** /* File access control feature */
 141:lib/ff/ff.c   **** #if _FS_LOCK
 142:lib/ff/ff.c   **** #if _FS_READONLY
 143:lib/ff/ff.c   **** #error _FS_LOCK must be 0 on read-only cfg.
 144:lib/ff/ff.c   **** #endif
 145:lib/ff/ff.c   **** typedef struct {
 146:lib/ff/ff.c   **** 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
 147:lib/ff/ff.c   **** 	DWORD clu;				/* File ID 2, directory */
 148:lib/ff/ff.c   **** 	WORD idx;				/* File ID 3, directory index */
 149:lib/ff/ff.c   **** 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
 150:lib/ff/ff.c   **** } FILESEM;
 151:lib/ff/ff.c   **** #endif
 152:lib/ff/ff.c   **** 
 153:lib/ff/ff.c   **** 
 154:lib/ff/ff.c   **** 
 155:lib/ff/ff.c   **** /* DBCS code ranges and SBCS extend char conversion table */
 156:lib/ff/ff.c   **** 
 157:lib/ff/ff.c   **** #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
 158:lib/ff/ff.c   **** #define _DF1S	0x81	/* DBC 1st byte range 1 start */
 159:lib/ff/ff.c   **** #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
 160:lib/ff/ff.c   **** #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
 161:lib/ff/ff.c   **** #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
 162:lib/ff/ff.c   **** #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
 163:lib/ff/ff.c   **** #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
 164:lib/ff/ff.c   **** #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
 165:lib/ff/ff.c   **** #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
 166:lib/ff/ff.c   **** 
 167:lib/ff/ff.c   **** #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
 168:lib/ff/ff.c   **** #define _DF1S	0x81
 169:lib/ff/ff.c   **** #define _DF1E	0xFE
 170:lib/ff/ff.c   **** #define _DS1S	0x40
 171:lib/ff/ff.c   **** #define _DS1E	0x7E
 172:lib/ff/ff.c   **** #define _DS2S	0x80
 173:lib/ff/ff.c   **** #define _DS2E	0xFE
 174:lib/ff/ff.c   **** 
 175:lib/ff/ff.c   **** #elif _CODE_PAGE == 949	/* Korean */
 176:lib/ff/ff.c   **** #define _DF1S	0x81
 177:lib/ff/ff.c   **** #define _DF1E	0xFE
 178:lib/ff/ff.c   **** #define _DS1S	0x41
 179:lib/ff/ff.c   **** #define _DS1E	0x5A
 180:lib/ff/ff.c   **** #define _DS2S	0x61
 181:lib/ff/ff.c   **** #define _DS2E	0x7A
 182:lib/ff/ff.c   **** #define _DS3S	0x81
 183:lib/ff/ff.c   **** #define _DS3E	0xFE
 184:lib/ff/ff.c   **** 
 185:lib/ff/ff.c   **** #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
 186:lib/ff/ff.c   **** #define _DF1S	0x81
 187:lib/ff/ff.c   **** #define _DF1E	0xFE
 188:lib/ff/ff.c   **** #define _DS1S	0x40
 189:lib/ff/ff.c   **** #define _DS1E	0x7E
 190:lib/ff/ff.c   **** #define _DS2S	0xA1
 191:lib/ff/ff.c   **** #define _DS2E	0xFE
 192:lib/ff/ff.c   **** 
 193:lib/ff/ff.c   **** #elif _CODE_PAGE == 437	/* U.S. (OEM) */
 194:lib/ff/ff.c   **** #define _DF1S	0
 195:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x9
 196:lib/ff/ff.c   **** 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 197:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 198:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 199:lib/ff/ff.c   **** 
 200:lib/ff/ff.c   **** #elif _CODE_PAGE == 720	/* Arabic (OEM) */
 201:lib/ff/ff.c   **** #define _DF1S	0
 202:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x9
 203:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 204:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 205:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 206:lib/ff/ff.c   **** 
 207:lib/ff/ff.c   **** #elif _CODE_PAGE == 737	/* Greek (OEM) */
 208:lib/ff/ff.c   **** #define _DF1S	0
 209:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 210:lib/ff/ff.c   **** 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,
 211:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 212:lib/ff/ff.c   **** 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 213:lib/ff/ff.c   **** 
 214:lib/ff/ff.c   **** #elif _CODE_PAGE == 775	/* Baltic (OEM) */
 215:lib/ff/ff.c   **** #define _DF1S	0
 216:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x9
 217:lib/ff/ff.c   **** 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 218:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,
 219:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 220:lib/ff/ff.c   **** 
 221:lib/ff/ff.c   **** #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
 222:lib/ff/ff.c   **** #define _DF1S	0
 223:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x9
 224:lib/ff/ff.c   **** 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 225:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 226:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 227:lib/ff/ff.c   **** 
 228:lib/ff/ff.c   **** #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
 229:lib/ff/ff.c   **** #define _DF1S	0
 230:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x9
 231:lib/ff/ff.c   **** 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,
 232:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,
 233:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,
 234:lib/ff/ff.c   **** 
 235:lib/ff/ff.c   **** #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
 236:lib/ff/ff.c   **** #define _DF1S	0
 237:lib/ff/ff.c   **** #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x9
 238:lib/ff/ff.c   **** 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 239:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,
 240:lib/ff/ff.c   **** 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,
 241:lib/ff/ff.c   **** 
 242:lib/ff/ff.c   **** #elif _CODE_PAGE == 857	/* Turkish (OEM) */
 243:lib/ff/ff.c   **** #define _DF1S	0
 244:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x9
 245:lib/ff/ff.c   **** 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 246:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 247:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,
 248:lib/ff/ff.c   **** 
 249:lib/ff/ff.c   **** #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
 250:lib/ff/ff.c   **** #define _DF1S	0
 251:lib/ff/ff.c   **** #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x9
 252:lib/ff/ff.c   **** 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 253:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,
 254:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 255:lib/ff/ff.c   **** 
 256:lib/ff/ff.c   **** #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
 257:lib/ff/ff.c   **** #define _DF1S	0
 258:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 259:lib/ff/ff.c   **** 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,
 260:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 261:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 262:lib/ff/ff.c   **** 
 263:lib/ff/ff.c   **** #elif _CODE_PAGE == 866	/* Russian (OEM) */
 264:lib/ff/ff.c   **** #define _DF1S	0
 265:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 266:lib/ff/ff.c   **** 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,
 267:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 268:lib/ff/ff.c   **** 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,
 269:lib/ff/ff.c   **** 
 270:lib/ff/ff.c   **** #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
 271:lib/ff/ff.c   **** #define _DF1S	0
 272:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 273:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 274:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 275:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 276:lib/ff/ff.c   **** 
 277:lib/ff/ff.c   **** #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
 278:lib/ff/ff.c   **** #define _DF1S	0
 279:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 280:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 281:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 282:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 283:lib/ff/ff.c   **** 
 284:lib/ff/ff.c   **** #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
 285:lib/ff/ff.c   **** #define _DF1S	0
 286:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x8
 287:lib/ff/ff.c   **** 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 288:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 289:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 290:lib/ff/ff.c   **** 
 291:lib/ff/ff.c   **** #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
 292:lib/ff/ff.c   **** #define _DF1S	0
 293:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 294:lib/ff/ff.c   **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 295:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 296:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 297:lib/ff/ff.c   **** 
 298:lib/ff/ff.c   **** #elif _CODE_PAGE == 1253 /* Greek (Windows) */
 299:lib/ff/ff.c   **** #define _DF1S	0
 300:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 301:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 302:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 303:lib/ff/ff.c   **** 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,
 304:lib/ff/ff.c   **** 
 305:lib/ff/ff.c   **** #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
 306:lib/ff/ff.c   **** #define _DF1S	0
 307:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 308:lib/ff/ff.c   **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 309:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 310:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 311:lib/ff/ff.c   **** 
 312:lib/ff/ff.c   **** #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
 313:lib/ff/ff.c   **** #define _DF1S	0
 314:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 315:lib/ff/ff.c   **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 316:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 317:lib/ff/ff.c   **** 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,
 318:lib/ff/ff.c   **** 
 319:lib/ff/ff.c   **** #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
 320:lib/ff/ff.c   **** #define _DF1S	0
 321:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 322:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 323:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 324:lib/ff/ff.c   **** 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,
 325:lib/ff/ff.c   **** 
 326:lib/ff/ff.c   **** #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
 327:lib/ff/ff.c   **** #define _DF1S	0
 328:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 329:lib/ff/ff.c   **** 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 330:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 331:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 332:lib/ff/ff.c   **** 
 333:lib/ff/ff.c   **** #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
 334:lib/ff/ff.c   **** #define _DF1S	0
 335:lib/ff/ff.c   **** #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x9
 336:lib/ff/ff.c   **** 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
 337:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
 338:lib/ff/ff.c   **** 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,
 339:lib/ff/ff.c   **** 
 340:lib/ff/ff.c   **** #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
 341:lib/ff/ff.c   **** #if _USE_LFN
 342:lib/ff/ff.c   **** #error Cannot use LFN feature without valid code page.
 343:lib/ff/ff.c   **** #endif
 344:lib/ff/ff.c   **** #define _DF1S	0
 345:lib/ff/ff.c   **** 
 346:lib/ff/ff.c   **** #else
 347:lib/ff/ff.c   **** #error Unknown code page
 348:lib/ff/ff.c   **** 
 349:lib/ff/ff.c   **** #endif
 350:lib/ff/ff.c   **** 
 351:lib/ff/ff.c   **** 
 352:lib/ff/ff.c   **** /* Character code support macros */
 353:lib/ff/ff.c   **** #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
 354:lib/ff/ff.c   **** #define IsLower(c)	(((c)>='a')&&((c)<='z'))
 355:lib/ff/ff.c   **** #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
 356:lib/ff/ff.c   **** 
 357:lib/ff/ff.c   **** #if _DF1S		/* Code page is DBCS */
 358:lib/ff/ff.c   **** 
 359:lib/ff/ff.c   **** #ifdef _DF2S	/* Two 1st byte areas */
 360:lib/ff/ff.c   **** #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) 
 361:lib/ff/ff.c   **** #else			/* One 1st byte area */
 362:lib/ff/ff.c   **** #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
 363:lib/ff/ff.c   **** #endif
 364:lib/ff/ff.c   **** 
 365:lib/ff/ff.c   **** #ifdef _DS3S	/* Three 2nd byte areas */
 366:lib/ff/ff.c   **** #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) 
 367:lib/ff/ff.c   **** #else			/* Two 2nd byte areas */
 368:lib/ff/ff.c   **** #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) 
 369:lib/ff/ff.c   **** #endif
 370:lib/ff/ff.c   **** 
 371:lib/ff/ff.c   **** #else			/* Code page is SBCS */
 372:lib/ff/ff.c   **** 
 373:lib/ff/ff.c   **** #define IsDBCS1(c)	0
 374:lib/ff/ff.c   **** #define IsDBCS2(c)	0
 375:lib/ff/ff.c   **** 
 376:lib/ff/ff.c   **** #endif /* _DF1S */
 377:lib/ff/ff.c   **** 
 378:lib/ff/ff.c   **** 
 379:lib/ff/ff.c   **** /* Name status flags */
 380:lib/ff/ff.c   **** #define NS			11		/* Index of name status byte in fn[] */
 381:lib/ff/ff.c   **** #define NS_LOSS		0x01	/* Out of 8.3 format */
 382:lib/ff/ff.c   **** #define NS_LFN		0x02	/* Force to create LFN entry */
 383:lib/ff/ff.c   **** #define NS_LAST		0x04	/* Last segment */
 384:lib/ff/ff.c   **** #define NS_BODY		0x08	/* Lower case flag (body) */
 385:lib/ff/ff.c   **** #define NS_EXT		0x10	/* Lower case flag (ext) */
 386:lib/ff/ff.c   **** #define NS_DOT		0x20	/* Dot entry */
 387:lib/ff/ff.c   **** 
 388:lib/ff/ff.c   **** 
 389:lib/ff/ff.c   **** /* FAT sub-type boundaries */
 390:lib/ff/ff.c   **** /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
 391:lib/ff/ff.c   **** #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
 392:lib/ff/ff.c   **** #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
 393:lib/ff/ff.c   **** 
 394:lib/ff/ff.c   **** 
 395:lib/ff/ff.c   **** /* FatFs refers the members in the FAT structures as byte array instead of
 396:lib/ff/ff.c   **** / structure member because the structure is not binary compatible between
 397:lib/ff/ff.c   **** / different platforms */
 398:lib/ff/ff.c   **** 
 399:lib/ff/ff.c   **** #define BS_jmpBoot			0	/* Jump instruction (3) */
 400:lib/ff/ff.c   **** #define BS_OEMName			3	/* OEM name (8) */
 401:lib/ff/ff.c   **** #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
 402:lib/ff/ff.c   **** #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
 403:lib/ff/ff.c   **** #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
 404:lib/ff/ff.c   **** #define BPB_NumFATs			16	/* Number of FAT copies (1) */
 405:lib/ff/ff.c   **** #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
 406:lib/ff/ff.c   **** #define BPB_TotSec16		19	/* Volume size [sector] (2) */
 407:lib/ff/ff.c   **** #define BPB_Media			21	/* Media descriptor (1) */
 408:lib/ff/ff.c   **** #define BPB_FATSz16			22	/* FAT size [sector] (2) */
 409:lib/ff/ff.c   **** #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
 410:lib/ff/ff.c   **** #define BPB_NumHeads		26	/* Number of heads (2) */
 411:lib/ff/ff.c   **** #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
 412:lib/ff/ff.c   **** #define BPB_TotSec32		32	/* Volume size [sector] (4) */
 413:lib/ff/ff.c   **** #define BS_DrvNum			36	/* Physical drive number (2) */
 414:lib/ff/ff.c   **** #define BS_BootSig			38	/* Extended boot signature (1) */
 415:lib/ff/ff.c   **** #define BS_VolID			39	/* Volume serial number (4) */
 416:lib/ff/ff.c   **** #define BS_VolLab			43	/* Volume label (8) */
 417:lib/ff/ff.c   **** #define BS_FilSysType		54	/* File system type (1) */
 418:lib/ff/ff.c   **** #define BPB_FATSz32			36	/* FAT size [sector] (4) */
 419:lib/ff/ff.c   **** #define BPB_ExtFlags		40	/* Extended flags (2) */
 420:lib/ff/ff.c   **** #define BPB_FSVer			42	/* File system version (2) */
 421:lib/ff/ff.c   **** #define BPB_RootClus		44	/* Root dir first cluster (4) */
 422:lib/ff/ff.c   **** #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
 423:lib/ff/ff.c   **** #define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
 424:lib/ff/ff.c   **** #define BS_DrvNum32			64	/* Physical drive number (2) */
 425:lib/ff/ff.c   **** #define BS_BootSig32		66	/* Extended boot signature (1) */
 426:lib/ff/ff.c   **** #define BS_VolID32			67	/* Volume serial number (4) */
 427:lib/ff/ff.c   **** #define BS_VolLab32			71	/* Volume label (8) */
 428:lib/ff/ff.c   **** #define BS_FilSysType32		82	/* File system type (1) */
 429:lib/ff/ff.c   **** #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
 430:lib/ff/ff.c   **** #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
 431:lib/ff/ff.c   **** #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
 432:lib/ff/ff.c   **** #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
 433:lib/ff/ff.c   **** #define MBR_Table			446	/* MBR: Partition table offset (2) */
 434:lib/ff/ff.c   **** #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
 435:lib/ff/ff.c   **** #define BS_55AA				510	/* Boot sector signature (2) */
 436:lib/ff/ff.c   **** 
 437:lib/ff/ff.c   **** #define	DIR_Name			0	/* Short file name (11) */
 438:lib/ff/ff.c   **** #define	DIR_Attr			11	/* Attribute (1) */
 439:lib/ff/ff.c   **** #define	DIR_NTres			12	/* NT flag (1) */
 440:lib/ff/ff.c   **** #define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
 441:lib/ff/ff.c   **** #define	DIR_CrtTime			14	/* Created time (2) */
 442:lib/ff/ff.c   **** #define	DIR_CrtDate			16	/* Created date (2) */
 443:lib/ff/ff.c   **** #define DIR_LstAccDate		18	/* Last accessed date (2) */
 444:lib/ff/ff.c   **** #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
 445:lib/ff/ff.c   **** #define	DIR_WrtTime			22	/* Modified time (2) */
 446:lib/ff/ff.c   **** #define	DIR_WrtDate			24	/* Modified date (2) */
 447:lib/ff/ff.c   **** #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
 448:lib/ff/ff.c   **** #define	DIR_FileSize		28	/* File size (4) */
 449:lib/ff/ff.c   **** #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
 450:lib/ff/ff.c   **** #define	LDIR_Attr			11	/* LFN attribute (1) */
 451:lib/ff/ff.c   **** #define	LDIR_Type			12	/* LFN type (1) */
 452:lib/ff/ff.c   **** #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
 453:lib/ff/ff.c   **** #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
 454:lib/ff/ff.c   **** #define	SZ_DIR				32		/* Size of a directory entry */
 455:lib/ff/ff.c   **** #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
 456:lib/ff/ff.c   **** #define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
 457:lib/ff/ff.c   **** #define	NDDE				0x05	/* Replacement of the character collides with DDE */
 458:lib/ff/ff.c   **** 
 459:lib/ff/ff.c   **** 
 460:lib/ff/ff.c   **** /*------------------------------------------------------------*/
 461:lib/ff/ff.c   **** /* Module private work area                                   */
 462:lib/ff/ff.c   **** /*------------------------------------------------------------*/
 463:lib/ff/ff.c   **** /* Note that uninitialized variables with static duration are
 464:lib/ff/ff.c   **** /  zeroed/nulled at start-up. If not, the compiler or start-up
 465:lib/ff/ff.c   **** /  routine is out of ANSI-C standard.
 466:lib/ff/ff.c   **** */
 467:lib/ff/ff.c   **** 
 468:lib/ff/ff.c   **** #if _VOLUMES
 469:lib/ff/ff.c   **** static
 470:lib/ff/ff.c   **** FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
 471:lib/ff/ff.c   **** #else
 472:lib/ff/ff.c   **** #error Number of volumes must not be 0.
 473:lib/ff/ff.c   **** #endif
 474:lib/ff/ff.c   **** 
 475:lib/ff/ff.c   **** static
 476:lib/ff/ff.c   **** WORD Fsid;				/* File system mount ID */
 477:lib/ff/ff.c   **** 
 478:lib/ff/ff.c   **** #if _FS_RPATH
 479:lib/ff/ff.c   **** static
 480:lib/ff/ff.c   **** BYTE CurrVol;			/* Current drive */
 481:lib/ff/ff.c   **** #endif
 482:lib/ff/ff.c   **** 
 483:lib/ff/ff.c   **** #if _FS_LOCK
 484:lib/ff/ff.c   **** static
 485:lib/ff/ff.c   **** FILESEM	Files[_FS_LOCK];	/* File lock semaphores */
 486:lib/ff/ff.c   **** #endif
 487:lib/ff/ff.c   **** 
 488:lib/ff/ff.c   **** #if _USE_LFN == 0			/* No LFN feature */
 489:lib/ff/ff.c   **** #define	DEF_NAMEBUF			BYTE sfn[12]
 490:lib/ff/ff.c   **** #define INIT_BUF(dobj)		(dobj).fn = sfn
 491:lib/ff/ff.c   **** #define	FREE_BUF()
 492:lib/ff/ff.c   **** 
 493:lib/ff/ff.c   **** #elif _USE_LFN == 1			/* LFN feature with static working buffer */
 494:lib/ff/ff.c   **** static WCHAR LfnBuf[_MAX_LFN+1];
 495:lib/ff/ff.c   **** #define	DEF_NAMEBUF			BYTE sfn[12]
 496:lib/ff/ff.c   **** #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
 497:lib/ff/ff.c   **** #define	FREE_BUF()
 498:lib/ff/ff.c   **** 
 499:lib/ff/ff.c   **** #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
 500:lib/ff/ff.c   **** #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
 501:lib/ff/ff.c   **** #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
 502:lib/ff/ff.c   **** #define	FREE_BUF()
 503:lib/ff/ff.c   **** 
 504:lib/ff/ff.c   **** #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
 505:lib/ff/ff.c   **** #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
 506:lib/ff/ff.c   **** #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
 507:lib/ff/ff.c   **** 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
 508:lib/ff/ff.c   **** 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
 509:lib/ff/ff.c   **** #define	FREE_BUF()			ff_memfree(lfn)
 510:lib/ff/ff.c   **** 
 511:lib/ff/ff.c   **** #else
 512:lib/ff/ff.c   **** #error Wrong LFN configuration.
 513:lib/ff/ff.c   **** #endif
 514:lib/ff/ff.c   **** 
 515:lib/ff/ff.c   **** 
 516:lib/ff/ff.c   **** #ifdef _EXCVT
 517:lib/ff/ff.c   **** static
 518:lib/ff/ff.c   **** const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for extended chars */
 519:lib/ff/ff.c   **** #endif
 520:lib/ff/ff.c   **** 
 521:lib/ff/ff.c   **** 
 522:lib/ff/ff.c   **** 
 523:lib/ff/ff.c   **** 
 524:lib/ff/ff.c   **** 
 525:lib/ff/ff.c   **** 
 526:lib/ff/ff.c   **** /*--------------------------------------------------------------------------
 527:lib/ff/ff.c   **** 
 528:lib/ff/ff.c   ****    Module Private Functions
 529:lib/ff/ff.c   **** 
 530:lib/ff/ff.c   **** ---------------------------------------------------------------------------*/
 531:lib/ff/ff.c   **** 
 532:lib/ff/ff.c   **** 
 533:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 534:lib/ff/ff.c   **** /* String functions                                                      */
 535:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 536:lib/ff/ff.c   **** 
 537:lib/ff/ff.c   **** /* Copy memory to memory */
 538:lib/ff/ff.c   **** static
 539:lib/ff/ff.c   **** void mem_cpy (void* dst, const void* src, UINT cnt) {
  26              		.loc 1 539 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 10B5     		push	{r4, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 4, -8
  35              		.cfi_offset 14, -4
  36              	.LVL1:
 540:lib/ff/ff.c   **** 	BYTE *d = (BYTE*)dst;
 541:lib/ff/ff.c   **** 	const BYTE *s = (const BYTE*)src;
 542:lib/ff/ff.c   **** 
 543:lib/ff/ff.c   **** #if _WORD_ACCESS == 1
 544:lib/ff/ff.c   **** 	while (cnt >= sizeof (int)) {
  37              		.loc 1 544 0
  38 0002 0023     		movs	r3, #0
  39              	.LVL2:
  40              	.L2:
  41              		.loc 1 544 0 is_stmt 0 discriminator 1
  42 0004 D41A     		subs	r4, r2, r3
  43 0006 032C     		cmp	r4, #3
  44 0008 03D9     		bls	.L7
  45              	.L3:
 545:lib/ff/ff.c   **** 		*(int*)d = *(int*)s;
  46              		.loc 1 545 0 is_stmt 1
  47 000a CC58     		ldr	r4, [r1, r3]
  48 000c C450     		str	r4, [r0, r3]
  49 000e 0433     		adds	r3, r3, #4
  50 0010 F8E7     		b	.L2
  51              	.L7:
  52 0012 02F00304 		and	r4, r2, #3
 539:lib/ff/ff.c   **** 	BYTE *d = (BYTE*)dst;
  53              		.loc 1 539 0
  54 0016 22F00302 		bic	r2, r2, #3
  55 001a 8018     		adds	r0, r0, r2
  56              	.LVL3:
  57 001c 8A18     		adds	r2, r1, r2
  58 001e 0023     		movs	r3, #0
  59              	.LVL4:
  60              	.L4:
 546:lib/ff/ff.c   **** 		d += sizeof (int); s += sizeof (int);
 547:lib/ff/ff.c   **** 		cnt -= sizeof (int);
 548:lib/ff/ff.c   **** 	}
 549:lib/ff/ff.c   **** #endif
 550:lib/ff/ff.c   **** 	while (cnt--)
  61              		.loc 1 550 0 discriminator 1
  62 0020 A342     		cmp	r3, r4
  63 0022 03D0     		beq	.L8
  64              	.L5:
 551:lib/ff/ff.c   **** 		*d++ = *s++;
  65              		.loc 1 551 0
  66 0024 D15C     		ldrb	r1, [r2, r3]	@ zero_extendqisi2
  67 0026 C154     		strb	r1, [r0, r3]
  68 0028 0133     		adds	r3, r3, #1
  69 002a F9E7     		b	.L4
  70              	.L8:
 552:lib/ff/ff.c   **** }
  71              		.loc 1 552 0
  72 002c 10BD     		pop	{r4, pc}
  73              		.cfi_endproc
  74              	.LFE0:
  76              		.section	.text.mem_set,"ax",%progbits
  77              		.align	1
  78              		.thumb
  79              		.thumb_func
  81              	mem_set:
  82              	.LFB1:
 553:lib/ff/ff.c   **** 
 554:lib/ff/ff.c   **** /* Fill memory */
 555:lib/ff/ff.c   **** static
 556:lib/ff/ff.c   **** void mem_set (void* dst, int val, UINT cnt) {
  83              		.loc 1 556 0
  84              		.cfi_startproc
  85              		@ args = 0, pretend = 0, frame = 0
  86              		@ frame_needed = 0, uses_anonymous_args = 0
  87              		@ link register save eliminated.
  88              	.LVL5:
  89              	.LVL6:
  90              		.loc 1 556 0
  91 0000 8218     		adds	r2, r0, r2
  92              	.LVL7:
  93              	.L10:
 557:lib/ff/ff.c   **** 	BYTE *d = (BYTE*)dst;
 558:lib/ff/ff.c   **** 
 559:lib/ff/ff.c   **** 	while (cnt--)
  94              		.loc 1 559 0 discriminator 1
  95 0002 9042     		cmp	r0, r2
  96 0004 02D0     		beq	.L12
  97              	.L11:
 560:lib/ff/ff.c   **** 		*d++ = (BYTE)val;
  98              		.loc 1 560 0
  99 0006 00F8011B 		strb	r1, [r0], #1
 100              	.LVL8:
 101 000a FAE7     		b	.L10
 102              	.L12:
 561:lib/ff/ff.c   **** }
 103              		.loc 1 561 0
 104 000c 7047     		bx	lr
 105              		.cfi_endproc
 106              	.LFE1:
 108              		.section	.text.clmt_clust,"ax",%progbits
 109              		.align	1
 110              		.thumb
 111              		.thumb_func
 113              	clmt_clust:
 114              	.LFB12:
 562:lib/ff/ff.c   **** 
 563:lib/ff/ff.c   **** /* Compare memory to memory */
 564:lib/ff/ff.c   **** static
 565:lib/ff/ff.c   **** int mem_cmp (const void* dst, const void* src, UINT cnt) {
 566:lib/ff/ff.c   **** 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 567:lib/ff/ff.c   **** 	int r = 0;
 568:lib/ff/ff.c   **** 
 569:lib/ff/ff.c   **** 	while (cnt-- && (r = *d++ - *s++) == 0) ;
 570:lib/ff/ff.c   **** 	return r;
 571:lib/ff/ff.c   **** }
 572:lib/ff/ff.c   **** 
 573:lib/ff/ff.c   **** /* Check if chr is contained in the string */
 574:lib/ff/ff.c   **** static
 575:lib/ff/ff.c   **** int chk_chr (const char* str, int chr) {
 576:lib/ff/ff.c   **** 	while (*str && *str != chr) str++;
 577:lib/ff/ff.c   **** 	return *str;
 578:lib/ff/ff.c   **** }
 579:lib/ff/ff.c   **** 
 580:lib/ff/ff.c   **** 
 581:lib/ff/ff.c   **** 
 582:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 583:lib/ff/ff.c   **** /* Request/Release grant to access the volume                            */
 584:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 585:lib/ff/ff.c   **** #if _FS_REENTRANT
 586:lib/ff/ff.c   **** 
 587:lib/ff/ff.c   **** static
 588:lib/ff/ff.c   **** int lock_fs (
 589:lib/ff/ff.c   **** 	FATFS *fs		/* File system object */
 590:lib/ff/ff.c   **** )
 591:lib/ff/ff.c   **** {
 592:lib/ff/ff.c   **** 	return ff_req_grant(fs->sobj);
 593:lib/ff/ff.c   **** }
 594:lib/ff/ff.c   **** 
 595:lib/ff/ff.c   **** 
 596:lib/ff/ff.c   **** static
 597:lib/ff/ff.c   **** void unlock_fs (
 598:lib/ff/ff.c   **** 	FATFS *fs,		/* File system object */
 599:lib/ff/ff.c   **** 	FRESULT res		/* Result code to be returned */
 600:lib/ff/ff.c   **** )
 601:lib/ff/ff.c   **** {
 602:lib/ff/ff.c   **** 	if (fs &&
 603:lib/ff/ff.c   **** 		res != FR_NOT_ENABLED &&
 604:lib/ff/ff.c   **** 		res != FR_INVALID_DRIVE &&
 605:lib/ff/ff.c   **** 		res != FR_INVALID_OBJECT &&
 606:lib/ff/ff.c   **** 		res != FR_TIMEOUT) {
 607:lib/ff/ff.c   **** 		ff_rel_grant(fs->sobj);
 608:lib/ff/ff.c   **** 	}
 609:lib/ff/ff.c   **** }
 610:lib/ff/ff.c   **** #endif
 611:lib/ff/ff.c   **** 
 612:lib/ff/ff.c   **** 
 613:lib/ff/ff.c   **** 
 614:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 615:lib/ff/ff.c   **** /* File lock control functions                                           */
 616:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 617:lib/ff/ff.c   **** #if _FS_LOCK
 618:lib/ff/ff.c   **** 
 619:lib/ff/ff.c   **** static
 620:lib/ff/ff.c   **** FRESULT chk_lock (	/* Check if the file can be accessed */
 621:lib/ff/ff.c   **** 	DIR* dj,		/* Directory object pointing the file to be checked */
 622:lib/ff/ff.c   **** 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
 623:lib/ff/ff.c   **** )
 624:lib/ff/ff.c   **** {
 625:lib/ff/ff.c   **** 	UINT i, be;
 626:lib/ff/ff.c   **** 
 627:lib/ff/ff.c   **** 	/* Search file semaphore table */
 628:lib/ff/ff.c   **** 	for (i = be = 0; i < _FS_LOCK; i++) {
 629:lib/ff/ff.c   **** 		if (Files[i].fs) {	/* Existing entry */
 630:lib/ff/ff.c   **** 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
 631:lib/ff/ff.c   **** 				Files[i].clu == dj->sclust &&
 632:lib/ff/ff.c   **** 				Files[i].idx == dj->index) break;
 633:lib/ff/ff.c   **** 		} else {			/* Blank entry */
 634:lib/ff/ff.c   **** 			be++;
 635:lib/ff/ff.c   **** 		}
 636:lib/ff/ff.c   **** 	}
 637:lib/ff/ff.c   **** 	if (i == _FS_LOCK)	/* The file is not opened */
 638:lib/ff/ff.c   **** 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file?
 639:lib/ff/ff.c   **** 
 640:lib/ff/ff.c   **** 	/* The file has been opened. Reject any open against writing file and all write mode open */
 641:lib/ff/ff.c   **** 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 642:lib/ff/ff.c   **** }
 643:lib/ff/ff.c   **** 
 644:lib/ff/ff.c   **** 
 645:lib/ff/ff.c   **** static
 646:lib/ff/ff.c   **** int enq_lock (void)	/* Check if an entry is available for a new file */
 647:lib/ff/ff.c   **** {
 648:lib/ff/ff.c   **** 	UINT i;
 649:lib/ff/ff.c   **** 
 650:lib/ff/ff.c   **** 	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 651:lib/ff/ff.c   **** 	return (i == _FS_LOCK) ? 0 : 1;
 652:lib/ff/ff.c   **** }
 653:lib/ff/ff.c   **** 
 654:lib/ff/ff.c   **** 
 655:lib/ff/ff.c   **** static
 656:lib/ff/ff.c   **** UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
 657:lib/ff/ff.c   **** 	DIR* dj,	/* Directory object pointing the file to register or increment */
 658:lib/ff/ff.c   **** 	int acc		/* Desired access mode (0:Read, !0:Write) */
 659:lib/ff/ff.c   **** )
 660:lib/ff/ff.c   **** {
 661:lib/ff/ff.c   **** 	UINT i;
 662:lib/ff/ff.c   **** 
 663:lib/ff/ff.c   **** 
 664:lib/ff/ff.c   **** 	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
 665:lib/ff/ff.c   **** 		if (Files[i].fs == dj->fs &&
 666:lib/ff/ff.c   **** 			Files[i].clu == dj->sclust &&
 667:lib/ff/ff.c   **** 			Files[i].idx == dj->index) break;
 668:lib/ff/ff.c   **** 	}
 669:lib/ff/ff.c   **** 
 670:lib/ff/ff.c   **** 	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 671:lib/ff/ff.c   **** 		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 672:lib/ff/ff.c   **** 		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
 673:lib/ff/ff.c   **** 		Files[i].fs = dj->fs;
 674:lib/ff/ff.c   **** 		Files[i].clu = dj->sclust;
 675:lib/ff/ff.c   **** 		Files[i].idx = dj->index;
 676:lib/ff/ff.c   **** 		Files[i].ctr = 0;
 677:lib/ff/ff.c   **** 	}
 678:lib/ff/ff.c   **** 
 679:lib/ff/ff.c   **** 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 680:lib/ff/ff.c   **** 
 681:lib/ff/ff.c   **** 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 682:lib/ff/ff.c   **** 
 683:lib/ff/ff.c   **** 	return i + 1;
 684:lib/ff/ff.c   **** }
 685:lib/ff/ff.c   **** 
 686:lib/ff/ff.c   **** 
 687:lib/ff/ff.c   **** static
 688:lib/ff/ff.c   **** FRESULT dec_lock (	/* Decrement file open counter */
 689:lib/ff/ff.c   **** 	UINT i			/* Semaphore index */
 690:lib/ff/ff.c   **** )
 691:lib/ff/ff.c   **** {
 692:lib/ff/ff.c   **** 	WORD n;
 693:lib/ff/ff.c   **** 	FRESULT res;
 694:lib/ff/ff.c   **** 
 695:lib/ff/ff.c   **** 
 696:lib/ff/ff.c   **** 	if (--i < _FS_LOCK) {
 697:lib/ff/ff.c   **** 		n = Files[i].ctr;
 698:lib/ff/ff.c   **** 		if (n == 0x100) n = 0;
 699:lib/ff/ff.c   **** 		if (n) n--;
 700:lib/ff/ff.c   **** 		Files[i].ctr = n;
 701:lib/ff/ff.c   **** 		if (!n) Files[i].fs = 0;
 702:lib/ff/ff.c   **** 		res = FR_OK;
 703:lib/ff/ff.c   **** 	} else {
 704:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 705:lib/ff/ff.c   **** 	}
 706:lib/ff/ff.c   **** 	return res;
 707:lib/ff/ff.c   **** }
 708:lib/ff/ff.c   **** 
 709:lib/ff/ff.c   **** 
 710:lib/ff/ff.c   **** static
 711:lib/ff/ff.c   **** void clear_lock (	/* Clear lock entries of the volume */
 712:lib/ff/ff.c   **** 	FATFS *fs
 713:lib/ff/ff.c   **** )
 714:lib/ff/ff.c   **** {
 715:lib/ff/ff.c   **** 	UINT i;
 716:lib/ff/ff.c   **** 
 717:lib/ff/ff.c   **** 	for (i = 0; i < _FS_LOCK; i++) {
 718:lib/ff/ff.c   **** 		if (Files[i].fs == fs) Files[i].fs = 0;
 719:lib/ff/ff.c   **** 	}
 720:lib/ff/ff.c   **** }
 721:lib/ff/ff.c   **** #endif
 722:lib/ff/ff.c   **** 
 723:lib/ff/ff.c   **** 
 724:lib/ff/ff.c   **** 
 725:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 726:lib/ff/ff.c   **** /* Move/Flush disk access window                                         */
 727:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 728:lib/ff/ff.c   **** 
 729:lib/ff/ff.c   **** 
 730:lib/ff/ff.c   **** #if !_FS_READONLY
 731:lib/ff/ff.c   **** static
 732:lib/ff/ff.c   **** FRESULT sync_window (
 733:lib/ff/ff.c   **** 	FATFS *fs		/* File system object */
 734:lib/ff/ff.c   **** )
 735:lib/ff/ff.c   **** {
 736:lib/ff/ff.c   **** 	DWORD wsect;
 737:lib/ff/ff.c   **** 	UINT nf;
 738:lib/ff/ff.c   **** 
 739:lib/ff/ff.c   **** 	
 740:lib/ff/ff.c   **** 	if (fs->wflag) {	/* Write back the sector if it is dirty */
 741:lib/ff/ff.c   **** 		wsect = fs->winsect;	/* Current sector number */
 742:lib/ff/ff.c   **** 		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 743:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 744:lib/ff/ff.c   **** 		fs->wflag = 0;
 745:lib/ff/ff.c   **** 		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 746:lib/ff/ff.c   **** 			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 747:lib/ff/ff.c   **** 				wsect += fs->fsize;
 748:lib/ff/ff.c   **** 				disk_write(fs->drv, fs->win, wsect, 1);
 749:lib/ff/ff.c   **** 			}
 750:lib/ff/ff.c   **** 		}
 751:lib/ff/ff.c   **** 	}
 752:lib/ff/ff.c   **** 	return FR_OK;
 753:lib/ff/ff.c   **** }
 754:lib/ff/ff.c   **** #endif
 755:lib/ff/ff.c   **** 
 756:lib/ff/ff.c   **** 
 757:lib/ff/ff.c   **** static
 758:lib/ff/ff.c   **** FRESULT move_window (
 759:lib/ff/ff.c   **** 	FATFS *fs,		/* File system object */
 760:lib/ff/ff.c   **** 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
 761:lib/ff/ff.c   **** )
 762:lib/ff/ff.c   **** {
 763:lib/ff/ff.c   **** 	if (sector != fs->winsect) {	/* Changed current window */
 764:lib/ff/ff.c   **** #if !_FS_READONLY
 765:lib/ff/ff.c   **** 		if (sync_window(fs) != FR_OK)
 766:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 767:lib/ff/ff.c   **** #endif
 768:lib/ff/ff.c   **** 		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 769:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 770:lib/ff/ff.c   **** 		fs->winsect = sector;
 771:lib/ff/ff.c   **** 	}
 772:lib/ff/ff.c   **** 
 773:lib/ff/ff.c   **** 	return FR_OK;
 774:lib/ff/ff.c   **** }
 775:lib/ff/ff.c   **** 
 776:lib/ff/ff.c   **** 
 777:lib/ff/ff.c   **** 
 778:lib/ff/ff.c   **** 
 779:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 780:lib/ff/ff.c   **** /* Synchronize file system and strage device                             */
 781:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 782:lib/ff/ff.c   **** #if !_FS_READONLY
 783:lib/ff/ff.c   **** static
 784:lib/ff/ff.c   **** FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
 785:lib/ff/ff.c   **** 	FATFS *fs		/* File system object */
 786:lib/ff/ff.c   **** )
 787:lib/ff/ff.c   **** {
 788:lib/ff/ff.c   **** 	FRESULT res;
 789:lib/ff/ff.c   **** 
 790:lib/ff/ff.c   **** 
 791:lib/ff/ff.c   **** 	res = sync_window(fs);
 792:lib/ff/ff.c   **** 	if (res == FR_OK) {
 793:lib/ff/ff.c   **** 		/* Update FSInfo sector if needed */
 794:lib/ff/ff.c   **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 795:lib/ff/ff.c   **** 			fs->winsect = 0;
 796:lib/ff/ff.c   **** 			/* Create FSInfo structure */
 797:lib/ff/ff.c   **** 			mem_set(fs->win, 0, 512);
 798:lib/ff/ff.c   **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);
 799:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 800:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 801:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 802:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 803:lib/ff/ff.c   **** 			/* Write it into the FSInfo sector */
 804:lib/ff/ff.c   **** 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
 805:lib/ff/ff.c   **** 			fs->fsi_flag = 0;
 806:lib/ff/ff.c   **** 		}
 807:lib/ff/ff.c   **** 		/* Make sure that no pending write process in the physical drive */
 808:lib/ff/ff.c   **** 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 809:lib/ff/ff.c   **** 			res = FR_DISK_ERR;
 810:lib/ff/ff.c   **** 	}
 811:lib/ff/ff.c   **** 
 812:lib/ff/ff.c   **** 	return res;
 813:lib/ff/ff.c   **** }
 814:lib/ff/ff.c   **** #endif
 815:lib/ff/ff.c   **** 
 816:lib/ff/ff.c   **** 
 817:lib/ff/ff.c   **** 
 818:lib/ff/ff.c   **** 
 819:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 820:lib/ff/ff.c   **** /* Get sector# from cluster#                                             */
 821:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 822:lib/ff/ff.c   **** 
 823:lib/ff/ff.c   **** 
 824:lib/ff/ff.c   **** DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
 825:lib/ff/ff.c   **** 	FATFS *fs,		/* File system object */
 826:lib/ff/ff.c   **** 	DWORD clst		/* Cluster# to be converted */
 827:lib/ff/ff.c   **** )
 828:lib/ff/ff.c   **** {
 829:lib/ff/ff.c   **** 	clst -= 2;
 830:lib/ff/ff.c   **** 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 831:lib/ff/ff.c   **** 	return clst * fs->csize + fs->database;
 832:lib/ff/ff.c   **** }
 833:lib/ff/ff.c   **** 
 834:lib/ff/ff.c   **** 
 835:lib/ff/ff.c   **** 
 836:lib/ff/ff.c   **** 
 837:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 838:lib/ff/ff.c   **** /* FAT access - Read value of a FAT entry                                */
 839:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 840:lib/ff/ff.c   **** 
 841:lib/ff/ff.c   **** 
 842:lib/ff/ff.c   **** DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
 843:lib/ff/ff.c   **** 	FATFS *fs,	/* File system object */
 844:lib/ff/ff.c   **** 	DWORD clst	/* Cluster# to get the link information */
 845:lib/ff/ff.c   **** )
 846:lib/ff/ff.c   **** {
 847:lib/ff/ff.c   **** 	UINT wc, bc;
 848:lib/ff/ff.c   **** 	BYTE *p;
 849:lib/ff/ff.c   **** 
 850:lib/ff/ff.c   **** 
 851:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 852:lib/ff/ff.c   **** 		return 1;
 853:lib/ff/ff.c   **** 
 854:lib/ff/ff.c   **** 	switch (fs->fs_type) {
 855:lib/ff/ff.c   **** 	case FS_FAT12 :
 856:lib/ff/ff.c   **** 		bc = (UINT)clst; bc += bc / 2;
 857:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 858:lib/ff/ff.c   **** 		wc = fs->win[bc % SS(fs)]; bc++;
 859:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 860:lib/ff/ff.c   **** 		wc |= fs->win[bc % SS(fs)] << 8;
 861:lib/ff/ff.c   **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 862:lib/ff/ff.c   **** 
 863:lib/ff/ff.c   **** 	case FS_FAT16 :
 864:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 865:lib/ff/ff.c   **** 		p = &fs->win[clst * 2 % SS(fs)];
 866:lib/ff/ff.c   **** 		return LD_WORD(p);
 867:lib/ff/ff.c   **** 
 868:lib/ff/ff.c   **** 	case FS_FAT32 :
 869:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 870:lib/ff/ff.c   **** 		p = &fs->win[clst * 4 % SS(fs)];
 871:lib/ff/ff.c   **** 		return LD_DWORD(p) & 0x0FFFFFFF;
 872:lib/ff/ff.c   **** 	}
 873:lib/ff/ff.c   **** 
 874:lib/ff/ff.c   **** 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 875:lib/ff/ff.c   **** }
 876:lib/ff/ff.c   **** 
 877:lib/ff/ff.c   **** 
 878:lib/ff/ff.c   **** 
 879:lib/ff/ff.c   **** 
 880:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 881:lib/ff/ff.c   **** /* FAT access - Change value of a FAT entry                              */
 882:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 883:lib/ff/ff.c   **** #if !_FS_READONLY
 884:lib/ff/ff.c   **** 
 885:lib/ff/ff.c   **** FRESULT put_fat (
 886:lib/ff/ff.c   **** 	FATFS *fs,	/* File system object */
 887:lib/ff/ff.c   **** 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
 888:lib/ff/ff.c   **** 	DWORD val	/* New value to mark the cluster */
 889:lib/ff/ff.c   **** )
 890:lib/ff/ff.c   **** {
 891:lib/ff/ff.c   **** 	UINT bc;
 892:lib/ff/ff.c   **** 	BYTE *p;
 893:lib/ff/ff.c   **** 	FRESULT res;
 894:lib/ff/ff.c   **** 
 895:lib/ff/ff.c   **** 
 896:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 897:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 898:lib/ff/ff.c   **** 
 899:lib/ff/ff.c   **** 	} else {
 900:lib/ff/ff.c   **** 		switch (fs->fs_type) {
 901:lib/ff/ff.c   **** 		case FS_FAT12 :
 902:lib/ff/ff.c   **** 			bc = (UINT)clst; bc += bc / 2;
 903:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 904:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 905:lib/ff/ff.c   **** 			p = &fs->win[bc % SS(fs)];
 906:lib/ff/ff.c   **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 907:lib/ff/ff.c   **** 			bc++;
 908:lib/ff/ff.c   **** 			fs->wflag = 1;
 909:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 910:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 911:lib/ff/ff.c   **** 			p = &fs->win[bc % SS(fs)];
 912:lib/ff/ff.c   **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 913:lib/ff/ff.c   **** 			break;
 914:lib/ff/ff.c   **** 
 915:lib/ff/ff.c   **** 		case FS_FAT16 :
 916:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 917:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 918:lib/ff/ff.c   **** 			p = &fs->win[clst * 2 % SS(fs)];
 919:lib/ff/ff.c   **** 			ST_WORD(p, (WORD)val);
 920:lib/ff/ff.c   **** 			break;
 921:lib/ff/ff.c   **** 
 922:lib/ff/ff.c   **** 		case FS_FAT32 :
 923:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 924:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 925:lib/ff/ff.c   **** 			p = &fs->win[clst * 4 % SS(fs)];
 926:lib/ff/ff.c   **** 			val |= LD_DWORD(p) & 0xF0000000;
 927:lib/ff/ff.c   **** 			ST_DWORD(p, val);
 928:lib/ff/ff.c   **** 			break;
 929:lib/ff/ff.c   **** 
 930:lib/ff/ff.c   **** 		default :
 931:lib/ff/ff.c   **** 			res = FR_INT_ERR;
 932:lib/ff/ff.c   **** 		}
 933:lib/ff/ff.c   **** 		fs->wflag = 1;
 934:lib/ff/ff.c   **** 	}
 935:lib/ff/ff.c   **** 
 936:lib/ff/ff.c   **** 	return res;
 937:lib/ff/ff.c   **** }
 938:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
 939:lib/ff/ff.c   **** 
 940:lib/ff/ff.c   **** 
 941:lib/ff/ff.c   **** 
 942:lib/ff/ff.c   **** 
 943:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 944:lib/ff/ff.c   **** /* FAT handling - Remove a cluster chain                                 */
 945:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 946:lib/ff/ff.c   **** #if !_FS_READONLY
 947:lib/ff/ff.c   **** static
 948:lib/ff/ff.c   **** FRESULT remove_chain (
 949:lib/ff/ff.c   **** 	FATFS *fs,			/* File system object */
 950:lib/ff/ff.c   **** 	DWORD clst			/* Cluster# to remove a chain from */
 951:lib/ff/ff.c   **** )
 952:lib/ff/ff.c   **** {
 953:lib/ff/ff.c   **** 	FRESULT res;
 954:lib/ff/ff.c   **** 	DWORD nxt;
 955:lib/ff/ff.c   **** #if _USE_ERASE
 956:lib/ff/ff.c   **** 	DWORD scl = clst, ecl = clst, rt[2];
 957:lib/ff/ff.c   **** #endif
 958:lib/ff/ff.c   **** 
 959:lib/ff/ff.c   **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 960:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 961:lib/ff/ff.c   **** 
 962:lib/ff/ff.c   **** 	} else {
 963:lib/ff/ff.c   **** 		res = FR_OK;
 964:lib/ff/ff.c   **** 		while (clst < fs->n_fatent) {			/* Not a last link? */
 965:lib/ff/ff.c   **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 966:lib/ff/ff.c   **** 			if (nxt == 0) break;				/* Empty cluster? */
 967:lib/ff/ff.c   **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 968:lib/ff/ff.c   **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 969:lib/ff/ff.c   **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 970:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 971:lib/ff/ff.c   **** 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 972:lib/ff/ff.c   **** 				fs->free_clust++;
 973:lib/ff/ff.c   **** 				fs->fsi_flag = 1;
 974:lib/ff/ff.c   **** 			}
 975:lib/ff/ff.c   **** #if _USE_ERASE
 976:lib/ff/ff.c   **** 			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
 977:lib/ff/ff.c   **** 				ecl = nxt;
 978:lib/ff/ff.c   **** 			} else {				/* End of contiguous clusters */ 
 979:lib/ff/ff.c   **** 				rt[0] = clust2sect(fs, scl);					/* Start sector */
 980:lib/ff/ff.c   **** 				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
 981:lib/ff/ff.c   **** 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
 982:lib/ff/ff.c   **** 				scl = ecl = nxt;
 983:lib/ff/ff.c   **** 			}
 984:lib/ff/ff.c   **** #endif
 985:lib/ff/ff.c   **** 			clst = nxt;	/* Next cluster */
 986:lib/ff/ff.c   **** 		}
 987:lib/ff/ff.c   **** 	}
 988:lib/ff/ff.c   **** 
 989:lib/ff/ff.c   **** 	return res;
 990:lib/ff/ff.c   **** }
 991:lib/ff/ff.c   **** #endif
 992:lib/ff/ff.c   **** 
 993:lib/ff/ff.c   **** 
 994:lib/ff/ff.c   **** 
 995:lib/ff/ff.c   **** 
 996:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 997:lib/ff/ff.c   **** /* FAT handling - Stretch or Create a cluster chain                      */
 998:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
 999:lib/ff/ff.c   **** #if !_FS_READONLY
1000:lib/ff/ff.c   **** static
1001:lib/ff/ff.c   **** DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster
1002:lib/ff/ff.c   **** 	FATFS *fs,			/* File system object */
1003:lib/ff/ff.c   **** 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
1004:lib/ff/ff.c   **** )
1005:lib/ff/ff.c   **** {
1006:lib/ff/ff.c   **** 	DWORD cs, ncl, scl;
1007:lib/ff/ff.c   **** 	FRESULT res;
1008:lib/ff/ff.c   **** 
1009:lib/ff/ff.c   **** 
1010:lib/ff/ff.c   **** 	if (clst == 0) {		/* Create a new chain */
1011:lib/ff/ff.c   **** 		scl = fs->last_clust;			/* Get suggested start point */
1012:lib/ff/ff.c   **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
1013:lib/ff/ff.c   **** 	}
1014:lib/ff/ff.c   **** 	else {					/* Stretch the current chain */
1015:lib/ff/ff.c   **** 		cs = get_fat(fs, clst);			/* Check the cluster status */
1016:lib/ff/ff.c   **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
1017:lib/ff/ff.c   **** 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
1018:lib/ff/ff.c   **** 		scl = clst;
1019:lib/ff/ff.c   **** 	}
1020:lib/ff/ff.c   **** 
1021:lib/ff/ff.c   **** 	ncl = scl;				/* Start cluster */
1022:lib/ff/ff.c   **** 	for (;;) {
1023:lib/ff/ff.c   **** 		ncl++;							/* Next cluster */
1024:lib/ff/ff.c   **** 		if (ncl >= fs->n_fatent) {		/* Wrap around */
1025:lib/ff/ff.c   **** 			ncl = 2;
1026:lib/ff/ff.c   **** 			if (ncl > scl) return 0;	/* No free cluster */
1027:lib/ff/ff.c   **** 		}
1028:lib/ff/ff.c   **** 		cs = get_fat(fs, ncl);			/* Get the cluster status */
1029:lib/ff/ff.c   **** 		if (cs == 0) break;				/* Found a free cluster */
1030:lib/ff/ff.c   **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
1031:lib/ff/ff.c   **** 			return cs;
1032:lib/ff/ff.c   **** 		if (ncl == scl) return 0;		/* No free cluster */
1033:lib/ff/ff.c   **** 	}
1034:lib/ff/ff.c   **** 
1035:lib/ff/ff.c   **** 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
1036:lib/ff/ff.c   **** 	if (res == FR_OK && clst != 0) {
1037:lib/ff/ff.c   **** 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
1038:lib/ff/ff.c   **** 	}
1039:lib/ff/ff.c   **** 	if (res == FR_OK) {
1040:lib/ff/ff.c   **** 		fs->last_clust = ncl;			/* Update FSINFO */
1041:lib/ff/ff.c   **** 		if (fs->free_clust != 0xFFFFFFFF) {
1042:lib/ff/ff.c   **** 			fs->free_clust--;
1043:lib/ff/ff.c   **** 			fs->fsi_flag = 1;
1044:lib/ff/ff.c   **** 		}
1045:lib/ff/ff.c   **** 	} else {
1046:lib/ff/ff.c   **** 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
1047:lib/ff/ff.c   **** 	}
1048:lib/ff/ff.c   **** 
1049:lib/ff/ff.c   **** 	return ncl;		/* Return new cluster number or error code */
1050:lib/ff/ff.c   **** }
1051:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
1052:lib/ff/ff.c   **** 
1053:lib/ff/ff.c   **** 
1054:lib/ff/ff.c   **** 
1055:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1056:lib/ff/ff.c   **** /* FAT handling - Convert offset into cluster with link map table        */
1057:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1058:lib/ff/ff.c   **** 
1059:lib/ff/ff.c   **** #if _USE_FASTSEEK
1060:lib/ff/ff.c   **** static
1061:lib/ff/ff.c   **** DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
1062:lib/ff/ff.c   **** 	FIL* fp,		/* Pointer to the file object */
1063:lib/ff/ff.c   **** 	DWORD ofs		/* File offset to be converted to cluster# */
1064:lib/ff/ff.c   **** )
1065:lib/ff/ff.c   **** {
 115              		.loc 1 1065 0
 116              		.cfi_startproc
 117              		@ args = 0, pretend = 0, frame = 0
 118              		@ frame_needed = 0, uses_anonymous_args = 0
 119              		@ link register save eliminated.
 120              	.LVL9:
1066:lib/ff/ff.c   **** 	DWORD cl, ncl, *tbl;
1067:lib/ff/ff.c   **** 
1068:lib/ff/ff.c   **** 
1069:lib/ff/ff.c   **** 	tbl = fp->cltbl + 1;	/* Top of CLMT */
 121              		.loc 1 1069 0
 122 0000 436A     		ldr	r3, [r0, #36]
 123 0002 0433     		adds	r3, r3, #4
 124              	.LVL10:
1070:lib/ff/ff.c   **** 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
 125              		.loc 1 1070 0
 126 0004 490A     		lsrs	r1, r1, #9
 127              	.LVL11:
 128 0006 0268     		ldr	r2, [r0, #0]
 129 0008 9078     		ldrb	r0, [r2, #2]	@ zero_extendqisi2
 130              	.LVL12:
 131 000a B1FBF0F1 		udiv	r1, r1, r0
 132              	.LVL13:
 133              	.L16:
1071:lib/ff/ff.c   **** 	for (;;) {
1072:lib/ff/ff.c   **** 		ncl = *tbl++;			/* Number of cluters in the fragment */
 134              		.loc 1 1072 0
 135 000e 1868     		ldr	r0, [r3, #0]
 136              	.LVL14:
1073:lib/ff/ff.c   **** 		if (!ncl) return 0;		/* End of table? (error) */
 137              		.loc 1 1073 0
 138 0010 30B1     		cbz	r0, .L14
1074:lib/ff/ff.c   **** 		if (cl < ncl) break;	/* In this fragment? */
 139              		.loc 1 1074 0
 140 0012 8142     		cmp	r1, r0
 141 0014 02D3     		bcc	.L15
1075:lib/ff/ff.c   **** 		cl -= ncl; tbl++;		/* Next fragment */
 142              		.loc 1 1075 0
 143 0016 091A     		subs	r1, r1, r0
 144              	.LVL15:
1061:lib/ff/ff.c   **** 	FIL* fp,		/* Pointer to the file object */
 145              		.loc 1 1061 0
 146 0018 0833     		adds	r3, r3, #8
 147              	.LVL16:
1076:lib/ff/ff.c   **** 	}
 148              		.loc 1 1076 0
 149 001a F8E7     		b	.L16
 150              	.LVL17:
 151              	.L15:
1077:lib/ff/ff.c   **** 	return cl + *tbl;	/* Return the cluster number */
 152              		.loc 1 1077 0
 153 001c 5B68     		ldr	r3, [r3, #4]
 154              	.LVL18:
 155 001e C818     		adds	r0, r1, r3
 156              	.LVL19:
 157              	.L14:
1078:lib/ff/ff.c   **** }
 158              		.loc 1 1078 0
 159 0020 7047     		bx	lr
 160              		.cfi_endproc
 161              	.LFE12:
 163              		.section	.text.get_fileinfo,"ax",%progbits
 164              		.align	1
 165              		.thumb
 166              		.thumb_func
 168              	get_fileinfo:
 169              	.LFB23:
1079:lib/ff/ff.c   **** #endif	/* _USE_FASTSEEK */
1080:lib/ff/ff.c   **** 
1081:lib/ff/ff.c   **** 
1082:lib/ff/ff.c   **** 
1083:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1084:lib/ff/ff.c   **** /* Directory handling - Set directory index                              */
1085:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1086:lib/ff/ff.c   **** 
1087:lib/ff/ff.c   **** static
1088:lib/ff/ff.c   **** FRESULT dir_sdi (
1089:lib/ff/ff.c   **** 	DIR *dj,		/* Pointer to directory object */
1090:lib/ff/ff.c   **** 	WORD idx		/* Index of directory table */
1091:lib/ff/ff.c   **** )
1092:lib/ff/ff.c   **** {
1093:lib/ff/ff.c   **** 	DWORD clst;
1094:lib/ff/ff.c   **** 	WORD ic;
1095:lib/ff/ff.c   **** 
1096:lib/ff/ff.c   **** 
1097:lib/ff/ff.c   **** 	dj->index = idx;
1098:lib/ff/ff.c   **** 	clst = dj->sclust;
1099:lib/ff/ff.c   **** 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
1100:lib/ff/ff.c   **** 		return FR_INT_ERR;
1101:lib/ff/ff.c   **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
1102:lib/ff/ff.c   **** 		clst = dj->fs->dirbase;
1103:lib/ff/ff.c   **** 
1104:lib/ff/ff.c   **** 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
1105:lib/ff/ff.c   **** 		dj->clust = clst;
1106:lib/ff/ff.c   **** 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
1107:lib/ff/ff.c   **** 			return FR_INT_ERR;
1108:lib/ff/ff.c   **** 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
1109:lib/ff/ff.c   **** 	}
1110:lib/ff/ff.c   **** 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
1111:lib/ff/ff.c   **** 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
1112:lib/ff/ff.c   **** 		while (idx >= ic) {	/* Follow cluster chain */
1113:lib/ff/ff.c   **** 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
1114:lib/ff/ff.c   **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
1115:lib/ff/ff.c   **** 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
1116:lib/ff/ff.c   **** 				return FR_INT_ERR;
1117:lib/ff/ff.c   **** 			idx -= ic;
1118:lib/ff/ff.c   **** 		}
1119:lib/ff/ff.c   **** 		dj->clust = clst;
1120:lib/ff/ff.c   **** 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
1121:lib/ff/ff.c   **** 	}
1122:lib/ff/ff.c   **** 
1123:lib/ff/ff.c   **** 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector 
1124:lib/ff/ff.c   **** 
1125:lib/ff/ff.c   **** 	return FR_OK;	/* Seek succeeded */
1126:lib/ff/ff.c   **** }
1127:lib/ff/ff.c   **** 
1128:lib/ff/ff.c   **** 
1129:lib/ff/ff.c   **** 
1130:lib/ff/ff.c   **** 
1131:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1132:lib/ff/ff.c   **** /* Directory handling - Move directory table index next                  */
1133:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1134:lib/ff/ff.c   **** 
1135:lib/ff/ff.c   **** static
1136:lib/ff/ff.c   **** FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
1137:lib/ff/ff.c   **** 	DIR *dj,		/* Pointer to the directory object */
1138:lib/ff/ff.c   **** 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
1139:lib/ff/ff.c   **** )
1140:lib/ff/ff.c   **** {
1141:lib/ff/ff.c   **** 	DWORD clst;
1142:lib/ff/ff.c   **** 	WORD i;
1143:lib/ff/ff.c   **** 
1144:lib/ff/ff.c   **** 
1145:lib/ff/ff.c   **** 	stretch = stretch;		/* To suppress warning on read-only cfg. */
1146:lib/ff/ff.c   **** 	i = dj->index + 1;
1147:lib/ff/ff.c   **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
1148:lib/ff/ff.c   **** 		return FR_NO_FILE;
1149:lib/ff/ff.c   **** 
1150:lib/ff/ff.c   **** 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
1151:lib/ff/ff.c   **** 		dj->sect++;					/* Next sector */
1152:lib/ff/ff.c   **** 
1153:lib/ff/ff.c   **** 		if (dj->clust == 0) {	/* Static table */
1154:lib/ff/ff.c   **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
1155:lib/ff/ff.c   **** 				return FR_NO_FILE;
1156:lib/ff/ff.c   **** 		}
1157:lib/ff/ff.c   **** 		else {					/* Dynamic table */
1158:lib/ff/ff.c   **** 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
1159:lib/ff/ff.c   **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
1160:lib/ff/ff.c   **** 				if (clst <= 1) return FR_INT_ERR;
1161:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
1162:lib/ff/ff.c   **** 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
1163:lib/ff/ff.c   **** #if !_FS_READONLY
1164:lib/ff/ff.c   **** 					BYTE c;
1165:lib/ff/ff.c   **** 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
1166:lib/ff/ff.c   **** 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
1167:lib/ff/ff.c   **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
1168:lib/ff/ff.c   **** 					if (clst == 1) return FR_INT_ERR;
1169:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
1170:lib/ff/ff.c   **** 					/* Clean-up stretched table */
1171:lib/ff/ff.c   **** 					if (sync_window(dj->fs)) return FR_DISK_ERR;	/* Flush active window */
1172:lib/ff/ff.c   **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
1173:lib/ff/ff.c   **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
1174:lib/ff/ff.c   **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
1175:lib/ff/ff.c   **** 						dj->fs->wflag = 1;
1176:lib/ff/ff.c   **** 						if (sync_window(dj->fs)) return FR_DISK_ERR;
1177:lib/ff/ff.c   **** 						dj->fs->winsect++;
1178:lib/ff/ff.c   **** 					}
1179:lib/ff/ff.c   **** 					dj->fs->winsect -= c;						/* Rewind window address */
1180:lib/ff/ff.c   **** #else
1181:lib/ff/ff.c   **** 					return FR_NO_FILE;			/* Report EOT */
1182:lib/ff/ff.c   **** #endif
1183:lib/ff/ff.c   **** 				}
1184:lib/ff/ff.c   **** 				dj->clust = clst;				/* Initialize data for new cluster */
1185:lib/ff/ff.c   **** 				dj->sect = clust2sect(dj->fs, clst);
1186:lib/ff/ff.c   **** 			}
1187:lib/ff/ff.c   **** 		}
1188:lib/ff/ff.c   **** 	}
1189:lib/ff/ff.c   **** 
1190:lib/ff/ff.c   **** 	dj->index = i;
1191:lib/ff/ff.c   **** 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
1192:lib/ff/ff.c   **** 
1193:lib/ff/ff.c   **** 	return FR_OK;
1194:lib/ff/ff.c   **** }
1195:lib/ff/ff.c   **** 
1196:lib/ff/ff.c   **** 
1197:lib/ff/ff.c   **** 
1198:lib/ff/ff.c   **** 
1199:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1200:lib/ff/ff.c   **** /* Directory handling - Reserve directory entry                          */
1201:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1202:lib/ff/ff.c   **** 
1203:lib/ff/ff.c   **** #if !_FS_READONLY
1204:lib/ff/ff.c   **** static
1205:lib/ff/ff.c   **** FRESULT dir_alloc (
1206:lib/ff/ff.c   **** 	DIR* dj,	/* Pointer to the directory object */
1207:lib/ff/ff.c   **** 	UINT nent	/* Number of contiguous entries to allocate (1-21) */
1208:lib/ff/ff.c   **** )
1209:lib/ff/ff.c   **** {
1210:lib/ff/ff.c   **** 	FRESULT res;
1211:lib/ff/ff.c   **** 	UINT n;
1212:lib/ff/ff.c   **** 
1213:lib/ff/ff.c   **** 
1214:lib/ff/ff.c   **** 	res = dir_sdi(dj, 0);
1215:lib/ff/ff.c   **** 	if (res == FR_OK) {
1216:lib/ff/ff.c   **** 		n = 0;
1217:lib/ff/ff.c   **** 		do {
1218:lib/ff/ff.c   **** 			res = move_window(dj->fs, dj->sect);
1219:lib/ff/ff.c   **** 			if (res != FR_OK) break;
1220:lib/ff/ff.c   **** 			if (dj->dir[0] == DDE || dj->dir[0] == 0) {	/* Is it a blank entry? */
1221:lib/ff/ff.c   **** 				if (++n == nent) break;	/* A block of contiguous entry is found */
1222:lib/ff/ff.c   **** 			} else {
1223:lib/ff/ff.c   **** 				n = 0;					/* Not a blank entry. Restart to search */
1224:lib/ff/ff.c   **** 			}
1225:lib/ff/ff.c   **** 			res = dir_next(dj, 1);		/* Next entry with table stretch enabled */
1226:lib/ff/ff.c   **** 		} while (res == FR_OK);
1227:lib/ff/ff.c   **** 	}
1228:lib/ff/ff.c   ****     if (res == FR_NO_FILE) res = FR_DENIED;
1229:lib/ff/ff.c   ****     return res;
1230:lib/ff/ff.c   **** }
1231:lib/ff/ff.c   **** #endif
1232:lib/ff/ff.c   **** 
1233:lib/ff/ff.c   **** 
1234:lib/ff/ff.c   **** 
1235:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1236:lib/ff/ff.c   **** /* Directory handling - Load/Store start cluster number                  */
1237:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1238:lib/ff/ff.c   **** 
1239:lib/ff/ff.c   **** static
1240:lib/ff/ff.c   **** DWORD ld_clust (
1241:lib/ff/ff.c   **** 	FATFS *fs,	/* Pointer to the fs object */
1242:lib/ff/ff.c   **** 	BYTE *dir	/* Pointer to the directory entry */
1243:lib/ff/ff.c   **** )
1244:lib/ff/ff.c   **** {
1245:lib/ff/ff.c   **** 	DWORD cl;
1246:lib/ff/ff.c   **** 
1247:lib/ff/ff.c   **** 	cl = LD_WORD(dir+DIR_FstClusLO);
1248:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
1249:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
1250:lib/ff/ff.c   **** 
1251:lib/ff/ff.c   **** 	return cl;
1252:lib/ff/ff.c   **** }
1253:lib/ff/ff.c   **** 
1254:lib/ff/ff.c   **** 
1255:lib/ff/ff.c   **** #if !_FS_READONLY
1256:lib/ff/ff.c   **** static
1257:lib/ff/ff.c   **** void st_clust (
1258:lib/ff/ff.c   **** 	BYTE *dir,	/* Pointer to the directory entry */
1259:lib/ff/ff.c   **** 	DWORD cl	/* Value to be set */
1260:lib/ff/ff.c   **** )
1261:lib/ff/ff.c   **** {
1262:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusLO, cl);
1263:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
1264:lib/ff/ff.c   **** }
1265:lib/ff/ff.c   **** #endif
1266:lib/ff/ff.c   **** 
1267:lib/ff/ff.c   **** 
1268:lib/ff/ff.c   **** 
1269:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1270:lib/ff/ff.c   **** /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1271:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1272:lib/ff/ff.c   **** #if _USE_LFN
1273:lib/ff/ff.c   **** static
1274:lib/ff/ff.c   **** const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory 
1275:lib/ff/ff.c   **** 
1276:lib/ff/ff.c   **** 
1277:lib/ff/ff.c   **** static
1278:lib/ff/ff.c   **** int cmp_lfn (			/* 1:Matched, 0:Not matched */
1279:lib/ff/ff.c   **** 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
1280:lib/ff/ff.c   **** 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
1281:lib/ff/ff.c   **** )
1282:lib/ff/ff.c   **** {
1283:lib/ff/ff.c   **** 	UINT i, s;
1284:lib/ff/ff.c   **** 	WCHAR wc, uc;
1285:lib/ff/ff.c   **** 
1286:lib/ff/ff.c   **** 
1287:lib/ff/ff.c   **** 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
1288:lib/ff/ff.c   **** 	s = 0; wc = 1;
1289:lib/ff/ff.c   **** 	do {
1290:lib/ff/ff.c   **** 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
1291:lib/ff/ff.c   **** 		if (wc) {	/* Last char has not been processed */
1292:lib/ff/ff.c   **** 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
1293:lib/ff/ff.c   **** 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
1294:lib/ff/ff.c   **** 				return 0;				/* Not matched */
1295:lib/ff/ff.c   **** 		} else {
1296:lib/ff/ff.c   **** 			if (uc != 0xFFFF) return 0;	/* Check filler */
1297:lib/ff/ff.c   **** 		}
1298:lib/ff/ff.c   **** 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
1299:lib/ff/ff.c   **** 
1300:lib/ff/ff.c   **** 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
1301:lib/ff/ff.c   **** 		return 0;
1302:lib/ff/ff.c   **** 
1303:lib/ff/ff.c   **** 	return 1;						/* The part of LFN matched */
1304:lib/ff/ff.c   **** }
1305:lib/ff/ff.c   **** 
1306:lib/ff/ff.c   **** 
1307:lib/ff/ff.c   **** 
1308:lib/ff/ff.c   **** static
1309:lib/ff/ff.c   **** int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
1310:lib/ff/ff.c   **** 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
1311:lib/ff/ff.c   **** 	BYTE *dir			/* Pointer to the directory entry */
1312:lib/ff/ff.c   **** )
1313:lib/ff/ff.c   **** {
1314:lib/ff/ff.c   **** 	UINT i, s;
1315:lib/ff/ff.c   **** 	WCHAR wc, uc;
1316:lib/ff/ff.c   **** 
1317:lib/ff/ff.c   **** 
1318:lib/ff/ff.c   **** 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
1319:lib/ff/ff.c   **** 
1320:lib/ff/ff.c   **** 	s = 0; wc = 1;
1321:lib/ff/ff.c   **** 	do {
1322:lib/ff/ff.c   **** 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
1323:lib/ff/ff.c   **** 		if (wc) {	/* Last char has not been processed */
1324:lib/ff/ff.c   **** 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
1325:lib/ff/ff.c   **** 			lfnbuf[i++] = wc = uc;			/* Store it */
1326:lib/ff/ff.c   **** 		} else {
1327:lib/ff/ff.c   **** 			if (uc != 0xFFFF) return 0;		/* Check filler */
1328:lib/ff/ff.c   **** 		}
1329:lib/ff/ff.c   **** 	} while (++s < 13);						/* Read all character in the entry */
1330:lib/ff/ff.c   **** 
1331:lib/ff/ff.c   **** 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
1332:lib/ff/ff.c   **** 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
1333:lib/ff/ff.c   **** 		lfnbuf[i] = 0;
1334:lib/ff/ff.c   **** 	}
1335:lib/ff/ff.c   **** 
1336:lib/ff/ff.c   **** 	return 1;
1337:lib/ff/ff.c   **** }
1338:lib/ff/ff.c   **** 
1339:lib/ff/ff.c   **** 
1340:lib/ff/ff.c   **** #if !_FS_READONLY
1341:lib/ff/ff.c   **** static
1342:lib/ff/ff.c   **** void fit_lfn (
1343:lib/ff/ff.c   **** 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
1344:lib/ff/ff.c   **** 	BYTE *dir,				/* Pointer to the directory entry */
1345:lib/ff/ff.c   **** 	BYTE ord,				/* LFN order (1-20) */
1346:lib/ff/ff.c   **** 	BYTE sum				/* SFN sum */
1347:lib/ff/ff.c   **** )
1348:lib/ff/ff.c   **** {
1349:lib/ff/ff.c   **** 	UINT i, s;
1350:lib/ff/ff.c   **** 	WCHAR wc;
1351:lib/ff/ff.c   **** 
1352:lib/ff/ff.c   **** 
1353:lib/ff/ff.c   **** 	dir[LDIR_Chksum] = sum;			/* Set check sum */
1354:lib/ff/ff.c   **** 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
1355:lib/ff/ff.c   **** 	dir[LDIR_Type] = 0;
1356:lib/ff/ff.c   **** 	ST_WORD(dir+LDIR_FstClusLO, 0);
1357:lib/ff/ff.c   **** 
1358:lib/ff/ff.c   **** 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
1359:lib/ff/ff.c   **** 	s = wc = 0;
1360:lib/ff/ff.c   **** 	do {
1361:lib/ff/ff.c   **** 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
1362:lib/ff/ff.c   **** 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
1363:lib/ff/ff.c   **** 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
1364:lib/ff/ff.c   **** 	} while (++s < 13);
1365:lib/ff/ff.c   **** 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
1366:lib/ff/ff.c   **** 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
1367:lib/ff/ff.c   **** }
1368:lib/ff/ff.c   **** 
1369:lib/ff/ff.c   **** #endif
1370:lib/ff/ff.c   **** #endif
1371:lib/ff/ff.c   **** 
1372:lib/ff/ff.c   **** 
1373:lib/ff/ff.c   **** 
1374:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1375:lib/ff/ff.c   **** /* Create numbered name                                                  */
1376:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1377:lib/ff/ff.c   **** #if _USE_LFN
1378:lib/ff/ff.c   **** void gen_numname (
1379:lib/ff/ff.c   **** 	BYTE *dst,			/* Pointer to generated SFN */
1380:lib/ff/ff.c   **** 	const BYTE *src,	/* Pointer to source SFN to be modified */
1381:lib/ff/ff.c   **** 	const WCHAR *lfn,	/* Pointer to LFN */
1382:lib/ff/ff.c   **** 	WORD seq			/* Sequence number */
1383:lib/ff/ff.c   **** )
1384:lib/ff/ff.c   **** {
1385:lib/ff/ff.c   **** 	BYTE ns[8], c;
1386:lib/ff/ff.c   **** 	UINT i, j;
1387:lib/ff/ff.c   **** 
1388:lib/ff/ff.c   **** 
1389:lib/ff/ff.c   **** 	mem_cpy(dst, src, 11);
1390:lib/ff/ff.c   **** 
1391:lib/ff/ff.c   **** 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
1392:lib/ff/ff.c   **** 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
1393:lib/ff/ff.c   **** 	}
1394:lib/ff/ff.c   **** 
1395:lib/ff/ff.c   **** 	/* itoa (hexdecimal) */
1396:lib/ff/ff.c   **** 	i = 7;
1397:lib/ff/ff.c   **** 	do {
1398:lib/ff/ff.c   **** 		c = (seq % 16) + '0';
1399:lib/ff/ff.c   **** 		if (c > '9') c += 7;
1400:lib/ff/ff.c   **** 		ns[i--] = c;
1401:lib/ff/ff.c   **** 		seq /= 16;
1402:lib/ff/ff.c   **** 	} while (seq);
1403:lib/ff/ff.c   **** 	ns[i] = '~';
1404:lib/ff/ff.c   **** 
1405:lib/ff/ff.c   **** 	/* Append the number */
1406:lib/ff/ff.c   **** 	for (j = 0; j < i && dst[j] != ' '; j++) {
1407:lib/ff/ff.c   **** 		if (IsDBCS1(dst[j])) {
1408:lib/ff/ff.c   **** 			if (j == i - 1) break;
1409:lib/ff/ff.c   **** 			j++;
1410:lib/ff/ff.c   **** 		}
1411:lib/ff/ff.c   **** 	}
1412:lib/ff/ff.c   **** 	do {
1413:lib/ff/ff.c   **** 		dst[j++] = (i < 8) ? ns[i++] : ' ';
1414:lib/ff/ff.c   **** 	} while (j < 8);
1415:lib/ff/ff.c   **** }
1416:lib/ff/ff.c   **** #endif
1417:lib/ff/ff.c   **** 
1418:lib/ff/ff.c   **** 
1419:lib/ff/ff.c   **** 
1420:lib/ff/ff.c   **** 
1421:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1422:lib/ff/ff.c   **** /* Calculate sum of an SFN                                               */
1423:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1424:lib/ff/ff.c   **** #if _USE_LFN
1425:lib/ff/ff.c   **** static
1426:lib/ff/ff.c   **** BYTE sum_sfn (
1427:lib/ff/ff.c   **** 	const BYTE *dir		/* Ptr to directory entry */
1428:lib/ff/ff.c   **** )
1429:lib/ff/ff.c   **** {
1430:lib/ff/ff.c   **** 	BYTE sum = 0;
1431:lib/ff/ff.c   **** 	UINT n = 11;
1432:lib/ff/ff.c   **** 
1433:lib/ff/ff.c   **** 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1434:lib/ff/ff.c   **** 	return sum;
1435:lib/ff/ff.c   **** }
1436:lib/ff/ff.c   **** #endif
1437:lib/ff/ff.c   **** 
1438:lib/ff/ff.c   **** 
1439:lib/ff/ff.c   **** 
1440:lib/ff/ff.c   **** 
1441:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1442:lib/ff/ff.c   **** /* Directory handling - Find an object in the directory                  */
1443:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1444:lib/ff/ff.c   **** 
1445:lib/ff/ff.c   **** static
1446:lib/ff/ff.c   **** FRESULT dir_find (
1447:lib/ff/ff.c   **** 	DIR *dj			/* Pointer to the directory object linked to the file name */
1448:lib/ff/ff.c   **** )
1449:lib/ff/ff.c   **** {
1450:lib/ff/ff.c   **** 	FRESULT res;
1451:lib/ff/ff.c   **** 	BYTE c, *dir;
1452:lib/ff/ff.c   **** #if _USE_LFN
1453:lib/ff/ff.c   **** 	BYTE a, ord, sum;
1454:lib/ff/ff.c   **** #endif
1455:lib/ff/ff.c   **** 
1456:lib/ff/ff.c   **** 	res = dir_sdi(dj, 0);			/* Rewind directory object */
1457:lib/ff/ff.c   **** 	if (res != FR_OK) return res;
1458:lib/ff/ff.c   **** 
1459:lib/ff/ff.c   **** #if _USE_LFN
1460:lib/ff/ff.c   **** 	ord = sum = 0xFF;
1461:lib/ff/ff.c   **** #endif
1462:lib/ff/ff.c   **** 	do {
1463:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
1464:lib/ff/ff.c   **** 		if (res != FR_OK) break;
1465:lib/ff/ff.c   **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
1466:lib/ff/ff.c   **** 		c = dir[DIR_Name];
1467:lib/ff/ff.c   **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
1468:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1469:lib/ff/ff.c   **** 		a = dir[DIR_Attr] & AM_MASK;
1470:lib/ff/ff.c   **** 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
1471:lib/ff/ff.c   **** 			ord = 0xFF;
1472:lib/ff/ff.c   **** 		} else {
1473:lib/ff/ff.c   **** 			if (a == AM_LFN) {			/* An LFN entry is found */
1474:lib/ff/ff.c   **** 				if (dj->lfn) {
1475:lib/ff/ff.c   **** 					if (c & LLE) {		/* Is it start of LFN sequence? */
1476:lib/ff/ff.c   **** 						sum = dir[LDIR_Chksum];
1477:lib/ff/ff.c   **** 						c &= ~LLE; ord = c;	/* LFN start order */
1478:lib/ff/ff.c   **** 						dj->lfn_idx = dj->index;
1479:lib/ff/ff.c   **** 					}
1480:lib/ff/ff.c   **** 					/* Check validity of the LFN entry and compare it with given name */
1481:lib/ff/ff.c   **** 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1482:lib/ff/ff.c   **** 				}
1483:lib/ff/ff.c   **** 			} else {					/* An SFN entry is found */
1484:lib/ff/ff.c   **** 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
1485:lib/ff/ff.c   **** 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
1486:lib/ff/ff.c   **** 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
1487:lib/ff/ff.c   **** 			}
1488:lib/ff/ff.c   **** 		}
1489:lib/ff/ff.c   **** #else		/* Non LFN configuration */
1490:lib/ff/ff.c   **** 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
1491:lib/ff/ff.c   **** 			break;
1492:lib/ff/ff.c   **** #endif
1493:lib/ff/ff.c   **** 		res = dir_next(dj, 0);		/* Next entry */
1494:lib/ff/ff.c   **** 	} while (res == FR_OK);
1495:lib/ff/ff.c   **** 
1496:lib/ff/ff.c   **** 	return res;
1497:lib/ff/ff.c   **** }
1498:lib/ff/ff.c   **** 
1499:lib/ff/ff.c   **** 
1500:lib/ff/ff.c   **** 
1501:lib/ff/ff.c   **** 
1502:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1503:lib/ff/ff.c   **** /* Read an object from the directory                                     */
1504:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1505:lib/ff/ff.c   **** #if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
1506:lib/ff/ff.c   **** static
1507:lib/ff/ff.c   **** FRESULT dir_read (
1508:lib/ff/ff.c   **** 	DIR *dj,		/* Pointer to the directory object */
1509:lib/ff/ff.c   **** 	int vol			/* Filtered by 0:file/dir or 1:volume label */
1510:lib/ff/ff.c   **** )
1511:lib/ff/ff.c   **** {
1512:lib/ff/ff.c   **** 	FRESULT res;
1513:lib/ff/ff.c   **** 	BYTE a, c, *dir;
1514:lib/ff/ff.c   **** #if _USE_LFN
1515:lib/ff/ff.c   **** 	BYTE ord = 0xFF, sum = 0xFF;
1516:lib/ff/ff.c   **** #endif
1517:lib/ff/ff.c   **** 
1518:lib/ff/ff.c   **** 	res = FR_NO_FILE;
1519:lib/ff/ff.c   **** 	while (dj->sect) {
1520:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
1521:lib/ff/ff.c   **** 		if (res != FR_OK) break;
1522:lib/ff/ff.c   **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
1523:lib/ff/ff.c   **** 		c = dir[DIR_Name];
1524:lib/ff/ff.c   **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
1525:lib/ff/ff.c   **** 		a = dir[DIR_Attr] & AM_MASK;
1526:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1527:lib/ff/ff.c   **** 		if (c == DDE || (!_FS_RPATH && c == '.') || (a == AM_VOL) != vol) {	/* An entry without valid dat
1528:lib/ff/ff.c   **** 			ord = 0xFF;
1529:lib/ff/ff.c   **** 		} else {
1530:lib/ff/ff.c   **** 			if (a == AM_LFN) {			/* An LFN entry is found */
1531:lib/ff/ff.c   **** 				if (c & LLE) {			/* Is it start of LFN sequence? */
1532:lib/ff/ff.c   **** 					sum = dir[LDIR_Chksum];
1533:lib/ff/ff.c   **** 					c &= ~LLE; ord = c;
1534:lib/ff/ff.c   **** 					dj->lfn_idx = dj->index;
1535:lib/ff/ff.c   **** 				}
1536:lib/ff/ff.c   **** 				/* Check LFN validity and capture it */
1537:lib/ff/ff.c   **** 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1538:lib/ff/ff.c   **** 			} else {					/* An SFN entry is found */
1539:lib/ff/ff.c   **** 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
1540:lib/ff/ff.c   **** 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
1541:lib/ff/ff.c   **** 				break;
1542:lib/ff/ff.c   **** 			}
1543:lib/ff/ff.c   **** 		}
1544:lib/ff/ff.c   **** #else		/* Non LFN configuration */
1545:lib/ff/ff.c   **** 		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid 
1546:lib/ff/ff.c   **** 			break;
1547:lib/ff/ff.c   **** #endif
1548:lib/ff/ff.c   **** 		res = dir_next(dj, 0);				/* Next entry */
1549:lib/ff/ff.c   **** 		if (res != FR_OK) break;
1550:lib/ff/ff.c   **** 	}
1551:lib/ff/ff.c   **** 
1552:lib/ff/ff.c   **** 	if (res != FR_OK) dj->sect = 0;
1553:lib/ff/ff.c   **** 
1554:lib/ff/ff.c   **** 	return res;
1555:lib/ff/ff.c   **** }
1556:lib/ff/ff.c   **** #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
1557:lib/ff/ff.c   **** 
1558:lib/ff/ff.c   **** 
1559:lib/ff/ff.c   **** 
1560:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1561:lib/ff/ff.c   **** /* Register an object to the directory                                   */
1562:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1563:lib/ff/ff.c   **** #if !_FS_READONLY
1564:lib/ff/ff.c   **** static
1565:lib/ff/ff.c   **** FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_D
1566:lib/ff/ff.c   **** 	DIR *dj				/* Target directory with object name to be created */
1567:lib/ff/ff.c   **** )
1568:lib/ff/ff.c   **** {
1569:lib/ff/ff.c   **** 	FRESULT res;
1570:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1571:lib/ff/ff.c   **** 	WORD n, ne;
1572:lib/ff/ff.c   **** 	BYTE sn[12], *fn, sum;
1573:lib/ff/ff.c   **** 	WCHAR *lfn;
1574:lib/ff/ff.c   **** 
1575:lib/ff/ff.c   **** 
1576:lib/ff/ff.c   **** 	fn = dj->fn; lfn = dj->lfn;
1577:lib/ff/ff.c   **** 	mem_cpy(sn, fn, 12);
1578:lib/ff/ff.c   **** 
1579:lib/ff/ff.c   **** 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
1580:lib/ff/ff.c   **** 		return FR_INVALID_NAME;
1581:lib/ff/ff.c   **** 
1582:lib/ff/ff.c   **** 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
1583:lib/ff/ff.c   **** 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
1584:lib/ff/ff.c   **** 		for (n = 1; n < 100; n++) {
1585:lib/ff/ff.c   **** 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
1586:lib/ff/ff.c   **** 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
1587:lib/ff/ff.c   **** 			if (res != FR_OK) break;
1588:lib/ff/ff.c   **** 		}
1589:lib/ff/ff.c   **** 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
1590:lib/ff/ff.c   **** 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
1591:lib/ff/ff.c   **** 		fn[NS] = sn[NS]; dj->lfn = lfn;
1592:lib/ff/ff.c   **** 	}
1593:lib/ff/ff.c   **** 
1594:lib/ff/ff.c   **** 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
1595:lib/ff/ff.c   **** 		for (n = 0; lfn[n]; n++) ;
1596:lib/ff/ff.c   **** 		ne = (n + 25) / 13;
1597:lib/ff/ff.c   **** 	} else {						/* Otherwise allocate an entry for an SFN  */
1598:lib/ff/ff.c   **** 		ne = 1;
1599:lib/ff/ff.c   **** 	}
1600:lib/ff/ff.c   **** 	res = dir_alloc(dj, ne);		/* Allocate entries */
1601:lib/ff/ff.c   **** 
1602:lib/ff/ff.c   **** 	if (res == FR_OK && --ne) {		/* Set LFN entry if needed */
1603:lib/ff/ff.c   **** 		res = dir_sdi(dj, (WORD)(dj->index - ne));
1604:lib/ff/ff.c   **** 		if (res == FR_OK) {
1605:lib/ff/ff.c   **** 			sum = sum_sfn(dj->fn);	/* Sum value of the SFN tied to the LFN */
1606:lib/ff/ff.c   **** 			do {					/* Store LFN entries in bottom first */
1607:lib/ff/ff.c   **** 				res = move_window(dj->fs, dj->sect);
1608:lib/ff/ff.c   **** 				if (res != FR_OK) break;
1609:lib/ff/ff.c   **** 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
1610:lib/ff/ff.c   **** 				dj->fs->wflag = 1;
1611:lib/ff/ff.c   **** 				res = dir_next(dj, 0);	/* Next entry */
1612:lib/ff/ff.c   **** 			} while (res == FR_OK && --ne);
1613:lib/ff/ff.c   **** 		}
1614:lib/ff/ff.c   **** 	}
1615:lib/ff/ff.c   **** #else	/* Non LFN configuration */
1616:lib/ff/ff.c   **** 	res = dir_alloc(dj, 1);		/* Allocate an entry for SFN */
1617:lib/ff/ff.c   **** #endif
1618:lib/ff/ff.c   **** 
1619:lib/ff/ff.c   **** 	if (res == FR_OK) {				/* Set SFN entry */
1620:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
1621:lib/ff/ff.c   **** 		if (res == FR_OK) {
1622:lib/ff/ff.c   **** 			mem_set(dj->dir, 0, SZ_DIR);	/* Clean the entry */
1623:lib/ff/ff.c   **** 			mem_cpy(dj->dir, dj->fn, 11);	/* Put SFN */
1624:lib/ff/ff.c   **** #if _USE_LFN
1625:lib/ff/ff.c   **** 			dj->dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
1626:lib/ff/ff.c   **** #endif
1627:lib/ff/ff.c   **** 			dj->fs->wflag = 1;
1628:lib/ff/ff.c   **** 		}
1629:lib/ff/ff.c   **** 	}
1630:lib/ff/ff.c   **** 
1631:lib/ff/ff.c   **** 	return res;
1632:lib/ff/ff.c   **** }
1633:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
1634:lib/ff/ff.c   **** 
1635:lib/ff/ff.c   **** 
1636:lib/ff/ff.c   **** 
1637:lib/ff/ff.c   **** 
1638:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1639:lib/ff/ff.c   **** /* Remove an object from the directory                                   */
1640:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1641:lib/ff/ff.c   **** #if !_FS_READONLY && !_FS_MINIMIZE
1642:lib/ff/ff.c   **** static
1643:lib/ff/ff.c   **** FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
1644:lib/ff/ff.c   **** 	DIR *dj				/* Directory object pointing the entry to be removed */
1645:lib/ff/ff.c   **** )
1646:lib/ff/ff.c   **** {
1647:lib/ff/ff.c   **** 	FRESULT res;
1648:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1649:lib/ff/ff.c   **** 	WORD i;
1650:lib/ff/ff.c   **** 
1651:lib/ff/ff.c   **** 	i = dj->index;	/* SFN index */
1652:lib/ff/ff.c   **** 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of th
1653:lib/ff/ff.c   **** 	if (res == FR_OK) {
1654:lib/ff/ff.c   **** 		do {
1655:lib/ff/ff.c   **** 			res = move_window(dj->fs, dj->sect);
1656:lib/ff/ff.c   **** 			if (res != FR_OK) break;
1657:lib/ff/ff.c   **** 			*dj->dir = DDE;			/* Mark the entry "deleted" */
1658:lib/ff/ff.c   **** 			dj->fs->wflag = 1;
1659:lib/ff/ff.c   **** 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
1660:lib/ff/ff.c   **** 			res = dir_next(dj, 0);		/* Next entry */
1661:lib/ff/ff.c   **** 		} while (res == FR_OK);
1662:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) res = FR_INT_ERR;
1663:lib/ff/ff.c   **** 	}
1664:lib/ff/ff.c   **** 
1665:lib/ff/ff.c   **** #else			/* Non LFN configuration */
1666:lib/ff/ff.c   **** 	res = dir_sdi(dj, dj->index);
1667:lib/ff/ff.c   **** 	if (res == FR_OK) {
1668:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
1669:lib/ff/ff.c   **** 		if (res == FR_OK) {
1670:lib/ff/ff.c   **** 			*dj->dir = DDE;			/* Mark the entry "deleted" */
1671:lib/ff/ff.c   **** 			dj->fs->wflag = 1;
1672:lib/ff/ff.c   **** 		}
1673:lib/ff/ff.c   **** 	}
1674:lib/ff/ff.c   **** #endif
1675:lib/ff/ff.c   **** 
1676:lib/ff/ff.c   **** 	return res;
1677:lib/ff/ff.c   **** }
1678:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
1679:lib/ff/ff.c   **** 
1680:lib/ff/ff.c   **** 
1681:lib/ff/ff.c   **** 
1682:lib/ff/ff.c   **** 
1683:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1684:lib/ff/ff.c   **** /* Pick a segment and create the object name in directory form           */
1685:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1686:lib/ff/ff.c   **** 
1687:lib/ff/ff.c   **** static
1688:lib/ff/ff.c   **** FRESULT create_name (
1689:lib/ff/ff.c   **** 	DIR *dj,			/* Pointer to the directory object */
1690:lib/ff/ff.c   **** 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
1691:lib/ff/ff.c   **** )
1692:lib/ff/ff.c   **** {
1693:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
1694:lib/ff/ff.c   **** 	BYTE b, cf;
1695:lib/ff/ff.c   **** 	WCHAR w, *lfn;
1696:lib/ff/ff.c   **** 	UINT i, ni, si, di;
1697:lib/ff/ff.c   **** 	const TCHAR *p;
1698:lib/ff/ff.c   **** 
1699:lib/ff/ff.c   **** 	/* Create LFN in Unicode */
1700:lib/ff/ff.c   **** 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
1701:lib/ff/ff.c   **** 	lfn = dj->lfn;
1702:lib/ff/ff.c   **** 	si = di = 0;
1703:lib/ff/ff.c   **** 	for (;;) {
1704:lib/ff/ff.c   **** 		w = p[si++];					/* Get a character */
1705:lib/ff/ff.c   **** 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
1706:lib/ff/ff.c   **** 		if (di >= _MAX_LFN)				/* Reject too long name */
1707:lib/ff/ff.c   **** 			return FR_INVALID_NAME;
1708:lib/ff/ff.c   **** #if !_LFN_UNICODE
1709:lib/ff/ff.c   **** 		w &= 0xFF;
1710:lib/ff/ff.c   **** 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1711:lib/ff/ff.c   **** 			b = (BYTE)p[si++];			/* Get 2nd byte */
1712:lib/ff/ff.c   **** 			if (!IsDBCS2(b))
1713:lib/ff/ff.c   **** 				return FR_INVALID_NAME;	/* Reject invalid sequence */
1714:lib/ff/ff.c   **** 			w = (w << 8) + b;			/* Create a DBC */
1715:lib/ff/ff.c   **** 		}
1716:lib/ff/ff.c   **** 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
1717:lib/ff/ff.c   **** 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
1718:lib/ff/ff.c   **** #endif
1719:lib/ff/ff.c   **** 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1720:lib/ff/ff.c   **** 			return FR_INVALID_NAME;
1721:lib/ff/ff.c   **** 		lfn[di++] = w;					/* Store the Unicode char */
1722:lib/ff/ff.c   **** 	}
1723:lib/ff/ff.c   **** 	*path = &p[si];						/* Return pointer to the next segment */
1724:lib/ff/ff.c   **** 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
1725:lib/ff/ff.c   **** #if _FS_RPATH
1726:lib/ff/ff.c   **** 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1727:lib/ff/ff.c   **** 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1728:lib/ff/ff.c   **** 		lfn[di] = 0;
1729:lib/ff/ff.c   **** 		for (i = 0; i < 11; i++)
1730:lib/ff/ff.c   **** 			dj->fn[i] = (i < di) ? '.' : ' ';
1731:lib/ff/ff.c   **** 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
1732:lib/ff/ff.c   **** 		return FR_OK;
1733:lib/ff/ff.c   **** 	}
1734:lib/ff/ff.c   **** #endif
1735:lib/ff/ff.c   **** 	while (di) {						/* Strip trailing spaces and dots */
1736:lib/ff/ff.c   **** 		w = lfn[di-1];
1737:lib/ff/ff.c   **** 		if (w != ' ' && w != '.') break;
1738:lib/ff/ff.c   **** 		di--;
1739:lib/ff/ff.c   **** 	}
1740:lib/ff/ff.c   **** 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
1741:lib/ff/ff.c   **** 
1742:lib/ff/ff.c   **** 	lfn[di] = 0;						/* LFN is created */
1743:lib/ff/ff.c   **** 
1744:lib/ff/ff.c   **** 	/* Create SFN in directory form */
1745:lib/ff/ff.c   **** 	mem_set(dj->fn, ' ', 11);
1746:lib/ff/ff.c   **** 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
1747:lib/ff/ff.c   **** 	if (si) cf |= NS_LOSS | NS_LFN;
1748:lib/ff/ff.c   **** 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
1749:lib/ff/ff.c   **** 
1750:lib/ff/ff.c   **** 	b = i = 0; ni = 8;
1751:lib/ff/ff.c   **** 	for (;;) {
1752:lib/ff/ff.c   **** 		w = lfn[si++];					/* Get an LFN char */
1753:lib/ff/ff.c   **** 		if (!w) break;					/* Break on end of the LFN */
1754:lib/ff/ff.c   **** 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
1755:lib/ff/ff.c   **** 			cf |= NS_LOSS | NS_LFN; continue;
1756:lib/ff/ff.c   **** 		}
1757:lib/ff/ff.c   **** 
1758:lib/ff/ff.c   **** 		if (i >= ni || si == di) {		/* Extension or end of SFN */
1759:lib/ff/ff.c   **** 			if (ni == 11) {				/* Long extension */
1760:lib/ff/ff.c   **** 				cf |= NS_LOSS | NS_LFN; break;
1761:lib/ff/ff.c   **** 			}
1762:lib/ff/ff.c   **** 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
1763:lib/ff/ff.c   **** 			if (si > di) break;			/* No extension */
1764:lib/ff/ff.c   **** 			si = di; i = 8; ni = 11;	/* Enter extension section */
1765:lib/ff/ff.c   **** 			b <<= 2; continue;
1766:lib/ff/ff.c   **** 		}
1767:lib/ff/ff.c   **** 
1768:lib/ff/ff.c   **** 		if (w >= 0x80) {				/* Non ASCII char */
1769:lib/ff/ff.c   **** #ifdef _EXCVT
1770:lib/ff/ff.c   **** 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
1771:lib/ff/ff.c   **** 			if (w) w = ExCvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
1772:lib/ff/ff.c   **** #else
1773:lib/ff/ff.c   **** 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
1774:lib/ff/ff.c   **** #endif
1775:lib/ff/ff.c   **** 			cf |= NS_LFN;				/* Force create LFN entry */
1776:lib/ff/ff.c   **** 		}
1777:lib/ff/ff.c   **** 
1778:lib/ff/ff.c   **** 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
1779:lib/ff/ff.c   **** 			if (i >= ni - 1) {
1780:lib/ff/ff.c   **** 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1781:lib/ff/ff.c   **** 			}
1782:lib/ff/ff.c   **** 			dj->fn[i++] = (BYTE)(w >> 8);
1783:lib/ff/ff.c   **** 		} else {						/* Single byte char */
1784:lib/ff/ff.c   **** 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
1785:lib/ff/ff.c   **** 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1786:lib/ff/ff.c   **** 			} else {
1787:lib/ff/ff.c   **** 				if (IsUpper(w)) {		/* ASCII large capital */
1788:lib/ff/ff.c   **** 					b |= 2;
1789:lib/ff/ff.c   **** 				} else {
1790:lib/ff/ff.c   **** 					if (IsLower(w)) {	/* ASCII small capital */
1791:lib/ff/ff.c   **** 						b |= 1; w -= 0x20;
1792:lib/ff/ff.c   **** 					}
1793:lib/ff/ff.c   **** 				}
1794:lib/ff/ff.c   **** 			}
1795:lib/ff/ff.c   **** 		}
1796:lib/ff/ff.c   **** 		dj->fn[i++] = (BYTE)w;
1797:lib/ff/ff.c   **** 	}
1798:lib/ff/ff.c   **** 
1799:lib/ff/ff.c   **** 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace i
1800:lib/ff/ff.c   **** 
1801:lib/ff/ff.c   **** 	if (ni == 8) b <<= 2;
1802:lib/ff/ff.c   **** 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capital
1803:lib/ff/ff.c   **** 		cf |= NS_LFN;
1804:lib/ff/ff.c   **** 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are create
1805:lib/ff/ff.c   **** 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
1806:lib/ff/ff.c   **** 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
1807:lib/ff/ff.c   **** 	}
1808:lib/ff/ff.c   **** 
1809:lib/ff/ff.c   **** 	dj->fn[NS] = cf;	/* SFN is created */
1810:lib/ff/ff.c   **** 
1811:lib/ff/ff.c   **** 	return FR_OK;
1812:lib/ff/ff.c   **** 
1813:lib/ff/ff.c   **** 
1814:lib/ff/ff.c   **** #else	/* Non-LFN configuration */
1815:lib/ff/ff.c   **** 	BYTE b, c, d, *sfn;
1816:lib/ff/ff.c   **** 	UINT ni, si, i;
1817:lib/ff/ff.c   **** 	const char *p;
1818:lib/ff/ff.c   **** 
1819:lib/ff/ff.c   **** 	/* Create file name in directory form */
1820:lib/ff/ff.c   **** 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
1821:lib/ff/ff.c   **** 	sfn = dj->fn;
1822:lib/ff/ff.c   **** 	mem_set(sfn, ' ', 11);
1823:lib/ff/ff.c   **** 	si = i = b = 0; ni = 8;
1824:lib/ff/ff.c   **** #if _FS_RPATH
1825:lib/ff/ff.c   **** 	if (p[si] == '.') { /* Is this a dot entry? */
1826:lib/ff/ff.c   **** 		for (;;) {
1827:lib/ff/ff.c   **** 			c = (BYTE)p[si++];
1828:lib/ff/ff.c   **** 			if (c != '.' || si >= 3) break;
1829:lib/ff/ff.c   **** 			sfn[i++] = c;
1830:lib/ff/ff.c   **** 		}
1831:lib/ff/ff.c   **** 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
1832:lib/ff/ff.c   **** 		*path = &p[si];									/* Return pointer to the next segment */
1833:lib/ff/ff.c   **** 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
1834:lib/ff/ff.c   **** 		return FR_OK;
1835:lib/ff/ff.c   **** 	}
1836:lib/ff/ff.c   **** #endif
1837:lib/ff/ff.c   **** 	for (;;) {
1838:lib/ff/ff.c   **** 		c = (BYTE)p[si++];
1839:lib/ff/ff.c   **** 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
1840:lib/ff/ff.c   **** 		if (c == '.' || i >= ni) {
1841:lib/ff/ff.c   **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
1842:lib/ff/ff.c   **** 			i = 8; ni = 11;
1843:lib/ff/ff.c   **** 			b <<= 2; continue;
1844:lib/ff/ff.c   **** 		}
1845:lib/ff/ff.c   **** 		if (c >= 0x80) {				/* Extended char? */
1846:lib/ff/ff.c   **** 			b |= 3;						/* Eliminate NT flag */
1847:lib/ff/ff.c   **** #ifdef _EXCVT
1848:lib/ff/ff.c   **** 			c = ExCvt[c - 0x80];		/* To upper extended chars (SBCS cfg) */
1849:lib/ff/ff.c   **** #else
1850:lib/ff/ff.c   **** #if !_DF1S
1851:lib/ff/ff.c   **** 			return FR_INVALID_NAME;		/* Reject extended chars (ASCII cfg) */
1852:lib/ff/ff.c   **** #endif
1853:lib/ff/ff.c   **** #endif
1854:lib/ff/ff.c   **** 		}
1855:lib/ff/ff.c   **** 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1856:lib/ff/ff.c   **** 			d = (BYTE)p[si++];			/* Get 2nd byte */
1857:lib/ff/ff.c   **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
1858:lib/ff/ff.c   **** 				return FR_INVALID_NAME;
1859:lib/ff/ff.c   **** 			sfn[i++] = c;
1860:lib/ff/ff.c   **** 			sfn[i++] = d;
1861:lib/ff/ff.c   **** 		} else {						/* Single byte code */
1862:lib/ff/ff.c   **** 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
1863:lib/ff/ff.c   **** 				return FR_INVALID_NAME;
1864:lib/ff/ff.c   **** 			if (IsUpper(c)) {			/* ASCII large capital? */
1865:lib/ff/ff.c   **** 				b |= 2;
1866:lib/ff/ff.c   **** 			} else {
1867:lib/ff/ff.c   **** 				if (IsLower(c)) {		/* ASCII small capital? */
1868:lib/ff/ff.c   **** 					b |= 1; c -= 0x20;
1869:lib/ff/ff.c   **** 				}
1870:lib/ff/ff.c   **** 			}
1871:lib/ff/ff.c   **** 			sfn[i++] = c;
1872:lib/ff/ff.c   **** 		}
1873:lib/ff/ff.c   **** 	}
1874:lib/ff/ff.c   **** 	*path = &p[si];						/* Return pointer to the next segment */
1875:lib/ff/ff.c   **** 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
1876:lib/ff/ff.c   **** 
1877:lib/ff/ff.c   **** 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
1878:lib/ff/ff.c   **** 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
1879:lib/ff/ff.c   **** 
1880:lib/ff/ff.c   **** 	if (ni == 8) b <<= 2;
1881:lib/ff/ff.c   **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
1882:lib/ff/ff.c   **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
1883:lib/ff/ff.c   **** 
1884:lib/ff/ff.c   **** 	sfn[NS] = c;		/* Store NT flag, File name is created */
1885:lib/ff/ff.c   **** 
1886:lib/ff/ff.c   **** 	return FR_OK;
1887:lib/ff/ff.c   **** #endif
1888:lib/ff/ff.c   **** }
1889:lib/ff/ff.c   **** 
1890:lib/ff/ff.c   **** 
1891:lib/ff/ff.c   **** 
1892:lib/ff/ff.c   **** 
1893:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1894:lib/ff/ff.c   **** /* Get file information from directory entry                             */
1895:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1896:lib/ff/ff.c   **** #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
1897:lib/ff/ff.c   **** static
1898:lib/ff/ff.c   **** void get_fileinfo (		/* No return code */
1899:lib/ff/ff.c   **** 	DIR *dj,			/* Pointer to the directory object */
1900:lib/ff/ff.c   **** 	FILINFO *fno	 	/* Pointer to the file information to be filled */
1901:lib/ff/ff.c   **** )
1902:lib/ff/ff.c   **** {
 170              		.loc 1 1902 0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 0
 173              		@ frame_needed = 0, uses_anonymous_args = 0
 174              	.LVL20:
 175 0000 70B5     		push	{r4, r5, r6, lr}
 176              	.LCFI1:
 177              		.cfi_def_cfa_offset 16
 178              		.cfi_offset 4, -16
 179              		.cfi_offset 5, -12
 180              		.cfi_offset 6, -8
 181              		.cfi_offset 14, -4
1903:lib/ff/ff.c   **** 	UINT i;
1904:lib/ff/ff.c   **** 	BYTE nt, *dir;
1905:lib/ff/ff.c   **** 	TCHAR *p, c;
1906:lib/ff/ff.c   **** 
1907:lib/ff/ff.c   **** 
1908:lib/ff/ff.c   **** 	p = fno->fname;
 182              		.loc 1 1908 0
 183 0002 01F10902 		add	r2, r1, #9
 184              	.LVL21:
1909:lib/ff/ff.c   **** 	if (dj->sect) {
 185              		.loc 1 1909 0
 186 0006 0369     		ldr	r3, [r0, #16]
 187 0008 4BB3     		cbz	r3, .L19
1910:lib/ff/ff.c   **** 		dir = dj->dir;
 188              		.loc 1 1910 0
 189 000a 4369     		ldr	r3, [r0, #20]
 190              	.LVL22:
 191 000c 1046     		mov	r0, r2
 192              	.LVL23:
1911:lib/ff/ff.c   **** 		nt = dir[DIR_NTres];		/* NT flag */
1912:lib/ff/ff.c   **** 		for (i = 0; i < 8; i++) {	/* Copy name body */
 193              		.loc 1 1912 0
 194 000e 0024     		movs	r4, #0
 195              	.LVL24:
 196              	.L22:
 197 0010 0246     		mov	r2, r0
1913:lib/ff/ff.c   **** 			c = dir[i];
 198              		.loc 1 1913 0
 199 0012 1D5D     		ldrb	r5, [r3, r4]	@ zero_extendqisi2
 200              	.LVL25:
1914:lib/ff/ff.c   **** 			if (c == ' ') break;
 201              		.loc 1 1914 0
 202 0014 6EB2     		sxtb	r6, r5
 203 0016 202E     		cmp	r6, #32
 204 0018 08D0     		beq	.L20
1915:lib/ff/ff.c   **** 			if (c == NDDE) c = (TCHAR)DDE;
 205              		.loc 1 1915 0
 206 001a 052E     		cmp	r6, #5
 207 001c 08BF     		it	eq
 208 001e E525     		moveq	r5, #229
1916:lib/ff/ff.c   **** 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
1917:lib/ff/ff.c   **** #if _LFN_UNICODE
1918:lib/ff/ff.c   **** 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1919:lib/ff/ff.c   **** 				c = (c << 8) | dir[++i];
1920:lib/ff/ff.c   **** 			c = ff_convert(c, 1);
1921:lib/ff/ff.c   **** 			if (!c) c = '?';
1922:lib/ff/ff.c   **** #endif
1923:lib/ff/ff.c   **** 			*p++ = c;
 209              		.loc 1 1923 0
 210 0020 00F8015B 		strb	r5, [r0], #1
 211              	.LVL26:
 212 0024 0246     		mov	r2, r0
 213              	.LVL27:
1912:lib/ff/ff.c   **** 			c = dir[i];
 214              		.loc 1 1912 0
 215 0026 0134     		adds	r4, r4, #1
 216              	.LVL28:
 217 0028 082C     		cmp	r4, #8
 218 002a F1D1     		bne	.L22
 219              	.LVL29:
 220              	.L20:
1924:lib/ff/ff.c   **** 		}
1925:lib/ff/ff.c   **** 		if (dir[8] != ' ') {		/* Copy name extension */
 221              		.loc 1 1925 0
 222 002c 1C7A     		ldrb	r4, [r3, #8]	@ zero_extendqisi2
 223 002e 202C     		cmp	r4, #32
 224 0030 0DD0     		beq	.L23
1926:lib/ff/ff.c   **** 			*p++ = '.';
 225              		.loc 1 1926 0
 226 0032 2E22     		movs	r2, #46
 227 0034 00F8012B 		strb	r2, [r0], #1
 228              	.LVL30:
1927:lib/ff/ff.c   **** 			for (i = 8; i < 11; i++) {
 229              		.loc 1 1927 0
 230 0038 0824     		movs	r4, #8
 231              	.LVL31:
 232              	.L24:
 233 003a 0246     		mov	r2, r0
1928:lib/ff/ff.c   **** 				c = dir[i];
 234              		.loc 1 1928 0
 235 003c 1D5D     		ldrb	r5, [r3, r4]	@ zero_extendqisi2
 236              	.LVL32:
1929:lib/ff/ff.c   **** 				if (c == ' ') break;
 237              		.loc 1 1929 0
 238 003e 202D     		cmp	r5, #32
 239 0040 05D0     		beq	.L23
1930:lib/ff/ff.c   **** 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
1931:lib/ff/ff.c   **** #if _LFN_UNICODE
1932:lib/ff/ff.c   **** 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1933:lib/ff/ff.c   **** 					c = (c << 8) | dir[++i];
1934:lib/ff/ff.c   **** 				c = ff_convert(c, 1);
1935:lib/ff/ff.c   **** 				if (!c) c = '?';
1936:lib/ff/ff.c   **** #endif
1937:lib/ff/ff.c   **** 				*p++ = c;
 240              		.loc 1 1937 0
 241 0042 00F8015B 		strb	r5, [r0], #1
 242 0046 0246     		mov	r2, r0
 243              	.LVL33:
1927:lib/ff/ff.c   **** 				c = dir[i];
 244              		.loc 1 1927 0
 245 0048 0134     		adds	r4, r4, #1
 246              	.LVL34:
 247 004a 0B2C     		cmp	r4, #11
 248 004c F5D1     		bne	.L24
 249              	.LVL35:
 250              	.L23:
1938:lib/ff/ff.c   **** 			}
1939:lib/ff/ff.c   **** 		}
1940:lib/ff/ff.c   **** 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 251              		.loc 1 1940 0
 252 004e D87A     		ldrb	r0, [r3, #11]	@ zero_extendqisi2
 253 0050 0872     		strb	r0, [r1, #8]
1941:lib/ff/ff.c   **** 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
 254              		.loc 1 1941 0
 255 0052 D869     		ldr	r0, [r3, #28]
 256 0054 0860     		str	r0, [r1, #0]
1942:lib/ff/ff.c   **** 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
 257              		.loc 1 1942 0
 258 0056 188B     		ldrh	r0, [r3, #24]
 259 0058 8880     		strh	r0, [r1, #4]	@ movhi
1943:lib/ff/ff.c   **** 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
 260              		.loc 1 1943 0
 261 005a DB8A     		ldrh	r3, [r3, #22]
 262              	.LVL36:
 263 005c CB80     		strh	r3, [r1, #6]	@ movhi
 264              	.LVL37:
 265              	.L19:
1944:lib/ff/ff.c   **** 	}
1945:lib/ff/ff.c   **** 	*p = 0;		/* Terminate SFN str by a \0 */
 266              		.loc 1 1945 0
 267 005e 0021     		movs	r1, #0
 268              	.LVL38:
 269 0060 1170     		strb	r1, [r2, #0]
 270 0062 70BD     		pop	{r4, r5, r6, pc}
 271              		.cfi_endproc
 272              	.LFE23:
 274              		.section	.text.validate,"ax",%progbits
 275              		.align	1
 276              		.thumb
 277              		.thumb_func
 279              	validate:
 280              	.LFB27:
1946:lib/ff/ff.c   **** 
1947:lib/ff/ff.c   **** #if _USE_LFN
1948:lib/ff/ff.c   **** 	if (fno->lfname && fno->lfsize) {
1949:lib/ff/ff.c   **** 		TCHAR *tp = fno->lfname;
1950:lib/ff/ff.c   **** 		WCHAR w, *lfn;
1951:lib/ff/ff.c   **** 
1952:lib/ff/ff.c   **** 		i = 0;
1953:lib/ff/ff.c   **** 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1954:lib/ff/ff.c   **** 			lfn = dj->lfn;
1955:lib/ff/ff.c   **** 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
1956:lib/ff/ff.c   **** #if !_LFN_UNICODE
1957:lib/ff/ff.c   **** 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
1958:lib/ff/ff.c   **** 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
1959:lib/ff/ff.c   **** 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1960:lib/ff/ff.c   **** 					tp[i++] = (TCHAR)(w >> 8);
1961:lib/ff/ff.c   **** #endif
1962:lib/ff/ff.c   **** 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
1963:lib/ff/ff.c   **** 				tp[i++] = (TCHAR)w;
1964:lib/ff/ff.c   **** 			}
1965:lib/ff/ff.c   **** 		}
1966:lib/ff/ff.c   **** 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
1967:lib/ff/ff.c   **** 	}
1968:lib/ff/ff.c   **** #endif
1969:lib/ff/ff.c   **** }
1970:lib/ff/ff.c   **** #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2*/
1971:lib/ff/ff.c   **** 
1972:lib/ff/ff.c   **** 
1973:lib/ff/ff.c   **** 
1974:lib/ff/ff.c   **** 
1975:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1976:lib/ff/ff.c   **** /* Follow a file path                                                    */
1977:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
1978:lib/ff/ff.c   **** 
1979:lib/ff/ff.c   **** static
1980:lib/ff/ff.c   **** FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
1981:lib/ff/ff.c   **** 	DIR *dj,			/* Directory object to return last directory and found object */
1982:lib/ff/ff.c   **** 	const TCHAR *path	/* Full-path string to find a file or directory */
1983:lib/ff/ff.c   **** )
1984:lib/ff/ff.c   **** {
1985:lib/ff/ff.c   **** 	FRESULT res;
1986:lib/ff/ff.c   **** 	BYTE *dir, ns;
1987:lib/ff/ff.c   **** 
1988:lib/ff/ff.c   **** 
1989:lib/ff/ff.c   **** #if _FS_RPATH
1990:lib/ff/ff.c   **** 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
1991:lib/ff/ff.c   **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
1992:lib/ff/ff.c   **** 	} else {							/* No heading separator */
1993:lib/ff/ff.c   **** 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
1994:lib/ff/ff.c   **** 	}
1995:lib/ff/ff.c   **** #else
1996:lib/ff/ff.c   **** 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
1997:lib/ff/ff.c   **** 		path++;
1998:lib/ff/ff.c   **** 	dj->sclust = 0;						/* Start from the root dir */
1999:lib/ff/ff.c   **** #endif
2000:lib/ff/ff.c   **** 
2001:lib/ff/ff.c   **** 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
2002:lib/ff/ff.c   **** 		res = dir_sdi(dj, 0);
2003:lib/ff/ff.c   **** 		dj->dir = 0;
2004:lib/ff/ff.c   **** 	} else {							/* Follow path */
2005:lib/ff/ff.c   **** 		for (;;) {
2006:lib/ff/ff.c   **** 			res = create_name(dj, &path);	/* Get a segment */
2007:lib/ff/ff.c   **** 			if (res != FR_OK) break;
2008:lib/ff/ff.c   **** 			res = dir_find(dj);				/* Find it */
2009:lib/ff/ff.c   **** 			ns = *(dj->fn+NS);
2010:lib/ff/ff.c   **** 			if (res != FR_OK) {				/* Failed to find the object */
2011:lib/ff/ff.c   **** 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
2012:lib/ff/ff.c   **** 				/* Object not found */
2013:lib/ff/ff.c   **** 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
2014:lib/ff/ff.c   **** 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
2015:lib/ff/ff.c   **** 					res = FR_OK;
2016:lib/ff/ff.c   **** 					if (!(ns & NS_LAST)) continue;
2017:lib/ff/ff.c   **** 				} else {							/* Could not find the object */
2018:lib/ff/ff.c   **** 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
2019:lib/ff/ff.c   **** 				}
2020:lib/ff/ff.c   **** 				break;
2021:lib/ff/ff.c   **** 			}
2022:lib/ff/ff.c   **** 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
2023:lib/ff/ff.c   **** 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
2024:lib/ff/ff.c   **** 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
2025:lib/ff/ff.c   **** 				res = FR_NO_PATH; break;
2026:lib/ff/ff.c   **** 			}
2027:lib/ff/ff.c   **** 			dj->sclust = ld_clust(dj->fs, dir);
2028:lib/ff/ff.c   **** 		}
2029:lib/ff/ff.c   **** 	}
2030:lib/ff/ff.c   **** 
2031:lib/ff/ff.c   **** 	return res;
2032:lib/ff/ff.c   **** }
2033:lib/ff/ff.c   **** 
2034:lib/ff/ff.c   **** 
2035:lib/ff/ff.c   **** 
2036:lib/ff/ff.c   **** 
2037:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2038:lib/ff/ff.c   **** /* Load a sector and check if it is an FAT Volume Boot Record            */
2039:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2040:lib/ff/ff.c   **** 
2041:lib/ff/ff.c   **** static
2042:lib/ff/ff.c   **** BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
2043:lib/ff/ff.c   **** 	FATFS *fs,	/* File system object */
2044:lib/ff/ff.c   **** 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
2045:lib/ff/ff.c   **** )
2046:lib/ff/ff.c   **** {
2047:lib/ff/ff.c   **** 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
2048:lib/ff/ff.c   **** 		return 3;
2049:lib/ff/ff.c   **** 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 
2050:lib/ff/ff.c   **** 		return 2;
2051:lib/ff/ff.c   **** 
2052:lib/ff/ff.c   **** 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
2053:lib/ff/ff.c   **** 		return 0;
2054:lib/ff/ff.c   **** 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
2055:lib/ff/ff.c   **** 		return 0;
2056:lib/ff/ff.c   **** 
2057:lib/ff/ff.c   **** 	return 1;
2058:lib/ff/ff.c   **** }
2059:lib/ff/ff.c   **** 
2060:lib/ff/ff.c   **** 
2061:lib/ff/ff.c   **** 
2062:lib/ff/ff.c   **** 
2063:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2064:lib/ff/ff.c   **** /* Check if the file system object is valid or not                       */
2065:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2066:lib/ff/ff.c   **** 
2067:lib/ff/ff.c   **** static
2068:lib/ff/ff.c   **** FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
2069:lib/ff/ff.c   **** 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
2070:lib/ff/ff.c   **** 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
2071:lib/ff/ff.c   **** 	BYTE wmode			/* !=0: Check write protection for write access */
2072:lib/ff/ff.c   **** )
2073:lib/ff/ff.c   **** {
2074:lib/ff/ff.c   **** 	BYTE fmt, b, pi, *tbl;
2075:lib/ff/ff.c   **** 	UINT vol;
2076:lib/ff/ff.c   **** 	DSTATUS stat;
2077:lib/ff/ff.c   **** 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
2078:lib/ff/ff.c   **** 	WORD nrsv;
2079:lib/ff/ff.c   **** 	const TCHAR *p = *path;
2080:lib/ff/ff.c   **** 	FATFS *fs;
2081:lib/ff/ff.c   **** 
2082:lib/ff/ff.c   **** 
2083:lib/ff/ff.c   **** 	/* Get logical drive number from the path name */
2084:lib/ff/ff.c   **** 	vol = p[0] - '0';					/* Is there a drive number? */
2085:lib/ff/ff.c   **** 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
2086:lib/ff/ff.c   **** 		p += 2; *path = p;				/* Return pointer to the path name */
2087:lib/ff/ff.c   **** 	} else {							/* No drive number, use default drive */
2088:lib/ff/ff.c   **** #if _FS_RPATH
2089:lib/ff/ff.c   **** 		vol = CurrVol;					/* Use current drive */
2090:lib/ff/ff.c   **** #else
2091:lib/ff/ff.c   **** 		vol = 0;						/* Use drive 0 */
2092:lib/ff/ff.c   **** #endif
2093:lib/ff/ff.c   **** 	}
2094:lib/ff/ff.c   **** 
2095:lib/ff/ff.c   **** 	/* Check if the file system object is valid or not */
2096:lib/ff/ff.c   **** 	*rfs = 0;
2097:lib/ff/ff.c   **** 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
2098:lib/ff/ff.c   **** 		return FR_INVALID_DRIVE;
2099:lib/ff/ff.c   **** 	fs = FatFs[vol];					/* Get corresponding file system object */
2100:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
2101:lib/ff/ff.c   **** 
2102:lib/ff/ff.c   **** 	ENTER_FF(fs);						/* Lock volume */
2103:lib/ff/ff.c   **** 
2104:lib/ff/ff.c   **** 	*rfs = fs;							/* Return pointer to the corresponding file system object */
2105:lib/ff/ff.c   **** 	if (fs->fs_type) {					/* If the volume has been mounted */
2106:lib/ff/ff.c   **** 		stat = disk_status(fs->drv);
2107:lib/ff/ff.c   **** 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed)
2108:lib/ff/ff.c   **** 			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
2109:lib/ff/ff.c   **** 				return FR_WRITE_PROTECTED;
2110:lib/ff/ff.c   **** 			return FR_OK;				/* The file system object is valid */
2111:lib/ff/ff.c   **** 		}
2112:lib/ff/ff.c   **** 	}
2113:lib/ff/ff.c   **** 
2114:lib/ff/ff.c   **** 	/* The file system object is not valid. */
2115:lib/ff/ff.c   **** 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
2116:lib/ff/ff.c   **** 
2117:lib/ff/ff.c   **** 	fs->fs_type = 0;					/* Clear the file system object */
2118:lib/ff/ff.c   **** 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
2119:lib/ff/ff.c   **** 	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
2120:lib/ff/ff.c   **** 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
2121:lib/ff/ff.c   **** 		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
2122:lib/ff/ff.c   **** 	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
2123:lib/ff/ff.c   **** 		return FR_WRITE_PROTECTED;
2124:lib/ff/ff.c   **** #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
2125:lib/ff/ff.c   **** 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
2126:lib/ff/ff.c   **** 		return FR_DISK_ERR;
2127:lib/ff/ff.c   **** #endif
2128:lib/ff/ff.c   **** 	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
2129:lib/ff/ff.c   **** 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
2130:lib/ff/ff.c   **** 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
2131:lib/ff/ff.c   **** 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
2132:lib/ff/ff.c   **** 		/* Check the partition listed in the partition table */
2133:lib/ff/ff.c   **** 		pi = LD2PT(vol);
2134:lib/ff/ff.c   **** 		if (pi) pi--;
2135:lib/ff/ff.c   **** 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2136:lib/ff/ff.c   **** 		if (tbl[4]) {						/* Is the partition existing? */
2137:lib/ff/ff.c   **** 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
2138:lib/ff/ff.c   **** 			fmt = check_fs(fs, bsect);		/* Check the partition */
2139:lib/ff/ff.c   **** 		}
2140:lib/ff/ff.c   **** 	}
2141:lib/ff/ff.c   **** 	if (fmt == 3) return FR_DISK_ERR;
2142:lib/ff/ff.c   **** 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
2143:lib/ff/ff.c   **** 
2144:lib/ff/ff.c   **** 	/* An FAT volume is found. Following code initializes the file system object */
2145:lib/ff/ff.c   **** 
2146:lib/ff/ff.c   **** 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical s
2147:lib/ff/ff.c   **** 		return FR_NO_FILESYSTEM;
2148:lib/ff/ff.c   **** 
2149:lib/ff/ff.c   **** 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
2150:lib/ff/ff.c   **** 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
2151:lib/ff/ff.c   **** 	fs->fsize = fasize;
2152:lib/ff/ff.c   **** 
2153:lib/ff/ff.c   **** 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
2154:lib/ff/ff.c   **** 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
2155:lib/ff/ff.c   **** 	fasize *= b;										/* Number of sectors for FAT area */
2156:lib/ff/ff.c   **** 
2157:lib/ff/ff.c   **** 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
2158:lib/ff/ff.c   **** 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
2159:lib/ff/ff.c   **** 
2160:lib/ff/ff.c   **** 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
2161:lib/ff/ff.c   **** 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector 
2162:lib/ff/ff.c   **** 
2163:lib/ff/ff.c   **** 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
2164:lib/ff/ff.c   **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
2165:lib/ff/ff.c   **** 
2166:lib/ff/ff.c   **** 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
2167:lib/ff/ff.c   **** 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
2168:lib/ff/ff.c   **** 
2169:lib/ff/ff.c   **** 	/* Determine the FAT sub type */
2170:lib/ff/ff.c   **** 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
2171:lib/ff/ff.c   **** 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
2172:lib/ff/ff.c   **** 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
2173:lib/ff/ff.c   **** 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
2174:lib/ff/ff.c   **** 	fmt = FS_FAT12;
2175:lib/ff/ff.c   **** 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
2176:lib/ff/ff.c   **** 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
2177:lib/ff/ff.c   **** 
2178:lib/ff/ff.c   **** 	/* Boundaries and Limits */
2179:lib/ff/ff.c   **** 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
2180:lib/ff/ff.c   **** 	fs->volbase = bsect;								/* Volume start sector */
2181:lib/ff/ff.c   **** 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
2182:lib/ff/ff.c   **** 	fs->database = bsect + sysect;						/* Data start sector */
2183:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
2184:lib/ff/ff.c   **** 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
2185:lib/ff/ff.c   **** 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
2186:lib/ff/ff.c   **** 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
2187:lib/ff/ff.c   **** 	} else {
2188:lib/ff/ff.c   **** 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
2189:lib/ff/ff.c   **** 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
2190:lib/ff/ff.c   **** 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
2191:lib/ff/ff.c   **** 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
2192:lib/ff/ff.c   **** 	}
2193:lib/ff/ff.c   **** 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
2194:lib/ff/ff.c   **** 		return FR_NO_FILESYSTEM;
2195:lib/ff/ff.c   **** 
2196:lib/ff/ff.c   **** #if !_FS_READONLY
2197:lib/ff/ff.c   **** 	/* Initialize cluster allocation information */
2198:lib/ff/ff.c   **** 	fs->free_clust = 0xFFFFFFFF;
2199:lib/ff/ff.c   **** 	fs->last_clust = 0;
2200:lib/ff/ff.c   **** 
2201:lib/ff/ff.c   **** 	/* Get fsinfo if available */
2202:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
2203:lib/ff/ff.c   **** 	 	fs->fsi_flag = 0;
2204:lib/ff/ff.c   **** 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
2205:lib/ff/ff.c   **** 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
2206:lib/ff/ff.c   **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
2207:lib/ff/ff.c   **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
2208:lib/ff/ff.c   **** 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
2209:lib/ff/ff.c   **** 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
2210:lib/ff/ff.c   **** 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
2211:lib/ff/ff.c   **** 		}
2212:lib/ff/ff.c   **** 	}
2213:lib/ff/ff.c   **** #endif
2214:lib/ff/ff.c   **** 	fs->fs_type = fmt;		/* FAT sub-type */
2215:lib/ff/ff.c   **** 	fs->id = ++Fsid;		/* File system mount ID */
2216:lib/ff/ff.c   **** 	fs->winsect = 0;		/* Invalidate sector cache */
2217:lib/ff/ff.c   **** 	fs->wflag = 0;
2218:lib/ff/ff.c   **** #if _FS_RPATH
2219:lib/ff/ff.c   **** 	fs->cdir = 0;			/* Current directory (root dir) */
2220:lib/ff/ff.c   **** #endif
2221:lib/ff/ff.c   **** #if _FS_LOCK				/* Clear file lock semaphores */
2222:lib/ff/ff.c   **** 	clear_lock(fs);
2223:lib/ff/ff.c   **** #endif
2224:lib/ff/ff.c   **** 
2225:lib/ff/ff.c   **** 	return FR_OK;
2226:lib/ff/ff.c   **** }
2227:lib/ff/ff.c   **** 
2228:lib/ff/ff.c   **** 
2229:lib/ff/ff.c   **** 
2230:lib/ff/ff.c   **** 
2231:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2232:lib/ff/ff.c   **** /* Check if the file/dir object is valid or not                          */
2233:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2234:lib/ff/ff.c   **** 
2235:lib/ff/ff.c   **** static
2236:lib/ff/ff.c   **** FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
2237:lib/ff/ff.c   **** 	void* obj		/* Pointer to the object FIL/DIR to check validity */
2238:lib/ff/ff.c   **** )
2239:lib/ff/ff.c   **** {
 281              		.loc 1 2239 0
 282              		.cfi_startproc
 283              		@ args = 0, pretend = 0, frame = 0
 284              		@ frame_needed = 0, uses_anonymous_args = 0
 285              	.LVL39:
 286 0000 08B5     		push	{r3, lr}
 287              	.LCFI2:
 288              		.cfi_def_cfa_offset 8
 289              		.cfi_offset 3, -8
 290              		.cfi_offset 14, -4
 291              	.LVL40:
2240:lib/ff/ff.c   **** 	FIL *fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
2241:lib/ff/ff.c   **** 
2242:lib/ff/ff.c   **** 
2243:lib/ff/ff.c   **** 	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 292              		.loc 1 2243 0
 293 0002 80B1     		cbz	r0, .L45
 294              		.loc 1 2243 0 is_stmt 0 discriminator 1
 295 0004 0368     		ldr	r3, [r0, #0]
 296 0006 73B1     		cbz	r3, .L45
 297 0008 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 298 000a 62B1     		cbz	r2, .L45
 299 000c D988     		ldrh	r1, [r3, #6]
 300 000e 8088     		ldrh	r0, [r0, #4]
 301              	.LVL41:
 302 0010 8142     		cmp	r1, r0
 303 0012 08D1     		bne	.L45
2244:lib/ff/ff.c   **** 		return FR_INVALID_OBJECT;
2245:lib/ff/ff.c   **** 
2246:lib/ff/ff.c   **** 	ENTER_FF(fil->fs);		/* Lock file system */
2247:lib/ff/ff.c   **** 
2248:lib/ff/ff.c   **** 	if (disk_status(fil->fs->drv) & STA_NOINIT)
 304              		.loc 1 2248 0 is_stmt 1
 305 0014 5878     		ldrb	r0, [r3, #1]	@ zero_extendqisi2
 306 0016 FFF7FEFF 		bl	disk_status
 307              	.LVL42:
 308 001a 10F0010F 		tst	r0, #1
2249:lib/ff/ff.c   **** 		return FR_NOT_READY;
 309              		.loc 1 2249 0
 310 001e 0CBF     		ite	eq
 311 0020 0020     		moveq	r0, #0
 312 0022 0320     		movne	r0, #3
 313 0024 08BD     		pop	{r3, pc}
 314              	.L45:
2244:lib/ff/ff.c   **** 		return FR_INVALID_OBJECT;
 315              		.loc 1 2244 0
 316 0026 0920     		movs	r0, #9
2250:lib/ff/ff.c   **** 
2251:lib/ff/ff.c   **** 	return FR_OK;
2252:lib/ff/ff.c   **** }
 317              		.loc 1 2252 0
 318 0028 08BD     		pop	{r3, pc}
 319              		.cfi_endproc
 320              	.LFE27:
 322              		.section	.text.sync_window,"ax",%progbits
 323              		.align	1
 324              		.thumb
 325              		.thumb_func
 327              	sync_window:
 328              	.LFB4:
 735:lib/ff/ff.c   **** 	DWORD wsect;
 329              		.loc 1 735 0
 330              		.cfi_startproc
 331              		@ args = 0, pretend = 0, frame = 0
 332              		@ frame_needed = 0, uses_anonymous_args = 0
 333              	.LVL43:
 334 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 335              	.LCFI3:
 336              		.cfi_def_cfa_offset 24
 337              		.cfi_offset 3, -24
 338              		.cfi_offset 4, -20
 339              		.cfi_offset 5, -16
 340              		.cfi_offset 6, -12
 341              		.cfi_offset 7, -8
 342              		.cfi_offset 14, -4
 343 0002 0446     		mov	r4, r0
 740:lib/ff/ff.c   **** 		wsect = fs->winsect;	/* Current sector number */
 344              		.loc 1 740 0
 345 0004 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 346              	.LVL44:
 347 0006 08B3     		cbz	r0, .L48
 348              	.LVL45:
 349              	.LBB17:
 350              	.LBB18:
 741:lib/ff/ff.c   **** 		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 351              		.loc 1 741 0
 352 0008 656B     		ldr	r5, [r4, #52]
 353              	.LVL46:
 742:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 354              		.loc 1 742 0
 355 000a 04F13807 		add	r7, r4, #56
 356 000e 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 357 0010 3946     		mov	r1, r7
 358 0012 2A46     		mov	r2, r5
 359 0014 0123     		movs	r3, #1
 360 0016 FFF7FEFF 		bl	disk_write
 361              	.LVL47:
 362 001a B0B9     		cbnz	r0, .L55
 744:lib/ff/ff.c   **** 		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 363              		.loc 1 744 0
 364 001c 2071     		strb	r0, [r4, #4]
 745:lib/ff/ff.c   **** 			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 365              		.loc 1 745 0
 366 001e A36A     		ldr	r3, [r4, #40]
 367 0020 9D42     		cmp	r5, r3
 368 0022 01D2     		bcs	.L50
 369              	.L51:
 752:lib/ff/ff.c   **** }
 370              		.loc 1 752 0
 371 0024 0020     		movs	r0, #0
 372 0026 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 373              	.L50:
 745:lib/ff/ff.c   **** 			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 374              		.loc 1 745 0
 375 0028 226A     		ldr	r2, [r4, #32]
 376 002a 9818     		adds	r0, r3, r2
 377 002c 8542     		cmp	r5, r0
 378 002e F9D2     		bcs	.L51
 746:lib/ff/ff.c   **** 				wsect += fs->fsize;
 379              		.loc 1 746 0
 380 0030 E678     		ldrb	r6, [r4, #3]	@ zero_extendqisi2
 381              	.LVL48:
 382              	.L52:
 383 0032 012E     		cmp	r6, #1
 384 0034 F6D9     		bls	.L51
 385              	.L53:
 747:lib/ff/ff.c   **** 				disk_write(fs->drv, fs->win, wsect, 1);
 386              		.loc 1 747 0
 387 0036 216A     		ldr	r1, [r4, #32]
 388 0038 6D18     		adds	r5, r5, r1
 389              	.LVL49:
 748:lib/ff/ff.c   **** 			}
 390              		.loc 1 748 0
 391 003a 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 392 003c 3946     		mov	r1, r7
 393 003e 2A46     		mov	r2, r5
 394 0040 0123     		movs	r3, #1
 395 0042 FFF7FEFF 		bl	disk_write
 396              	.LVL50:
 746:lib/ff/ff.c   **** 				wsect += fs->fsize;
 397              		.loc 1 746 0
 398 0046 013E     		subs	r6, r6, #1
 399              	.LVL51:
 400 0048 F3E7     		b	.L52
 401              	.LVL52:
 402              	.L55:
 743:lib/ff/ff.c   **** 		fs->wflag = 0;
 403              		.loc 1 743 0
 404 004a 0120     		movs	r0, #1
 405              	.LVL53:
 406              	.L48:
 407              	.LBE18:
 408              	.LBE17:
 753:lib/ff/ff.c   **** #endif
 409              		.loc 1 753 0
 410 004c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 411              		.cfi_endproc
 412              	.LFE4:
 414              		.section	.text.sync_fs,"ax",%progbits
 415              		.align	1
 416              		.thumb
 417              		.thumb_func
 419              	sync_fs:
 420              	.LFB6:
 787:lib/ff/ff.c   **** 	FRESULT res;
 421              		.loc 1 787 0
 422              		.cfi_startproc
 423              		@ args = 0, pretend = 0, frame = 0
 424              		@ frame_needed = 0, uses_anonymous_args = 0
 425              	.LVL54:
 426 0000 70B5     		push	{r4, r5, r6, lr}
 427              	.LCFI4:
 428              		.cfi_def_cfa_offset 16
 429              		.cfi_offset 4, -16
 430              		.cfi_offset 5, -12
 431              		.cfi_offset 6, -8
 432              		.cfi_offset 14, -4
 433 0002 0446     		mov	r4, r0
 791:lib/ff/ff.c   **** 	if (res == FR_OK) {
 434              		.loc 1 791 0
 435 0004 FFF7FEFF 		bl	sync_window
 436              	.LVL55:
 437 0008 0546     		mov	r5, r0
 438              	.LVL56:
 792:lib/ff/ff.c   **** 		/* Update FSInfo sector if needed */
 439              		.loc 1 792 0
 440 000a 5DBB     		cbnz	r5, .L57
 794:lib/ff/ff.c   **** 			fs->winsect = 0;
 441              		.loc 1 794 0
 442 000c 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 443 000e 032B     		cmp	r3, #3
 444 0010 20D1     		bne	.L58
 794:lib/ff/ff.c   **** 			fs->winsect = 0;
 445              		.loc 1 794 0 is_stmt 0 discriminator 1
 446 0012 6079     		ldrb	r0, [r4, #5]	@ zero_extendqisi2
 447              	.LVL57:
 448 0014 F0B1     		cbz	r0, .L58
 795:lib/ff/ff.c   **** 			/* Create FSInfo structure */
 449              		.loc 1 795 0 is_stmt 1
 450 0016 6563     		str	r5, [r4, #52]
 797:lib/ff/ff.c   **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);
 451              		.loc 1 797 0
 452 0018 04F13806 		add	r6, r4, #56
 453 001c 3046     		mov	r0, r6
 454 001e 2946     		mov	r1, r5
 455 0020 4FF40072 		mov	r2, #512
 456 0024 FFF7FEFF 		bl	mem_set
 457              	.LVL58:
 798:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 458              		.loc 1 798 0
 459 0028 4AF65521 		movw	r1, #43605
 460 002c A4F83612 		strh	r1, [r4, #566]	@ movhi
 799:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 461              		.loc 1 799 0
 462 0030 0D4A     		ldr	r2, .L62
 463 0032 A263     		str	r2, [r4, #56]
 800:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 464              		.loc 1 800 0
 465 0034 0D4B     		ldr	r3, .L62+4
 466 0036 C4F81C32 		str	r3, [r4, #540]
 801:lib/ff/ff.c   **** 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 467              		.loc 1 801 0
 468 003a 2069     		ldr	r0, [r4, #16]
 469 003c C4F82002 		str	r0, [r4, #544]
 802:lib/ff/ff.c   **** 			/* Write it into the FSInfo sector */
 470              		.loc 1 802 0
 471 0040 E168     		ldr	r1, [r4, #12]
 472 0042 C4F82412 		str	r1, [r4, #548]
 804:lib/ff/ff.c   **** 			fs->fsi_flag = 0;
 473              		.loc 1 804 0
 474 0046 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 475 0048 3146     		mov	r1, r6
 476 004a 6269     		ldr	r2, [r4, #20]
 477 004c 0123     		movs	r3, #1
 478 004e FFF7FEFF 		bl	disk_write
 479              	.LVL59:
 805:lib/ff/ff.c   **** 		}
 480              		.loc 1 805 0
 481 0052 6571     		strb	r5, [r4, #5]
 482              	.L58:
 808:lib/ff/ff.c   **** 			res = FR_DISK_ERR;
 483              		.loc 1 808 0
 484 0054 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 485 0056 0021     		movs	r1, #0
 486 0058 0A46     		mov	r2, r1
 487 005a FFF7FEFF 		bl	disk_ioctl
 488              	.LVL60:
 489 005e 0030     		adds	r0, r0, #0
 490 0060 18BF     		it	ne
 491 0062 0120     		movne	r0, #1
 492              	.L57:
 493              	.LVL61:
 813:lib/ff/ff.c   **** #endif
 494              		.loc 1 813 0
 495 0064 70BD     		pop	{r4, r5, r6, pc}
 496              	.L63:
 497 0066 00BF     		.align	2
 498              	.L62:
 499 0068 52526141 		.word	1096897106
 500 006c 72724161 		.word	1631679090
 501              		.cfi_endproc
 502              	.LFE6:
 504              		.section	.text.move_window,"ax",%progbits
 505              		.align	1
 506              		.thumb
 507              		.thumb_func
 509              	move_window:
 510              	.LFB5:
 762:lib/ff/ff.c   **** 	if (sector != fs->winsect) {	/* Changed current window */
 511              		.loc 1 762 0
 512              		.cfi_startproc
 513              		@ args = 0, pretend = 0, frame = 0
 514              		@ frame_needed = 0, uses_anonymous_args = 0
 515              	.LVL62:
 516 0000 38B5     		push	{r3, r4, r5, lr}
 517              	.LCFI5:
 518              		.cfi_def_cfa_offset 16
 519              		.cfi_offset 3, -16
 520              		.cfi_offset 4, -12
 521              		.cfi_offset 5, -8
 522              		.cfi_offset 14, -4
 523 0002 0446     		mov	r4, r0
 524 0004 0D46     		mov	r5, r1
 763:lib/ff/ff.c   **** #if !_FS_READONLY
 525              		.loc 1 763 0
 526 0006 436B     		ldr	r3, [r0, #52]
 527 0008 9942     		cmp	r1, r3
 528 000a 0CD0     		beq	.L67
 765:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 529              		.loc 1 765 0
 530 000c FFF7FEFF 		bl	sync_window
 531              	.LVL63:
 532 0010 58B9     		cbnz	r0, .L68
 533              	.LVL64:
 534              	.LBB21:
 535              	.LBB22:
 768:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 536              		.loc 1 768 0
 537 0012 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 538 0014 04F13801 		add	r1, r4, #56
 539 0018 2A46     		mov	r2, r5
 540 001a 0123     		movs	r3, #1
 541 001c FFF7FEFF 		bl	disk_read
 542              	.LVL65:
 543 0020 18B9     		cbnz	r0, .L68
 770:lib/ff/ff.c   **** 	}
 544              		.loc 1 770 0
 545 0022 6563     		str	r5, [r4, #52]
 546 0024 38BD     		pop	{r3, r4, r5, pc}
 547              	.LVL66:
 548              	.L67:
 549              	.LBE22:
 550              	.LBE21:
 773:lib/ff/ff.c   **** }
 551              		.loc 1 773 0
 552 0026 0020     		movs	r0, #0
 553              	.LVL67:
 554 0028 38BD     		pop	{r3, r4, r5, pc}
 555              	.LVL68:
 556              	.L68:
 766:lib/ff/ff.c   **** #endif
 557              		.loc 1 766 0
 558 002a 0120     		movs	r0, #1
 774:lib/ff/ff.c   **** 
 559              		.loc 1 774 0
 560 002c 38BD     		pop	{r3, r4, r5, pc}
 561              		.cfi_endproc
 562              	.LFE5:
 564              		.section	.text.check_fs,"ax",%progbits
 565              		.align	1
 566              		.thumb
 567              		.thumb_func
 569              	check_fs:
 570              	.LFB25:
2046:lib/ff/ff.c   **** 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 571              		.loc 1 2046 0
 572              		.cfi_startproc
 573              		@ args = 0, pretend = 0, frame = 0
 574              		@ frame_needed = 0, uses_anonymous_args = 0
 575              	.LVL69:
 576 0000 10B5     		push	{r4, lr}
 577              	.LCFI6:
 578              		.cfi_def_cfa_offset 8
 579              		.cfi_offset 4, -8
 580              		.cfi_offset 14, -4
 581 0002 0446     		mov	r4, r0
 582 0004 0A46     		mov	r2, r1
2047:lib/ff/ff.c   **** 		return 3;
 583              		.loc 1 2047 0
 584 0006 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 585              	.LVL70:
 586 0008 04F13801 		add	r1, r4, #56
 587              	.LVL71:
 588 000c 0123     		movs	r3, #1
 589 000e FFF7FEFF 		bl	disk_read
 590              	.LVL72:
 591 0012 A0B9     		cbnz	r0, .L72
2049:lib/ff/ff.c   **** 		return 2;
 592              		.loc 1 2049 0
 593 0014 B4F83622 		ldrh	r2, [r4, #566]
 594 0018 4AF65523 		movw	r3, #43605
 595 001c 9A42     		cmp	r2, r3
 596 001e 10D1     		bne	.L73
2052:lib/ff/ff.c   **** 		return 0;
 597              		.loc 1 2052 0
 598 0020 D4F86E10 		ldr	r1, [r4, #110]
 599 0024 21F07F42 		bic	r2, r1, #-16777216
 600 0028 074B     		ldr	r3, .L75
 601 002a 9A42     		cmp	r2, r3
 602 002c 0AD0     		beq	.L71
 603              	.LVL73:
 604              	.LBB25:
 605              	.LBB26:
2054:lib/ff/ff.c   **** 		return 0;
 606              		.loc 1 2054 0
 607 002e D4F88A00 		ldr	r0, [r4, #138]
 608 0032 20F07F41 		bic	r1, r0, #-16777216
 609              	.LBE26:
 610              	.LBE25:
2055:lib/ff/ff.c   **** 
 611              		.loc 1 2055 0
 612 0036 C81A     		subs	r0, r1, r3
 613 0038 18BF     		it	ne
 614 003a 0120     		movne	r0, #1
 615 003c 10BD     		pop	{r4, pc}
 616              	.LVL74:
 617              	.L72:
2048:lib/ff/ff.c   **** 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 
 618              		.loc 1 2048 0
 619 003e 0320     		movs	r0, #3
 620 0040 10BD     		pop	{r4, pc}
 621              	.L73:
2050:lib/ff/ff.c   **** 
 622              		.loc 1 2050 0
 623 0042 0220     		movs	r0, #2
 624              	.L71:
2058:lib/ff/ff.c   **** 
 625              		.loc 1 2058 0
 626 0044 10BD     		pop	{r4, pc}
 627              	.L76:
 628 0046 00BF     		.align	2
 629              	.L75:
 630 0048 46415400 		.word	5521734
 631              		.cfi_endproc
 632              	.LFE25:
 634              		.section	.text.chk_mounted,"ax",%progbits
 635              		.align	1
 636              		.thumb
 637              		.thumb_func
 639              	chk_mounted:
 640              	.LFB26:
2073:lib/ff/ff.c   **** 	BYTE fmt, b, pi, *tbl;
 641              		.loc 1 2073 0
 642              		.cfi_startproc
 643              		@ args = 0, pretend = 0, frame = 0
 644              		@ frame_needed = 0, uses_anonymous_args = 0
 645              	.LVL75:
 646 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 647              	.LCFI7:
 648              		.cfi_def_cfa_offset 24
 649              		.cfi_offset 4, -24
 650              		.cfi_offset 5, -20
 651              		.cfi_offset 6, -16
 652              		.cfi_offset 7, -12
 653              		.cfi_offset 8, -8
 654              		.cfi_offset 14, -4
 655 0004 1546     		mov	r5, r2
2079:lib/ff/ff.c   **** 	FATFS *fs;
 656              		.loc 1 2079 0
 657 0006 0268     		ldr	r2, [r0, #0]
 658              	.LVL76:
2084:lib/ff/ff.c   **** 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 659              		.loc 1 2084 0
 660 0008 92F90030 		ldrsb	r3, [r2, #0]
 661 000c 303B     		subs	r3, r3, #48
 662              	.LVL77:
2085:lib/ff/ff.c   **** 		p += 2; *path = p;				/* Return pointer to the path name */
 663              		.loc 1 2085 0
 664 000e 092B     		cmp	r3, #9
 665 0010 06D8     		bhi	.L78
2085:lib/ff/ff.c   **** 		p += 2; *path = p;				/* Return pointer to the path name */
 666              		.loc 1 2085 0 is_stmt 0 discriminator 1
 667 0012 92F90140 		ldrsb	r4, [r2, #1]
 668 0016 3A2C     		cmp	r4, #58
 669 0018 02D1     		bne	.L78
 670              	.LVL78:
2086:lib/ff/ff.c   **** 	} else {							/* No drive number, use default drive */
 671              		.loc 1 2086 0 is_stmt 1
 672 001a 0232     		adds	r2, r2, #2
 673              	.LVL79:
 674 001c 0260     		str	r2, [r0, #0]
 675 001e 01E0     		b	.L79
 676              	.L78:
2089:lib/ff/ff.c   **** #else
 677              		.loc 1 2089 0
 678 0020 784B     		ldr	r3, .L124
 679              	.LVL80:
 680 0022 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 681              	.LVL81:
 682              	.L79:
2096:lib/ff/ff.c   **** 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 683              		.loc 1 2096 0
 684 0024 0020     		movs	r0, #0
 685              	.LVL82:
 686 0026 0860     		str	r0, [r1, #0]
2097:lib/ff/ff.c   **** 		return FR_INVALID_DRIVE;
 687              		.loc 1 2097 0
 688 0028 002B     		cmp	r3, #0
 689 002a 40F0D880 		bne	.L96
2099:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 690              		.loc 1 2099 0
 691 002e 764C     		ldr	r4, .L124+4
 692 0030 2468     		ldr	r4, [r4, #0]
 693              	.LVL83:
2100:lib/ff/ff.c   **** 
 694              		.loc 1 2100 0
 695 0032 002C     		cmp	r4, #0
 696 0034 00F0D680 		beq	.L97
2104:lib/ff/ff.c   **** 	if (fs->fs_type) {					/* If the volume has been mounted */
 697              		.loc 1 2104 0
 698 0038 0C60     		str	r4, [r1, #0]
2105:lib/ff/ff.c   **** 		stat = disk_status(fs->drv);
 699              		.loc 1 2105 0
 700 003a 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 701              	.LVL84:
 702 003c 81B1     		cbz	r1, .L81
2106:lib/ff/ff.c   **** 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed)
 703              		.loc 1 2106 0
 704 003e 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 705 0040 FFF7FEFF 		bl	disk_status
 706              	.LVL85:
2107:lib/ff/ff.c   **** 			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 707              		.loc 1 2107 0
 708 0044 C307     		lsls	r3, r0, #31
 709 0046 0BD4     		bmi	.L81
2108:lib/ff/ff.c   **** 				return FR_WRITE_PROTECTED;
 710              		.loc 1 2108 0
 711 0048 002D     		cmp	r5, #0
 712 004a 00F0CE80 		beq	.L98
2108:lib/ff/ff.c   **** 				return FR_WRITE_PROTECTED;
 713              		.loc 1 2108 0 is_stmt 0 discriminator 1
 714 004e 00F00402 		and	r2, r0, #4
 715 0052 D3B2     		uxtb	r3, r2
2109:lib/ff/ff.c   **** 			return FR_OK;				/* The file system object is valid */
 716              		.loc 1 2109 0 is_stmt 1 discriminator 1
 717 0054 002B     		cmp	r3, #0
 718 0056 14BF     		ite	ne
 719 0058 0A20     		movne	r0, #10
 720 005a 0020     		moveq	r0, #0
 721              	.LVL86:
 722 005c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 723              	.L81:
2117:lib/ff/ff.c   **** 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 724              		.loc 1 2117 0
 725 0060 0020     		movs	r0, #0
 726 0062 2070     		strb	r0, [r4, #0]
2118:lib/ff/ff.c   **** 	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 727              		.loc 1 2118 0
 728 0064 6070     		strb	r0, [r4, #1]
2119:lib/ff/ff.c   **** 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 729              		.loc 1 2119 0
 730 0066 FFF7FEFF 		bl	disk_initialize
 731              	.LVL87:
2120:lib/ff/ff.c   **** 		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 732              		.loc 1 2120 0
 733 006a C107     		lsls	r1, r0, #31
 734 006c 00F1C080 		bmi	.L100
2122:lib/ff/ff.c   **** 		return FR_WRITE_PROTECTED;
 735              		.loc 1 2122 0
 736 0070 2DB1     		cbz	r5, .L82
2122:lib/ff/ff.c   **** 		return FR_WRITE_PROTECTED;
 737              		.loc 1 2122 0 is_stmt 0 discriminator 1
 738 0072 00F00403 		and	r3, r0, #4
 739 0076 DAB2     		uxtb	r2, r3
 740 0078 002A     		cmp	r2, #0
 741 007a 40F0BC80 		bne	.L101
 742              	.L82:
 743              	.LVL88:
2129:lib/ff/ff.c   **** 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
 744              		.loc 1 2129 0 is_stmt 1
 745 007e 2046     		mov	r0, r4
 746              	.LVL89:
 747 0080 0021     		movs	r1, #0
 748 0082 FFF7FEFF 		bl	check_fs
 749              	.LVL90:
2131:lib/ff/ff.c   **** 		/* Check the partition listed in the partition table */
 750              		.loc 1 2131 0
 751 0086 0128     		cmp	r0, #1
 752 0088 0CD1     		bne	.L102
 753              	.LVL91:
2136:lib/ff/ff.c   **** 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 754              		.loc 1 2136 0
 755 008a 94F8FA01 		ldrb	r0, [r4, #506]	@ zero_extendqisi2
 756              	.LVL92:
 757 008e 10B9     		cbnz	r0, .L84
 758              	.LVL93:
 759              	.L85:
2142:lib/ff/ff.c   **** 
 760              		.loc 1 2142 0
 761 0090 0D20     		movs	r0, #13
 762 0092 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 763              	.LVL94:
 764              	.L84:
2137:lib/ff/ff.c   **** 			fmt = check_fs(fs, bsect);		/* Check the partition */
 765              		.loc 1 2137 0
 766 0096 D4F8FE51 		ldr	r5, [r4, #510]
 767              	.LVL95:
2138:lib/ff/ff.c   **** 		}
 768              		.loc 1 2138 0
 769 009a 2046     		mov	r0, r4
 770 009c 2946     		mov	r1, r5
 771 009e FFF7FEFF 		bl	check_fs
 772              	.LVL96:
 773 00a2 00E0     		b	.L83
 774              	.LVL97:
 775              	.L102:
2129:lib/ff/ff.c   **** 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
 776              		.loc 1 2129 0
 777 00a4 0025     		movs	r5, #0
 778              	.LVL98:
 779              	.L83:
2141:lib/ff/ff.c   **** 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 780              		.loc 1 2141 0
 781 00a6 0328     		cmp	r0, #3
 782 00a8 00F0A880 		beq	.L103
2142:lib/ff/ff.c   **** 
 783              		.loc 1 2142 0
 784 00ac 0028     		cmp	r0, #0
 785 00ae EFD1     		bne	.L85
2146:lib/ff/ff.c   **** 		return FR_NO_FILESYSTEM;
 786              		.loc 1 2146 0
 787 00b0 B4F84310 		ldrh	r1, [r4, #67]
 788 00b4 B1F5007F 		cmp	r1, #512
 789 00b8 EAD1     		bne	.L85
2149:lib/ff/ff.c   **** 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 790              		.loc 1 2149 0
 791 00ba B4F84E30 		ldrh	r3, [r4, #78]
 792              	.LVL99:
2150:lib/ff/ff.c   **** 	fs->fsize = fasize;
 793              		.loc 1 2150 0
 794 00be 03B9     		cbnz	r3, .L86
2150:lib/ff/ff.c   **** 	fs->fsize = fasize;
 795              		.loc 1 2150 0 is_stmt 0 discriminator 1
 796 00c0 E36D     		ldr	r3, [r4, #92]
 797              	.LVL100:
 798              	.L86:
2151:lib/ff/ff.c   **** 
 799              		.loc 1 2151 0 is_stmt 1
 800 00c2 2362     		str	r3, [r4, #32]
2153:lib/ff/ff.c   **** 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 801              		.loc 1 2153 0
 802 00c4 94F84860 		ldrb	r6, [r4, #72]	@ zero_extendqisi2
 803              	.LVL101:
 804 00c8 E670     		strb	r6, [r4, #3]
2154:lib/ff/ff.c   **** 	fasize *= b;										/* Number of sectors for FAT area */
 805              		.loc 1 2154 0
 806 00ca 721E     		subs	r2, r6, #1
 807 00cc 012A     		cmp	r2, #1
 808 00ce DFD8     		bhi	.L85
 809              	.LVL102:
2157:lib/ff/ff.c   **** 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 810              		.loc 1 2157 0
 811 00d0 94F84500 		ldrb	r0, [r4, #69]	@ zero_extendqisi2
 812              	.LVL103:
 813 00d4 A070     		strb	r0, [r4, #2]
2158:lib/ff/ff.c   **** 
 814              		.loc 1 2158 0
 815 00d6 0028     		cmp	r0, #0
 816 00d8 DAD0     		beq	.L85
2158:lib/ff/ff.c   **** 
 817              		.loc 1 2158 0 is_stmt 0 discriminator 2
 818 00da 411E     		subs	r1, r0, #1
 819 00dc 0142     		tst	r1, r0
 820 00de D7D1     		bne	.L85
2160:lib/ff/ff.c   **** 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector 
 821              		.loc 1 2160 0 is_stmt 1
 822 00e0 B4F84910 		ldrh	r1, [r4, #73]
 823 00e4 2181     		strh	r1, [r4, #8]	@ movhi
2161:lib/ff/ff.c   **** 
 824              		.loc 1 2161 0
 825 00e6 0A07     		lsls	r2, r1, #28
 826 00e8 D2D1     		bne	.L85
2163:lib/ff/ff.c   **** 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 827              		.loc 1 2163 0
 828 00ea B4F84B20 		ldrh	r2, [r4, #75]
 829              	.LVL104:
2164:lib/ff/ff.c   **** 
 830              		.loc 1 2164 0
 831 00ee 02B9     		cbnz	r2, .L87
2164:lib/ff/ff.c   **** 
 832              		.loc 1 2164 0 is_stmt 0 discriminator 1
 833 00f0 A26D     		ldr	r2, [r4, #88]
 834              	.LVL105:
 835              	.L87:
2166:lib/ff/ff.c   **** 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 836              		.loc 1 2166 0 is_stmt 1
 837 00f2 B4F846C0 		ldrh	ip, [r4, #70]
 838              	.LVL106:
2167:lib/ff/ff.c   **** 
 839              		.loc 1 2167 0
 840 00f6 BCF1000F 		cmp	ip, #0
 841 00fa C9D0     		beq	.L85
2155:lib/ff/ff.c   **** 
 842              		.loc 1 2155 0
 843 00fc 06FB03F8 		mul	r8, r6, r3
2170:lib/ff/ff.c   **** 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 844              		.loc 1 2170 0
 845 0100 0CEB1117 		add	r7, ip, r1, lsr #4
 846 0104 4744     		add	r7, r7, r8
 847              	.LVL107:
2171:lib/ff/ff.c   **** 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 848              		.loc 1 2171 0
 849 0106 BA42     		cmp	r2, r7
 850 0108 C2D3     		bcc	.L85
2172:lib/ff/ff.c   **** 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 851              		.loc 1 2172 0
 852 010a D21B     		subs	r2, r2, r7
 853              	.LVL108:
 854 010c B2FBF0F2 		udiv	r2, r2, r0
 855              	.LVL109:
2173:lib/ff/ff.c   **** 	fmt = FS_FAT12;
 856              		.loc 1 2173 0
 857 0110 002A     		cmp	r2, #0
 858 0112 BDD0     		beq	.L85
 859              	.LVL110:
2175:lib/ff/ff.c   **** 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 860              		.loc 1 2175 0
 861 0114 40F6F576 		movw	r6, #4085
 862              	.LVL111:
 863 0118 B242     		cmp	r2, r6
 864 011a 06D9     		bls	.L104
 865              	.LVL112:
 866 011c 4FF6F570 		movw	r0, #65525
 867 0120 8242     		cmp	r2, r0
 868 0122 8CBF     		ite	hi
 869 0124 0326     		movhi	r6, #3
 870 0126 0226     		movls	r6, #2
 871 0128 00E0     		b	.L89
 872              	.LVL113:
 873              	.L104:
2174:lib/ff/ff.c   **** 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 874              		.loc 1 2174 0
 875 012a 0126     		movs	r6, #1
 876              	.LVL114:
 877              	.L89:
2179:lib/ff/ff.c   **** 	fs->volbase = bsect;								/* Volume start sector */
 878              		.loc 1 2179 0
 879 012c 0232     		adds	r2, r2, #2
 880              	.LVL115:
 881 012e E261     		str	r2, [r4, #28]
2180:lib/ff/ff.c   **** 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 882              		.loc 1 2180 0
 883 0130 6562     		str	r5, [r4, #36]
2181:lib/ff/ff.c   **** 	fs->database = bsect + sysect;						/* Data start sector */
 884              		.loc 1 2181 0
 885 0132 05EB0C00 		add	r0, r5, ip
 886 0136 A062     		str	r0, [r4, #40]
2182:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
 887              		.loc 1 2182 0
 888 0138 7F19     		adds	r7, r7, r5
 889              	.LVL116:
 890 013a 2763     		str	r7, [r4, #48]
2183:lib/ff/ff.c   **** 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 891              		.loc 1 2183 0
 892 013c 032E     		cmp	r6, #3
 893 013e 05D1     		bne	.L90
2184:lib/ff/ff.c   **** 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 894              		.loc 1 2184 0
 895 0140 0029     		cmp	r1, #0
 896 0142 A5D1     		bne	.L85
2185:lib/ff/ff.c   **** 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 897              		.loc 1 2185 0
 898 0144 606E     		ldr	r0, [r4, #100]
 899 0146 E062     		str	r0, [r4, #44]
2186:lib/ff/ff.c   **** 	} else {
 900              		.loc 1 2186 0
 901 0148 9100     		lsls	r1, r2, #2
 902              	.LVL117:
 903 014a 0EE0     		b	.L91
 904              	.LVL118:
 905              	.L90:
2188:lib/ff/ff.c   **** 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 906              		.loc 1 2188 0
 907 014c 0029     		cmp	r1, #0
 908 014e 9FD0     		beq	.L85
2189:lib/ff/ff.c   **** 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
 909              		.loc 1 2189 0
 910 0150 08EB0001 		add	r1, r8, r0
 911              	.LVL119:
 912 0154 E162     		str	r1, [r4, #44]
2191:lib/ff/ff.c   **** 	}
 913              		.loc 1 2191 0
 914 0156 022E     		cmp	r6, #2
 915 0158 01D1     		bne	.L92
2191:lib/ff/ff.c   **** 	}
 916              		.loc 1 2191 0 is_stmt 0 discriminator 1
 917 015a 5100     		lsls	r1, r2, #1
 918 015c 05E0     		b	.L91
 919              	.L92:
2191:lib/ff/ff.c   **** 	}
 920              		.loc 1 2191 0 discriminator 2
 921 015e 0320     		movs	r0, #3
 922 0160 5043     		muls	r0, r2, r0
 923 0162 02F00102 		and	r2, r2, #1
 924              	.LVL120:
 925 0166 02EB5001 		add	r1, r2, r0, lsr #1
 926              	.L91:
 927              	.LVL121:
2193:lib/ff/ff.c   **** 		return FR_NO_FILESYSTEM;
 928              		.loc 1 2193 0 is_stmt 1
 929 016a 01F2FF12 		addw	r2, r1, #511
 930 016e B3EB522F 		cmp	r3, r2, lsr #9
 931 0172 8DD3     		bcc	.L85
2198:lib/ff/ff.c   **** 	fs->last_clust = 0;
 932              		.loc 1 2198 0
 933 0174 4FF0FF33 		mov	r3, #-1
 934              	.LVL122:
 935 0178 2361     		str	r3, [r4, #16]
2199:lib/ff/ff.c   **** 
 936              		.loc 1 2199 0
 937 017a 0021     		movs	r1, #0
 938              	.LVL123:
 939 017c E160     		str	r1, [r4, #12]
2202:lib/ff/ff.c   **** 	 	fs->fsi_flag = 0;
 940              		.loc 1 2202 0
 941 017e 032E     		cmp	r6, #3
 942 0180 20D1     		bne	.L94
2203:lib/ff/ff.c   **** 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 943              		.loc 1 2203 0
 944 0182 6171     		strb	r1, [r4, #5]
2204:lib/ff/ff.c   **** 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 945              		.loc 1 2204 0
 946 0184 B4F86800 		ldrh	r0, [r4, #104]
 947 0188 2A18     		adds	r2, r5, r0
 948              	.LVL124:
 949 018a 6261     		str	r2, [r4, #20]
2205:lib/ff/ff.c   **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 950              		.loc 1 2205 0
 951 018c 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 952 018e 04F13801 		add	r1, r4, #56
 953 0192 0123     		movs	r3, #1
 954 0194 FFF7FEFF 		bl	disk_read
 955              	.LVL125:
 956 0198 A0B9     		cbnz	r0, .L94
2205:lib/ff/ff.c   **** 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 957              		.loc 1 2205 0 is_stmt 0 discriminator 1
 958 019a B4F83622 		ldrh	r2, [r4, #566]
 959 019e 4AF65523 		movw	r3, #43605
 960 01a2 9A42     		cmp	r2, r3
 961 01a4 0ED1     		bne	.L94
2206:lib/ff/ff.c   **** 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 962              		.loc 1 2206 0 is_stmt 1
 963 01a6 A16B     		ldr	r1, [r4, #56]
 964 01a8 1848     		ldr	r0, .L124+8
 965 01aa 8142     		cmp	r1, r0
 966 01ac 0AD1     		bne	.L94
2207:lib/ff/ff.c   **** 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
 967              		.loc 1 2207 0
 968 01ae D4F81C32 		ldr	r3, [r4, #540]
 969 01b2 174A     		ldr	r2, .L124+12
 970 01b4 9342     		cmp	r3, r2
 971 01b6 05D1     		bne	.L94
2209:lib/ff/ff.c   **** 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 972              		.loc 1 2209 0
 973 01b8 D4F82412 		ldr	r1, [r4, #548]
 974 01bc E160     		str	r1, [r4, #12]
2210:lib/ff/ff.c   **** 		}
 975              		.loc 1 2210 0
 976 01be D4F82002 		ldr	r0, [r4, #544]
 977 01c2 2061     		str	r0, [r4, #16]
 978              	.L94:
2214:lib/ff/ff.c   **** 	fs->id = ++Fsid;		/* File system mount ID */
 979              		.loc 1 2214 0
 980 01c4 2670     		strb	r6, [r4, #0]
2215:lib/ff/ff.c   **** 	fs->winsect = 0;		/* Invalidate sector cache */
 981              		.loc 1 2215 0
 982 01c6 134A     		ldr	r2, .L124+16
 983 01c8 1388     		ldrh	r3, [r2, #0]
 984 01ca 591C     		adds	r1, r3, #1
 985 01cc 88B2     		uxth	r0, r1
 986 01ce 1080     		strh	r0, [r2, #0]	@ movhi
 987 01d0 E080     		strh	r0, [r4, #6]	@ movhi
2216:lib/ff/ff.c   **** 	fs->wflag = 0;
 988              		.loc 1 2216 0
 989 01d2 0020     		movs	r0, #0
 990 01d4 6063     		str	r0, [r4, #52]
2217:lib/ff/ff.c   **** #if _FS_RPATH
 991              		.loc 1 2217 0
 992 01d6 2071     		strb	r0, [r4, #4]
2219:lib/ff/ff.c   **** #endif
 993              		.loc 1 2219 0
 994 01d8 A061     		str	r0, [r4, #24]
2225:lib/ff/ff.c   **** }
 995              		.loc 1 2225 0
 996 01da BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 997              	.LVL126:
 998              	.L96:
2098:lib/ff/ff.c   **** 	fs = FatFs[vol];					/* Get corresponding file system object */
 999              		.loc 1 2098 0
 1000 01de 0B20     		movs	r0, #11
 1001 01e0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1002              	.LVL127:
 1003              	.L97:
2100:lib/ff/ff.c   **** 
 1004              		.loc 1 2100 0
 1005 01e4 0C20     		movs	r0, #12
 1006 01e6 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1007              	.LVL128:
 1008              	.L98:
2110:lib/ff/ff.c   **** 		}
 1009              		.loc 1 2110 0
 1010 01ea 2846     		mov	r0, r5
 1011              	.LVL129:
 1012 01ec BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1013              	.LVL130:
 1014              	.L100:
2121:lib/ff/ff.c   **** 	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 1015              		.loc 1 2121 0
 1016 01f0 0320     		movs	r0, #3
 1017              	.LVL131:
 1018 01f2 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1019              	.LVL132:
 1020              	.L101:
2123:lib/ff/ff.c   **** #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
 1021              		.loc 1 2123 0
 1022 01f6 0A20     		movs	r0, #10
 1023              	.LVL133:
 1024 01f8 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1025              	.LVL134:
 1026              	.L103:
2141:lib/ff/ff.c   **** 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 1027              		.loc 1 2141 0
 1028 01fc 0120     		movs	r0, #1
 1029              	.LVL135:
2226:lib/ff/ff.c   **** 
 1030              		.loc 1 2226 0
 1031 01fe BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1032              	.L125:
 1033 0202 00BF     		.align	2
 1034              	.L124:
 1035 0204 00000000 		.word	.LANCHOR0
 1036 0208 00000000 		.word	.LANCHOR1
 1037 020c 52526141 		.word	1096897106
 1038 0210 72724161 		.word	1631679090
 1039 0214 00000000 		.word	.LANCHOR2
 1040              		.cfi_endproc
 1041              	.LFE26:
 1043              		.section	.text.clust2sect,"ax",%progbits
 1044              		.align	1
 1045              		.global	clust2sect
 1046              		.thumb
 1047              		.thumb_func
 1049              	clust2sect:
 1050              	.LFB7:
 828:lib/ff/ff.c   **** 	clst -= 2;
 1051              		.loc 1 828 0
 1052              		.cfi_startproc
 1053              		@ args = 0, pretend = 0, frame = 0
 1054              		@ frame_needed = 0, uses_anonymous_args = 0
 1055              		@ link register save eliminated.
 1056              	.LVL136:
 829:lib/ff/ff.c   **** 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 1057              		.loc 1 829 0
 1058 0000 0239     		subs	r1, r1, #2
 1059              	.LVL137:
 830:lib/ff/ff.c   **** 	return clst * fs->csize + fs->database;
 1060              		.loc 1 830 0
 1061 0002 C369     		ldr	r3, [r0, #28]
 1062 0004 9A1E     		subs	r2, r3, #2
 1063 0006 9142     		cmp	r1, r2
 1064 0008 04D2     		bcs	.L128
 831:lib/ff/ff.c   **** }
 1065              		.loc 1 831 0
 1066 000a 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 1067 000c 006B     		ldr	r0, [r0, #48]
 1068              	.LVL138:
 1069 000e 02FB0100 		mla	r0, r2, r1, r0
 1070 0012 7047     		bx	lr
 1071              	.LVL139:
 1072              	.L128:
 830:lib/ff/ff.c   **** 	return clst * fs->csize + fs->database;
 1073              		.loc 1 830 0
 1074 0014 0020     		movs	r0, #0
 1075              	.LVL140:
 832:lib/ff/ff.c   **** 
 1076              		.loc 1 832 0
 1077 0016 7047     		bx	lr
 1078              		.cfi_endproc
 1079              	.LFE7:
 1081              		.section	.text.get_fat,"ax",%progbits
 1082              		.align	1
 1083              		.global	get_fat
 1084              		.thumb
 1085              		.thumb_func
 1087              	get_fat:
 1088              	.LFB8:
 846:lib/ff/ff.c   **** 	UINT wc, bc;
 1089              		.loc 1 846 0
 1090              		.cfi_startproc
 1091              		@ args = 0, pretend = 0, frame = 0
 1092              		@ frame_needed = 0, uses_anonymous_args = 0
 1093              	.LVL141:
 1094 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1095              	.LCFI8:
 1096              		.cfi_def_cfa_offset 24
 1097              		.cfi_offset 3, -24
 1098              		.cfi_offset 4, -20
 1099              		.cfi_offset 5, -16
 1100              		.cfi_offset 6, -12
 1101              		.cfi_offset 7, -8
 1102              		.cfi_offset 14, -4
 1103 0002 0446     		mov	r4, r0
 1104 0004 0D46     		mov	r5, r1
 851:lib/ff/ff.c   **** 		return 1;
 1105              		.loc 1 851 0
 1106 0006 0129     		cmp	r1, #1
 1107 0008 48D9     		bls	.L139
 851:lib/ff/ff.c   **** 		return 1;
 1108              		.loc 1 851 0 is_stmt 0 discriminator 1
 1109 000a C369     		ldr	r3, [r0, #28]
 1110 000c 9942     		cmp	r1, r3
 1111 000e 45D2     		bcs	.L139
 1112              	.LVL142:
 1113              	.LBB29:
 1114              	.LBB30:
 854:lib/ff/ff.c   **** 	case FS_FAT12 :
 1115              		.loc 1 854 0 is_stmt 1
 1116 0010 0178     		ldrb	r1, [r0, #0]	@ zero_extendqisi2
 1117              	.LVL143:
 1118 0012 0229     		cmp	r1, #2
 1119 0014 27D0     		beq	.L133
 1120 0016 0329     		cmp	r1, #3
 1121 0018 30D0     		beq	.L134
 1122 001a 0129     		cmp	r1, #1
 1123 001c 3BD1     		bne	.L141
 1124              	.LVL144:
 856:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 1125              		.loc 1 856 0
 1126 001e 05EB5506 		add	r6, r5, r5, lsr #1
 1127              	.LVL145:
 857:lib/ff/ff.c   **** 		wc = fs->win[bc % SS(fs)]; bc++;
 1128              		.loc 1 857 0
 1129 0022 826A     		ldr	r2, [r0, #40]
 1130 0024 02EB5621 		add	r1, r2, r6, lsr #9
 1131 0028 FFF7FEFF 		bl	move_window
 1132              	.LVL146:
 1133 002c 0028     		cmp	r0, #0
 1134 002e 32D1     		bne	.L141
 1135              	.L135:
 858:lib/ff/ff.c   **** 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 1136              		.loc 1 858 0
 1137 0030 F005     		lsls	r0, r6, #23
 1138 0032 04EBD057 		add	r7, r4, r0, lsr #23
 1139 0036 97F83870 		ldrb	r7, [r7, #56]	@ zero_extendqisi2
 1140              	.LVL147:
 1141 003a 0136     		adds	r6, r6, #1
 1142              	.LVL148:
 859:lib/ff/ff.c   **** 		wc |= fs->win[bc % SS(fs)] << 8;
 1143              		.loc 1 859 0
 1144 003c A36A     		ldr	r3, [r4, #40]
 1145 003e 2046     		mov	r0, r4
 1146 0040 03EB5621 		add	r1, r3, r6, lsr #9
 1147 0044 FFF7FEFF 		bl	move_window
 1148              	.LVL149:
 1149 0048 28BB     		cbnz	r0, .L141
 860:lib/ff/ff.c   **** 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 1150              		.loc 1 860 0
 1151 004a F605     		lsls	r6, r6, #23
 1152              	.LVL150:
 1153 004c 04EBD654 		add	r4, r4, r6, lsr #23
 1154              	.LVL151:
 1155 0050 94F83810 		ldrb	r1, [r4, #56]	@ zero_extendqisi2
 1156 0054 47EA0120 		orr	r0, r7, r1, lsl #8
 1157              	.LVL152:
 861:lib/ff/ff.c   **** 
 1158              		.loc 1 861 0
 1159 0058 EA07     		lsls	r2, r5, #31
 1160 005a 01D5     		bpl	.L137
 1161 005c 0009     		lsrs	r0, r0, #4
 1162              	.LVL153:
 1163 005e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1164              	.LVL154:
 1165              	.L137:
 1166 0060 0205     		lsls	r2, r0, #20
 1167 0062 100D     		lsrs	r0, r2, #20
 1168              	.LVL155:
 1169 0064 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1170              	.LVL156:
 1171              	.L133:
 864:lib/ff/ff.c   **** 		p = &fs->win[clst * 2 % SS(fs)];
 1172              		.loc 1 864 0
 1173 0066 826A     		ldr	r2, [r0, #40]
 1174 0068 02EB1521 		add	r1, r2, r5, lsr #8
 1175 006c FFF7FEFF 		bl	move_window
 1176              	.LVL157:
 1177 0070 88B9     		cbnz	r0, .L141
 1178              	.LVL158:
 865:lib/ff/ff.c   **** 		return LD_WORD(p);
 1179              		.loc 1 865 0
 1180 0072 2D06     		lsls	r5, r5, #24
 1181              	.LVL159:
 1182 0074 04EBD554 		add	r4, r4, r5, lsr #23
 1183              	.LVL160:
 866:lib/ff/ff.c   **** 
 1184              		.loc 1 866 0
 1185 0078 208F     		ldrh	r0, [r4, #56]
 1186 007a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1187              	.LVL161:
 1188              	.L134:
 869:lib/ff/ff.c   **** 		p = &fs->win[clst * 4 % SS(fs)];
 1189              		.loc 1 869 0
 1190 007c 836A     		ldr	r3, [r0, #40]
 1191 007e 03EBD511 		add	r1, r3, r5, lsr #7
 1192 0082 FFF7FEFF 		bl	move_window
 1193              	.LVL162:
 1194 0086 30B9     		cbnz	r0, .L141
 1195              	.LVL163:
 870:lib/ff/ff.c   **** 		return LD_DWORD(p) & 0x0FFFFFFF;
 1196              		.loc 1 870 0
 1197 0088 6D06     		lsls	r5, r5, #25
 1198              	.LVL164:
 1199 008a 04EBD554 		add	r4, r4, r5, lsr #23
 1200              	.LVL165:
 871:lib/ff/ff.c   **** 	}
 1201              		.loc 1 871 0
 1202 008e A16B     		ldr	r1, [r4, #56]
 1203 0090 21F07040 		bic	r0, r1, #-268435456
 1204 0094 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1205              	.LVL166:
 1206              	.L141:
 874:lib/ff/ff.c   **** }
 1207              		.loc 1 874 0
 1208 0096 4FF0FF30 		mov	r0, #-1
 1209 009a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1210              	.LVL167:
 1211              	.L139:
 1212              	.LBE30:
 1213              	.LBE29:
 852:lib/ff/ff.c   **** 
 1214              		.loc 1 852 0
 1215 009c 0120     		movs	r0, #1
 1216              	.LVL168:
 875:lib/ff/ff.c   **** 
 1217              		.loc 1 875 0
 1218 009e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1219              		.cfi_endproc
 1220              	.LFE8:
 1222              		.section	.text.dir_sdi,"ax",%progbits
 1223              		.align	1
 1224              		.thumb
 1225              		.thumb_func
 1227              	dir_sdi:
 1228              	.LFB13:
1092:lib/ff/ff.c   **** 	DWORD clst;
 1229              		.loc 1 1092 0
 1230              		.cfi_startproc
 1231              		@ args = 0, pretend = 0, frame = 0
 1232              		@ frame_needed = 0, uses_anonymous_args = 0
 1233              	.LVL169:
 1234 0000 70B5     		push	{r4, r5, r6, lr}
 1235              	.LCFI9:
 1236              		.cfi_def_cfa_offset 16
 1237              		.cfi_offset 4, -16
 1238              		.cfi_offset 5, -12
 1239              		.cfi_offset 6, -8
 1240              		.cfi_offset 14, -4
 1241 0002 0446     		mov	r4, r0
 1242 0004 0D46     		mov	r5, r1
1097:lib/ff/ff.c   **** 	clst = dj->sclust;
 1243              		.loc 1 1097 0
 1244 0006 E180     		strh	r1, [r4, #6]	@ movhi
1098:lib/ff/ff.c   **** 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
 1245              		.loc 1 1098 0
 1246 0008 8168     		ldr	r1, [r0, #8]
 1247              	.LVL170:
1099:lib/ff/ff.c   **** 		return FR_INT_ERR;
 1248              		.loc 1 1099 0
 1249 000a 0129     		cmp	r1, #1
 1250 000c 01D1     		bne	.L143
 1251              	.LVL171:
 1252              	.L145:
1100:lib/ff/ff.c   **** 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 1253              		.loc 1 1100 0
 1254 000e 0220     		movs	r0, #2
 1255 0010 70BD     		pop	{r4, r5, r6, pc}
 1256              	.LVL172:
 1257              	.L143:
1099:lib/ff/ff.c   **** 		return FR_INT_ERR;
 1258              		.loc 1 1099 0 discriminator 1
 1259 0012 0368     		ldr	r3, [r0, #0]
 1260 0014 DA69     		ldr	r2, [r3, #28]
 1261 0016 9142     		cmp	r1, r2
 1262 0018 F9D2     		bcs	.L145
1101:lib/ff/ff.c   **** 		clst = dj->fs->dirbase;
 1263              		.loc 1 1101 0
 1264 001a 71B9     		cbnz	r1, .L146
1101:lib/ff/ff.c   **** 		clst = dj->fs->dirbase;
 1265              		.loc 1 1101 0 is_stmt 0 discriminator 1
 1266 001c 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 1267              	.LVL173:
 1268 001e 0328     		cmp	r0, #3
 1269 0020 01D1     		bne	.L147
1102:lib/ff/ff.c   **** 
 1270              		.loc 1 1102 0 is_stmt 1
 1271 0022 D96A     		ldr	r1, [r3, #44]
 1272              	.LVL174:
1104:lib/ff/ff.c   **** 		dj->clust = clst;
 1273              		.loc 1 1104 0
 1274 0024 49B9     		cbnz	r1, .L146
 1275              	.L147:
1105:lib/ff/ff.c   **** 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 1276              		.loc 1 1105 0
 1277 0026 0020     		movs	r0, #0
 1278 0028 E060     		str	r0, [r4, #12]
1106:lib/ff/ff.c   **** 			return FR_INT_ERR;
 1279              		.loc 1 1106 0
 1280 002a 1989     		ldrh	r1, [r3, #8]
 1281              	.LVL175:
 1282 002c A942     		cmp	r1, r5
 1283 002e EED9     		bls	.L145
1108:lib/ff/ff.c   **** 	}
 1284              		.loc 1 1108 0
 1285 0030 DB6A     		ldr	r3, [r3, #44]
 1286 0032 03EB1512 		add	r2, r3, r5, lsr #4
 1287 0036 2261     		str	r2, [r4, #16]
 1288 0038 19E0     		b	.L148
 1289              	.LVL176:
 1290              	.L146:
1111:lib/ff/ff.c   **** 		while (idx >= ic) {	/* Follow cluster chain */
 1291              		.loc 1 1111 0
 1292 003a 9E78     		ldrb	r6, [r3, #2]	@ zero_extendqisi2
 1293 003c 3601     		lsls	r6, r6, #4
 1294              	.LVL177:
 1295              	.L149:
1112:lib/ff/ff.c   **** 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 1296              		.loc 1 1112 0 discriminator 1
 1297 003e B542     		cmp	r5, r6
 1298 0040 0ED3     		bcc	.L152
 1299              	.L150:
1113:lib/ff/ff.c   **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1300              		.loc 1 1113 0
 1301 0042 2068     		ldr	r0, [r4, #0]
 1302 0044 FFF7FEFF 		bl	get_fat
 1303              	.LVL178:
 1304 0048 0146     		mov	r1, r0
 1305              	.LVL179:
1114:lib/ff/ff.c   **** 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
 1306              		.loc 1 1114 0
 1307 004a 0130     		adds	r0, r0, #1
 1308              	.LVL180:
 1309 004c 18D0     		beq	.L151
1115:lib/ff/ff.c   **** 				return FR_INT_ERR;
 1310              		.loc 1 1115 0
 1311 004e 0129     		cmp	r1, #1
 1312 0050 DDD9     		bls	.L145
1115:lib/ff/ff.c   **** 				return FR_INT_ERR;
 1313              		.loc 1 1115 0 is_stmt 0 discriminator 1
 1314 0052 2368     		ldr	r3, [r4, #0]
 1315 0054 DA69     		ldr	r2, [r3, #28]
 1316 0056 9142     		cmp	r1, r2
 1317 0058 D9D2     		bcs	.L145
1117:lib/ff/ff.c   **** 		}
 1318              		.loc 1 1117 0 is_stmt 1
 1319 005a AD1B     		subs	r5, r5, r6
 1320              	.LVL181:
 1321 005c ADB2     		uxth	r5, r5
 1322              	.LVL182:
 1323 005e EEE7     		b	.L149
 1324              	.L152:
1119:lib/ff/ff.c   **** 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 1325              		.loc 1 1119 0
 1326 0060 E160     		str	r1, [r4, #12]
1120:lib/ff/ff.c   **** 	}
 1327              		.loc 1 1120 0
 1328 0062 2068     		ldr	r0, [r4, #0]
 1329 0064 FFF7FEFF 		bl	clust2sect
 1330              	.LVL183:
 1331 0068 00EB1511 		add	r1, r0, r5, lsr #4
 1332 006c 2161     		str	r1, [r4, #16]
 1333              	.LVL184:
 1334              	.L148:
1123:lib/ff/ff.c   **** 
 1335              		.loc 1 1123 0
 1336 006e 05F00F05 		and	r5, r5, #15
 1337              	.LVL185:
 1338 0072 6D01     		lsls	r5, r5, #5
 1339 0074 3835     		adds	r5, r5, #56
 1340 0076 2068     		ldr	r0, [r4, #0]
 1341 0078 4119     		adds	r1, r0, r5
 1342 007a 6161     		str	r1, [r4, #20]
1125:lib/ff/ff.c   **** }
 1343              		.loc 1 1125 0
 1344 007c 0020     		movs	r0, #0
 1345 007e 70BD     		pop	{r4, r5, r6, pc}
 1346              	.LVL186:
 1347              	.L151:
1114:lib/ff/ff.c   **** 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
 1348              		.loc 1 1114 0
 1349 0080 0120     		movs	r0, #1
1126:lib/ff/ff.c   **** 
 1350              		.loc 1 1126 0
 1351 0082 70BD     		pop	{r4, r5, r6, pc}
 1352              		.cfi_endproc
 1353              	.LFE13:
 1355              		.section	.text.dir_remove,"ax",%progbits
 1356              		.align	1
 1357              		.thumb
 1358              		.thumb_func
 1360              	dir_remove:
 1361              	.LFB21:
1646:lib/ff/ff.c   **** 	FRESULT res;
 1362              		.loc 1 1646 0
 1363              		.cfi_startproc
 1364              		@ args = 0, pretend = 0, frame = 0
 1365              		@ frame_needed = 0, uses_anonymous_args = 0
 1366              	.LVL187:
 1367 0000 10B5     		push	{r4, lr}
 1368              	.LCFI10:
 1369              		.cfi_def_cfa_offset 8
 1370              		.cfi_offset 4, -8
 1371              		.cfi_offset 14, -4
 1372 0002 0446     		mov	r4, r0
1666:lib/ff/ff.c   **** 	if (res == FR_OK) {
 1373              		.loc 1 1666 0
 1374 0004 C188     		ldrh	r1, [r0, #6]
 1375 0006 FFF7FEFF 		bl	dir_sdi
 1376              	.LVL188:
1667:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
 1377              		.loc 1 1667 0
 1378 000a 50B9     		cbnz	r0, .L154
 1379              	.LVL189:
 1380              	.LBB33:
 1381              	.LBB34:
1668:lib/ff/ff.c   **** 		if (res == FR_OK) {
 1382              		.loc 1 1668 0
 1383 000c 2068     		ldr	r0, [r4, #0]
 1384              	.LVL190:
 1385 000e 2169     		ldr	r1, [r4, #16]
 1386 0010 FFF7FEFF 		bl	move_window
 1387              	.LVL191:
1669:lib/ff/ff.c   **** 			*dj->dir = DDE;			/* Mark the entry "deleted" */
 1388              		.loc 1 1669 0
 1389 0014 28B9     		cbnz	r0, .L154
1670:lib/ff/ff.c   **** 			dj->fs->wflag = 1;
 1390              		.loc 1 1670 0
 1391 0016 6369     		ldr	r3, [r4, #20]
 1392 0018 E522     		movs	r2, #229
 1393 001a 1A70     		strb	r2, [r3, #0]
1671:lib/ff/ff.c   **** 		}
 1394              		.loc 1 1671 0
 1395 001c 2168     		ldr	r1, [r4, #0]
 1396 001e 0123     		movs	r3, #1
 1397 0020 0B71     		strb	r3, [r1, #4]
 1398              	.LVL192:
 1399              	.L154:
 1400              	.LBE34:
 1401              	.LBE33:
1677:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
 1402              		.loc 1 1677 0
 1403 0022 10BD     		pop	{r4, pc}
 1404              		.cfi_endproc
 1405              	.LFE21:
 1407              		.section	.text.put_fat,"ax",%progbits
 1408              		.align	1
 1409              		.global	put_fat
 1410              		.thumb
 1411              		.thumb_func
 1413              	put_fat:
 1414              	.LFB9:
 890:lib/ff/ff.c   **** 	UINT bc;
 1415              		.loc 1 890 0
 1416              		.cfi_startproc
 1417              		@ args = 0, pretend = 0, frame = 0
 1418              		@ frame_needed = 0, uses_anonymous_args = 0
 1419              	.LVL193:
 1420 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1421              	.LCFI11:
 1422              		.cfi_def_cfa_offset 24
 1423              		.cfi_offset 3, -24
 1424              		.cfi_offset 4, -20
 1425              		.cfi_offset 5, -16
 1426              		.cfi_offset 6, -12
 1427              		.cfi_offset 7, -8
 1428              		.cfi_offset 14, -4
 1429 0002 0446     		mov	r4, r0
 1430 0004 0D46     		mov	r5, r1
 1431 0006 1646     		mov	r6, r2
 896:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 1432              		.loc 1 896 0
 1433 0008 0129     		cmp	r1, #1
 1434 000a 5DD9     		bls	.L167
 896:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 1435              		.loc 1 896 0 is_stmt 0 discriminator 1
 1436 000c C369     		ldr	r3, [r0, #28]
 1437 000e 9942     		cmp	r1, r3
 1438 0010 5AD2     		bcs	.L167
 1439              	.LVL194:
 1440              	.LBB37:
 1441              	.LBB38:
 900:lib/ff/ff.c   **** 		case FS_FAT12 :
 1442              		.loc 1 900 0 is_stmt 1
 1443 0012 0178     		ldrb	r1, [r0, #0]	@ zero_extendqisi2
 1444              	.LVL195:
 1445 0014 0229     		cmp	r1, #2
 1446 0016 39D0     		beq	.L160
 1447 0018 0329     		cmp	r1, #3
 1448 001a 42D0     		beq	.L161
 1449 001c 0129     		cmp	r1, #1
 1450 001e 4FD1     		bne	.L169
 1451              	.LVL196:
 902:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 1452              		.loc 1 902 0
 1453 0020 05EB5507 		add	r7, r5, r5, lsr #1
 1454              	.LVL197:
 903:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 1455              		.loc 1 903 0
 1456 0024 826A     		ldr	r2, [r0, #40]
 1457              	.LVL198:
 1458 0026 02EB5721 		add	r1, r2, r7, lsr #9
 1459 002a FFF7FEFF 		bl	move_window
 1460              	.LVL199:
 904:lib/ff/ff.c   **** 			p = &fs->win[bc % SS(fs)];
 1461              		.loc 1 904 0
 1462 002e 0028     		cmp	r0, #0
 1463 0030 47D1     		bne	.L158
 905:lib/ff/ff.c   **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 1464              		.loc 1 905 0
 1465 0032 F805     		lsls	r0, r7, #23
 1466              	.LVL200:
 1467 0034 C20D     		lsrs	r2, r0, #23
 1468              	.LVL201:
 906:lib/ff/ff.c   **** 			bc++;
 1469              		.loc 1 906 0
 1470 0036 15F00105 		ands	r5, r5, #1
 1471              	.LVL202:
 1472 003a F3B2     		uxtb	r3, r6
 1473 003c 07D0     		beq	.L163
 1474 003e A118     		adds	r1, r4, r2
 1475              	.LBE38:
 1476 0040 91F83800 		ldrb	r0, [r1, #56]	@ zero_extendqisi2
 1477 0044 00F00F01 		and	r1, r0, #15
 1478              	.LBB39:
 1479 0048 41EA0313 		orr	r3, r1, r3, lsl #4
 1480 004c DBB2     		uxtb	r3, r3
 1481              	.L163:
 1482 004e A218     		adds	r2, r4, r2
 1483              	.LVL203:
 1484 0050 82F83830 		strb	r3, [r2, #56]
 907:lib/ff/ff.c   **** 			fs->wflag = 1;
 1485              		.loc 1 907 0
 1486 0054 0137     		adds	r7, r7, #1
 1487              	.LVL204:
 908:lib/ff/ff.c   **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 1488              		.loc 1 908 0
 1489 0056 0120     		movs	r0, #1
 1490 0058 2071     		strb	r0, [r4, #4]
 909:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 1491              		.loc 1 909 0
 1492 005a A16A     		ldr	r1, [r4, #40]
 1493 005c 2046     		mov	r0, r4
 1494 005e 01EB5721 		add	r1, r1, r7, lsr #9
 1495 0062 FFF7FEFF 		bl	move_window
 1496              	.LVL205:
 910:lib/ff/ff.c   **** 			p = &fs->win[bc % SS(fs)];
 1497              		.loc 1 910 0
 1498 0066 60BB     		cbnz	r0, .L158
 911:lib/ff/ff.c   **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 1499              		.loc 1 911 0
 1500 0068 FF05     		lsls	r7, r7, #23
 1501              	.LVL206:
 1502 006a FA0D     		lsrs	r2, r7, #23
 1503              	.LVL207:
 912:lib/ff/ff.c   **** 			break;
 1504              		.loc 1 912 0
 1505 006c 15B1     		cbz	r5, .L164
 1506 006e C6F30716 		ubfx	r6, r6, #4, #8
 1507              	.LVL208:
 1508 0072 07E0     		b	.L165
 1509              	.LVL209:
 1510              	.L164:
 1511 0074 A318     		adds	r3, r4, r2
 1512 0076 93F83810 		ldrb	r1, [r3, #56]	@ zero_extendqisi2
 1513 007a 21F00F07 		bic	r7, r1, #15
 1514              	.LBE39:
 1515 007e C6F30326 		ubfx	r6, r6, #8, #4
 1516              	.LVL210:
 1517              	.LBB40:
 1518 0082 3E43     		orrs	r6, r6, r7
 1519              	.L165:
 1520 0084 A718     		adds	r7, r4, r2
 1521 0086 87F83860 		strb	r6, [r7, #56]
 1522 008a 1AE0     		b	.L158
 1523              	.LVL211:
 1524              	.L160:
 916:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 1525              		.loc 1 916 0
 1526 008c 826A     		ldr	r2, [r0, #40]
 1527              	.LVL212:
 1528 008e 02EB1521 		add	r1, r2, r5, lsr #8
 1529 0092 FFF7FEFF 		bl	move_window
 1530              	.LVL213:
 917:lib/ff/ff.c   **** 			p = &fs->win[clst * 2 % SS(fs)];
 1531              		.loc 1 917 0
 1532 0096 A0B9     		cbnz	r0, .L158
 1533              	.LVL214:
 918:lib/ff/ff.c   **** 			ST_WORD(p, (WORD)val);
 1534              		.loc 1 918 0
 1535 0098 2D06     		lsls	r5, r5, #24
 1536              	.LVL215:
 1537 009a 04EBD555 		add	r5, r4, r5, lsr #23
 919:lib/ff/ff.c   **** 			break;
 1538              		.loc 1 919 0
 1539 009e 2E87     		strh	r6, [r5, #56]	@ movhi
 1540 00a0 0FE0     		b	.L158
 1541              	.LVL216:
 1542              	.L161:
 923:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 1543              		.loc 1 923 0
 1544 00a2 826A     		ldr	r2, [r0, #40]
 1545              	.LVL217:
 1546 00a4 02EBD511 		add	r1, r2, r5, lsr #7
 1547 00a8 FFF7FEFF 		bl	move_window
 1548              	.LVL218:
 924:lib/ff/ff.c   **** 			p = &fs->win[clst * 4 % SS(fs)];
 1549              		.loc 1 924 0
 1550 00ac 48B9     		cbnz	r0, .L158
 925:lib/ff/ff.c   **** 			val |= LD_DWORD(p) & 0xF0000000;
 1551              		.loc 1 925 0
 1552 00ae 6D06     		lsls	r5, r5, #25
 1553              	.LVL219:
 1554 00b0 ED0D     		lsrs	r5, r5, #23
 1555 00b2 3835     		adds	r5, r5, #56
 1556              	.LVL220:
 926:lib/ff/ff.c   **** 			ST_DWORD(p, val);
 1557              		.loc 1 926 0
 1558 00b4 6359     		ldr	r3, [r4, r5]
 1559 00b6 03F07041 		and	r1, r3, #-268435456
 1560 00ba 0E43     		orrs	r6, r6, r1
 1561              	.LVL221:
 927:lib/ff/ff.c   **** 			break;
 1562              		.loc 1 927 0
 1563 00bc 6651     		str	r6, [r4, r5]
 1564 00be 00E0     		b	.L158
 1565              	.LVL222:
 1566              	.L169:
 931:lib/ff/ff.c   **** 		}
 1567              		.loc 1 931 0
 1568 00c0 0220     		movs	r0, #2
 1569              	.LVL223:
 1570              	.L158:
 933:lib/ff/ff.c   **** 	}
 1571              		.loc 1 933 0
 1572 00c2 0123     		movs	r3, #1
 1573 00c4 2371     		strb	r3, [r4, #4]
 1574 00c6 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1575              	.LVL224:
 1576              	.L167:
 1577              	.LBE40:
 1578              	.LBE37:
 897:lib/ff/ff.c   **** 
 1579              		.loc 1 897 0
 1580 00c8 0220     		movs	r0, #2
 1581              	.LVL225:
 937:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
 1582              		.loc 1 937 0
 1583 00ca F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1584              		.cfi_endproc
 1585              	.LFE9:
 1587              		.section	.text.create_chain,"ax",%progbits
 1588              		.align	1
 1589              		.thumb
 1590              		.thumb_func
 1592              	create_chain:
 1593              	.LFB11:
1005:lib/ff/ff.c   **** 	DWORD cs, ncl, scl;
 1594              		.loc 1 1005 0
 1595              		.cfi_startproc
 1596              		@ args = 0, pretend = 0, frame = 0
 1597              		@ frame_needed = 0, uses_anonymous_args = 0
 1598              	.LVL226:
 1599 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1600              	.LCFI12:
 1601              		.cfi_def_cfa_offset 24
 1602              		.cfi_offset 3, -24
 1603              		.cfi_offset 4, -20
 1604              		.cfi_offset 5, -16
 1605              		.cfi_offset 6, -12
 1606              		.cfi_offset 7, -8
 1607              		.cfi_offset 14, -4
 1608 0002 0546     		mov	r5, r0
1010:lib/ff/ff.c   **** 		scl = fs->last_clust;			/* Get suggested start point */
 1609              		.loc 1 1010 0
 1610 0004 0F46     		mov	r7, r1
 1611 0006 31B9     		cbnz	r1, .L171
1011:lib/ff/ff.c   **** 		if (!scl || scl >= fs->n_fatent) scl = 1;
 1612              		.loc 1 1011 0
 1613 0008 C668     		ldr	r6, [r0, #12]
 1614              	.LVL227:
1012:lib/ff/ff.c   **** 	}
 1615              		.loc 1 1012 0
 1616 000a 6EB1     		cbz	r6, .L186
1012:lib/ff/ff.c   **** 	}
 1617              		.loc 1 1012 0 is_stmt 0 discriminator 2
 1618 000c C069     		ldr	r0, [r0, #28]
 1619              	.LVL228:
 1620 000e 8642     		cmp	r6, r0
 1621 0010 28BF     		it	cs
 1622 0012 0126     		movcs	r6, #1
 1623              	.LVL229:
 1624 0014 09E0     		b	.L172
 1625              	.LVL230:
 1626              	.L171:
1015:lib/ff/ff.c   **** 		if (cs < 2) return 1;			/* It is an invalid cluster */
 1627              		.loc 1 1015 0 is_stmt 1
 1628 0016 FFF7FEFF 		bl	get_fat
 1629              	.LVL231:
1016:lib/ff/ff.c   **** 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 1630              		.loc 1 1016 0
 1631 001a 0128     		cmp	r0, #1
 1632 001c 3BD9     		bls	.L198
 1633              	.L173:
1017:lib/ff/ff.c   **** 		scl = clst;
 1634              		.loc 1 1017 0
 1635 001e EB69     		ldr	r3, [r5, #28]
 1636 0020 9842     		cmp	r0, r3
 1637 0022 39D3     		bcc	.L174
 1638 0024 3E46     		mov	r6, r7
 1639 0026 00E0     		b	.L172
 1640              	.LVL232:
 1641              	.L186:
1012:lib/ff/ff.c   **** 	}
 1642              		.loc 1 1012 0
 1643 0028 0126     		movs	r6, #1
 1644              	.LVL233:
 1645              	.L172:
 1646 002a 3446     		mov	r4, r6
 1647              	.L180:
 1648              	.LVL234:
1023:lib/ff/ff.c   **** 		if (ncl >= fs->n_fatent) {		/* Wrap around */
 1649              		.loc 1 1023 0
 1650 002c 0134     		adds	r4, r4, #1
 1651              	.LVL235:
1024:lib/ff/ff.c   **** 			ncl = 2;
 1652              		.loc 1 1024 0
 1653 002e E969     		ldr	r1, [r5, #28]
 1654 0030 8C42     		cmp	r4, r1
 1655 0032 04D3     		bcc	.L175
 1656              	.LVL236:
1026:lib/ff/ff.c   **** 		}
 1657              		.loc 1 1026 0
 1658 0034 012E     		cmp	r6, #1
 1659 0036 01D8     		bhi	.L188
 1660              	.LVL237:
 1661              	.L179:
 1662 0038 0020     		movs	r0, #0
 1663 003a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1664              	.LVL238:
 1665              	.L188:
1025:lib/ff/ff.c   **** 			if (ncl > scl) return 0;	/* No free cluster */
 1666              		.loc 1 1025 0
 1667 003c 0224     		movs	r4, #2
 1668              	.LVL239:
 1669              	.L175:
1028:lib/ff/ff.c   **** 		if (cs == 0) break;				/* Found a free cluster */
 1670              		.loc 1 1028 0
 1671 003e 2846     		mov	r0, r5
 1672 0040 2146     		mov	r1, r4
 1673 0042 FFF7FEFF 		bl	get_fat
 1674              	.LVL240:
1029:lib/ff/ff.c   **** 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 1675              		.loc 1 1029 0
 1676 0046 48B1     		cbz	r0, .L176
1030:lib/ff/ff.c   **** 			return cs;
 1677              		.loc 1 1030 0
 1678 0048 411C     		adds	r1, r0, #1
 1679 004a 02D1     		bne	.L177
 1680              	.LVL241:
 1681              	.L185:
1046:lib/ff/ff.c   **** 	}
 1682              		.loc 1 1046 0
 1683 004c 4FF0FF30 		mov	r0, #-1
 1684 0050 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1685              	.LVL242:
 1686              	.L177:
1030:lib/ff/ff.c   **** 			return cs;
 1687              		.loc 1 1030 0 discriminator 1
 1688 0052 0128     		cmp	r0, #1
 1689 0054 1FD0     		beq	.L198
1032:lib/ff/ff.c   **** 	}
 1690              		.loc 1 1032 0
 1691 0056 B442     		cmp	r4, r6
 1692 0058 E8D1     		bne	.L180
 1693 005a EDE7     		b	.L179
 1694              	.L176:
1035:lib/ff/ff.c   **** 	if (res == FR_OK && clst != 0) {
 1695              		.loc 1 1035 0
 1696 005c 2846     		mov	r0, r5
 1697              	.LVL243:
 1698 005e 2146     		mov	r1, r4
 1699 0060 6FF07042 		mvn	r2, #-268435456
 1700 0064 FFF7FEFF 		bl	put_fat
 1701              	.LVL244:
1036:lib/ff/ff.c   **** 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 1702              		.loc 1 1036 0
 1703 0068 98B9     		cbnz	r0, .L181
1036:lib/ff/ff.c   **** 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 1704              		.loc 1 1036 0 is_stmt 0 discriminator 1
 1705 006a 47B9     		cbnz	r7, .L182
 1706              	.L184:
1040:lib/ff/ff.c   **** 		if (fs->free_clust != 0xFFFFFFFF) {
 1707              		.loc 1 1040 0 is_stmt 1
 1708 006c EC60     		str	r4, [r5, #12]
1041:lib/ff/ff.c   **** 			fs->free_clust--;
 1709              		.loc 1 1041 0
 1710 006e 2B69     		ldr	r3, [r5, #16]
 1711 0070 5A1C     		adds	r2, r3, #1
 1712 0072 0CD0     		beq	.L199
 1713              	.L183:
1042:lib/ff/ff.c   **** 			fs->fsi_flag = 1;
 1714              		.loc 1 1042 0
 1715 0074 5A1E     		subs	r2, r3, #1
 1716 0076 2A61     		str	r2, [r5, #16]
1043:lib/ff/ff.c   **** 		}
 1717              		.loc 1 1043 0
 1718 0078 0120     		movs	r0, #1
 1719              	.LVL245:
 1720 007a 6871     		strb	r0, [r5, #5]
 1721 007c 07E0     		b	.L199
 1722              	.LVL246:
 1723              	.L182:
1037:lib/ff/ff.c   **** 	}
 1724              		.loc 1 1037 0
 1725 007e 2846     		mov	r0, r5
 1726              	.LVL247:
 1727 0080 3946     		mov	r1, r7
 1728 0082 2246     		mov	r2, r4
 1729 0084 FFF7FEFF 		bl	put_fat
 1730              	.LVL248:
1039:lib/ff/ff.c   **** 		fs->last_clust = ncl;			/* Update FSINFO */
 1731              		.loc 1 1039 0
 1732 0088 0028     		cmp	r0, #0
 1733 008a EFD0     		beq	.L184
 1734 008c 01E0     		b	.L181
 1735              	.LVL249:
 1736              	.L199:
1043:lib/ff/ff.c   **** 		}
 1737              		.loc 1 1043 0
 1738 008e 2046     		mov	r0, r4
 1739 0090 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1740              	.LVL250:
 1741              	.L181:
1046:lib/ff/ff.c   **** 	}
 1742              		.loc 1 1046 0
 1743 0092 0128     		cmp	r0, #1
 1744 0094 DAD0     		beq	.L185
 1745              	.LVL251:
 1746              	.L198:
 1747 0096 0120     		movs	r0, #1
 1748              	.L174:
1050:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
 1749              		.loc 1 1050 0
 1750 0098 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1751              		.cfi_endproc
 1752              	.LFE11:
 1754              		.section	.text.dir_next,"ax",%progbits
 1755              		.align	1
 1756              		.thumb
 1757              		.thumb_func
 1759              	dir_next:
 1760              	.LFB14:
1140:lib/ff/ff.c   **** 	DWORD clst;
 1761              		.loc 1 1140 0
 1762              		.cfi_startproc
 1763              		@ args = 0, pretend = 0, frame = 0
 1764              		@ frame_needed = 0, uses_anonymous_args = 0
 1765              	.LVL252:
 1766 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1767              	.LCFI13:
 1768              		.cfi_def_cfa_offset 32
 1769              		.cfi_offset 3, -32
 1770              		.cfi_offset 4, -28
 1771              		.cfi_offset 5, -24
 1772              		.cfi_offset 6, -20
 1773              		.cfi_offset 7, -16
 1774              		.cfi_offset 8, -12
 1775              		.cfi_offset 9, -8
 1776              		.cfi_offset 14, -4
 1777 0004 0446     		mov	r4, r0
 1778 0006 0F46     		mov	r7, r1
1146:lib/ff/ff.c   **** 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 1779              		.loc 1 1146 0
 1780 0008 C688     		ldrh	r6, [r0, #6]
 1781 000a 701C     		adds	r0, r6, #1
 1782              	.LVL253:
 1783 000c 86B2     		uxth	r6, r0
 1784              	.LVL254:
1147:lib/ff/ff.c   **** 		return FR_NO_FILE;
 1785              		.loc 1 1147 0
 1786 000e 16B9     		cbnz	r6, .L201
 1787              	.LVL255:
 1788              	.L203:
 1789              	.LBB41:
1148:lib/ff/ff.c   **** 
 1790              		.loc 1 1148 0
 1791 0010 0420     		movs	r0, #4
 1792 0012 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1793              	.LVL256:
 1794              	.L201:
 1795              	.LBE41:
1147:lib/ff/ff.c   **** 		return FR_NO_FILE;
 1796              		.loc 1 1147 0 discriminator 1
 1797 0016 2369     		ldr	r3, [r4, #16]
 1798 0018 002B     		cmp	r3, #0
 1799 001a F9D0     		beq	.L203
1150:lib/ff/ff.c   **** 		dj->sect++;					/* Next sector */
 1800              		.loc 1 1150 0
 1801 001c 16F00F08 		ands	r8, r6, #15
 1802 0020 5AD1     		bne	.L205
1151:lib/ff/ff.c   **** 
 1803              		.loc 1 1151 0
 1804 0022 591C     		adds	r1, r3, #1
 1805              	.LVL257:
 1806 0024 2161     		str	r1, [r4, #16]
1153:lib/ff/ff.c   **** 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 1807              		.loc 1 1153 0
 1808 0026 E168     		ldr	r1, [r4, #12]
 1809 0028 2068     		ldr	r0, [r4, #0]
 1810              	.LVL258:
 1811 002a 19B9     		cbnz	r1, .L206
1154:lib/ff/ff.c   **** 				return FR_NO_FILE;
 1812              		.loc 1 1154 0
 1813 002c 0189     		ldrh	r1, [r0, #8]
 1814 002e B142     		cmp	r1, r6
 1815 0030 EED9     		bls	.L203
 1816 0032 51E0     		b	.L205
 1817              	.L206:
1158:lib/ff/ff.c   **** 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 1818              		.loc 1 1158 0
 1819 0034 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 1820 0036 531E     		subs	r3, r2, #1
 1821 0038 13EA1612 		ands	r2, r3, r6, lsr #4
 1822 003c 4CD1     		bne	.L205
1159:lib/ff/ff.c   **** 				if (clst <= 1) return FR_INT_ERR;
 1823              		.loc 1 1159 0
 1824 003e FFF7FEFF 		bl	get_fat
 1825              	.LVL259:
 1826 0042 0546     		mov	r5, r0
 1827              	.LVL260:
1160:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 1828              		.loc 1 1160 0
 1829 0044 0128     		cmp	r0, #1
 1830 0046 02D8     		bhi	.L208
 1831              	.L211:
 1832 0048 0220     		movs	r0, #2
 1833              	.LVL261:
 1834 004a BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1835              	.LVL262:
 1836              	.L208:
1161:lib/ff/ff.c   **** 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 1837              		.loc 1 1161 0
 1838 004e 431C     		adds	r3, r0, #1
 1839 0050 02D1     		bne	.L209
 1840              	.LVL263:
 1841              	.L212:
 1842 0052 0120     		movs	r0, #1
 1843 0054 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1844              	.LVL264:
 1845              	.L209:
1162:lib/ff/ff.c   **** #if !_FS_READONLY
 1846              		.loc 1 1162 0
 1847 0058 2068     		ldr	r0, [r4, #0]
 1848              	.LVL265:
 1849 005a C169     		ldr	r1, [r0, #28]
 1850 005c 8D42     		cmp	r5, r1
 1851 005e 35D3     		bcc	.L210
 1852              	.LBB42:
1165:lib/ff/ff.c   **** 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
 1853              		.loc 1 1165 0
 1854 0060 002F     		cmp	r7, #0
 1855 0062 D5D0     		beq	.L203
1166:lib/ff/ff.c   **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
 1856              		.loc 1 1166 0
 1857 0064 E168     		ldr	r1, [r4, #12]
 1858 0066 FFF7FEFF 		bl	create_chain
 1859              	.LVL266:
1167:lib/ff/ff.c   **** 					if (clst == 1) return FR_INT_ERR;
 1860              		.loc 1 1167 0
 1861 006a 0546     		mov	r5, r0
 1862 006c 0028     		cmp	r0, #0
 1863 006e 3FD0     		beq	.L215
1168:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 1864              		.loc 1 1168 0
 1865 0070 0128     		cmp	r0, #1
 1866 0072 E9D0     		beq	.L211
1169:lib/ff/ff.c   **** 					/* Clean-up stretched table */
 1867              		.loc 1 1169 0
 1868 0074 0130     		adds	r0, r0, #1
 1869              	.LVL267:
 1870 0076 ECD0     		beq	.L212
1171:lib/ff/ff.c   **** 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 1871              		.loc 1 1171 0
 1872 0078 2068     		ldr	r0, [r4, #0]
 1873 007a FFF7FEFF 		bl	sync_window
 1874              	.LVL268:
 1875 007e 0746     		mov	r7, r0
 1876              	.LVL269:
 1877 0080 0028     		cmp	r0, #0
 1878 0082 E6D1     		bne	.L212
1172:lib/ff/ff.c   **** 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 1879              		.loc 1 1172 0
 1880 0084 2068     		ldr	r0, [r4, #0]
 1881 0086 3830     		adds	r0, r0, #56
 1882 0088 3946     		mov	r1, r7
 1883 008a 4FF40072 		mov	r2, #512
 1884 008e FFF7FEFF 		bl	mem_set
 1885              	.LVL270:
1173:lib/ff/ff.c   **** 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 1886              		.loc 1 1173 0
 1887 0092 D4F80090 		ldr	r9, [r4, #0]
 1888 0096 4846     		mov	r0, r9
 1889 0098 2946     		mov	r1, r5
 1890 009a FFF7FEFF 		bl	clust2sect
 1891              	.LVL271:
 1892 009e C9F83400 		str	r0, [r9, #52]
 1893              	.LVL272:
 1894              	.L213:
1174:lib/ff/ff.c   **** 						dj->fs->wflag = 1;
 1895              		.loc 1 1174 0 discriminator 1
 1896 00a2 2068     		ldr	r0, [r4, #0]
 1897 00a4 8278     		ldrb	r2, [r0, #2]	@ zero_extendqisi2
 1898 00a6 BA42     		cmp	r2, r7
 1899 00a8 0DD9     		bls	.L228
 1900              	.L214:
1175:lib/ff/ff.c   **** 						if (sync_window(dj->fs)) return FR_DISK_ERR;
 1901              		.loc 1 1175 0
 1902 00aa 0121     		movs	r1, #1
 1903 00ac 0171     		strb	r1, [r0, #4]
1176:lib/ff/ff.c   **** 						dj->fs->winsect++;
 1904              		.loc 1 1176 0
 1905 00ae 2068     		ldr	r0, [r4, #0]
 1906 00b0 FFF7FEFF 		bl	sync_window
 1907              	.LVL273:
 1908 00b4 0028     		cmp	r0, #0
 1909 00b6 CCD1     		bne	.L212
1177:lib/ff/ff.c   **** 					}
 1910              		.loc 1 1177 0
 1911 00b8 2068     		ldr	r0, [r4, #0]
 1912 00ba 426B     		ldr	r2, [r0, #52]
 1913 00bc 531C     		adds	r3, r2, #1
 1914 00be 4363     		str	r3, [r0, #52]
1174:lib/ff/ff.c   **** 						dj->fs->wflag = 1;
 1915              		.loc 1 1174 0
 1916 00c0 0137     		adds	r7, r7, #1
 1917              	.LVL274:
 1918 00c2 FFB2     		uxtb	r7, r7
 1919              	.LVL275:
 1920 00c4 EDE7     		b	.L213
 1921              	.L228:
1179:lib/ff/ff.c   **** #else
 1922              		.loc 1 1179 0
 1923 00c6 436B     		ldr	r3, [r0, #52]
 1924 00c8 DF1B     		subs	r7, r3, r7
 1925              	.LVL276:
 1926 00ca 4763     		str	r7, [r0, #52]
 1927              	.L210:
 1928              	.LBE42:
1184:lib/ff/ff.c   **** 				dj->sect = clust2sect(dj->fs, clst);
 1929              		.loc 1 1184 0
 1930 00cc E560     		str	r5, [r4, #12]
1185:lib/ff/ff.c   **** 			}
 1931              		.loc 1 1185 0
 1932 00ce 2068     		ldr	r0, [r4, #0]
 1933 00d0 2946     		mov	r1, r5
 1934 00d2 FFF7FEFF 		bl	clust2sect
 1935              	.LVL277:
 1936 00d6 2061     		str	r0, [r4, #16]
 1937              	.LVL278:
 1938              	.L205:
1190:lib/ff/ff.c   **** 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 1939              		.loc 1 1190 0
 1940 00d8 E680     		strh	r6, [r4, #6]	@ movhi
1191:lib/ff/ff.c   **** 
 1941              		.loc 1 1191 0
 1942 00da 4FEA4818 		lsl	r8, r8, #5
 1943 00de 08F13808 		add	r8, r8, #56
 1944 00e2 2068     		ldr	r0, [r4, #0]
 1945 00e4 00EB0802 		add	r2, r0, r8
 1946 00e8 6261     		str	r2, [r4, #20]
1193:lib/ff/ff.c   **** }
 1947              		.loc 1 1193 0
 1948 00ea 0020     		movs	r0, #0
 1949 00ec BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1950              	.LVL279:
 1951              	.L215:
 1952              	.LBB43:
1167:lib/ff/ff.c   **** 					if (clst == 1) return FR_INT_ERR;
 1953              		.loc 1 1167 0
 1954 00f0 0720     		movs	r0, #7
 1955              	.LVL280:
 1956              	.LBE43:
1194:lib/ff/ff.c   **** 
 1957              		.loc 1 1194 0
 1958 00f2 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1959              		.cfi_endproc
 1960              	.LFE14:
 1962              		.section	.text.dir_read,"ax",%progbits
 1963              		.align	1
 1964              		.thumb
 1965              		.thumb_func
 1967              	dir_read:
 1968              	.LFB19:
1511:lib/ff/ff.c   **** 	FRESULT res;
 1969              		.loc 1 1511 0
 1970              		.cfi_startproc
 1971              		@ args = 0, pretend = 0, frame = 0
 1972              		@ frame_needed = 0, uses_anonymous_args = 0
 1973              	.LVL281:
 1974 0000 38B5     		push	{r3, r4, r5, lr}
 1975              	.LCFI14:
 1976              		.cfi_def_cfa_offset 16
 1977              		.cfi_offset 3, -16
 1978              		.cfi_offset 4, -12
 1979              		.cfi_offset 5, -8
 1980              		.cfi_offset 14, -4
 1981 0002 0446     		mov	r4, r0
 1982 0004 0D46     		mov	r5, r1
 1983              	.LVL282:
1518:lib/ff/ff.c   **** 	while (dj->sect) {
 1984              		.loc 1 1518 0
 1985 0006 0423     		movs	r3, #4
 1986              	.LVL283:
 1987              	.L230:
1519:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
 1988              		.loc 1 1519 0 discriminator 1
 1989 0008 2169     		ldr	r1, [r4, #16]
 1990 000a E1B1     		cbz	r1, .L248
 1991              	.L234:
1520:lib/ff/ff.c   **** 		if (res != FR_OK) break;
 1992              		.loc 1 1520 0
 1993 000c 2068     		ldr	r0, [r4, #0]
 1994 000e FFF7FEFF 		bl	move_window
 1995              	.LVL284:
1521:lib/ff/ff.c   **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 1996              		.loc 1 1521 0
 1997 0012 F8B9     		cbnz	r0, .L231
1522:lib/ff/ff.c   **** 		c = dir[DIR_Name];
 1998              		.loc 1 1522 0
 1999 0014 6369     		ldr	r3, [r4, #20]
 2000              	.LVL285:
1523:lib/ff/ff.c   **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 2001              		.loc 1 1523 0
 2002 0016 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2003              	.LVL286:
1524:lib/ff/ff.c   **** 		a = dir[DIR_Attr] & AM_MASK;
 2004              		.loc 1 1524 0
 2005 0018 DAB1     		cbz	r2, .L236
1525:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
 2006              		.loc 1 1525 0
 2007 001a D97A     		ldrb	r1, [r3, #11]	@ zero_extendqisi2
 2008 001c 01F03F03 		and	r3, r1, #63
 2009              	.LVL287:
1545:lib/ff/ff.c   **** 			break;
 2010              		.loc 1 1545 0
 2011 0020 E52A     		cmp	r2, #229
 2012 0022 08D0     		beq	.L232
1545:lib/ff/ff.c   **** 			break;
 2013              		.loc 1 1545 0 is_stmt 0 discriminator 1
 2014 0024 0F2B     		cmp	r3, #15
 2015 0026 06D0     		beq	.L232
 2016 0028 B3F10802 		subs	r2, r3, #8
 2017 002c 5142     		rsbs	r1, r2, #0
 2018 002e 51EB0203 		adcs	r3, r1, r2
 2019              	.LVL288:
 2020 0032 AB42     		cmp	r3, r5
 2021 0034 10D0     		beq	.L241
 2022              	.LVL289:
 2023              	.L232:
1548:lib/ff/ff.c   **** 		if (res != FR_OK) break;
 2024              		.loc 1 1548 0 is_stmt 1
 2025 0036 2046     		mov	r0, r4
 2026              	.LVL290:
 2027 0038 0021     		movs	r1, #0
 2028 003a FFF7FEFF 		bl	dir_next
 2029              	.LVL291:
 2030 003e 0346     		mov	r3, r0
 2031              	.LVL292:
1549:lib/ff/ff.c   **** 	}
 2032              		.loc 1 1549 0
 2033 0040 0028     		cmp	r0, #0
 2034 0042 E1D0     		beq	.L230
 2035 0044 06E0     		b	.L231
 2036              	.LVL293:
 2037              	.L248:
1519:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
 2038              		.loc 1 1519 0
 2039 0046 1846     		mov	r0, r3
 2040              	.LVL294:
1552:lib/ff/ff.c   **** 
 2041              		.loc 1 1552 0
 2042 0048 33B1     		cbz	r3, .L241
 2043              	.LVL295:
 2044              	.L235:
1552:lib/ff/ff.c   **** 
 2045              		.loc 1 1552 0 is_stmt 0 discriminator 1
 2046 004a 0020     		movs	r0, #0
 2047 004c 2061     		str	r0, [r4, #16]
 2048 004e 1846     		mov	r0, r3
 2049 0050 38BD     		pop	{r3, r4, r5, pc}
 2050              	.LVL296:
 2051              	.L236:
1524:lib/ff/ff.c   **** 		a = dir[DIR_Attr] & AM_MASK;
 2052              		.loc 1 1524 0 is_stmt 1
 2053 0052 0420     		movs	r0, #4
 2054              	.LVL297:
 2055              	.L231:
1519:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
 2056              		.loc 1 1519 0
 2057 0054 0346     		mov	r3, r0
 2058 0056 F8E7     		b	.L235
 2059              	.LVL298:
 2060              	.L241:
1555:lib/ff/ff.c   **** #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
 2061              		.loc 1 1555 0
 2062 0058 38BD     		pop	{r3, r4, r5, pc}
 2063              		.cfi_endproc
 2064              	.LFE19:
 2066              		.section	.text.follow_path,"ax",%progbits
 2067              		.align	1
 2068              		.thumb
 2069              		.thumb_func
 2071              	follow_path:
 2072              	.LFB24:
1984:lib/ff/ff.c   **** 	FRESULT res;
 2073              		.loc 1 1984 0
 2074              		.cfi_startproc
 2075              		@ args = 0, pretend = 0, frame = 0
 2076              		@ frame_needed = 0, uses_anonymous_args = 0
 2077              	.LVL299:
 2078 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 2079              	.LCFI15:
 2080              		.cfi_def_cfa_offset 24
 2081              		.cfi_offset 4, -24
 2082              		.cfi_offset 5, -20
 2083              		.cfi_offset 6, -16
 2084              		.cfi_offset 7, -12
 2085              		.cfi_offset 8, -8
 2086              		.cfi_offset 14, -4
 2087 0004 0446     		mov	r4, r0
 2088 0006 0F46     		mov	r7, r1
1990:lib/ff/ff.c   **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 2089              		.loc 1 1990 0
 2090 0008 91F90030 		ldrsb	r3, [r1, #0]
 2091 000c 2F2B     		cmp	r3, #47
 2092 000e 01D0     		beq	.L250
1990:lib/ff/ff.c   **** 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 2093              		.loc 1 1990 0 is_stmt 0 discriminator 1
 2094 0010 5C2B     		cmp	r3, #92
 2095 0012 02D1     		bne	.L251
 2096              	.L250:
1991:lib/ff/ff.c   **** 	} else {							/* No heading separator */
 2097              		.loc 1 1991 0 is_stmt 1
 2098 0014 0137     		adds	r7, r7, #1
 2099              	.LVL300:
 2100 0016 0021     		movs	r1, #0
 2101 0018 01E0     		b	.L344
 2102              	.LVL301:
 2103              	.L251:
1993:lib/ff/ff.c   **** 	}
 2104              		.loc 1 1993 0
 2105 001a 0068     		ldr	r0, [r0, #0]
 2106              	.LVL302:
 2107 001c 8169     		ldr	r1, [r0, #24]
 2108              	.LVL303:
 2109              	.L344:
 2110 001e A160     		str	r1, [r4, #8]
2001:lib/ff/ff.c   **** 		res = dir_sdi(dj, 0);
 2111              		.loc 1 2001 0
 2112 0020 3A78     		ldrb	r2, [r7, #0]	@ zero_extendqisi2
 2113 0022 1F2A     		cmp	r2, #31
 2114 0024 4AD8     		bhi	.L340
2002:lib/ff/ff.c   **** 		dj->dir = 0;
 2115              		.loc 1 2002 0
 2116 0026 2046     		mov	r0, r4
 2117 0028 0021     		movs	r1, #0
 2118 002a FFF7FEFF 		bl	dir_sdi
 2119              	.LVL304:
2003:lib/ff/ff.c   **** 	} else {							/* Follow path */
 2120              		.loc 1 2003 0
 2121 002e 0022     		movs	r2, #0
 2122 0030 6261     		str	r2, [r4, #20]
 2123 0032 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2124              	.LVL305:
 2125              	.L339:
 2126 0036 0746     		mov	r7, r0
 2127              	.LVL306:
 2128              	.LBB54:
 2129              	.LBB55:
1820:lib/ff/ff.c   **** 	sfn = dj->fn;
 2130              		.loc 1 1820 0
 2131 0038 0678     		ldrb	r6, [r0, #0]	@ zero_extendqisi2
 2132 003a 0130     		adds	r0, r0, #1
 2133              	.LVL307:
 2134 003c 73B2     		sxtb	r3, r6
 2135 003e 2F2B     		cmp	r3, #47
 2136 0040 F9D0     		beq	.L339
 2137 0042 5C2B     		cmp	r3, #92
 2138 0044 F7D0     		beq	.L339
1821:lib/ff/ff.c   **** 	mem_set(sfn, ' ', 11);
 2139              		.loc 1 1821 0
 2140 0046 A669     		ldr	r6, [r4, #24]
 2141              	.LVL308:
1822:lib/ff/ff.c   **** 	si = i = b = 0; ni = 8;
 2142              		.loc 1 1822 0
 2143 0048 3046     		mov	r0, r6
 2144 004a 2021     		movs	r1, #32
 2145 004c 0B22     		movs	r2, #11
 2146 004e FFF7FEFF 		bl	mem_set
 2147              	.LVL309:
1825:lib/ff/ff.c   **** 		for (;;) {
 2148              		.loc 1 1825 0
 2149 0052 97F90010 		ldrsb	r1, [r7, #0]
 2150 0056 2E29     		cmp	r1, #46
 2151 0058 3AD1     		bne	.L292
 2152              	.LVL310:
1829:lib/ff/ff.c   **** 		}
 2153              		.loc 1 1829 0
 2154 005a 3170     		strb	r1, [r6, #0]
 2155              	.LVL311:
1827:lib/ff/ff.c   **** 			if (c != '.' || si >= 3) break;
 2156              		.loc 1 1827 0
 2157 005c 7878     		ldrb	r0, [r7, #1]	@ zero_extendqisi2
 2158              	.LVL312:
1828:lib/ff/ff.c   **** 			sfn[i++] = c;
 2159              		.loc 1 1828 0
 2160 005e 2E28     		cmp	r0, #46
 2161 0060 2ED1     		bne	.L293
1829:lib/ff/ff.c   **** 		}
 2162              		.loc 1 1829 0
 2163 0062 7070     		strb	r0, [r6, #1]
 2164              	.LVL313:
1827:lib/ff/ff.c   **** 			if (c != '.' || si >= 3) break;
 2165              		.loc 1 1827 0
 2166 0064 B878     		ldrb	r0, [r7, #2]	@ zero_extendqisi2
 2167              	.LVL314:
 2168 0066 0323     		movs	r3, #3
 2169              	.LVL315:
 2170              	.L259:
1831:lib/ff/ff.c   **** 		*path = &p[si];									/* Return pointer to the next segment */
 2171              		.loc 1 1831 0
 2172 0068 2F28     		cmp	r0, #47
 2173 006a 2BD1     		bne	.L347
 2174              	.L260:
1832:lib/ff/ff.c   **** 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
 2175              		.loc 1 1832 0
 2176 006c FF18     		adds	r7, r7, r3
 2177              	.LVL316:
1833:lib/ff/ff.c   **** 		return FR_OK;
 2178              		.loc 1 1833 0
 2179 006e 2028     		cmp	r0, #32
 2180 0070 8CBF     		ite	hi
 2181 0072 2023     		movhi	r3, #32
 2182 0074 2423     		movls	r3, #36
 2183              	.LVL317:
 2184              	.L346:
1884:lib/ff/ff.c   **** 
 2185              		.loc 1 1884 0
 2186 0076 F372     		strb	r3, [r6, #11]
 2187              	.LVL318:
 2188              	.LBE55:
 2189              	.LBE54:
 2190              	.LBB60:
 2191              	.LBB61:
1456:lib/ff/ff.c   **** 	if (res != FR_OK) return res;
 2192              		.loc 1 1456 0
 2193 0078 2046     		mov	r0, r4
 2194 007a 0021     		movs	r1, #0
 2195 007c FFF7FEFF 		bl	dir_sdi
 2196              	.LVL319:
 2197              	.L345:
1457:lib/ff/ff.c   **** 
 2198              		.loc 1 1457 0
 2199 0080 30B9     		cbnz	r0, .L279
 2200              	.L324:
1463:lib/ff/ff.c   **** 		if (res != FR_OK) break;
 2201              		.loc 1 1463 0
 2202 0082 2068     		ldr	r0, [r4, #0]
 2203              	.LVL320:
 2204 0084 2169     		ldr	r1, [r4, #16]
 2205 0086 FFF7FEFF 		bl	move_window
 2206              	.LVL321:
1464:lib/ff/ff.c   **** 		dir = dj->dir;					/* Ptr to the directory entry of current index */
 2207              		.loc 1 1464 0
 2208 008a 0028     		cmp	r0, #0
 2209 008c 00F0A680 		beq	.L348
 2210              	.LVL322:
 2211              	.L279:
 2212              	.LBE61:
 2213              	.LBE60:
2009:lib/ff/ff.c   **** 			if (res != FR_OK) {				/* Failed to find the object */
 2214              		.loc 1 2009 0
 2215 0090 A169     		ldr	r1, [r4, #24]
 2216 0092 CB7A     		ldrb	r3, [r1, #11]	@ zero_extendqisi2
 2217              	.LVL323:
2010:lib/ff/ff.c   **** 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
 2218              		.loc 1 2010 0
 2219 0094 0028     		cmp	r0, #0
 2220 0096 00F0BA80 		beq	.L284
2011:lib/ff/ff.c   **** 				/* Object not found */
 2221              		.loc 1 2011 0
 2222 009a 0428     		cmp	r0, #4
 2223 009c 40F0D880 		bne	.L314
2013:lib/ff/ff.c   **** 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
 2224              		.loc 1 2013 0
 2225 00a0 03F02002 		and	r2, r3, #32
 2226 00a4 D1B2     		uxtb	r1, r2
 2227              	.LVL324:
 2228 00a6 03F00400 		and	r0, r3, #4
 2229 00aa 0029     		cmp	r1, #0
 2230 00ac 00F0B680 		beq	.L285
2014:lib/ff/ff.c   **** 					res = FR_OK;
 2231              		.loc 1 2014 0
 2232 00b0 0023     		movs	r3, #0
 2233 00b2 A360     		str	r3, [r4, #8]
 2234 00b4 6361     		str	r3, [r4, #20]
 2235              	.LVL325:
2016:lib/ff/ff.c   **** 				} else {							/* Could not find the object */
 2236              		.loc 1 2016 0
 2237 00b6 0028     		cmp	r0, #0
 2238 00b8 40F0AD80 		bne	.L287
 2239              	.LVL326:
 2240              	.L340:
 2241 00bc 3846     		mov	r0, r7
 2242 00be BAE7     		b	.L339
 2243              	.LVL327:
 2244              	.L293:
 2245              	.LBB66:
 2246              	.LBB58:
1827:lib/ff/ff.c   **** 			if (c != '.' || si >= 3) break;
 2247              		.loc 1 1827 0
 2248 00c0 0223     		movs	r3, #2
 2249 00c2 D1E7     		b	.L259
 2250              	.LVL328:
 2251              	.L347:
1831:lib/ff/ff.c   **** 		*path = &p[si];									/* Return pointer to the next segment */
 2252              		.loc 1 1831 0
 2253 00c4 5C28     		cmp	r0, #92
 2254 00c6 D1D0     		beq	.L260
 2255 00c8 2028     		cmp	r0, #32
 2256 00ca 00F2C080 		bhi	.L261
 2257 00ce CDE7     		b	.L260
 2258              	.LVL329:
 2259              	.L292:
1825:lib/ff/ff.c   **** 		for (;;) {
 2260              		.loc 1 1825 0
 2261 00d0 0022     		movs	r2, #0
 2262 00d2 9446     		mov	ip, r2
 2263 00d4 0821     		movs	r1, #8
 2264 00d6 1546     		mov	r5, r2
 2265              	.LVL330:
 2266              	.L258:
1838:lib/ff/ff.c   **** 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 2267              		.loc 1 1838 0
 2268 00d8 17F80C80 		ldrb	r8, [r7, ip]	@ zero_extendqisi2
 2269 00dc 5FFA88F3 		uxtb	r3, r8
 2270              	.LVL331:
 2271 00e0 0CF10100 		add	r0, ip, #1
 2272              	.LVL332:
1839:lib/ff/ff.c   **** 		if (c == '.' || i >= ni) {
 2273              		.loc 1 1839 0
 2274 00e4 202B     		cmp	r3, #32
 2275 00e6 42D9     		bls	.L295
 2276 00e8 2F2B     		cmp	r3, #47
 2277 00ea 42D0     		beq	.L297
 2278 00ec 5C2B     		cmp	r3, #92
 2279 00ee 40D0     		beq	.L297
1840:lib/ff/ff.c   **** 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 2280              		.loc 1 1840 0
 2281 00f0 2E2B     		cmp	r3, #46
 2282 00f2 6CD0     		beq	.L265
 2283 00f4 8A42     		cmp	r2, r1
 2284 00f6 80F0AA80 		bcs	.L261
1845:lib/ff/ff.c   **** 			b |= 3;						/* Eliminate NT flag */
 2285              		.loc 1 1845 0
 2286 00fa 18F0800F 		tst	r8, #128
1846:lib/ff/ff.c   **** #ifdef _EXCVT
 2287              		.loc 1 1846 0
 2288 00fe 18BF     		it	ne
 2289 0100 45F00305 		orrne	r5, r5, #3
 2290              	.LVL333:
1855:lib/ff/ff.c   **** 			d = (BYTE)p[si++];			/* Get 2nd byte */
 2291              		.loc 1 1855 0
 2292 0104 03F17F08 		add	r8, r3, #127
 2293              	.LVL334:
 2294 0108 5FFA88FE 		uxtb	lr, r8
 2295 010c BEF11E0F 		cmp	lr, #30
 2296 0110 06D9     		bls	.L269
 2297 0112 03F12008 		add	r8, r3, #32
 2298 0116 5FFA88FE 		uxtb	lr, r8
 2299 011a BEF11C0F 		cmp	lr, #28
 2300 011e 1AD8     		bhi	.L270
 2301              	.L269:
1856:lib/ff/ff.c   **** 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 2302              		.loc 1 1856 0
 2303 0120 17F80080 		ldrb	r8, [r7, r0]	@ zero_extendqisi2
 2304              	.LVL335:
 2305 0124 0CF10200 		add	r0, ip, #2
 2306              	.LVL336:
1857:lib/ff/ff.c   **** 				return FR_INVALID_NAME;
 2307              		.loc 1 1857 0
 2308 0128 A8F1400E 		sub	lr, r8, #64
 2309 012c BEF13E0F 		cmp	lr, #62
 2310 0130 05D9     		bls	.L271
 2311 0132 88F0800C 		eor	ip, r8, #128
 2312              	.LVL337:
 2313 0136 BCF17C0F 		cmp	ip, #124
 2314 013a 00F28880 		bhi	.L261
 2315              	.L271:
 2316 013e 01F1FF3E 		add	lr, r1, #-1
 2317 0142 7245     		cmp	r2, lr
 2318 0144 80F08380 		bcs	.L261
1859:lib/ff/ff.c   **** 			sfn[i++] = d;
 2319              		.loc 1 1859 0
 2320 0148 B354     		strb	r3, [r6, r2]
 2321              	.LVL338:
1860:lib/ff/ff.c   **** 		} else {						/* Single byte code */
 2322              		.loc 1 1860 0
 2323 014a B318     		adds	r3, r6, r2
 2324              	.LVL339:
 2325 014c 83F80180 		strb	r8, [r3, #1]
 2326 0150 0232     		adds	r2, r2, #2
 2327              	.LVL340:
 2328              	.L267:
1825:lib/ff/ff.c   **** 		for (;;) {
 2329              		.loc 1 1825 0
 2330 0152 8446     		mov	ip, r0
 2331 0154 C0E7     		b	.L258
 2332              	.LVL341:
 2333              	.L270:
 2334 0156 DFF8FC80 		ldr	r8, .L351
 2335              	.LVL342:
 2336              	.L273:
 2337              	.LBB56:
 2338              	.LBB57:
 576:lib/ff/ff.c   **** 	return *str;
 2339              		.loc 1 576 0
 2340 015a 18F801CF 		ldrb	ip, [r8, #1]!	@ zero_extendqisi2
 2341 015e BCF1000F 		cmp	ip, #0
 2342 0162 20D0     		beq	.L272
 2343 0164 4FFA8CFC 		sxtb	ip, ip
 2344 0168 9C45     		cmp	ip, r3
 2345 016a F6D1     		bne	.L273
 2346 016c 6FE0     		b	.L261
 2347              	.LVL343:
 2348              	.L295:
 2349              	.LBE57:
 2350              	.LBE56:
1875:lib/ff/ff.c   **** 
 2351              		.loc 1 1875 0
 2352 016e 0423     		movs	r3, #4
 2353 0170 00E0     		b	.L264
 2354              	.L297:
 2355 0172 0023     		movs	r3, #0
 2356              	.L264:
 2357              	.LVL344:
1877:lib/ff/ff.c   **** 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
 2358              		.loc 1 1877 0
 2359 0174 002A     		cmp	r2, #0
 2360 0176 6AD0     		beq	.L261
1878:lib/ff/ff.c   **** 
 2361              		.loc 1 1878 0
 2362 0178 3278     		ldrb	r2, [r6, #0]	@ zero_extendqisi2
 2363              	.LVL345:
 2364 017a E52A     		cmp	r2, #229
 2365 017c 01D1     		bne	.L275
 2366 017e 0522     		movs	r2, #5
 2367 0180 3270     		strb	r2, [r6, #0]
 2368              	.L275:
1880:lib/ff/ff.c   **** 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 2369              		.loc 1 1880 0
 2370 0182 0829     		cmp	r1, #8
 2371 0184 01D1     		bne	.L276
 2372 0186 A900     		lsls	r1, r5, #2
 2373              	.LVL346:
 2374 0188 CDB2     		uxtb	r5, r1
 2375              	.LVL347:
 2376              	.L276:
1881:lib/ff/ff.c   **** 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 2377              		.loc 1 1881 0
 2378 018a 05F00302 		and	r2, r5, #3
 2379 018e 012A     		cmp	r2, #1
 2380 0190 08BF     		it	eq
 2381 0192 43F01003 		orreq	r3, r3, #16
 2382              	.LVL348:
1882:lib/ff/ff.c   **** 
 2383              		.loc 1 1882 0
 2384 0196 05F00C05 		and	r5, r5, #12
 2385              	.LVL349:
 2386 019a 042D     		cmp	r5, #4
 2387 019c 08BF     		it	eq
 2388 019e 43F00803 		orreq	r3, r3, #8
 2389              	.LVL350:
1874:lib/ff/ff.c   **** 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 2390              		.loc 1 1874 0
 2391 01a2 3F18     		adds	r7, r7, r0
 2392              	.LVL351:
 2393 01a4 67E7     		b	.L346
 2394              	.LVL352:
 2395              	.L272:
1864:lib/ff/ff.c   **** 				b |= 2;
 2396              		.loc 1 1864 0
 2397 01a6 A3F14108 		sub	r8, r3, #65
 2398 01aa B8F1190F 		cmp	r8, #25
 2399 01ae 02D8     		bhi	.L349
 2400              	.L289:
1865:lib/ff/ff.c   **** 			} else {
 2401              		.loc 1 1865 0
 2402 01b0 45F00205 		orr	r5, r5, #2
 2403              	.LVL353:
 2404 01b4 08E0     		b	.L274
 2405              	.L349:
1867:lib/ff/ff.c   **** 					b |= 1; c -= 0x20;
 2406              		.loc 1 1867 0
 2407 01b6 A3F1610E 		sub	lr, r3, #97
 2408 01ba BEF1190F 		cmp	lr, #25
 2409 01be 03D8     		bhi	.L274
1868:lib/ff/ff.c   **** 				}
 2410              		.loc 1 1868 0
 2411 01c0 45F00105 		orr	r5, r5, #1
 2412              	.LVL354:
 2413 01c4 203B     		subs	r3, r3, #32
 2414              	.LVL355:
 2415 01c6 DBB2     		uxtb	r3, r3
 2416              	.LVL356:
 2417              	.L274:
1871:lib/ff/ff.c   **** 		}
 2418              		.loc 1 1871 0
 2419 01c8 B354     		strb	r3, [r6, r2]
 2420 01ca 0132     		adds	r2, r2, #1
 2421              	.LVL357:
 2422 01cc C1E7     		b	.L267
 2423              	.LVL358:
 2424              	.L265:
1841:lib/ff/ff.c   **** 			i = 8; ni = 11;
 2425              		.loc 1 1841 0
 2426 01ce 0829     		cmp	r1, #8
 2427 01d0 3DD1     		bne	.L261
 2428              	.L343:
 2429              	.LVL359:
1843:lib/ff/ff.c   **** 		}
 2430              		.loc 1 1843 0
 2431 01d2 AD00     		lsls	r5, r5, #2
 2432              	.LVL360:
 2433 01d4 EDB2     		uxtb	r5, r5
 2434              	.LVL361:
1842:lib/ff/ff.c   **** 			b <<= 2; continue;
 2435              		.loc 1 1842 0
 2436 01d6 0A46     		mov	r2, r1
 2437 01d8 0B21     		movs	r1, #11
 2438 01da BAE7     		b	.L267
 2439              	.LVL362:
 2440              	.L348:
 2441              	.LBE58:
 2442              	.LBE66:
 2443              	.LBB67:
 2444              	.LBB64:
1465:lib/ff/ff.c   **** 		c = dir[DIR_Name];
 2445              		.loc 1 1465 0
 2446 01dc 6269     		ldr	r2, [r4, #20]
 2447              	.LVL363:
1467:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
 2448              		.loc 1 1467 0
 2449 01de 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 2450 01e0 99B1     		cbz	r1, .L299
 2451              	.LBE64:
1490:lib/ff/ff.c   **** 			break;
 2452              		.loc 1 1490 0
 2453 01e2 D37A     		ldrb	r3, [r2, #11]	@ zero_extendqisi2
 2454              	.LBB65:
 2455 01e4 03F00801 		and	r1, r3, #8
 2456 01e8 CBB2     		uxtb	r3, r1
 2457 01ea 4BB9     		cbnz	r3, .L280
 2458 01ec A669     		ldr	r6, [r4, #24]
 2459              	.LVL364:
 2460 01ee 0346     		mov	r3, r0
 2461              	.L281:
 2462              	.LBB62:
 2463              	.LBB63:
 569:lib/ff/ff.c   **** 	return r;
 2464              		.loc 1 569 0
 2465 01f0 D55C     		ldrb	r5, [r2, r3]	@ zero_extendqisi2
 2466 01f2 F15C     		ldrb	r1, [r6, r3]	@ zero_extendqisi2
 2467              	.LVL365:
 2468 01f4 0133     		adds	r3, r3, #1
 2469 01f6 8D42     		cmp	r5, r1
 2470 01f8 02D1     		bne	.L280
 2471              	.L282:
 2472              	.LVL366:
 2473 01fa 0B2B     		cmp	r3, #11
 2474 01fc F8D1     		bne	.L281
 2475 01fe 47E7     		b	.L279
 2476              	.LVL367:
 2477              	.L280:
 2478              	.LBE63:
 2479              	.LBE62:
1493:lib/ff/ff.c   **** 	} while (res == FR_OK);
 2480              		.loc 1 1493 0
 2481 0200 2046     		mov	r0, r4
 2482              	.LVL368:
 2483 0202 0021     		movs	r1, #0
 2484 0204 FFF7FEFF 		bl	dir_next
 2485              	.LVL369:
 2486 0208 3AE7     		b	.L345
 2487              	.LVL370:
 2488              	.L299:
1467:lib/ff/ff.c   **** #if _USE_LFN	/* LFN configuration */
 2489              		.loc 1 1467 0
 2490 020a 0420     		movs	r0, #4
 2491              	.LVL371:
 2492 020c 40E7     		b	.L279
 2493              	.LVL372:
 2494              	.L284:
 2495              	.LBE65:
 2496              	.LBE67:
2022:lib/ff/ff.c   **** 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
 2497              		.loc 1 2022 0
 2498 020e 03F00400 		and	r0, r3, #4
 2499 0212 C2B2     		uxtb	r2, r0
 2500 0214 42B1     		cbz	r2, .L350
 2501              	.LVL373:
 2502              	.L287:
2015:lib/ff/ff.c   **** 					if (!(ns & NS_LAST)) continue;
 2503              		.loc 1 2015 0
 2504 0216 0020     		movs	r0, #0
 2505 0218 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2506              	.L285:
2018:lib/ff/ff.c   **** 				}
 2507              		.loc 1 2018 0
 2508 021c 0028     		cmp	r0, #0
 2509 021e 14BF     		ite	ne
 2510 0220 0420     		movne	r0, #4
 2511 0222 0520     		moveq	r0, #5
 2512 0224 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2513              	.LVL374:
 2514              	.L350:
2023:lib/ff/ff.c   **** 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
 2515              		.loc 1 2023 0
 2516 0228 6369     		ldr	r3, [r4, #20]
 2517              	.LVL375:
2024:lib/ff/ff.c   **** 				res = FR_NO_PATH; break;
 2518              		.loc 1 2024 0
 2519 022a D97A     		ldrb	r1, [r3, #11]	@ zero_extendqisi2
 2520              	.LVL376:
 2521 022c 01F01000 		and	r0, r1, #16
 2522 0230 C2B2     		uxtb	r2, r0
 2523 0232 4AB1     		cbz	r2, .L301
 2524              	.LVL377:
 2525              	.LBB68:
 2526              	.LBB69:
1247:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 2527              		.loc 1 1247 0
 2528 0234 5E8B     		ldrh	r6, [r3, #26]
 2529              	.LVL378:
2253:lib/ff/ff.c   **** 
2254:lib/ff/ff.c   **** 
2255:lib/ff/ff.c   **** 
2256:lib/ff/ff.c   **** 
2257:lib/ff/ff.c   **** /*--------------------------------------------------------------------------
2258:lib/ff/ff.c   **** 
2259:lib/ff/ff.c   ****    Public Functions
2260:lib/ff/ff.c   **** 
2261:lib/ff/ff.c   **** --------------------------------------------------------------------------*/
2262:lib/ff/ff.c   **** 
2263:lib/ff/ff.c   **** 
2264:lib/ff/ff.c   **** 
2265:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2266:lib/ff/ff.c   **** /* Mount/Unmount a Logical Drive                                         */
2267:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2268:lib/ff/ff.c   **** 
2269:lib/ff/ff.c   **** FRESULT f_mount (
2270:lib/ff/ff.c   **** 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
2271:lib/ff/ff.c   **** 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
2272:lib/ff/ff.c   **** )
2273:lib/ff/ff.c   **** {
2274:lib/ff/ff.c   **** 	FATFS *rfs;
2275:lib/ff/ff.c   **** 
2276:lib/ff/ff.c   **** 
2277:lib/ff/ff.c   **** 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
2278:lib/ff/ff.c   **** 		return FR_INVALID_DRIVE;
2279:lib/ff/ff.c   **** 	rfs = FatFs[vol];			/* Get current fs object */
2280:lib/ff/ff.c   **** 
2281:lib/ff/ff.c   **** 	if (rfs) {
2282:lib/ff/ff.c   **** #if _FS_LOCK
2283:lib/ff/ff.c   **** 		clear_lock(rfs);
2284:lib/ff/ff.c   **** #endif
2285:lib/ff/ff.c   **** #if _FS_REENTRANT				/* Discard sync object of the current volume */
2286:lib/ff/ff.c   **** 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2287:lib/ff/ff.c   **** #endif
2288:lib/ff/ff.c   **** 		rfs->fs_type = 0;		/* Clear old fs object */
2289:lib/ff/ff.c   **** 	}
2290:lib/ff/ff.c   **** 
2291:lib/ff/ff.c   **** 	if (fs) {
2292:lib/ff/ff.c   **** 		fs->fs_type = 0;		/* Clear new fs object */
2293:lib/ff/ff.c   **** #if _FS_REENTRANT				/* Create sync object for the new volume */
2294:lib/ff/ff.c   **** 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2295:lib/ff/ff.c   **** #endif
2296:lib/ff/ff.c   **** 	}
2297:lib/ff/ff.c   **** 	FatFs[vol] = fs;			/* Register new fs object */
2298:lib/ff/ff.c   **** 
2299:lib/ff/ff.c   **** 	return FR_OK;
2300:lib/ff/ff.c   **** }
2301:lib/ff/ff.c   **** 
2302:lib/ff/ff.c   **** 
2303:lib/ff/ff.c   **** 
2304:lib/ff/ff.c   **** 
2305:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2306:lib/ff/ff.c   **** /* Open or Create a File                                                 */
2307:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2308:lib/ff/ff.c   **** 
2309:lib/ff/ff.c   **** FRESULT f_open (
2310:lib/ff/ff.c   **** 	FIL *fp,			/* Pointer to the blank file object */
2311:lib/ff/ff.c   **** 	const TCHAR *path,	/* Pointer to the file name */
2312:lib/ff/ff.c   **** 	BYTE mode			/* Access mode and file open mode flags */
2313:lib/ff/ff.c   **** )
2314:lib/ff/ff.c   **** {
2315:lib/ff/ff.c   **** 	FRESULT res;
2316:lib/ff/ff.c   **** 	DIR dj;
2317:lib/ff/ff.c   **** 	BYTE *dir;
2318:lib/ff/ff.c   **** 	DEF_NAMEBUF;
2319:lib/ff/ff.c   **** 
2320:lib/ff/ff.c   **** 
2321:lib/ff/ff.c   **** 	if (!fp) return FR_INVALID_OBJECT;
2322:lib/ff/ff.c   **** 	fp->fs = 0;			/* Clear file object */
2323:lib/ff/ff.c   **** 
2324:lib/ff/ff.c   **** #if !_FS_READONLY
2325:lib/ff/ff.c   **** 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
2326:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
2327:lib/ff/ff.c   **** #else
2328:lib/ff/ff.c   **** 	mode &= FA_READ;
2329:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 0);
2330:lib/ff/ff.c   **** #endif
2331:lib/ff/ff.c   **** 	if (res == FR_OK) {
2332:lib/ff/ff.c   **** 		INIT_BUF(dj);
2333:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
2334:lib/ff/ff.c   **** 		dir = dj.dir;
2335:lib/ff/ff.c   **** #if !_FS_READONLY	/* R/W configuration */
2336:lib/ff/ff.c   **** 		if (res == FR_OK) {
2337:lib/ff/ff.c   **** 			if (!dir)	/* Current dir itself */
2338:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
2339:lib/ff/ff.c   **** #if _FS_LOCK
2340:lib/ff/ff.c   **** 			else
2341:lib/ff/ff.c   **** 				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2342:lib/ff/ff.c   **** #endif
2343:lib/ff/ff.c   **** 		}
2344:lib/ff/ff.c   **** 		/* Create or Open a file */
2345:lib/ff/ff.c   **** 		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
2346:lib/ff/ff.c   **** 			DWORD dw, cl;
2347:lib/ff/ff.c   **** 
2348:lib/ff/ff.c   **** 			if (res != FR_OK) {					/* No file, create new */
2349:lib/ff/ff.c   **** 				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
2350:lib/ff/ff.c   **** #if _FS_LOCK
2351:lib/ff/ff.c   **** 					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2352:lib/ff/ff.c   **** #else
2353:lib/ff/ff.c   **** 					res = dir_register(&dj);
2354:lib/ff/ff.c   **** #endif
2355:lib/ff/ff.c   **** 				mode |= FA_CREATE_ALWAYS;		/* File is created */
2356:lib/ff/ff.c   **** 				dir = dj.dir;					/* New entry */
2357:lib/ff/ff.c   **** 			}
2358:lib/ff/ff.c   **** 			else {								/* Any object is already existing */
2359:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
2360:lib/ff/ff.c   **** 					res = FR_DENIED;
2361:lib/ff/ff.c   **** 				} else {
2362:lib/ff/ff.c   **** 					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
2363:lib/ff/ff.c   **** 						res = FR_EXIST;
2364:lib/ff/ff.c   **** 				}
2365:lib/ff/ff.c   **** 			}
2366:lib/ff/ff.c   **** 			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
2367:lib/ff/ff.c   **** 				dw = get_fattime();					/* Created time */
2368:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_CrtTime, dw);
2369:lib/ff/ff.c   **** 				dir[DIR_Attr] = 0;					/* Reset attribute */
2370:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
2371:lib/ff/ff.c   **** 				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
2372:lib/ff/ff.c   **** 				st_clust(dir, 0);					/* cluster = 0 */
2373:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
2374:lib/ff/ff.c   **** 				if (cl) {							/* Remove the cluster chain if exist */
2375:lib/ff/ff.c   **** 					dw = dj.fs->winsect;
2376:lib/ff/ff.c   **** 					res = remove_chain(dj.fs, cl);
2377:lib/ff/ff.c   **** 					if (res == FR_OK) {
2378:lib/ff/ff.c   **** 						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
2379:lib/ff/ff.c   **** 						res = move_window(dj.fs, dw);
2380:lib/ff/ff.c   **** 					}
2381:lib/ff/ff.c   **** 				}
2382:lib/ff/ff.c   **** 			}
2383:lib/ff/ff.c   **** 		}
2384:lib/ff/ff.c   **** 		else {	/* Open an existing file */
2385:lib/ff/ff.c   **** 			if (res == FR_OK) {						/* Follow succeeded */
2386:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
2387:lib/ff/ff.c   **** 					res = FR_NO_FILE;
2388:lib/ff/ff.c   **** 				} else {
2389:lib/ff/ff.c   **** 					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
2390:lib/ff/ff.c   **** 						res = FR_DENIED;
2391:lib/ff/ff.c   **** 				}
2392:lib/ff/ff.c   **** 			}
2393:lib/ff/ff.c   **** 		}
2394:lib/ff/ff.c   **** 		if (res == FR_OK) {
2395:lib/ff/ff.c   **** 			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
2396:lib/ff/ff.c   **** 				mode |= FA__WRITTEN;
2397:lib/ff/ff.c   **** 			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
2398:lib/ff/ff.c   **** 			fp->dir_ptr = dir;
2399:lib/ff/ff.c   **** #if _FS_LOCK
2400:lib/ff/ff.c   **** 			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2401:lib/ff/ff.c   **** 			if (!fp->lockid) res = FR_INT_ERR;
2402:lib/ff/ff.c   **** #endif
2403:lib/ff/ff.c   **** 		}
2404:lib/ff/ff.c   **** 
2405:lib/ff/ff.c   **** #else				/* R/O configuration */
2406:lib/ff/ff.c   **** 		if (res == FR_OK) {					/* Follow succeeded */
2407:lib/ff/ff.c   **** 			dir = dj.dir;
2408:lib/ff/ff.c   **** 			if (!dir) {						/* Current dir itself */
2409:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
2410:lib/ff/ff.c   **** 			} else {
2411:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
2412:lib/ff/ff.c   **** 					res = FR_NO_FILE;
2413:lib/ff/ff.c   **** 			}
2414:lib/ff/ff.c   **** 		}
2415:lib/ff/ff.c   **** #endif
2416:lib/ff/ff.c   **** 		FREE_BUF();
2417:lib/ff/ff.c   **** 
2418:lib/ff/ff.c   **** 		if (res == FR_OK) {
2419:lib/ff/ff.c   **** 			fp->flag = mode;					/* File access mode */
2420:lib/ff/ff.c   **** 			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
2421:lib/ff/ff.c   **** 			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
2422:lib/ff/ff.c   **** 			fp->fptr = 0;						/* File pointer */
2423:lib/ff/ff.c   **** 			fp->dsect = 0;
2424:lib/ff/ff.c   **** #if _USE_FASTSEEK
2425:lib/ff/ff.c   **** 			fp->cltbl = 0;						/* Normal seek mode */
2426:lib/ff/ff.c   **** #endif
2427:lib/ff/ff.c   **** 			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
2428:lib/ff/ff.c   **** 		}
2429:lib/ff/ff.c   **** 	}
2430:lib/ff/ff.c   **** 
2431:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
2432:lib/ff/ff.c   **** }
2433:lib/ff/ff.c   **** 
2434:lib/ff/ff.c   **** 
2435:lib/ff/ff.c   **** 
2436:lib/ff/ff.c   **** 
2437:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2438:lib/ff/ff.c   **** /* Read File                                                             */
2439:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2440:lib/ff/ff.c   **** 
2441:lib/ff/ff.c   **** FRESULT f_read (
2442:lib/ff/ff.c   **** 	FIL *fp, 		/* Pointer to the file object */
2443:lib/ff/ff.c   **** 	void *buff,		/* Pointer to data buffer */
2444:lib/ff/ff.c   **** 	UINT btr,		/* Number of bytes to read */
2445:lib/ff/ff.c   **** 	UINT *br		/* Pointer to number of bytes read */
2446:lib/ff/ff.c   **** )
2447:lib/ff/ff.c   **** {
2448:lib/ff/ff.c   **** 	FRESULT res;
2449:lib/ff/ff.c   **** 	DWORD clst, sect, remain;
2450:lib/ff/ff.c   **** 	UINT rcnt, cc;
2451:lib/ff/ff.c   **** 	BYTE csect, *rbuff = (BYTE*)buff;
2452:lib/ff/ff.c   **** 
2453:lib/ff/ff.c   **** 
2454:lib/ff/ff.c   **** 	*br = 0;	/* Clear read byte counter */
2455:lib/ff/ff.c   **** 
2456:lib/ff/ff.c   **** 	res = validate(fp);							/* Check validity */
2457:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2458:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)					/* Aborted file? */
2459:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2460:lib/ff/ff.c   **** 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
2461:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
2462:lib/ff/ff.c   **** 	remain = fp->fsize - fp->fptr;
2463:lib/ff/ff.c   **** 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
2464:lib/ff/ff.c   **** 
2465:lib/ff/ff.c   **** 	for ( ;  btr;								/* Repeat until all data read */
2466:lib/ff/ff.c   **** 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
2467:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
2468:lib/ff/ff.c   **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
2469:lib/ff/ff.c   **** 			if (!csect) {						/* On the cluster boundary? */
2470:lib/ff/ff.c   **** 				if (fp->fptr == 0) {			/* On the top of the file? */
2471:lib/ff/ff.c   **** 					clst = fp->sclust;			/* Follow from the origin */
2472:lib/ff/ff.c   **** 				} else {						/* Middle or end of the file */
2473:lib/ff/ff.c   **** #if _USE_FASTSEEK
2474:lib/ff/ff.c   **** 					if (fp->cltbl)
2475:lib/ff/ff.c   **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
2476:lib/ff/ff.c   **** 					else
2477:lib/ff/ff.c   **** #endif
2478:lib/ff/ff.c   **** 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
2479:lib/ff/ff.c   **** 				}
2480:lib/ff/ff.c   **** 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
2481:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2482:lib/ff/ff.c   **** 				fp->clust = clst;				/* Update current cluster */
2483:lib/ff/ff.c   **** 			}
2484:lib/ff/ff.c   **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
2485:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
2486:lib/ff/ff.c   **** 			sect += csect;
2487:lib/ff/ff.c   **** 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
2488:lib/ff/ff.c   **** 			if (cc) {							/* Read maximum contiguous sectors directly */
2489:lib/ff/ff.c   **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
2490:lib/ff/ff.c   **** 					cc = fp->fs->csize - csect;
2491:lib/ff/ff.c   **** 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
2492:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
2493:lib/ff/ff.c   **** #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it 
2494:lib/ff/ff.c   **** #if _FS_TINY
2495:lib/ff/ff.c   **** 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
2496:lib/ff/ff.c   **** 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
2497:lib/ff/ff.c   **** #else
2498:lib/ff/ff.c   **** 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2499:lib/ff/ff.c   **** 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
2500:lib/ff/ff.c   **** #endif
2501:lib/ff/ff.c   **** #endif
2502:lib/ff/ff.c   **** 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
2503:lib/ff/ff.c   **** 				continue;
2504:lib/ff/ff.c   **** 			}
2505:lib/ff/ff.c   **** #if !_FS_TINY
2506:lib/ff/ff.c   **** 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
2507:lib/ff/ff.c   **** #if !_FS_READONLY
2508:lib/ff/ff.c   **** 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
2509:lib/ff/ff.c   **** 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2510:lib/ff/ff.c   **** 						ABORT(fp->fs, FR_DISK_ERR);
2511:lib/ff/ff.c   **** 					fp->flag &= ~FA__DIRTY;
2512:lib/ff/ff.c   **** 				}
2513:lib/ff/ff.c   **** #endif
2514:lib/ff/ff.c   **** 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
2515:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
2516:lib/ff/ff.c   **** 			}
2517:lib/ff/ff.c   **** #endif
2518:lib/ff/ff.c   **** 			fp->dsect = sect;
2519:lib/ff/ff.c   **** 		}
2520:lib/ff/ff.c   **** 		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer 
2521:lib/ff/ff.c   **** 		if (rcnt > btr) rcnt = btr;
2522:lib/ff/ff.c   **** #if _FS_TINY
2523:lib/ff/ff.c   **** 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
2524:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
2525:lib/ff/ff.c   **** 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
2526:lib/ff/ff.c   **** #else
2527:lib/ff/ff.c   **** 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
2528:lib/ff/ff.c   **** #endif
2529:lib/ff/ff.c   **** 	}
2530:lib/ff/ff.c   **** 
2531:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, FR_OK);
2532:lib/ff/ff.c   **** }
2533:lib/ff/ff.c   **** 
2534:lib/ff/ff.c   **** 
2535:lib/ff/ff.c   **** 
2536:lib/ff/ff.c   **** 
2537:lib/ff/ff.c   **** #if !_FS_READONLY
2538:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2539:lib/ff/ff.c   **** /* Write File                                                            */
2540:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2541:lib/ff/ff.c   **** 
2542:lib/ff/ff.c   **** FRESULT f_write (
2543:lib/ff/ff.c   **** 	FIL *fp,			/* Pointer to the file object */
2544:lib/ff/ff.c   **** 	const void *buff,	/* Pointer to the data to be written */
2545:lib/ff/ff.c   **** 	UINT btw,			/* Number of bytes to write */
2546:lib/ff/ff.c   **** 	UINT *bw			/* Pointer to number of bytes written */
2547:lib/ff/ff.c   **** )
2548:lib/ff/ff.c   **** {
2549:lib/ff/ff.c   **** 	FRESULT res;
2550:lib/ff/ff.c   **** 	DWORD clst, sect;
2551:lib/ff/ff.c   **** 	UINT wcnt, cc;
2552:lib/ff/ff.c   **** 	const BYTE *wbuff = (const BYTE*)buff;
2553:lib/ff/ff.c   **** 	BYTE csect;
2554:lib/ff/ff.c   **** 
2555:lib/ff/ff.c   **** 
2556:lib/ff/ff.c   **** 	*bw = 0;	/* Clear write byte counter */
2557:lib/ff/ff.c   **** 
2558:lib/ff/ff.c   **** 	res = validate(fp);						/* Check validity */
2559:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2560:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)				/* Aborted file? */
2561:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2562:lib/ff/ff.c   **** 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
2563:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
2564:lib/ff/ff.c   **** 	if (fp->fptr + btw < fp->fptr) btw = 0;    /* File size cannot reach 4GB */
2565:lib/ff/ff.c   **** 
2566:lib/ff/ff.c   **** 	for ( ;  btw;							/* Repeat until all data written */
2567:lib/ff/ff.c   **** 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
2568:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
2569:lib/ff/ff.c   **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
2570:lib/ff/ff.c   **** 			if (!csect) {					/* On the cluster boundary? */
2571:lib/ff/ff.c   **** 				if (fp->fptr == 0) {		/* On the top of the file? */
2572:lib/ff/ff.c   **** 					clst = fp->sclust;		/* Follow from the origin */
2573:lib/ff/ff.c   **** 					if (clst == 0)			/* When no cluster is allocated, */
2574:lib/ff/ff.c   **** 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
2575:lib/ff/ff.c   **** 				} else {					/* Middle or end of the file */
2576:lib/ff/ff.c   **** #if _USE_FASTSEEK
2577:lib/ff/ff.c   **** 					if (fp->cltbl)
2578:lib/ff/ff.c   **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
2579:lib/ff/ff.c   **** 					else
2580:lib/ff/ff.c   **** #endif
2581:lib/ff/ff.c   **** 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
2582:lib/ff/ff.c   **** 				}
2583:lib/ff/ff.c   **** 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
2584:lib/ff/ff.c   **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
2585:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2586:lib/ff/ff.c   **** 				fp->clust = clst;			/* Update current cluster */
2587:lib/ff/ff.c   **** 			}
2588:lib/ff/ff.c   **** #if _FS_TINY
2589:lib/ff/ff.c   **** 			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
2590:lib/ff/ff.c   **** 				ABORT(fp->fs, FR_DISK_ERR);
2591:lib/ff/ff.c   **** #else
2592:lib/ff/ff.c   **** 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
2593:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2594:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
2595:lib/ff/ff.c   **** 				fp->flag &= ~FA__DIRTY;
2596:lib/ff/ff.c   **** 			}
2597:lib/ff/ff.c   **** #endif
2598:lib/ff/ff.c   **** 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
2599:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
2600:lib/ff/ff.c   **** 			sect += csect;
2601:lib/ff/ff.c   **** 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
2602:lib/ff/ff.c   **** 			if (cc) {						/* Write maximum contiguous sectors directly */
2603:lib/ff/ff.c   **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
2604:lib/ff/ff.c   **** 					cc = fp->fs->csize - csect;
2605:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
2606:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
2607:lib/ff/ff.c   **** #if _FS_TINY
2608:lib/ff/ff.c   **** 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct 
2609:lib/ff/ff.c   **** 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
2610:lib/ff/ff.c   **** 					fp->fs->wflag = 0;
2611:lib/ff/ff.c   **** 				}
2612:lib/ff/ff.c   **** #else
2613:lib/ff/ff.c   **** 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write 
2614:lib/ff/ff.c   **** 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
2615:lib/ff/ff.c   **** 					fp->flag &= ~FA__DIRTY;
2616:lib/ff/ff.c   **** 				}
2617:lib/ff/ff.c   **** #endif
2618:lib/ff/ff.c   **** 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
2619:lib/ff/ff.c   **** 				continue;
2620:lib/ff/ff.c   **** 			}
2621:lib/ff/ff.c   **** #if _FS_TINY
2622:lib/ff/ff.c   **** 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
2623:lib/ff/ff.c   **** 				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
2624:lib/ff/ff.c   **** 				fp->fs->winsect = sect;
2625:lib/ff/ff.c   **** 			}
2626:lib/ff/ff.c   **** #else
2627:lib/ff/ff.c   **** 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
2628:lib/ff/ff.c   **** 				if (fp->fptr < fp->fsize &&
2629:lib/ff/ff.c   **** 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
2630:lib/ff/ff.c   **** 						ABORT(fp->fs, FR_DISK_ERR);
2631:lib/ff/ff.c   **** 			}
2632:lib/ff/ff.c   **** #endif
2633:lib/ff/ff.c   **** 			fp->dsect = sect;
2634:lib/ff/ff.c   **** 		}
2635:lib/ff/ff.c   **** 		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
2636:lib/ff/ff.c   **** 		if (wcnt > btw) wcnt = btw;
2637:lib/ff/ff.c   **** #if _FS_TINY
2638:lib/ff/ff.c   **** 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
2639:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
2640:lib/ff/ff.c   **** 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
2641:lib/ff/ff.c   **** 		fp->fs->wflag = 1;
2642:lib/ff/ff.c   **** #else
2643:lib/ff/ff.c   **** 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
2644:lib/ff/ff.c   **** 		fp->flag |= FA__DIRTY;
2645:lib/ff/ff.c   **** #endif
2646:lib/ff/ff.c   **** 	}
2647:lib/ff/ff.c   **** 
2648:lib/ff/ff.c   **** 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
2649:lib/ff/ff.c   **** 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
2650:lib/ff/ff.c   **** 
2651:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, FR_OK);
2652:lib/ff/ff.c   **** }
2653:lib/ff/ff.c   **** 
2654:lib/ff/ff.c   **** 
2655:lib/ff/ff.c   **** 
2656:lib/ff/ff.c   **** 
2657:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2658:lib/ff/ff.c   **** /* Synchronize the File Object                                           */
2659:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2660:lib/ff/ff.c   **** 
2661:lib/ff/ff.c   **** FRESULT f_sync (
2662:lib/ff/ff.c   **** 	FIL *fp		/* Pointer to the file object */
2663:lib/ff/ff.c   **** )
2664:lib/ff/ff.c   **** {
2665:lib/ff/ff.c   **** 	FRESULT res;
2666:lib/ff/ff.c   **** 	DWORD tm;
2667:lib/ff/ff.c   **** 	BYTE *dir;
2668:lib/ff/ff.c   **** 
2669:lib/ff/ff.c   **** 
2670:lib/ff/ff.c   **** 	res = validate(fp);					/* Check validity of the object */
2671:lib/ff/ff.c   **** 	if (res == FR_OK) {
2672:lib/ff/ff.c   **** 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
2673:lib/ff/ff.c   **** #if !_FS_TINY	/* Write-back dirty buffer */
2674:lib/ff/ff.c   **** 			if (fp->flag & FA__DIRTY) {
2675:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2676:lib/ff/ff.c   **** 					LEAVE_FF(fp->fs, FR_DISK_ERR);
2677:lib/ff/ff.c   **** 				fp->flag &= ~FA__DIRTY;
2678:lib/ff/ff.c   **** 			}
2679:lib/ff/ff.c   **** #endif
2680:lib/ff/ff.c   **** 			/* Update the directory entry */
2681:lib/ff/ff.c   **** 			res = move_window(fp->fs, fp->dir_sect);
2682:lib/ff/ff.c   **** 			if (res == FR_OK) {
2683:lib/ff/ff.c   **** 				dir = fp->dir_ptr;
2684:lib/ff/ff.c   **** 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
2685:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
2686:lib/ff/ff.c   **** 				st_clust(dir, fp->sclust);					/* Update start cluster */
2687:lib/ff/ff.c   **** 				tm = get_fattime();							/* Update updated time */
2688:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tm);
2689:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_LstAccDate, 0);
2690:lib/ff/ff.c   **** 				fp->flag &= ~FA__WRITTEN;
2691:lib/ff/ff.c   **** 				fp->fs->wflag = 1;
2692:lib/ff/ff.c   **** 				res = sync_fs(fp->fs);
2693:lib/ff/ff.c   **** 			}
2694:lib/ff/ff.c   **** 		}
2695:lib/ff/ff.c   **** 	}
2696:lib/ff/ff.c   **** 
2697:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, res);
2698:lib/ff/ff.c   **** }
2699:lib/ff/ff.c   **** 
2700:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
2701:lib/ff/ff.c   **** 
2702:lib/ff/ff.c   **** 
2703:lib/ff/ff.c   **** 
2704:lib/ff/ff.c   **** 
2705:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2706:lib/ff/ff.c   **** /* Close File                                                            */
2707:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2708:lib/ff/ff.c   **** 
2709:lib/ff/ff.c   **** FRESULT f_close (
2710:lib/ff/ff.c   **** 	FIL *fp		/* Pointer to the file object to be closed */
2711:lib/ff/ff.c   **** )
2712:lib/ff/ff.c   **** {
2713:lib/ff/ff.c   **** 	FRESULT res;
2714:lib/ff/ff.c   **** 
2715:lib/ff/ff.c   **** 
2716:lib/ff/ff.c   **** #if _FS_READONLY
2717:lib/ff/ff.c   **** 	res = validate(fp);
2718:lib/ff/ff.c   **** 	{
2719:lib/ff/ff.c   **** #if _FS_REENTRANT
2720:lib/ff/ff.c   **** 		FATFS *fs = fp->fs;
2721:lib/ff/ff.c   **** #endif
2722:lib/ff/ff.c   **** 		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
2723:lib/ff/ff.c   **** 		LEAVE_FF(fs, res);
2724:lib/ff/ff.c   **** 	}
2725:lib/ff/ff.c   **** #else
2726:lib/ff/ff.c   **** 	res = f_sync(fp);		/* Flush cached data */
2727:lib/ff/ff.c   **** #if _FS_LOCK
2728:lib/ff/ff.c   **** 	if (res == FR_OK) {		/* Decrement open counter */
2729:lib/ff/ff.c   **** #if _FS_REENTRANT
2730:lib/ff/ff.c   **** 		FATFS *fs = fp->fs;;
2731:lib/ff/ff.c   **** 		res = validate(fp);
2732:lib/ff/ff.c   **** 		if (res == FR_OK) {
2733:lib/ff/ff.c   **** 			res = dec_lock(fp->lockid);	
2734:lib/ff/ff.c   **** 			unlock_fs(fs, FR_OK);
2735:lib/ff/ff.c   **** 		}
2736:lib/ff/ff.c   **** #else
2737:lib/ff/ff.c   **** 		res = dec_lock(fp->lockid);
2738:lib/ff/ff.c   **** #endif
2739:lib/ff/ff.c   **** 	}
2740:lib/ff/ff.c   **** #endif
2741:lib/ff/ff.c   **** 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
2742:lib/ff/ff.c   **** 	return res;
2743:lib/ff/ff.c   **** #endif
2744:lib/ff/ff.c   **** }
2745:lib/ff/ff.c   **** 
2746:lib/ff/ff.c   **** 
2747:lib/ff/ff.c   **** 
2748:lib/ff/ff.c   **** 
2749:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2750:lib/ff/ff.c   **** /* Current Drive/Directory Handlings                                     */
2751:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2752:lib/ff/ff.c   **** 
2753:lib/ff/ff.c   **** #if _FS_RPATH >= 1
2754:lib/ff/ff.c   **** 
2755:lib/ff/ff.c   **** FRESULT f_chdrive (
2756:lib/ff/ff.c   **** 	BYTE drv		/* Drive number */
2757:lib/ff/ff.c   **** )
2758:lib/ff/ff.c   **** {
2759:lib/ff/ff.c   **** 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
2760:lib/ff/ff.c   **** 
2761:lib/ff/ff.c   **** 	CurrVol = drv;
2762:lib/ff/ff.c   **** 
2763:lib/ff/ff.c   **** 	return FR_OK;
2764:lib/ff/ff.c   **** }
2765:lib/ff/ff.c   **** 
2766:lib/ff/ff.c   **** 
2767:lib/ff/ff.c   **** 
2768:lib/ff/ff.c   **** FRESULT f_chdir (
2769:lib/ff/ff.c   **** 	const TCHAR *path	/* Pointer to the directory path */
2770:lib/ff/ff.c   **** )
2771:lib/ff/ff.c   **** {
2772:lib/ff/ff.c   **** 	FRESULT res;
2773:lib/ff/ff.c   **** 	DIR dj;
2774:lib/ff/ff.c   **** 	DEF_NAMEBUF;
2775:lib/ff/ff.c   **** 
2776:lib/ff/ff.c   **** 
2777:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 0);
2778:lib/ff/ff.c   **** 	if (res == FR_OK) {
2779:lib/ff/ff.c   **** 		INIT_BUF(dj);
2780:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the path */
2781:lib/ff/ff.c   **** 		FREE_BUF();
2782:lib/ff/ff.c   **** 		if (res == FR_OK) {					/* Follow completed */
2783:lib/ff/ff.c   **** 			if (!dj.dir) {
2784:lib/ff/ff.c   **** 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
2785:lib/ff/ff.c   **** 			} else {
2786:lib/ff/ff.c   **** 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
2787:lib/ff/ff.c   **** 					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
2788:lib/ff/ff.c   **** 				else
2789:lib/ff/ff.c   **** 					res = FR_NO_PATH;		/* Reached but a file */
2790:lib/ff/ff.c   **** 			}
2791:lib/ff/ff.c   **** 		}
2792:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
2793:lib/ff/ff.c   **** 	}
2794:lib/ff/ff.c   **** 
2795:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
2796:lib/ff/ff.c   **** }
2797:lib/ff/ff.c   **** 
2798:lib/ff/ff.c   **** 
2799:lib/ff/ff.c   **** #if _FS_RPATH >= 2
2800:lib/ff/ff.c   **** FRESULT f_getcwd (
2801:lib/ff/ff.c   **** 	TCHAR *buff,	/* Pointer to the directory path */
2802:lib/ff/ff.c   **** 	UINT len		/* Size of path */
2803:lib/ff/ff.c   **** )
2804:lib/ff/ff.c   **** {
2805:lib/ff/ff.c   **** 	FRESULT res;
2806:lib/ff/ff.c   **** 	DIR dj;
2807:lib/ff/ff.c   **** 	UINT i, n;
2808:lib/ff/ff.c   **** 	DWORD ccl;
2809:lib/ff/ff.c   **** 	TCHAR *tp;
2810:lib/ff/ff.c   **** 	FILINFO fno;
2811:lib/ff/ff.c   **** 	DEF_NAMEBUF;
2812:lib/ff/ff.c   **** 
2813:lib/ff/ff.c   **** 
2814:lib/ff/ff.c   **** 	*buff = 0;
2815:lib/ff/ff.c   **** 	res = chk_mounted((const TCHAR**)&buff, &dj.fs, 0);	/* Get current volume */
2816:lib/ff/ff.c   **** 	if (res == FR_OK) {
2817:lib/ff/ff.c   **** 		INIT_BUF(dj);
2818:lib/ff/ff.c   **** 		i = len;			/* Bottom of buffer (dir stack base) */
2819:lib/ff/ff.c   **** 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
2820:lib/ff/ff.c   **** 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
2821:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 1);			/* Get parent dir */
2822:lib/ff/ff.c   **** 			if (res != FR_OK) break;
2823:lib/ff/ff.c   **** 			res = dir_read(&dj, 0);
2824:lib/ff/ff.c   **** 			if (res != FR_OK) break;
2825:lib/ff/ff.c   **** 			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
2826:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 0);
2827:lib/ff/ff.c   **** 			if (res != FR_OK) break;
2828:lib/ff/ff.c   **** 			do {							/* Find the entry links to the child dir */
2829:lib/ff/ff.c   **** 				res = dir_read(&dj, 0);
2830:lib/ff/ff.c   **** 				if (res != FR_OK) break;
2831:lib/ff/ff.c   **** 				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
2832:lib/ff/ff.c   **** 				res = dir_next(&dj, 0);	
2833:lib/ff/ff.c   **** 			} while (res == FR_OK);
2834:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
2835:lib/ff/ff.c   **** 			if (res != FR_OK) break;
2836:lib/ff/ff.c   **** #if _USE_LFN
2837:lib/ff/ff.c   **** 			fno.lfname = buff;
2838:lib/ff/ff.c   **** 			fno.lfsize = i;
2839:lib/ff/ff.c   **** #endif
2840:lib/ff/ff.c   **** 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
2841:lib/ff/ff.c   **** 			tp = fno.fname;
2842:lib/ff/ff.c   **** 			if (_USE_LFN && *buff) tp = buff;
2843:lib/ff/ff.c   **** 			for (n = 0; tp[n]; n++) ;
2844:lib/ff/ff.c   **** 			if (i < n + 3) {
2845:lib/ff/ff.c   **** 				res = FR_NOT_ENOUGH_CORE; break;
2846:lib/ff/ff.c   **** 			}
2847:lib/ff/ff.c   **** 			while (n) buff[--i] = tp[--n];
2848:lib/ff/ff.c   **** 			buff[--i] = '/';
2849:lib/ff/ff.c   **** 		}
2850:lib/ff/ff.c   **** 		tp = buff;
2851:lib/ff/ff.c   **** 		if (res == FR_OK) {
2852:lib/ff/ff.c   **** 			*tp++ = '0' + CurrVol;			/* Put drive number */
2853:lib/ff/ff.c   **** 			*tp++ = ':';
2854:lib/ff/ff.c   **** 			if (i == len) {					/* Root-dir */
2855:lib/ff/ff.c   **** 				*tp++ = '/';
2856:lib/ff/ff.c   **** 			} else {						/* Sub-dir */
2857:lib/ff/ff.c   **** 				do		/* Add stacked path str */
2858:lib/ff/ff.c   **** 					*tp++ = buff[i++];
2859:lib/ff/ff.c   **** 				while (i < len);
2860:lib/ff/ff.c   **** 			}
2861:lib/ff/ff.c   **** 		}
2862:lib/ff/ff.c   **** 		*tp = 0;
2863:lib/ff/ff.c   **** 		FREE_BUF();
2864:lib/ff/ff.c   **** 	}
2865:lib/ff/ff.c   **** 
2866:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
2867:lib/ff/ff.c   **** }
2868:lib/ff/ff.c   **** #endif /* _FS_RPATH >= 2 */
2869:lib/ff/ff.c   **** #endif /* _FS_RPATH >= 1 */
2870:lib/ff/ff.c   **** 
2871:lib/ff/ff.c   **** 
2872:lib/ff/ff.c   **** 
2873:lib/ff/ff.c   **** #if _FS_MINIMIZE <= 2
2874:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2875:lib/ff/ff.c   **** /* Seek File R/W Pointer                                                 */
2876:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
2877:lib/ff/ff.c   **** 
2878:lib/ff/ff.c   **** FRESULT f_lseek (
2879:lib/ff/ff.c   **** 	FIL *fp,		/* Pointer to the file object */
2880:lib/ff/ff.c   **** 	DWORD ofs		/* File pointer from top of file */
2881:lib/ff/ff.c   **** )
2882:lib/ff/ff.c   **** {
2883:lib/ff/ff.c   **** 	FRESULT res;
2884:lib/ff/ff.c   **** 
2885:lib/ff/ff.c   **** 
2886:lib/ff/ff.c   **** 	res = validate(fp);					/* Check validity of the object */
2887:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
2888:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)			/* Check abort flag */
2889:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
2890:lib/ff/ff.c   **** 
2891:lib/ff/ff.c   **** #if _USE_FASTSEEK
2892:lib/ff/ff.c   **** 	if (fp->cltbl) {	/* Fast seek */
2893:lib/ff/ff.c   **** 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2894:lib/ff/ff.c   **** 
2895:lib/ff/ff.c   **** 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
2896:lib/ff/ff.c   **** 			tbl = fp->cltbl;
2897:lib/ff/ff.c   **** 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
2898:lib/ff/ff.c   **** 			cl = fp->sclust;			/* Top of the chain */
2899:lib/ff/ff.c   **** 			if (cl) {
2900:lib/ff/ff.c   **** 				do {
2901:lib/ff/ff.c   **** 					/* Get a fragment */
2902:lib/ff/ff.c   **** 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
2903:lib/ff/ff.c   **** 					do {
2904:lib/ff/ff.c   **** 						pcl = cl; ncl++;
2905:lib/ff/ff.c   **** 						cl = get_fat(fp->fs, cl);
2906:lib/ff/ff.c   **** 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
2907:lib/ff/ff.c   **** 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2908:lib/ff/ff.c   **** 					} while (cl == pcl + 1);
2909:lib/ff/ff.c   **** 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
2910:lib/ff/ff.c   **** 						*tbl++ = ncl; *tbl++ = tcl;
2911:lib/ff/ff.c   **** 					}
2912:lib/ff/ff.c   **** 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
2913:lib/ff/ff.c   **** 			}
2914:lib/ff/ff.c   **** 			*fp->cltbl = ulen;	/* Number of items used */
2915:lib/ff/ff.c   **** 			if (ulen <= tlen)
2916:lib/ff/ff.c   **** 				*tbl = 0;		/* Terminate table */
2917:lib/ff/ff.c   **** 			else
2918:lib/ff/ff.c   **** 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
2919:lib/ff/ff.c   **** 
2920:lib/ff/ff.c   **** 		} else {						/* Fast seek */
2921:lib/ff/ff.c   **** 			if (ofs > fp->fsize)		/* Clip offset at the file size */
2922:lib/ff/ff.c   **** 				ofs = fp->fsize;
2923:lib/ff/ff.c   **** 			fp->fptr = ofs;				/* Set file pointer */
2924:lib/ff/ff.c   **** 			if (ofs) {
2925:lib/ff/ff.c   **** 				fp->clust = clmt_clust(fp, ofs - 1);
2926:lib/ff/ff.c   **** 				dsc = clust2sect(fp->fs, fp->clust);
2927:lib/ff/ff.c   **** 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
2928:lib/ff/ff.c   **** 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
2929:lib/ff/ff.c   **** 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
2930:lib/ff/ff.c   **** #if !_FS_TINY
2931:lib/ff/ff.c   **** #if !_FS_READONLY
2932:lib/ff/ff.c   **** 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
2933:lib/ff/ff.c   **** 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2934:lib/ff/ff.c   **** 							ABORT(fp->fs, FR_DISK_ERR);
2935:lib/ff/ff.c   **** 						fp->flag &= ~FA__DIRTY;
2936:lib/ff/ff.c   **** 					}
2937:lib/ff/ff.c   **** #endif
2938:lib/ff/ff.c   **** 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
2939:lib/ff/ff.c   **** 						ABORT(fp->fs, FR_DISK_ERR);
2940:lib/ff/ff.c   **** #endif
2941:lib/ff/ff.c   **** 					fp->dsect = dsc;
2942:lib/ff/ff.c   **** 				}
2943:lib/ff/ff.c   **** 			}
2944:lib/ff/ff.c   **** 		}
2945:lib/ff/ff.c   **** 	} else
2946:lib/ff/ff.c   **** #endif
2947:lib/ff/ff.c   **** 
2948:lib/ff/ff.c   **** 	/* Normal Seek */
2949:lib/ff/ff.c   **** 	{
2950:lib/ff/ff.c   **** 		DWORD clst, bcs, nsect, ifptr;
2951:lib/ff/ff.c   **** 
2952:lib/ff/ff.c   **** 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
2953:lib/ff/ff.c   **** #if !_FS_READONLY
2954:lib/ff/ff.c   **** 			 && !(fp->flag & FA_WRITE)
2955:lib/ff/ff.c   **** #endif
2956:lib/ff/ff.c   **** 			) ofs = fp->fsize;
2957:lib/ff/ff.c   **** 
2958:lib/ff/ff.c   **** 		ifptr = fp->fptr;
2959:lib/ff/ff.c   **** 		fp->fptr = nsect = 0;
2960:lib/ff/ff.c   **** 		if (ofs) {
2961:lib/ff/ff.c   **** 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
2962:lib/ff/ff.c   **** 			if (ifptr > 0 &&
2963:lib/ff/ff.c   **** 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
2964:lib/ff/ff.c   **** 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
2965:lib/ff/ff.c   **** 				ofs -= fp->fptr;
2966:lib/ff/ff.c   **** 				clst = fp->clust;
2967:lib/ff/ff.c   **** 			} else {									/* When seek to back cluster, */
2968:lib/ff/ff.c   **** 				clst = fp->sclust;						/* start from the first cluster */
2969:lib/ff/ff.c   **** #if !_FS_READONLY
2970:lib/ff/ff.c   **** 				if (clst == 0) {						/* If no cluster chain, create a new chain */
2971:lib/ff/ff.c   **** 					clst = create_chain(fp->fs, 0);
2972:lib/ff/ff.c   **** 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
2973:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2974:lib/ff/ff.c   **** 					fp->sclust = clst;
2975:lib/ff/ff.c   **** 				}
2976:lib/ff/ff.c   **** #endif
2977:lib/ff/ff.c   **** 				fp->clust = clst;
2978:lib/ff/ff.c   **** 			}
2979:lib/ff/ff.c   **** 			if (clst != 0) {
2980:lib/ff/ff.c   **** 				while (ofs > bcs) {						/* Cluster following loop */
2981:lib/ff/ff.c   **** #if !_FS_READONLY
2982:lib/ff/ff.c   **** 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
2983:lib/ff/ff.c   **** 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
2984:lib/ff/ff.c   **** 						if (clst == 0) {				/* When disk gets full, clip file size */
2985:lib/ff/ff.c   **** 							ofs = bcs; break;
2986:lib/ff/ff.c   **** 						}
2987:lib/ff/ff.c   **** 					} else
2988:lib/ff/ff.c   **** #endif
2989:lib/ff/ff.c   **** 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
2990:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2991:lib/ff/ff.c   **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
2992:lib/ff/ff.c   **** 					fp->clust = clst;
2993:lib/ff/ff.c   **** 					fp->fptr += bcs;
2994:lib/ff/ff.c   **** 					ofs -= bcs;
2995:lib/ff/ff.c   **** 				}
2996:lib/ff/ff.c   **** 				fp->fptr += ofs;
2997:lib/ff/ff.c   **** 				if (ofs % SS(fp->fs)) {
2998:lib/ff/ff.c   **** 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
2999:lib/ff/ff.c   **** 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
3000:lib/ff/ff.c   **** 					nsect += ofs / SS(fp->fs);
3001:lib/ff/ff.c   **** 				}
3002:lib/ff/ff.c   **** 			}
3003:lib/ff/ff.c   **** 		}
3004:lib/ff/ff.c   **** 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
3005:lib/ff/ff.c   **** #if !_FS_TINY
3006:lib/ff/ff.c   **** #if !_FS_READONLY
3007:lib/ff/ff.c   **** 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
3008:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
3009:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
3010:lib/ff/ff.c   **** 				fp->flag &= ~FA__DIRTY;
3011:lib/ff/ff.c   **** 			}
3012:lib/ff/ff.c   **** #endif
3013:lib/ff/ff.c   **** 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
3014:lib/ff/ff.c   **** 				ABORT(fp->fs, FR_DISK_ERR);
3015:lib/ff/ff.c   **** #endif
3016:lib/ff/ff.c   **** 			fp->dsect = nsect;
3017:lib/ff/ff.c   **** 		}
3018:lib/ff/ff.c   **** #if !_FS_READONLY
3019:lib/ff/ff.c   **** 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
3020:lib/ff/ff.c   **** 			fp->fsize = fp->fptr;
3021:lib/ff/ff.c   **** 			fp->flag |= FA__WRITTEN;
3022:lib/ff/ff.c   **** 		}
3023:lib/ff/ff.c   **** #endif
3024:lib/ff/ff.c   **** 	}
3025:lib/ff/ff.c   **** 
3026:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, res);
3027:lib/ff/ff.c   **** }
3028:lib/ff/ff.c   **** 
3029:lib/ff/ff.c   **** 
3030:lib/ff/ff.c   **** 
3031:lib/ff/ff.c   **** #if _FS_MINIMIZE <= 1
3032:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3033:lib/ff/ff.c   **** /* Create a Directory Object                                             */
3034:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3035:lib/ff/ff.c   **** 
3036:lib/ff/ff.c   **** FRESULT f_opendir (
3037:lib/ff/ff.c   **** 	DIR *dj,			/* Pointer to directory object to create */
3038:lib/ff/ff.c   **** 	const TCHAR *path	/* Pointer to the directory path */
3039:lib/ff/ff.c   **** )
3040:lib/ff/ff.c   **** {
3041:lib/ff/ff.c   **** 	FRESULT res;
3042:lib/ff/ff.c   **** 	FATFS *fs;
3043:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3044:lib/ff/ff.c   **** 
3045:lib/ff/ff.c   **** 
3046:lib/ff/ff.c   **** 	if (!dj) return FR_INVALID_OBJECT;
3047:lib/ff/ff.c   **** 
3048:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj->fs, 0);
3049:lib/ff/ff.c   **** 	fs = dj->fs;
3050:lib/ff/ff.c   **** 	if (res == FR_OK) {
3051:lib/ff/ff.c   **** 		INIT_BUF(*dj);
3052:lib/ff/ff.c   **** 		res = follow_path(dj, path);			/* Follow the path to the directory */
3053:lib/ff/ff.c   **** 		FREE_BUF();
3054:lib/ff/ff.c   **** 		if (res == FR_OK) {						/* Follow completed */
3055:lib/ff/ff.c   **** 			if (dj->dir) {						/* It is not the root dir */
3056:lib/ff/ff.c   **** 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
3057:lib/ff/ff.c   **** 					dj->sclust = ld_clust(fs, dj->dir);
3058:lib/ff/ff.c   **** 				} else {						/* The object is not a directory */
3059:lib/ff/ff.c   **** 					res = FR_NO_PATH;
3060:lib/ff/ff.c   **** 				}
3061:lib/ff/ff.c   **** 			}
3062:lib/ff/ff.c   **** 			if (res == FR_OK) {
3063:lib/ff/ff.c   **** 				dj->id = fs->id;
3064:lib/ff/ff.c   **** 				res = dir_sdi(dj, 0);			/* Rewind dir */
3065:lib/ff/ff.c   **** 			}
3066:lib/ff/ff.c   **** 		}
3067:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
3068:lib/ff/ff.c   **** 		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
3069:lib/ff/ff.c   **** 	} else {
3070:lib/ff/ff.c   **** 		dj->fs = 0;
3071:lib/ff/ff.c   **** 	}
3072:lib/ff/ff.c   **** 
3073:lib/ff/ff.c   **** 	LEAVE_FF(fs, res);
3074:lib/ff/ff.c   **** }
3075:lib/ff/ff.c   **** 
3076:lib/ff/ff.c   **** 
3077:lib/ff/ff.c   **** 
3078:lib/ff/ff.c   **** 
3079:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3080:lib/ff/ff.c   **** /* Read Directory Entry in Sequence                                      */
3081:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3082:lib/ff/ff.c   **** 
3083:lib/ff/ff.c   **** FRESULT f_readdir (
3084:lib/ff/ff.c   **** 	DIR *dj,			/* Pointer to the open directory object */
3085:lib/ff/ff.c   **** 	FILINFO *fno		/* Pointer to file information to return */
3086:lib/ff/ff.c   **** )
3087:lib/ff/ff.c   **** {
3088:lib/ff/ff.c   **** 	FRESULT res;
3089:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3090:lib/ff/ff.c   **** 
3091:lib/ff/ff.c   **** 
3092:lib/ff/ff.c   **** 	res = validate(dj);						/* Check validity of the object */
3093:lib/ff/ff.c   **** 	if (res == FR_OK) {
3094:lib/ff/ff.c   **** 		if (!fno) {
3095:lib/ff/ff.c   **** 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
3096:lib/ff/ff.c   **** 		} else {
3097:lib/ff/ff.c   **** 			INIT_BUF(*dj);
3098:lib/ff/ff.c   **** 			res = dir_read(dj, 0);			/* Read an item */
3099:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) {		/* Reached end of dir */
3100:lib/ff/ff.c   **** 				dj->sect = 0;
3101:lib/ff/ff.c   **** 				res = FR_OK;
3102:lib/ff/ff.c   **** 			}
3103:lib/ff/ff.c   **** 			if (res == FR_OK) {				/* A valid entry is found */
3104:lib/ff/ff.c   **** 				get_fileinfo(dj, fno);		/* Get the object information */
3105:lib/ff/ff.c   **** 				res = dir_next(dj, 0);		/* Increment index for next */
3106:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) {
3107:lib/ff/ff.c   **** 					dj->sect = 0;
3108:lib/ff/ff.c   **** 					res = FR_OK;
3109:lib/ff/ff.c   **** 				}
3110:lib/ff/ff.c   **** 			}
3111:lib/ff/ff.c   **** 			FREE_BUF();
3112:lib/ff/ff.c   **** 		}
3113:lib/ff/ff.c   **** 	}
3114:lib/ff/ff.c   **** 
3115:lib/ff/ff.c   **** 	LEAVE_FF(dj->fs, res);
3116:lib/ff/ff.c   **** }
3117:lib/ff/ff.c   **** 
3118:lib/ff/ff.c   **** 
3119:lib/ff/ff.c   **** 
3120:lib/ff/ff.c   **** #if _FS_MINIMIZE == 0
3121:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3122:lib/ff/ff.c   **** /* Get File Status                                                       */
3123:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3124:lib/ff/ff.c   **** 
3125:lib/ff/ff.c   **** FRESULT f_stat (
3126:lib/ff/ff.c   **** 	const TCHAR *path,	/* Pointer to the file path */
3127:lib/ff/ff.c   **** 	FILINFO *fno		/* Pointer to file information to return */
3128:lib/ff/ff.c   **** )
3129:lib/ff/ff.c   **** {
3130:lib/ff/ff.c   **** 	FRESULT res;
3131:lib/ff/ff.c   **** 	DIR dj;
3132:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3133:lib/ff/ff.c   **** 
3134:lib/ff/ff.c   **** 
3135:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 0);
3136:lib/ff/ff.c   **** 	if (res == FR_OK) {
3137:lib/ff/ff.c   **** 		INIT_BUF(dj);
3138:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
3139:lib/ff/ff.c   **** 		if (res == FR_OK) {				/* Follow completed */
3140:lib/ff/ff.c   **** 			if (dj.dir)		/* Found an object */
3141:lib/ff/ff.c   **** 				get_fileinfo(&dj, fno);
3142:lib/ff/ff.c   **** 			else			/* It is root dir */
3143:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
3144:lib/ff/ff.c   **** 		}
3145:lib/ff/ff.c   **** 		FREE_BUF();
3146:lib/ff/ff.c   **** 	}
3147:lib/ff/ff.c   **** 
3148:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3149:lib/ff/ff.c   **** }
3150:lib/ff/ff.c   **** 
3151:lib/ff/ff.c   **** 
3152:lib/ff/ff.c   **** 
3153:lib/ff/ff.c   **** #if !_FS_READONLY
3154:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3155:lib/ff/ff.c   **** /* Get Number of Free Clusters                                           */
3156:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3157:lib/ff/ff.c   **** 
3158:lib/ff/ff.c   **** FRESULT f_getfree (
3159:lib/ff/ff.c   **** 	const TCHAR *path,	/* Path name of the logical drive number */
3160:lib/ff/ff.c   **** 	DWORD *nclst,		/* Pointer to a variable to return number of free clusters */
3161:lib/ff/ff.c   **** 	FATFS **fatfs		/* Pointer to return pointer to corresponding file system object */
3162:lib/ff/ff.c   **** )
3163:lib/ff/ff.c   **** {
3164:lib/ff/ff.c   **** 	FRESULT res;
3165:lib/ff/ff.c   **** 	FATFS *fs;
3166:lib/ff/ff.c   **** 	DWORD n, clst, sect, stat;
3167:lib/ff/ff.c   **** 	UINT i;
3168:lib/ff/ff.c   **** 	BYTE fat, *p;
3169:lib/ff/ff.c   **** 
3170:lib/ff/ff.c   **** 
3171:lib/ff/ff.c   **** 	/* Get drive number */
3172:lib/ff/ff.c   **** 	res = chk_mounted(&path, fatfs, 0);
3173:lib/ff/ff.c   **** 	fs = *fatfs;
3174:lib/ff/ff.c   **** 	if (res == FR_OK) {
3175:lib/ff/ff.c   **** 		/* If free_clust is valid, return it without full cluster scan */
3176:lib/ff/ff.c   **** 		if (fs->free_clust <= fs->n_fatent - 2) {
3177:lib/ff/ff.c   **** 			*nclst = fs->free_clust;
3178:lib/ff/ff.c   **** 		} else {
3179:lib/ff/ff.c   **** 			/* Get number of free clusters */
3180:lib/ff/ff.c   **** 			fat = fs->fs_type;
3181:lib/ff/ff.c   **** 			n = 0;
3182:lib/ff/ff.c   **** 			if (fat == FS_FAT12) {
3183:lib/ff/ff.c   **** 				clst = 2;
3184:lib/ff/ff.c   **** 				do {
3185:lib/ff/ff.c   **** 					stat = get_fat(fs, clst);
3186:lib/ff/ff.c   **** 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
3187:lib/ff/ff.c   **** 					if (stat == 1) { res = FR_INT_ERR; break; }
3188:lib/ff/ff.c   **** 					if (stat == 0) n++;
3189:lib/ff/ff.c   **** 				} while (++clst < fs->n_fatent);
3190:lib/ff/ff.c   **** 			} else {
3191:lib/ff/ff.c   **** 				clst = fs->n_fatent;
3192:lib/ff/ff.c   **** 				sect = fs->fatbase;
3193:lib/ff/ff.c   **** 				i = 0; p = 0;
3194:lib/ff/ff.c   **** 				do {
3195:lib/ff/ff.c   **** 					if (!i) {
3196:lib/ff/ff.c   **** 						res = move_window(fs, sect++);
3197:lib/ff/ff.c   **** 						if (res != FR_OK) break;
3198:lib/ff/ff.c   **** 						p = fs->win;
3199:lib/ff/ff.c   **** 						i = SS(fs);
3200:lib/ff/ff.c   **** 					}
3201:lib/ff/ff.c   **** 					if (fat == FS_FAT16) {
3202:lib/ff/ff.c   **** 						if (LD_WORD(p) == 0) n++;
3203:lib/ff/ff.c   **** 						p += 2; i -= 2;
3204:lib/ff/ff.c   **** 					} else {
3205:lib/ff/ff.c   **** 						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
3206:lib/ff/ff.c   **** 						p += 4; i -= 4;
3207:lib/ff/ff.c   **** 					}
3208:lib/ff/ff.c   **** 				} while (--clst);
3209:lib/ff/ff.c   **** 			}
3210:lib/ff/ff.c   **** 			fs->free_clust = n;
3211:lib/ff/ff.c   **** 			if (fat == FS_FAT32) fs->fsi_flag = 1;
3212:lib/ff/ff.c   **** 			*nclst = n;
3213:lib/ff/ff.c   **** 		}
3214:lib/ff/ff.c   **** 	}
3215:lib/ff/ff.c   **** 	LEAVE_FF(fs, res);
3216:lib/ff/ff.c   **** }
3217:lib/ff/ff.c   **** 
3218:lib/ff/ff.c   **** 
3219:lib/ff/ff.c   **** 
3220:lib/ff/ff.c   **** 
3221:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3222:lib/ff/ff.c   **** /* Truncate File                                                         */
3223:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3224:lib/ff/ff.c   **** 
3225:lib/ff/ff.c   **** FRESULT f_truncate (
3226:lib/ff/ff.c   **** 	FIL *fp		/* Pointer to the file object */
3227:lib/ff/ff.c   **** )
3228:lib/ff/ff.c   **** {
3229:lib/ff/ff.c   **** 	FRESULT res;
3230:lib/ff/ff.c   **** 	DWORD ncl;
3231:lib/ff/ff.c   **** 
3232:lib/ff/ff.c   **** 
3233:lib/ff/ff.c   **** 	res = validate(fp);						/* Check validity of the object */
3234:lib/ff/ff.c   **** 	if (res == FR_OK) {
3235:lib/ff/ff.c   **** 		if (fp->flag & FA__ERROR) {			/* Check abort flag */
3236:lib/ff/ff.c   **** 			res = FR_INT_ERR;
3237:lib/ff/ff.c   **** 		} else {
3238:lib/ff/ff.c   **** 			if (!(fp->flag & FA_WRITE))		/* Check access mode */
3239:lib/ff/ff.c   **** 				res = FR_DENIED;
3240:lib/ff/ff.c   **** 		}
3241:lib/ff/ff.c   **** 	}
3242:lib/ff/ff.c   **** 	if (res == FR_OK) {
3243:lib/ff/ff.c   **** 		if (fp->fsize > fp->fptr) {
3244:lib/ff/ff.c   **** 			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
3245:lib/ff/ff.c   **** 			fp->flag |= FA__WRITTEN;
3246:lib/ff/ff.c   **** 			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
3247:lib/ff/ff.c   **** 				res = remove_chain(fp->fs, fp->sclust);
3248:lib/ff/ff.c   **** 				fp->sclust = 0;
3249:lib/ff/ff.c   **** 			} else {				/* When truncate a part of the file, remove remaining clusters */
3250:lib/ff/ff.c   **** 				ncl = get_fat(fp->fs, fp->clust);
3251:lib/ff/ff.c   **** 				res = FR_OK;
3252:lib/ff/ff.c   **** 				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
3253:lib/ff/ff.c   **** 				if (ncl == 1) res = FR_INT_ERR;
3254:lib/ff/ff.c   **** 				if (res == FR_OK && ncl < fp->fs->n_fatent) {
3255:lib/ff/ff.c   **** 					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
3256:lib/ff/ff.c   **** 					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
3257:lib/ff/ff.c   **** 				}
3258:lib/ff/ff.c   **** 			}
3259:lib/ff/ff.c   **** 		}
3260:lib/ff/ff.c   **** 		if (res != FR_OK) fp->flag |= FA__ERROR;
3261:lib/ff/ff.c   **** 	}
3262:lib/ff/ff.c   **** 
3263:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, res);
3264:lib/ff/ff.c   **** }
3265:lib/ff/ff.c   **** 
3266:lib/ff/ff.c   **** 
3267:lib/ff/ff.c   **** 
3268:lib/ff/ff.c   **** 
3269:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3270:lib/ff/ff.c   **** /* Delete a File or Directory                                            */
3271:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3272:lib/ff/ff.c   **** 
3273:lib/ff/ff.c   **** FRESULT f_unlink (
3274:lib/ff/ff.c   **** 	const TCHAR *path		/* Pointer to the file or directory path */
3275:lib/ff/ff.c   **** )
3276:lib/ff/ff.c   **** {
3277:lib/ff/ff.c   **** 	FRESULT res;
3278:lib/ff/ff.c   **** 	DIR dj, sdj;
3279:lib/ff/ff.c   **** 	BYTE *dir;
3280:lib/ff/ff.c   **** 	DWORD dclst;
3281:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3282:lib/ff/ff.c   **** 
3283:lib/ff/ff.c   **** 
3284:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
3285:lib/ff/ff.c   **** 	if (res == FR_OK) {
3286:lib/ff/ff.c   **** 		INIT_BUF(dj);
3287:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the file path */
3288:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3289:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
3290:lib/ff/ff.c   **** #if _FS_LOCK
3291:lib/ff/ff.c   **** 		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
3292:lib/ff/ff.c   **** #endif
3293:lib/ff/ff.c   **** 		if (res == FR_OK) {					/* The object is accessible */
3294:lib/ff/ff.c   **** 			dir = dj.dir;
3295:lib/ff/ff.c   **** 			if (!dir) {
3296:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
3297:lib/ff/ff.c   **** 			} else {
3298:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & AM_RDO)
3299:lib/ff/ff.c   **** 					res = FR_DENIED;		/* Cannot remove R/O object */
3300:lib/ff/ff.c   **** 			}
3301:lib/ff/ff.c   **** 			dclst = ld_clust(dj.fs, dir);
3302:lib/ff/ff.c   **** 			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
3303:lib/ff/ff.c   **** 				if (dclst < 2) {
3304:lib/ff/ff.c   **** 					res = FR_INT_ERR;
3305:lib/ff/ff.c   **** 				} else {
3306:lib/ff/ff.c   **** 					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
3307:lib/ff/ff.c   **** 					sdj.sclust = dclst;
3308:lib/ff/ff.c   **** 					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
3309:lib/ff/ff.c   **** 					if (res == FR_OK) {
3310:lib/ff/ff.c   **** 						res = dir_read(&sdj, 0);	/* Read an item */
3311:lib/ff/ff.c   **** 						if (res == FR_OK		/* Not empty dir */
3312:lib/ff/ff.c   **** #if _FS_RPATH
3313:lib/ff/ff.c   **** 						|| dclst == dj.fs->cdir	/* Current dir */
3314:lib/ff/ff.c   **** #endif
3315:lib/ff/ff.c   **** 						) res = FR_DENIED;
3316:lib/ff/ff.c   **** 						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
3317:lib/ff/ff.c   **** 					}
3318:lib/ff/ff.c   **** 				}
3319:lib/ff/ff.c   **** 			}
3320:lib/ff/ff.c   **** 			if (res == FR_OK) {
3321:lib/ff/ff.c   **** 				res = dir_remove(&dj);		/* Remove the directory entry */
3322:lib/ff/ff.c   **** 				if (res == FR_OK) {
3323:lib/ff/ff.c   **** 					if (dclst)				/* Remove the cluster chain if exist */
3324:lib/ff/ff.c   **** 						res = remove_chain(dj.fs, dclst);
3325:lib/ff/ff.c   **** 					if (res == FR_OK) res = sync_fs(dj.fs);
3326:lib/ff/ff.c   **** 				}
3327:lib/ff/ff.c   **** 			}
3328:lib/ff/ff.c   **** 		}
3329:lib/ff/ff.c   **** 		FREE_BUF();
3330:lib/ff/ff.c   **** 	}
3331:lib/ff/ff.c   **** 
3332:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3333:lib/ff/ff.c   **** }
3334:lib/ff/ff.c   **** 
3335:lib/ff/ff.c   **** 
3336:lib/ff/ff.c   **** 
3337:lib/ff/ff.c   **** 
3338:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3339:lib/ff/ff.c   **** /* Create a Directory                                                    */
3340:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3341:lib/ff/ff.c   **** 
3342:lib/ff/ff.c   **** FRESULT f_mkdir (
3343:lib/ff/ff.c   **** 	const TCHAR *path		/* Pointer to the directory path */
3344:lib/ff/ff.c   **** )
3345:lib/ff/ff.c   **** {
3346:lib/ff/ff.c   **** 	FRESULT res;
3347:lib/ff/ff.c   **** 	DIR dj;
3348:lib/ff/ff.c   **** 	BYTE *dir, n;
3349:lib/ff/ff.c   **** 	DWORD dsc, dcl, pcl, tm = get_fattime();
3350:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3351:lib/ff/ff.c   **** 
3352:lib/ff/ff.c   **** 
3353:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
3354:lib/ff/ff.c   **** 	if (res == FR_OK) {
3355:lib/ff/ff.c   **** 		INIT_BUF(dj);
3356:lib/ff/ff.c   **** 		res = follow_path(&dj, path);			/* Follow the file path */
3357:lib/ff/ff.c   **** 		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
3358:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
3359:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
3360:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) {				/* Can create a new directory */
3361:lib/ff/ff.c   **** 			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
3362:lib/ff/ff.c   **** 			res = FR_OK;
3363:lib/ff/ff.c   **** 			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
3364:lib/ff/ff.c   **** 			if (dcl == 1) res = FR_INT_ERR;
3365:lib/ff/ff.c   **** 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
3366:lib/ff/ff.c   **** 			if (res == FR_OK)					/* Flush FAT */
3367:lib/ff/ff.c   **** 				res = sync_window(dj.fs);
3368:lib/ff/ff.c   **** 			if (res == FR_OK) {					/* Initialize the new directory table */
3369:lib/ff/ff.c   **** 				dsc = clust2sect(dj.fs, dcl);
3370:lib/ff/ff.c   **** 				dir = dj.fs->win;
3371:lib/ff/ff.c   **** 				mem_set(dir, 0, SS(dj.fs));
3372:lib/ff/ff.c   **** 				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
3373:lib/ff/ff.c   **** 				dir[DIR_Name] = '.';
3374:lib/ff/ff.c   **** 				dir[DIR_Attr] = AM_DIR;
3375:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tm);
3376:lib/ff/ff.c   **** 				st_clust(dir, dcl);
3377:lib/ff/ff.c   **** 				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
3378:lib/ff/ff.c   **** 				dir[33] = '.'; pcl = dj.sclust;
3379:lib/ff/ff.c   **** 				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
3380:lib/ff/ff.c   **** 					pcl = 0;
3381:lib/ff/ff.c   **** 				st_clust(dir+SZ_DIR, pcl);
3382:lib/ff/ff.c   **** 				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
3383:lib/ff/ff.c   **** 					dj.fs->winsect = dsc++;
3384:lib/ff/ff.c   **** 					dj.fs->wflag = 1;
3385:lib/ff/ff.c   **** 					res = sync_window(dj.fs);
3386:lib/ff/ff.c   **** 					if (res != FR_OK) break;
3387:lib/ff/ff.c   **** 					mem_set(dir, 0, SS(dj.fs));
3388:lib/ff/ff.c   **** 				}
3389:lib/ff/ff.c   **** 			}
3390:lib/ff/ff.c   **** 			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
3391:lib/ff/ff.c   **** 			if (res != FR_OK) {
3392:lib/ff/ff.c   **** 				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
3393:lib/ff/ff.c   **** 			} else {
3394:lib/ff/ff.c   **** 				dir = dj.dir;
3395:lib/ff/ff.c   **** 				dir[DIR_Attr] = AM_DIR;				/* Attribute */
3396:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
3397:lib/ff/ff.c   **** 				st_clust(dir, dcl);					/* Table start cluster */
3398:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
3399:lib/ff/ff.c   **** 				res = sync_fs(dj.fs);
3400:lib/ff/ff.c   **** 			}
3401:lib/ff/ff.c   **** 		}
3402:lib/ff/ff.c   **** 		FREE_BUF();
3403:lib/ff/ff.c   **** 	}
3404:lib/ff/ff.c   **** 
3405:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3406:lib/ff/ff.c   **** }
3407:lib/ff/ff.c   **** 
3408:lib/ff/ff.c   **** 
3409:lib/ff/ff.c   **** 
3410:lib/ff/ff.c   **** 
3411:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3412:lib/ff/ff.c   **** /* Change Attribute                                                      */
3413:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3414:lib/ff/ff.c   **** 
3415:lib/ff/ff.c   **** FRESULT f_chmod (
3416:lib/ff/ff.c   **** 	const TCHAR *path,	/* Pointer to the file path */
3417:lib/ff/ff.c   **** 	BYTE value,			/* Attribute bits */
3418:lib/ff/ff.c   **** 	BYTE mask			/* Attribute mask to change */
3419:lib/ff/ff.c   **** )
3420:lib/ff/ff.c   **** {
3421:lib/ff/ff.c   **** 	FRESULT res;
3422:lib/ff/ff.c   **** 	DIR dj;
3423:lib/ff/ff.c   **** 	BYTE *dir;
3424:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3425:lib/ff/ff.c   **** 
3426:lib/ff/ff.c   **** 
3427:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
3428:lib/ff/ff.c   **** 	if (res == FR_OK) {
3429:lib/ff/ff.c   **** 		INIT_BUF(dj);
3430:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the file path */
3431:lib/ff/ff.c   **** 		FREE_BUF();
3432:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3433:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
3434:lib/ff/ff.c   **** 		if (res == FR_OK) {
3435:lib/ff/ff.c   **** 			dir = dj.dir;
3436:lib/ff/ff.c   **** 			if (!dir) {						/* Is it a root directory? */
3437:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
3438:lib/ff/ff.c   **** 			} else {						/* File or sub directory */
3439:lib/ff/ff.c   **** 				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
3440:lib/ff/ff.c   **** 				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
3441:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
3442:lib/ff/ff.c   **** 				res = sync_fs(dj.fs);
3443:lib/ff/ff.c   **** 			}
3444:lib/ff/ff.c   **** 		}
3445:lib/ff/ff.c   **** 	}
3446:lib/ff/ff.c   **** 
3447:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3448:lib/ff/ff.c   **** }
3449:lib/ff/ff.c   **** 
3450:lib/ff/ff.c   **** 
3451:lib/ff/ff.c   **** 
3452:lib/ff/ff.c   **** 
3453:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3454:lib/ff/ff.c   **** /* Change Timestamp                                                      */
3455:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3456:lib/ff/ff.c   **** 
3457:lib/ff/ff.c   **** FRESULT f_utime (
3458:lib/ff/ff.c   **** 	const TCHAR *path,	/* Pointer to the file/directory name */
3459:lib/ff/ff.c   **** 	const FILINFO *fno	/* Pointer to the time stamp to be set */
3460:lib/ff/ff.c   **** )
3461:lib/ff/ff.c   **** {
3462:lib/ff/ff.c   **** 	FRESULT res;
3463:lib/ff/ff.c   **** 	DIR dj;
3464:lib/ff/ff.c   **** 	BYTE *dir;
3465:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3466:lib/ff/ff.c   **** 
3467:lib/ff/ff.c   **** 
3468:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 1);
3469:lib/ff/ff.c   **** 	if (res == FR_OK) {
3470:lib/ff/ff.c   **** 		INIT_BUF(dj);
3471:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
3472:lib/ff/ff.c   **** 		FREE_BUF();
3473:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3474:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
3475:lib/ff/ff.c   **** 		if (res == FR_OK) {
3476:lib/ff/ff.c   **** 			dir = dj.dir;
3477:lib/ff/ff.c   **** 			if (!dir) {					/* Root directory */
3478:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
3479:lib/ff/ff.c   **** 			} else {					/* File or sub-directory */
3480:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_WrtTime, fno->ftime);
3481:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
3482:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
3483:lib/ff/ff.c   **** 				res = sync_fs(dj.fs);
3484:lib/ff/ff.c   **** 			}
3485:lib/ff/ff.c   **** 		}
3486:lib/ff/ff.c   **** 	}
3487:lib/ff/ff.c   **** 
3488:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3489:lib/ff/ff.c   **** }
3490:lib/ff/ff.c   **** 
3491:lib/ff/ff.c   **** 
3492:lib/ff/ff.c   **** 
3493:lib/ff/ff.c   **** 
3494:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3495:lib/ff/ff.c   **** /* Rename File/Directory                                                 */
3496:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3497:lib/ff/ff.c   **** 
3498:lib/ff/ff.c   **** FRESULT f_rename (
3499:lib/ff/ff.c   **** 	const TCHAR *path_old,	/* Pointer to the old name */
3500:lib/ff/ff.c   **** 	const TCHAR *path_new	/* Pointer to the new name */
3501:lib/ff/ff.c   **** )
3502:lib/ff/ff.c   **** {
3503:lib/ff/ff.c   **** 	FRESULT res;
3504:lib/ff/ff.c   **** 	DIR djo, djn;
3505:lib/ff/ff.c   **** 	BYTE buf[21], *dir;
3506:lib/ff/ff.c   **** 	DWORD dw;
3507:lib/ff/ff.c   **** 	DEF_NAMEBUF;
3508:lib/ff/ff.c   **** 
3509:lib/ff/ff.c   **** 
3510:lib/ff/ff.c   **** 	res = chk_mounted(&path_old, &djo.fs, 1);
3511:lib/ff/ff.c   **** 	if (res == FR_OK) {
3512:lib/ff/ff.c   **** 		djn.fs = djo.fs;
3513:lib/ff/ff.c   **** 		INIT_BUF(djo);
3514:lib/ff/ff.c   **** 		res = follow_path(&djo, path_old);		/* Check old object */
3515:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
3516:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
3517:lib/ff/ff.c   **** #if _FS_LOCK
3518:lib/ff/ff.c   **** 		if (res == FR_OK) res = chk_lock(&djo, 2);
3519:lib/ff/ff.c   **** #endif
3520:lib/ff/ff.c   **** 		if (res == FR_OK) {						/* Old object is found */
3521:lib/ff/ff.c   **** 			if (!djo.dir) {						/* Is root dir? */
3522:lib/ff/ff.c   **** 				res = FR_NO_FILE;
3523:lib/ff/ff.c   **** 			} else {
3524:lib/ff/ff.c   **** 				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
3525:lib/ff/ff.c   **** 				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
3526:lib/ff/ff.c   **** 				res = follow_path(&djn, path_new);
3527:lib/ff/ff.c   **** 				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
3528:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
3529:lib/ff/ff.c   **** /* Start critical section that any interruption can cause a cross-link */
3530:lib/ff/ff.c   **** 					res = dir_register(&djn);			/* Register the new entry */
3531:lib/ff/ff.c   **** 					if (res == FR_OK) {
3532:lib/ff/ff.c   **** 						dir = djn.dir;					/* Copy object information except for name */
3533:lib/ff/ff.c   **** 						mem_cpy(dir+13, buf+2, 19);
3534:lib/ff/ff.c   **** 						dir[DIR_Attr] = buf[0] | AM_ARC;
3535:lib/ff/ff.c   **** 						djo.fs->wflag = 1;
3536:lib/ff/ff.c   **** 						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the direct
3537:lib/ff/ff.c   **** 							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
3538:lib/ff/ff.c   **** 							if (!dw) {
3539:lib/ff/ff.c   **** 								res = FR_INT_ERR;
3540:lib/ff/ff.c   **** 							} else {
3541:lib/ff/ff.c   **** 								res = move_window(djo.fs, dw);
3542:lib/ff/ff.c   **** 								dir = djo.fs->win+SZ_DIR;	/* .. entry */
3543:lib/ff/ff.c   **** 								if (res == FR_OK && dir[1] == '.') {
3544:lib/ff/ff.c   **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
3545:lib/ff/ff.c   **** 									st_clust(dir, dw);
3546:lib/ff/ff.c   **** 									djo.fs->wflag = 1;
3547:lib/ff/ff.c   **** 								}
3548:lib/ff/ff.c   **** 							}
3549:lib/ff/ff.c   **** 						}
3550:lib/ff/ff.c   **** 						if (res == FR_OK) {
3551:lib/ff/ff.c   **** 							res = dir_remove(&djo);		/* Remove old entry */
3552:lib/ff/ff.c   **** 							if (res == FR_OK)
3553:lib/ff/ff.c   **** 								res = sync_fs(djo.fs);
3554:lib/ff/ff.c   **** 						}
3555:lib/ff/ff.c   **** 					}
3556:lib/ff/ff.c   **** /* End critical section */
3557:lib/ff/ff.c   **** 				}
3558:lib/ff/ff.c   **** 			}
3559:lib/ff/ff.c   **** 		}
3560:lib/ff/ff.c   **** 		FREE_BUF();
3561:lib/ff/ff.c   **** 	}
3562:lib/ff/ff.c   **** 
3563:lib/ff/ff.c   **** 	LEAVE_FF(djo.fs, res);
3564:lib/ff/ff.c   **** }
3565:lib/ff/ff.c   **** 
3566:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
3567:lib/ff/ff.c   **** #endif /* _FS_MINIMIZE == 0 */
3568:lib/ff/ff.c   **** #endif /* _FS_MINIMIZE <= 1 */
3569:lib/ff/ff.c   **** #endif /* _FS_MINIMIZE <= 2 */
3570:lib/ff/ff.c   **** 
3571:lib/ff/ff.c   **** 
3572:lib/ff/ff.c   **** 
3573:lib/ff/ff.c   **** #if _USE_LABEL
3574:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3575:lib/ff/ff.c   **** /* Get volume label                                                      */
3576:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3577:lib/ff/ff.c   **** 
3578:lib/ff/ff.c   **** FRESULT f_getlabel (
3579:lib/ff/ff.c   **** 	const TCHAR* path,	/* Path name of the logical drive number */
3580:lib/ff/ff.c   **** 	TCHAR* label,		/* Pointer to a buffer to return the volume label */
3581:lib/ff/ff.c   **** 	DWORD* sn			/* Pointer to a variable to return the volume serial number */
3582:lib/ff/ff.c   **** )
3583:lib/ff/ff.c   **** {
3584:lib/ff/ff.c   **** 	FRESULT res;
3585:lib/ff/ff.c   **** 	DIR dj;
3586:lib/ff/ff.c   **** 	UINT i, j;
3587:lib/ff/ff.c   **** 
3588:lib/ff/ff.c   **** 
3589:lib/ff/ff.c   **** 	/* Get logical drive */
3590:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, 0);
3591:lib/ff/ff.c   **** 
3592:lib/ff/ff.c   **** 	/* Get volume label */
3593:lib/ff/ff.c   **** 	if (res == FR_OK && label) {
3594:lib/ff/ff.c   **** 		dj.sclust = 0;					/* Open root dir */
3595:lib/ff/ff.c   **** 		res = dir_sdi(&dj, 0);
3596:lib/ff/ff.c   **** 		if (res == FR_OK) {
3597:lib/ff/ff.c   **** 			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
3598:lib/ff/ff.c   **** 			if (res == FR_OK) {			/* A volume label is exist */
3599:lib/ff/ff.c   **** #if _LFN_UNICODE
3600:lib/ff/ff.c   **** 				WCHAR w;
3601:lib/ff/ff.c   **** 				i = j = 0;
3602:lib/ff/ff.c   **** 				do {
3603:lib/ff/ff.c   **** 					w = (i < 11) ? dj.dir[i++] : ' ';
3604:lib/ff/ff.c   **** 					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
3605:lib/ff/ff.c   **** 						w = (w << 8) | dj.dir[i++];
3606:lib/ff/ff.c   **** 					label[j++] = ff_convert(w, 1);
3607:lib/ff/ff.c   **** 				} while (j < 11);
3608:lib/ff/ff.c   **** #else
3609:lib/ff/ff.c   **** 				mem_cpy(label, dj.dir, 11);
3610:lib/ff/ff.c   **** #endif
3611:lib/ff/ff.c   **** 				j = 11;
3612:lib/ff/ff.c   **** 				do {
3613:lib/ff/ff.c   **** 					label[j] = 0;
3614:lib/ff/ff.c   **** 					if (!j) break;
3615:lib/ff/ff.c   **** 				} while (label[--j] == ' ');
3616:lib/ff/ff.c   **** 			}
3617:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) {	/* No label, return nul string */
3618:lib/ff/ff.c   **** 				label[0] = 0;
3619:lib/ff/ff.c   **** 				res = FR_OK;
3620:lib/ff/ff.c   **** 			}
3621:lib/ff/ff.c   **** 		}
3622:lib/ff/ff.c   **** 	}
3623:lib/ff/ff.c   **** 
3624:lib/ff/ff.c   **** 	/* Get volume serial number */
3625:lib/ff/ff.c   **** 	if (res == FR_OK && sn) {
3626:lib/ff/ff.c   **** 		res = move_window(dj.fs, dj.fs->volbase);
3627:lib/ff/ff.c   **** 		if (res == FR_OK) {
3628:lib/ff/ff.c   **** 			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
3629:lib/ff/ff.c   **** 			*sn = LD_DWORD(&dj.fs->win[i]);
3630:lib/ff/ff.c   **** 		}
3631:lib/ff/ff.c   **** 	}
3632:lib/ff/ff.c   **** 
3633:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3634:lib/ff/ff.c   **** }
3635:lib/ff/ff.c   **** 
3636:lib/ff/ff.c   **** 
3637:lib/ff/ff.c   **** 
3638:lib/ff/ff.c   **** #if !_FS_READONLY
3639:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3640:lib/ff/ff.c   **** /* Set volume label                                                      */
3641:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3642:lib/ff/ff.c   **** 
3643:lib/ff/ff.c   **** FRESULT f_setlabel (
3644:lib/ff/ff.c   **** 	const TCHAR* label	/* Pointer to the volume label to set */
3645:lib/ff/ff.c   **** )
3646:lib/ff/ff.c   **** {
3647:lib/ff/ff.c   **** 	FRESULT res;
3648:lib/ff/ff.c   **** 	DIR dj;
3649:lib/ff/ff.c   **** 	BYTE vn[11];
3650:lib/ff/ff.c   **** 	UINT i, j, sl;
3651:lib/ff/ff.c   **** 	WCHAR w;
3652:lib/ff/ff.c   **** 	DWORD tm;
3653:lib/ff/ff.c   **** 
3654:lib/ff/ff.c   **** 
3655:lib/ff/ff.c   **** 	/* Get logical drive */
3656:lib/ff/ff.c   **** 	res = chk_mounted(&label, &dj.fs, 1);
3657:lib/ff/ff.c   **** 	if (res) LEAVE_FF(dj.fs, res);
3658:lib/ff/ff.c   **** 
3659:lib/ff/ff.c   **** 	/* Create a volume label in directory form */
3660:lib/ff/ff.c   **** 	vn[0] = 0;
3661:lib/ff/ff.c   **** 	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
3662:lib/ff/ff.c   **** 	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
3663:lib/ff/ff.c   **** 	if (sl) {	/* Create volume label in directory form */
3664:lib/ff/ff.c   **** 		i = j = 0;
3665:lib/ff/ff.c   **** 		do {
3666:lib/ff/ff.c   **** #if _LFN_UNICODE
3667:lib/ff/ff.c   **** 			w = ff_convert(ff_wtoupper(label[i++]), 0);
3668:lib/ff/ff.c   **** #else
3669:lib/ff/ff.c   **** 			w = (BYTE)label[i++];
3670:lib/ff/ff.c   **** 			if (IsDBCS1(w))
3671:lib/ff/ff.c   **** 				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? (w << 8) | (BYTE)label[i++] : 0;
3672:lib/ff/ff.c   **** #if _USE_LFN
3673:lib/ff/ff.c   **** 			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
3674:lib/ff/ff.c   **** #else
3675:lib/ff/ff.c   **** 			if (IsLower(w)) w -= 0x20;			/* To upper ASCII chars */
3676:lib/ff/ff.c   **** #ifdef _EXCVT
3677:lib/ff/ff.c   **** 			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended chars (SBCS cfg) */
3678:lib/ff/ff.c   **** #else
3679:lib/ff/ff.c   **** 			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended chars (ASCII cfg) */
3680:lib/ff/ff.c   **** #endif
3681:lib/ff/ff.c   **** #endif
3682:lib/ff/ff.c   **** #endif
3683:lib/ff/ff.c   **** 			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject i
3684:lib/ff/ff.c   **** 				LEAVE_FF(dj.fs, FR_INVALID_NAME);
3685:lib/ff/ff.c   **** 			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
3686:lib/ff/ff.c   **** 			vn[j++] = (BYTE)w;
3687:lib/ff/ff.c   **** 		} while (i < sl);
3688:lib/ff/ff.c   **** 		while (j < 11) vn[j++] = ' ';
3689:lib/ff/ff.c   **** 	}
3690:lib/ff/ff.c   **** 
3691:lib/ff/ff.c   **** 	/* Set volume label */
3692:lib/ff/ff.c   **** 	dj.sclust = 0;					/* Open root dir */
3693:lib/ff/ff.c   **** 	res = dir_sdi(&dj, 0);
3694:lib/ff/ff.c   **** 	if (res == FR_OK) {
3695:lib/ff/ff.c   **** 		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
3696:lib/ff/ff.c   **** 		if (res == FR_OK) {			/* A volume label is found */
3697:lib/ff/ff.c   **** 			if (vn[0]) {
3698:lib/ff/ff.c   **** 				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
3699:lib/ff/ff.c   **** 				tm = get_fattime();
3700:lib/ff/ff.c   **** 				ST_DWORD(dj.dir+DIR_WrtTime, tm);
3701:lib/ff/ff.c   **** 			} else {
3702:lib/ff/ff.c   **** 				dj.dir[0] = DDE;			/* Remove the volume label */
3703:lib/ff/ff.c   **** 			}
3704:lib/ff/ff.c   **** 			dj.fs->wflag = 1;
3705:lib/ff/ff.c   **** 			res = sync_fs(dj.fs);
3706:lib/ff/ff.c   **** 		} else {					/* No volume label is found or error */
3707:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) {
3708:lib/ff/ff.c   **** 				res = FR_OK;
3709:lib/ff/ff.c   **** 				if (vn[0]) {				/* Create volume label as new */
3710:lib/ff/ff.c   **** 					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
3711:lib/ff/ff.c   **** 					if (res == FR_OK) {
3712:lib/ff/ff.c   **** 						mem_set(dj.dir, 0, SZ_DIR);	/* Set volume label */
3713:lib/ff/ff.c   **** 						mem_cpy(dj.dir, vn, 11);
3714:lib/ff/ff.c   **** 						dj.dir[DIR_Attr] = AM_VOL;
3715:lib/ff/ff.c   **** 						tm = get_fattime();
3716:lib/ff/ff.c   **** 						ST_DWORD(dj.dir+DIR_WrtTime, tm);
3717:lib/ff/ff.c   **** 						dj.fs->wflag = 1;
3718:lib/ff/ff.c   **** 						res = sync_fs(dj.fs);
3719:lib/ff/ff.c   **** 					}
3720:lib/ff/ff.c   **** 				}
3721:lib/ff/ff.c   **** 			}
3722:lib/ff/ff.c   **** 		}
3723:lib/ff/ff.c   **** 	}
3724:lib/ff/ff.c   **** 
3725:lib/ff/ff.c   **** 	LEAVE_FF(dj.fs, res);
3726:lib/ff/ff.c   **** }
3727:lib/ff/ff.c   **** 
3728:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
3729:lib/ff/ff.c   **** #endif /* _USE_LABEL */
3730:lib/ff/ff.c   **** 
3731:lib/ff/ff.c   **** 
3732:lib/ff/ff.c   **** 
3733:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3734:lib/ff/ff.c   **** /* Forward data to the stream directly (available on only tiny cfg)      */
3735:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3736:lib/ff/ff.c   **** #if _USE_FORWARD && _FS_TINY
3737:lib/ff/ff.c   **** 
3738:lib/ff/ff.c   **** FRESULT f_forward (
3739:lib/ff/ff.c   **** 	FIL *fp, 						/* Pointer to the file object */
3740:lib/ff/ff.c   **** 	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
3741:lib/ff/ff.c   **** 	UINT btf,						/* Number of bytes to forward */
3742:lib/ff/ff.c   **** 	UINT *bf						/* Pointer to number of bytes forwarded */
3743:lib/ff/ff.c   **** )
3744:lib/ff/ff.c   **** {
3745:lib/ff/ff.c   **** 	FRESULT res;
3746:lib/ff/ff.c   **** 	DWORD remain, clst, sect;
3747:lib/ff/ff.c   **** 	UINT rcnt;
3748:lib/ff/ff.c   **** 	BYTE csect;
3749:lib/ff/ff.c   **** 
3750:lib/ff/ff.c   **** 
3751:lib/ff/ff.c   **** 	*bf = 0;	/* Clear transfer byte counter */
3752:lib/ff/ff.c   **** 
3753:lib/ff/ff.c   **** 	res = validate(fp);								/* Check validity of the object */
3754:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
3755:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)						/* Check error flag */
3756:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
3757:lib/ff/ff.c   **** 	if (!(fp->flag & FA_READ))						/* Check access mode */
3758:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
3759:lib/ff/ff.c   **** 
3760:lib/ff/ff.c   **** 	remain = fp->fsize - fp->fptr;
3761:lib/ff/ff.c   **** 	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
3762:lib/ff/ff.c   **** 
3763:lib/ff/ff.c   **** 	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
3764:lib/ff/ff.c   **** 		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
3765:lib/ff/ff.c   **** 		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
3766:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
3767:lib/ff/ff.c   **** 			if (!csect) {							/* On the cluster boundary? */
3768:lib/ff/ff.c   **** 				clst = (fp->fptr == 0) ?			/* On the top of the file? */
3769:lib/ff/ff.c   **** 					fp->sclust : get_fat(fp->fs, fp->clust);
3770:lib/ff/ff.c   **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3771:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3772:lib/ff/ff.c   **** 				fp->clust = clst;					/* Update current cluster */
3773:lib/ff/ff.c   **** 			}
3774:lib/ff/ff.c   **** 		}
3775:lib/ff/ff.c   **** 		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
3776:lib/ff/ff.c   **** 		if (!sect) ABORT(fp->fs, FR_INT_ERR);
3777:lib/ff/ff.c   **** 		sect += csect;
3778:lib/ff/ff.c   **** 		if (move_window(fp->fs, sect))				/* Move sector window */
3779:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
3780:lib/ff/ff.c   **** 		fp->dsect = sect;
3781:lib/ff/ff.c   **** 		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
3782:lib/ff/ff.c   **** 		if (rcnt > btf) rcnt = btf;
3783:lib/ff/ff.c   **** 		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
3784:lib/ff/ff.c   **** 		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3785:lib/ff/ff.c   **** 	}
3786:lib/ff/ff.c   **** 
3787:lib/ff/ff.c   **** 	LEAVE_FF(fp->fs, FR_OK);
3788:lib/ff/ff.c   **** }
3789:lib/ff/ff.c   **** #endif /* _USE_FORWARD */
3790:lib/ff/ff.c   **** 
3791:lib/ff/ff.c   **** 
3792:lib/ff/ff.c   **** 
3793:lib/ff/ff.c   **** #if _USE_MKFS && !_FS_READONLY
3794:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3795:lib/ff/ff.c   **** /* Create File System on the Drive                                       */
3796:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
3797:lib/ff/ff.c   **** #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3798:lib/ff/ff.c   **** #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3799:lib/ff/ff.c   **** 
3800:lib/ff/ff.c   **** 
3801:lib/ff/ff.c   **** FRESULT f_mkfs (
3802:lib/ff/ff.c   **** 	BYTE vol,		/* Logical drive number */
3803:lib/ff/ff.c   **** 	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
3804:lib/ff/ff.c   **** 	UINT au			/* Allocation unit size [bytes] */
3805:lib/ff/ff.c   **** )
3806:lib/ff/ff.c   **** {
3807:lib/ff/ff.c   **** 	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
3808:lib/ff/ff.c   **** 	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3809:lib/ff/ff.c   **** 	BYTE fmt, md, sys, *tbl, pdrv, part;
3810:lib/ff/ff.c   **** 	DWORD n_clst, vs, n, wsect;
3811:lib/ff/ff.c   **** 	UINT i;
3812:lib/ff/ff.c   **** 	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
3813:lib/ff/ff.c   **** 	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
3814:lib/ff/ff.c   **** 	FATFS *fs;
3815:lib/ff/ff.c   **** 	DSTATUS stat;
3816:lib/ff/ff.c   **** 
3817:lib/ff/ff.c   **** 
3818:lib/ff/ff.c   **** 	/* Check mounted drive and clear work area */
3819:lib/ff/ff.c   **** 	if (vol >= _VOLUMES) return FR_INVALID_DRIVE;
3820:lib/ff/ff.c   **** 	if (sfd > 1) return FR_INVALID_PARAMETER;
3821:lib/ff/ff.c   **** 	if (au & (au - 1)) return FR_INVALID_PARAMETER;
3822:lib/ff/ff.c   **** 	fs = FatFs[vol];
3823:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;
3824:lib/ff/ff.c   **** 	fs->fs_type = 0;
3825:lib/ff/ff.c   **** 	pdrv = LD2PD(vol);	/* Physical drive */
3826:lib/ff/ff.c   **** 	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
3827:lib/ff/ff.c   **** 
3828:lib/ff/ff.c   **** 	/* Get disk statics */
3829:lib/ff/ff.c   **** 	stat = disk_initialize(pdrv);
3830:lib/ff/ff.c   **** 	if (stat & STA_NOINIT) return FR_NOT_READY;
3831:lib/ff/ff.c   **** 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3832:lib/ff/ff.c   **** #if _MAX_SS != 512					/* Get disk sector size */
3833:lib/ff/ff.c   **** 	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3834:lib/ff/ff.c   **** 		return FR_DISK_ERR;
3835:lib/ff/ff.c   **** #endif
3836:lib/ff/ff.c   **** 	if (_MULTI_PARTITION && part) {
3837:lib/ff/ff.c   **** 		/* Get partition information from partition table in the MBR */
3838:lib/ff/ff.c   **** 		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3839:lib/ff/ff.c   **** 		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3840:lib/ff/ff.c   **** 		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3841:lib/ff/ff.c   **** 		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
3842:lib/ff/ff.c   **** 		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
3843:lib/ff/ff.c   **** 		n_vol = LD_DWORD(tbl+12);	/* Volume size */
3844:lib/ff/ff.c   **** 	} else {
3845:lib/ff/ff.c   **** 		/* Create a partition in this function */
3846:lib/ff/ff.c   **** 		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
3847:lib/ff/ff.c   **** 			return FR_DISK_ERR;
3848:lib/ff/ff.c   **** 		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
3849:lib/ff/ff.c   **** 		n_vol -= b_vol;				/* Volume size */
3850:lib/ff/ff.c   **** 	}
3851:lib/ff/ff.c   **** 
3852:lib/ff/ff.c   **** 	if (!au) {				/* AU auto selection */
3853:lib/ff/ff.c   **** 		vs = n_vol / (2000 / (SS(fs) / 512));
3854:lib/ff/ff.c   **** 		for (i = 0; vs < vst[i]; i++) ;
3855:lib/ff/ff.c   **** 		au = cst[i];
3856:lib/ff/ff.c   **** 	}
3857:lib/ff/ff.c   **** 	au /= SS(fs);		/* Number of sectors per cluster */
3858:lib/ff/ff.c   **** 	if (au == 0) au = 1;
3859:lib/ff/ff.c   **** 	if (au > 128) au = 128;
3860:lib/ff/ff.c   **** 
3861:lib/ff/ff.c   **** 	/* Pre-compute number of clusters and FAT sub-type */
3862:lib/ff/ff.c   **** 	n_clst = n_vol / au;
3863:lib/ff/ff.c   **** 	fmt = FS_FAT12;
3864:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
3865:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
3866:lib/ff/ff.c   **** 
3867:lib/ff/ff.c   **** 	/* Determine offset and size of FAT structure */
3868:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
3869:lib/ff/ff.c   **** 		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
3870:lib/ff/ff.c   **** 		n_rsv = 32;
3871:lib/ff/ff.c   **** 		n_dir = 0;
3872:lib/ff/ff.c   **** 	} else {
3873:lib/ff/ff.c   **** 		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
3874:lib/ff/ff.c   **** 		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
3875:lib/ff/ff.c   **** 		n_rsv = 1;
3876:lib/ff/ff.c   **** 		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
3877:lib/ff/ff.c   **** 	}
3878:lib/ff/ff.c   **** 	b_fat = b_vol + n_rsv;				/* FAT area start sector */
3879:lib/ff/ff.c   **** 	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
3880:lib/ff/ff.c   **** 	b_data = b_dir + n_dir;				/* Data area start sector */
3881:lib/ff/ff.c   **** 	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
3882:lib/ff/ff.c   **** 
3883:lib/ff/ff.c   **** 	/* Align data start sector to erase block boundary (for flash memory media) */
3884:lib/ff/ff.c   **** 	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
3885:lib/ff/ff.c   **** 	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
3886:lib/ff/ff.c   **** 	n = (n - b_data) / N_FATS;
3887:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
3888:lib/ff/ff.c   **** 		n_rsv += n;
3889:lib/ff/ff.c   **** 		b_fat += n;
3890:lib/ff/ff.c   **** 	} else {					/* FAT12/16: Expand FAT size */
3891:lib/ff/ff.c   **** 		n_fat += n;
3892:lib/ff/ff.c   **** 	}
3893:lib/ff/ff.c   **** 
3894:lib/ff/ff.c   **** 	/* Determine number of clusters and final check of validity of the FAT sub-type */
3895:lib/ff/ff.c   **** 	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
3896:lib/ff/ff.c   **** 	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
3897:lib/ff/ff.c   **** 		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
3898:lib/ff/ff.c   **** 		return FR_MKFS_ABORTED;
3899:lib/ff/ff.c   **** 
3900:lib/ff/ff.c   **** 	switch (fmt) {	/* Determine system ID for partition table */
3901:lib/ff/ff.c   **** 	case FS_FAT12:	sys = 0x01; break;
3902:lib/ff/ff.c   **** 	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
3903:lib/ff/ff.c   **** 	default: 		sys = 0x0C;
3904:lib/ff/ff.c   **** 	}
3905:lib/ff/ff.c   **** 
3906:lib/ff/ff.c   **** 	if (_MULTI_PARTITION && part) {
3907:lib/ff/ff.c   **** 		/* Update system ID in the partition table */
3908:lib/ff/ff.c   **** 		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3909:lib/ff/ff.c   **** 		tbl[4] = sys;
3910:lib/ff/ff.c   **** 		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3911:lib/ff/ff.c   **** 		md = 0xF8;
3912:lib/ff/ff.c   **** 	} else {
3913:lib/ff/ff.c   **** 		if (sfd) {	/* No partition table (SFD) */
3914:lib/ff/ff.c   **** 			md = 0xF0;
3915:lib/ff/ff.c   **** 		} else {	/* Create partition table (FDISK) */
3916:lib/ff/ff.c   **** 			mem_set(fs->win, 0, SS(fs));
3917:lib/ff/ff.c   **** 			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
3918:lib/ff/ff.c   **** 			tbl[1] = 1;						/* Partition start head */
3919:lib/ff/ff.c   **** 			tbl[2] = 1;						/* Partition start sector */
3920:lib/ff/ff.c   **** 			tbl[3] = 0;						/* Partition start cylinder */
3921:lib/ff/ff.c   **** 			tbl[4] = sys;					/* System type */
3922:lib/ff/ff.c   **** 			tbl[5] = 254;					/* Partition end head */
3923:lib/ff/ff.c   **** 			n = (b_vol + n_vol) / 63 / 255;
3924:lib/ff/ff.c   **** 			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partition end sector */
3925:lib/ff/ff.c   **** 			tbl[7] = (BYTE)n;				/* End cylinder */
3926:lib/ff/ff.c   **** 			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
3927:lib/ff/ff.c   **** 			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
3928:lib/ff/ff.c   **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
3929:lib/ff/ff.c   **** 			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
3930:lib/ff/ff.c   **** 				return FR_DISK_ERR;
3931:lib/ff/ff.c   **** 			md = 0xF8;
3932:lib/ff/ff.c   **** 		}
3933:lib/ff/ff.c   **** 	}
3934:lib/ff/ff.c   **** 
3935:lib/ff/ff.c   **** 	/* Create BPB in the VBR */
3936:lib/ff/ff.c   **** 	tbl = fs->win;							/* Clear sector */
3937:lib/ff/ff.c   **** 	mem_set(tbl, 0, SS(fs));
3938:lib/ff/ff.c   **** 	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
3939:lib/ff/ff.c   **** 	i = SS(fs);								/* Sector size */
3940:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_BytsPerSec, i);
3941:lib/ff/ff.c   **** 	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
3942:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
3943:lib/ff/ff.c   **** 	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
3944:lib/ff/ff.c   **** 	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
3945:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_RootEntCnt, i);
3946:lib/ff/ff.c   **** 	if (n_vol < 0x10000) {					/* Number of total sectors */
3947:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_TotSec16, n_vol);
3948:lib/ff/ff.c   **** 	} else {
3949:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_TotSec32, n_vol);
3950:lib/ff/ff.c   **** 	}
3951:lib/ff/ff.c   **** 	tbl[BPB_Media] = md;					/* Media descriptor */
3952:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
3953:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
3954:lib/ff/ff.c   **** 	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
3955:lib/ff/ff.c   **** 	n = get_fattime();						/* Use current time as VSN */
3956:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
3957:lib/ff/ff.c   **** 		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
3958:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
3959:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
3960:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
3961:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
3962:lib/ff/ff.c   **** 		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
3963:lib/ff/ff.c   **** 		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
3964:lib/ff/ff.c   **** 		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
3965:lib/ff/ff.c   **** 	} else {
3966:lib/ff/ff.c   **** 		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
3967:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
3968:lib/ff/ff.c   **** 		tbl[BS_DrvNum] = 0x80;				/* Drive number */
3969:lib/ff/ff.c   **** 		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
3970:lib/ff/ff.c   **** 		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
3971:lib/ff/ff.c   **** 	}
3972:lib/ff/ff.c   **** 	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
3973:lib/ff/ff.c   **** 	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
3974:lib/ff/ff.c   **** 		return FR_DISK_ERR;
3975:lib/ff/ff.c   **** 	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
3976:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 6, 1);
3977:lib/ff/ff.c   **** 
3978:lib/ff/ff.c   **** 	/* Initialize FAT area */
3979:lib/ff/ff.c   **** 	wsect = b_fat;
3980:lib/ff/ff.c   **** 	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
3981:lib/ff/ff.c   **** 		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
3982:lib/ff/ff.c   **** 		n = md;								/* Media descriptor byte */
3983:lib/ff/ff.c   **** 		if (fmt != FS_FAT32) {
3984:lib/ff/ff.c   **** 			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
3985:lib/ff/ff.c   **** 			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
3986:lib/ff/ff.c   **** 		} else {
3987:lib/ff/ff.c   **** 			n |= 0xFFFFFF00;
3988:lib/ff/ff.c   **** 			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
3989:lib/ff/ff.c   **** 			ST_DWORD(tbl+4, 0xFFFFFFFF);
3990:lib/ff/ff.c   **** 			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
3991:lib/ff/ff.c   **** 		}
3992:lib/ff/ff.c   **** 		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3993:lib/ff/ff.c   **** 			return FR_DISK_ERR;
3994:lib/ff/ff.c   **** 		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
3995:lib/ff/ff.c   **** 		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single se
3996:lib/ff/ff.c   **** 			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3997:lib/ff/ff.c   **** 				return FR_DISK_ERR;
3998:lib/ff/ff.c   **** 		}
3999:lib/ff/ff.c   **** 	}
4000:lib/ff/ff.c   **** 
4001:lib/ff/ff.c   **** 	/* Initialize root directory */
4002:lib/ff/ff.c   **** 	i = (fmt == FS_FAT32) ? au : n_dir;
4003:lib/ff/ff.c   **** 	do {
4004:lib/ff/ff.c   **** 		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
4005:lib/ff/ff.c   **** 			return FR_DISK_ERR;
4006:lib/ff/ff.c   **** 	} while (--i);
4007:lib/ff/ff.c   **** 
4008:lib/ff/ff.c   **** #if _USE_ERASE	/* Erase data area if needed */
4009:lib/ff/ff.c   **** 	{
4010:lib/ff/ff.c   **** 		DWORD eb[2];
4011:lib/ff/ff.c   **** 
4012:lib/ff/ff.c   **** 		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
4013:lib/ff/ff.c   **** 		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
4014:lib/ff/ff.c   **** 	}
4015:lib/ff/ff.c   **** #endif
4016:lib/ff/ff.c   **** 
4017:lib/ff/ff.c   **** 	/* Create FSInfo if needed */
4018:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
4019:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
4020:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
4021:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
4022:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
4023:lib/ff/ff.c   **** 		ST_WORD(tbl+BS_55AA, 0xAA55);
4024:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
4025:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
4026:lib/ff/ff.c   **** 	}
4027:lib/ff/ff.c   **** 
4028:lib/ff/ff.c   **** 	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
4029:lib/ff/ff.c   **** }
4030:lib/ff/ff.c   **** 
4031:lib/ff/ff.c   **** 
4032:lib/ff/ff.c   **** #if _MULTI_PARTITION
4033:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4034:lib/ff/ff.c   **** /* Divide Physical Drive                                                 */
4035:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4036:lib/ff/ff.c   **** 
4037:lib/ff/ff.c   **** FRESULT f_fdisk (
4038:lib/ff/ff.c   **** 	BYTE pdrv,			/* Physical drive number */
4039:lib/ff/ff.c   **** 	const DWORD szt[],	/* Pointer to the size table for each partitions */
4040:lib/ff/ff.c   **** 	void* work			/* Pointer to the working buffer */
4041:lib/ff/ff.c   **** )
4042:lib/ff/ff.c   **** {
4043:lib/ff/ff.c   **** 	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
4044:lib/ff/ff.c   **** 	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
4045:lib/ff/ff.c   **** 	DSTATUS stat;
4046:lib/ff/ff.c   **** 	DWORD sz_disk, sz_part, s_part;
4047:lib/ff/ff.c   **** 
4048:lib/ff/ff.c   **** 
4049:lib/ff/ff.c   **** 	stat = disk_initialize(pdrv);
4050:lib/ff/ff.c   **** 	if (stat & STA_NOINIT) return FR_NOT_READY;
4051:lib/ff/ff.c   **** 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
4052:lib/ff/ff.c   **** 	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
4053:lib/ff/ff.c   **** 
4054:lib/ff/ff.c   **** 	/* Determine CHS in the table regardless of the drive geometry */
4055:lib/ff/ff.c   **** 	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
4056:lib/ff/ff.c   **** 	if (n == 256) n--;
4057:lib/ff/ff.c   **** 	e_hd = n - 1;
4058:lib/ff/ff.c   **** 	sz_cyl = 63 * n;
4059:lib/ff/ff.c   **** 	tot_cyl = sz_disk / sz_cyl;
4060:lib/ff/ff.c   **** 
4061:lib/ff/ff.c   **** 	/* Create partition table */
4062:lib/ff/ff.c   **** 	mem_set(buf, 0, _MAX_SS);
4063:lib/ff/ff.c   **** 	p = buf + MBR_Table; b_cyl = 0;
4064:lib/ff/ff.c   **** 	for (i = 0; i < 4; i++, p += SZ_PTE) {
4065:lib/ff/ff.c   **** 		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
4066:lib/ff/ff.c   **** 		if (!p_cyl) continue;
4067:lib/ff/ff.c   **** 		s_part = (DWORD)sz_cyl * b_cyl;
4068:lib/ff/ff.c   **** 		sz_part = (DWORD)sz_cyl * p_cyl;
4069:lib/ff/ff.c   **** 		if (i == 0) {	/* Exclude first track of cylinder 0 */
4070:lib/ff/ff.c   **** 			s_hd = 1;
4071:lib/ff/ff.c   **** 			s_part += 63; sz_part -= 63;
4072:lib/ff/ff.c   **** 		} else {
4073:lib/ff/ff.c   **** 			s_hd = 0;
4074:lib/ff/ff.c   **** 		}
4075:lib/ff/ff.c   **** 		e_cyl = b_cyl + p_cyl - 1;
4076:lib/ff/ff.c   **** 		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
4077:lib/ff/ff.c   **** 
4078:lib/ff/ff.c   **** 		/* Set partition table */
4079:lib/ff/ff.c   **** 		p[1] = s_hd;						/* Start head */
4080:lib/ff/ff.c   **** 		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
4081:lib/ff/ff.c   **** 		p[3] = (BYTE)b_cyl;					/* Start cylinder */
4082:lib/ff/ff.c   **** 		p[4] = 0x06;						/* System type (temporary setting) */
4083:lib/ff/ff.c   **** 		p[5] = e_hd;						/* End head */
4084:lib/ff/ff.c   **** 		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
4085:lib/ff/ff.c   **** 		p[7] = (BYTE)e_cyl;					/* End cylinder */
4086:lib/ff/ff.c   **** 		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
4087:lib/ff/ff.c   **** 		ST_DWORD(p + 12, sz_part);			/* Partition size */
4088:lib/ff/ff.c   **** 
4089:lib/ff/ff.c   **** 		/* Next partition */
4090:lib/ff/ff.c   **** 		b_cyl += p_cyl;
4091:lib/ff/ff.c   **** 	}
4092:lib/ff/ff.c   **** 	ST_WORD(p, 0xAA55);
4093:lib/ff/ff.c   **** 
4094:lib/ff/ff.c   **** 	/* Write it to the MBR */
4095:lib/ff/ff.c   **** 	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
4096:lib/ff/ff.c   **** }
4097:lib/ff/ff.c   **** 
4098:lib/ff/ff.c   **** 
4099:lib/ff/ff.c   **** #endif /* _MULTI_PARTITION */
4100:lib/ff/ff.c   **** #endif /* _USE_MKFS && !_FS_READONLY */
4101:lib/ff/ff.c   **** 
4102:lib/ff/ff.c   **** 
4103:lib/ff/ff.c   **** 
4104:lib/ff/ff.c   **** 
4105:lib/ff/ff.c   **** #if _USE_STRFUNC
4106:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4107:lib/ff/ff.c   **** /* Get a string from the file                                            */
4108:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4109:lib/ff/ff.c   **** 
4110:lib/ff/ff.c   **** TCHAR* f_gets (
4111:lib/ff/ff.c   **** 	TCHAR* buff,	/* Pointer to the string buffer to read */
4112:lib/ff/ff.c   **** 	int len,		/* Size of string buffer (characters) */
4113:lib/ff/ff.c   **** 	FIL* fp			/* Pointer to the file object */
4114:lib/ff/ff.c   **** )
4115:lib/ff/ff.c   **** {
4116:lib/ff/ff.c   **** 	int n = 0;
4117:lib/ff/ff.c   **** 	TCHAR c, *p = buff;
4118:lib/ff/ff.c   **** 	BYTE s[2];
4119:lib/ff/ff.c   **** 	UINT rc;
4120:lib/ff/ff.c   **** 
4121:lib/ff/ff.c   **** 
4122:lib/ff/ff.c   **** 	while (n < len - 1) {			/* Read bytes until buffer gets filled */
4123:lib/ff/ff.c   **** 		f_read(fp, s, 1, &rc);
4124:lib/ff/ff.c   **** 		if (rc != 1) break;			/* Break on EOF or error */
4125:lib/ff/ff.c   **** 		c = s[0];
4126:lib/ff/ff.c   **** #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
4127:lib/ff/ff.c   **** 		if (c >= 0x80) {
4128:lib/ff/ff.c   **** 			if (c < 0xC0) continue;	/* Skip stray trailer */
4129:lib/ff/ff.c   **** 			if (c < 0xE0) {			/* Two-byte sequence */
4130:lib/ff/ff.c   **** 				f_read(fp, s, 1, &rc);
4131:lib/ff/ff.c   **** 				if (rc != 1) break;
4132:lib/ff/ff.c   **** 				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
4133:lib/ff/ff.c   **** 				if (c < 0x80) c = '?';
4134:lib/ff/ff.c   **** 			} else {
4135:lib/ff/ff.c   **** 				if (c < 0xF0) {		/* Three-byte sequence */
4136:lib/ff/ff.c   **** 					f_read(fp, s, 2, &rc);
4137:lib/ff/ff.c   **** 					if (rc != 2) break;
4138:lib/ff/ff.c   **** 					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
4139:lib/ff/ff.c   **** 					if (c < 0x800) c = '?';
4140:lib/ff/ff.c   **** 				} else {			/* Reject four-byte sequence */
4141:lib/ff/ff.c   **** 					c = '?';
4142:lib/ff/ff.c   **** 				}
4143:lib/ff/ff.c   **** 			}
4144:lib/ff/ff.c   **** 		}
4145:lib/ff/ff.c   **** #endif
4146:lib/ff/ff.c   **** #if _USE_STRFUNC >= 2
4147:lib/ff/ff.c   **** 		if (c == '\r') continue;	/* Strip '\r' */
4148:lib/ff/ff.c   **** #endif
4149:lib/ff/ff.c   **** 		*p++ = c;
4150:lib/ff/ff.c   **** 		n++;
4151:lib/ff/ff.c   **** 		if (c == '\n') break;		/* Break on EOL */
4152:lib/ff/ff.c   **** 	}
4153:lib/ff/ff.c   **** 	*p = 0;
4154:lib/ff/ff.c   **** 	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
4155:lib/ff/ff.c   **** }
4156:lib/ff/ff.c   **** 
4157:lib/ff/ff.c   **** 
4158:lib/ff/ff.c   **** 
4159:lib/ff/ff.c   **** #if !_FS_READONLY
4160:lib/ff/ff.c   **** #include <stdarg.h>
4161:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4162:lib/ff/ff.c   **** /* Put a character to the file                                           */
4163:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4164:lib/ff/ff.c   **** 
4165:lib/ff/ff.c   **** int f_putc (
4166:lib/ff/ff.c   **** 	TCHAR c,	/* A character to be output */
4167:lib/ff/ff.c   **** 	FIL* fp		/* Pointer to the file object */
4168:lib/ff/ff.c   **** )
4169:lib/ff/ff.c   **** {
4170:lib/ff/ff.c   **** 	UINT bw, btw;
4171:lib/ff/ff.c   **** 	BYTE s[3];
4172:lib/ff/ff.c   **** 
4173:lib/ff/ff.c   **** 
4174:lib/ff/ff.c   **** #if _USE_STRFUNC >= 2
4175:lib/ff/ff.c   **** 	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
4176:lib/ff/ff.c   **** #endif
4177:lib/ff/ff.c   **** 
4178:lib/ff/ff.c   **** #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
4179:lib/ff/ff.c   **** 	if (c < 0x80) {			/* 7-bit */
4180:lib/ff/ff.c   **** 		s[0] = (BYTE)c;
4181:lib/ff/ff.c   **** 		btw = 1;
4182:lib/ff/ff.c   **** 	} else {
4183:lib/ff/ff.c   **** 		if (c < 0x800) {	/* 11-bit */
4184:lib/ff/ff.c   **** 			s[0] = (BYTE)(0xC0 | (c >> 6));
4185:lib/ff/ff.c   **** 			s[1] = (BYTE)(0x80 | (c & 0x3F));
4186:lib/ff/ff.c   **** 			btw = 2;
4187:lib/ff/ff.c   **** 		} else {			/* 16-bit */
4188:lib/ff/ff.c   **** 			s[0] = (BYTE)(0xE0 | (c >> 12));
4189:lib/ff/ff.c   **** 			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
4190:lib/ff/ff.c   **** 			s[2] = (BYTE)(0x80 | (c & 0x3F));
4191:lib/ff/ff.c   **** 			btw = 3;
4192:lib/ff/ff.c   **** 		}
4193:lib/ff/ff.c   **** 	}
4194:lib/ff/ff.c   **** #else				/* Write the character without conversion */
4195:lib/ff/ff.c   **** 	s[0] = (BYTE)c;
4196:lib/ff/ff.c   **** 	btw = 1;
4197:lib/ff/ff.c   **** #endif
4198:lib/ff/ff.c   **** 	f_write(fp, s, btw, &bw);		/* Write the char to the file */
4199:lib/ff/ff.c   **** 	return (bw == btw) ? 1 : EOF;	/* Return the result */
4200:lib/ff/ff.c   **** }
4201:lib/ff/ff.c   **** 
4202:lib/ff/ff.c   **** 
4203:lib/ff/ff.c   **** 
4204:lib/ff/ff.c   **** 
4205:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4206:lib/ff/ff.c   **** /* Put a string to the file                                              */
4207:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4208:lib/ff/ff.c   **** 
4209:lib/ff/ff.c   **** int f_puts (
4210:lib/ff/ff.c   **** 	const TCHAR* str,	/* Pointer to the string to be output */
4211:lib/ff/ff.c   **** 	FIL* fp				/* Pointer to the file object */
4212:lib/ff/ff.c   **** )
4213:lib/ff/ff.c   **** {
4214:lib/ff/ff.c   **** 	int n;
4215:lib/ff/ff.c   **** 
4216:lib/ff/ff.c   **** 
4217:lib/ff/ff.c   **** 	for (n = 0; *str; str++, n++) {
4218:lib/ff/ff.c   **** 		if (f_putc(*str, fp) == EOF) return EOF;
4219:lib/ff/ff.c   **** 	}
4220:lib/ff/ff.c   **** 	return n;
4221:lib/ff/ff.c   **** }
4222:lib/ff/ff.c   **** 
4223:lib/ff/ff.c   **** 
4224:lib/ff/ff.c   **** 
4225:lib/ff/ff.c   **** 
4226:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4227:lib/ff/ff.c   **** /* Put a formatted string to the file                                    */
4228:lib/ff/ff.c   **** /*-----------------------------------------------------------------------*/
4229:lib/ff/ff.c   **** 
4230:lib/ff/ff.c   **** int f_printf (
4231:lib/ff/ff.c   **** 	FIL* fp,			/* Pointer to the file object */
4232:lib/ff/ff.c   **** 	const TCHAR* str,	/* Pointer to the format string */
4233:lib/ff/ff.c   **** 	...					/* Optional arguments... */
4234:lib/ff/ff.c   **** )
4235:lib/ff/ff.c   **** {
4236:lib/ff/ff.c   **** 	va_list arp;
4237:lib/ff/ff.c   **** 	BYTE f, r;
4238:lib/ff/ff.c   **** 	UINT i, j, w;
4239:lib/ff/ff.c   **** 	ULONG v;
4240:lib/ff/ff.c   **** 	TCHAR c, d, s[16], *p;
4241:lib/ff/ff.c   **** 	int res, chc, cc;
4242:lib/ff/ff.c   **** 
4243:lib/ff/ff.c   **** 
4244:lib/ff/ff.c   **** 	va_start(arp, str);
4245:lib/ff/ff.c   **** 
4246:lib/ff/ff.c   **** 	for (cc = res = 0; cc != EOF; res += cc) {
4247:lib/ff/ff.c   **** 		c = *str++;
4248:lib/ff/ff.c   **** 		if (c == 0) break;			/* End of string */
4249:lib/ff/ff.c   **** 		if (c != '%') {				/* Non escape character */
4250:lib/ff/ff.c   **** 			cc = f_putc(c, fp);
4251:lib/ff/ff.c   **** 			if (cc != EOF) cc = 1;
4252:lib/ff/ff.c   **** 			continue;
4253:lib/ff/ff.c   **** 		}
4254:lib/ff/ff.c   **** 		w = f = 0;
4255:lib/ff/ff.c   **** 		c = *str++;
4256:lib/ff/ff.c   **** 		if (c == '0') {				/* Flag: '0' padding */
4257:lib/ff/ff.c   **** 			f = 1; c = *str++;
4258:lib/ff/ff.c   **** 		} else {
4259:lib/ff/ff.c   **** 			if (c == '-') {			/* Flag: left justified */
4260:lib/ff/ff.c   **** 				f = 2; c = *str++;
4261:lib/ff/ff.c   **** 			}
4262:lib/ff/ff.c   **** 		}
4263:lib/ff/ff.c   **** 		while (IsDigit(c)) {		/* Precision */
4264:lib/ff/ff.c   **** 			w = w * 10 + c - '0';
4265:lib/ff/ff.c   **** 			c = *str++;
4266:lib/ff/ff.c   **** 		}
4267:lib/ff/ff.c   **** 		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
4268:lib/ff/ff.c   **** 			f |= 4; c = *str++;
4269:lib/ff/ff.c   **** 		}
4270:lib/ff/ff.c   **** 		if (!c) break;
4271:lib/ff/ff.c   **** 		d = c;
4272:lib/ff/ff.c   **** 		if (IsLower(d)) d -= 0x20;
4273:lib/ff/ff.c   **** 		switch (d) {				/* Type is... */
4274:lib/ff/ff.c   **** 		case 'S' :					/* String */
4275:lib/ff/ff.c   **** 			p = va_arg(arp, TCHAR*);
4276:lib/ff/ff.c   **** 			for (j = 0; p[j]; j++) ;
4277:lib/ff/ff.c   **** 			chc = 0;
4278:lib/ff/ff.c   **** 			if (!(f & 2)) {
4279:lib/ff/ff.c   **** 				while (j++ < w) chc += (cc = f_putc(' ', fp));
4280:lib/ff/ff.c   **** 			}
4281:lib/ff/ff.c   **** 			chc += (cc = f_puts(p, fp));
4282:lib/ff/ff.c   **** 			while (j++ < w) chc += (cc = f_putc(' ', fp));
4283:lib/ff/ff.c   **** 			if (cc != EOF) cc = chc;
4284:lib/ff/ff.c   **** 			continue;
4285:lib/ff/ff.c   **** 		case 'C' :					/* Character */
4286:lib/ff/ff.c   **** 			cc = f_putc((TCHAR)va_arg(arp, int), fp); continue;
4287:lib/ff/ff.c   **** 		case 'B' :					/* Binary */
4288:lib/ff/ff.c   **** 			r = 2; break;
4289:lib/ff/ff.c   **** 		case 'O' :					/* Octal */
4290:lib/ff/ff.c   **** 			r = 8; break;
4291:lib/ff/ff.c   **** 		case 'D' :					/* Signed decimal */
4292:lib/ff/ff.c   **** 		case 'U' :					/* Unsigned decimal */
4293:lib/ff/ff.c   **** 			r = 10; break;
4294:lib/ff/ff.c   **** 		case 'X' :					/* Hexdecimal */
4295:lib/ff/ff.c   **** 			r = 16; break;
4296:lib/ff/ff.c   **** 		default:					/* Unknown type (pass-through) */
4297:lib/ff/ff.c   **** 			cc = f_putc(c, fp); continue;
4298:lib/ff/ff.c   **** 		}
4299:lib/ff/ff.c   **** 
4300:lib/ff/ff.c   **** 		/* Get an argument and put it in numeral */
4301:lib/ff/ff.c   **** 		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_
4302:lib/ff/ff.c   **** 		if (d == 'D' && (v & 0x80000000)) {
4303:lib/ff/ff.c   **** 			v = 0 - v;
4304:lib/ff/ff.c   **** 			f |= 8;
4305:lib/ff/ff.c   **** 		}
4306:lib/ff/ff.c   **** 		i = 0;
4307:lib/ff/ff.c   **** 		do {
4308:lib/ff/ff.c   **** 			d = (TCHAR)(v % r); v /= r;
4309:lib/ff/ff.c   **** 			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
4310:lib/ff/ff.c   **** 			s[i++] = d + '0';
4311:lib/ff/ff.c   **** 		} while (v && i < sizeof s / sizeof s[0]);
4312:lib/ff/ff.c   **** 		if (f & 8) s[i++] = '-';
4313:lib/ff/ff.c   **** 		j = i; d = (f & 1) ? '0' : ' ';
4314:lib/ff/ff.c   **** 		chc = 0;
4315:lib/ff/ff.c   **** 		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, fp));
4316:lib/ff/ff.c   **** 		do chc += (cc = f_putc(s[--i], fp)); while(i);
4317:lib/ff/ff.c   **** 		while (j++ < w) chc += (cc = f_putc(' ', fp));
4318:lib/ff/ff.c   **** 		if (cc != EOF) cc = chc;
4319:lib/ff/ff.c   **** 	}
4320:lib/ff/ff.c   **** 
4321:lib/ff/ff.c   **** 	va_end(arp);
4322:lib/ff/ff.c   **** 	return (cc == EOF) ? cc : res;
4323:lib/ff/ff.c   **** }
 2530              		.loc 1 4323 0
 2531 0236 2168     		ldr	r1, [r4, #0]
1248:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 2532              		.loc 1 1248 0
 2533 0238 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 2534 023a 0328     		cmp	r0, #3
1249:lib/ff/ff.c   **** 
 2535              		.loc 1 1249 0
 2536 023c 04BF     		itt	eq
 2537 023e 9B8A     		ldrheq	r3, [r3, #20]
 2538              	.LVL379:
 2539 0240 46EA0346 		orreq	r6, r6, r3, lsl #16
 2540              	.LVL380:
 2541              	.LBE69:
 2542              	.LBE68:
2027:lib/ff/ff.c   **** 		}
 2543              		.loc 1 2027 0
 2544 0244 A660     		str	r6, [r4, #8]
 2545 0246 39E7     		b	.L340
 2546              	.LVL381:
 2547              	.L301:
2025:lib/ff/ff.c   **** 			}
 2548              		.loc 1 2025 0
 2549 0248 0520     		movs	r0, #5
 2550 024a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2551              	.LVL382:
 2552              	.L261:
 2553              	.LBB70:
 2554              	.LBB59:
1841:lib/ff/ff.c   **** 			i = 8; ni = 11;
 2555              		.loc 1 1841 0
 2556 024e 0620     		movs	r0, #6
 2557              	.LVL383:
 2558              	.L314:
 2559              	.LBE59:
 2560              	.LBE70:
2032:lib/ff/ff.c   **** 
 2561              		.loc 1 2032 0
 2562 0250 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2563              	.L352:
 2564              		.align	2
 2565              	.L351:
 2566 0254 FFFFFFFF 		.word	.LC0-1
 2567              		.cfi_endproc
 2568              	.LFE24:
 2570              		.section	.text.dir_alloc.constprop.9,"ax",%progbits
 2571              		.align	1
 2572              		.thumb
 2573              		.thumb_func
 2575              	dir_alloc.constprop.9:
 2576              	.LFB66:
1205:lib/ff/ff.c   **** 	DIR* dj,	/* Pointer to the directory object */
 2577              		.loc 1 1205 0
 2578              		.cfi_startproc
 2579              		@ args = 0, pretend = 0, frame = 0
 2580              		@ frame_needed = 0, uses_anonymous_args = 0
 2581              	.LVL384:
 2582 0000 10B5     		push	{r4, lr}
 2583              	.LCFI16:
 2584              		.cfi_def_cfa_offset 8
 2585              		.cfi_offset 4, -8
 2586              		.cfi_offset 14, -4
 2587 0002 0446     		mov	r4, r0
 2588              	.LVL385:
1214:lib/ff/ff.c   **** 	if (res == FR_OK) {
 2589              		.loc 1 1214 0
 2590 0004 0021     		movs	r1, #0
 2591 0006 FFF7FEFF 		bl	dir_sdi
 2592              	.LVL386:
 2593              	.L370:
1215:lib/ff/ff.c   **** 		n = 0;
 2594              		.loc 1 1215 0
 2595 000a 70B9     		cbnz	r0, .L354
 2596              	.LVL387:
1218:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 2597              		.loc 1 1218 0
 2598 000c 2068     		ldr	r0, [r4, #0]
 2599              	.LVL388:
 2600 000e 2169     		ldr	r1, [r4, #16]
 2601 0010 FFF7FEFF 		bl	move_window
 2602              	.LVL389:
1219:lib/ff/ff.c   **** 			if (dj->dir[0] == DDE || dj->dir[0] == 0) {	/* Is it a blank entry? */
 2603              		.loc 1 1219 0
 2604 0014 48B9     		cbnz	r0, .L354
1220:lib/ff/ff.c   **** 				if (++n == nent) break;	/* A block of contiguous entry is found */
 2605              		.loc 1 1220 0
 2606 0016 6369     		ldr	r3, [r4, #20]
 2607 0018 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 2608 001a E529     		cmp	r1, #229
 2609 001c 08D0     		beq	.L357
 2610 001e 39B1     		cbz	r1, .L357
1225:lib/ff/ff.c   **** 		} while (res == FR_OK);
 2611              		.loc 1 1225 0
 2612 0020 2046     		mov	r0, r4
 2613              	.LVL390:
 2614 0022 0121     		movs	r1, #1
 2615 0024 FFF7FEFF 		bl	dir_next
 2616              	.LVL391:
 2617 0028 EFE7     		b	.L370
 2618              	.LVL392:
 2619              	.L354:
1228:lib/ff/ff.c   ****     return res;
 2620              		.loc 1 1228 0
 2621 002a 0428     		cmp	r0, #4
 2622 002c 08BF     		it	eq
 2623 002e 0720     		moveq	r0, #7
 2624              	.LVL393:
 2625              	.L357:
1230:lib/ff/ff.c   **** #endif
 2626              		.loc 1 1230 0
 2627 0030 10BD     		pop	{r4, pc}
 2628              		.cfi_endproc
 2629              	.LFE66:
 2631              		.section	.text.dir_register,"ax",%progbits
 2632              		.align	1
 2633              		.thumb
 2634              		.thumb_func
 2636              	dir_register:
 2637              	.LFB20:
1568:lib/ff/ff.c   **** 	FRESULT res;
 2638              		.loc 1 1568 0
 2639              		.cfi_startproc
 2640              		@ args = 0, pretend = 0, frame = 0
 2641              		@ frame_needed = 0, uses_anonymous_args = 0
 2642              	.LVL394:
 2643 0000 38B5     		push	{r3, r4, r5, lr}
 2644              	.LCFI17:
 2645              		.cfi_def_cfa_offset 16
 2646              		.cfi_offset 3, -16
 2647              		.cfi_offset 4, -12
 2648              		.cfi_offset 5, -8
 2649              		.cfi_offset 14, -4
 2650 0002 0446     		mov	r4, r0
1616:lib/ff/ff.c   **** #endif
 2651              		.loc 1 1616 0
 2652 0004 FFF7FEFF 		bl	dir_alloc.constprop.9
 2653              	.LVL395:
1619:lib/ff/ff.c   **** 		res = move_window(dj->fs, dj->sect);
 2654              		.loc 1 1619 0
 2655 0008 0546     		mov	r5, r0
 2656 000a 90B9     		cbnz	r0, .L372
 2657              	.LVL396:
 2658              	.LBB73:
 2659              	.LBB74:
1620:lib/ff/ff.c   **** 		if (res == FR_OK) {
 2660              		.loc 1 1620 0
 2661 000c 2068     		ldr	r0, [r4, #0]
 2662              	.LVL397:
 2663 000e 2169     		ldr	r1, [r4, #16]
 2664 0010 FFF7FEFF 		bl	move_window
 2665              	.LVL398:
1621:lib/ff/ff.c   **** 			mem_set(dj->dir, 0, SZ_DIR);	/* Clean the entry */
 2666              		.loc 1 1621 0
 2667 0014 0546     		mov	r5, r0
 2668 0016 60B9     		cbnz	r0, .L372
1622:lib/ff/ff.c   **** 			mem_cpy(dj->dir, dj->fn, 11);	/* Put SFN */
 2669              		.loc 1 1622 0
 2670 0018 6069     		ldr	r0, [r4, #20]
 2671              	.LVL399:
 2672 001a 2946     		mov	r1, r5
 2673 001c 2022     		movs	r2, #32
 2674 001e FFF7FEFF 		bl	mem_set
 2675              	.LVL400:
1623:lib/ff/ff.c   **** #if _USE_LFN
 2676              		.loc 1 1623 0
 2677 0022 6069     		ldr	r0, [r4, #20]
 2678 0024 A169     		ldr	r1, [r4, #24]
 2679 0026 0B22     		movs	r2, #11
 2680 0028 FFF7FEFF 		bl	mem_cpy
 2681              	.LVL401:
1627:lib/ff/ff.c   **** 		}
 2682              		.loc 1 1627 0
 2683 002c 2368     		ldr	r3, [r4, #0]
 2684 002e 0122     		movs	r2, #1
 2685 0030 1A71     		strb	r2, [r3, #4]
 2686              	.LVL402:
 2687              	.L372:
 2688              	.LBE74:
 2689              	.LBE73:
1632:lib/ff/ff.c   **** #endif /* !_FS_READONLY */
 2690              		.loc 1 1632 0
 2691 0032 2846     		mov	r0, r5
 2692 0034 38BD     		pop	{r3, r4, r5, pc}
 2693              		.cfi_endproc
 2694              	.LFE20:
 2696              		.section	.text.remove_chain,"ax",%progbits
 2697              		.align	1
 2698              		.thumb
 2699              		.thumb_func
 2701              	remove_chain:
 2702              	.LFB10:
 952:lib/ff/ff.c   **** 	FRESULT res;
 2703              		.loc 1 952 0
 2704              		.cfi_startproc
 2705              		@ args = 0, pretend = 0, frame = 8
 2706              		@ frame_needed = 0, uses_anonymous_args = 0
 2707              	.LVL403:
 2708 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 2709              	.LCFI18:
 2710              		.cfi_def_cfa_offset 32
 2711              		.cfi_offset 0, -32
 2712              		.cfi_offset 1, -28
 2713              		.cfi_offset 2, -24
 2714              		.cfi_offset 4, -20
 2715              		.cfi_offset 5, -16
 2716              		.cfi_offset 6, -12
 2717              		.cfi_offset 7, -8
 2718              		.cfi_offset 14, -4
 2719 0002 0446     		mov	r4, r0
 2720 0004 0F46     		mov	r7, r1
 2721              	.LVL404:
 959:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 2722              		.loc 1 959 0
 2723 0006 0129     		cmp	r1, #1
 2724 0008 39D9     		bls	.L384
 959:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 2725              		.loc 1 959 0 is_stmt 0 discriminator 1
 2726 000a C369     		ldr	r3, [r0, #28]
 2727 000c 9942     		cmp	r1, r3
 2728 000e 36D2     		bcs	.L384
 959:lib/ff/ff.c   **** 		res = FR_INT_ERR;
 2729              		.loc 1 959 0
 2730 0010 0D46     		mov	r5, r1
 2731              	.LVL405:
 2732              	.L376:
 2733              	.LBB77:
 2734              	.LBB78:
 964:lib/ff/ff.c   **** 			nxt = get_fat(fs, clst);			/* Get cluster status */
 2735              		.loc 1 964 0 is_stmt 1
 2736 0012 E069     		ldr	r0, [r4, #28]
 2737 0014 8542     		cmp	r5, r0
 2738 0016 05D2     		bcs	.L382
 2739              	.L381:
 965:lib/ff/ff.c   **** 			if (nxt == 0) break;				/* Empty cluster? */
 2740              		.loc 1 965 0
 2741 0018 2046     		mov	r0, r4
 2742 001a 2946     		mov	r1, r5
 2743 001c FFF7FEFF 		bl	get_fat
 2744              	.LVL406:
 966:lib/ff/ff.c   **** 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 2745              		.loc 1 966 0
 2746 0020 0646     		mov	r6, r0
 2747 0022 08B9     		cbnz	r0, .L377
 2748              	.LVL407:
 2749              	.L382:
 981:lib/ff/ff.c   **** 				scl = ecl = nxt;
 2750              		.loc 1 981 0
 2751 0024 0020     		movs	r0, #0
 2752 0026 2BE0     		b	.L375
 2753              	.LVL408:
 2754              	.L377:
 967:lib/ff/ff.c   **** 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 2755              		.loc 1 967 0
 2756 0028 0128     		cmp	r0, #1
 2757 002a 28D0     		beq	.L384
 968:lib/ff/ff.c   **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 2758              		.loc 1 968 0
 2759 002c 0130     		adds	r0, r0, #1
 2760              	.LVL409:
 2761 002e 24D0     		beq	.L386
 969:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 2762              		.loc 1 969 0
 2763 0030 2046     		mov	r0, r4
 2764 0032 2946     		mov	r1, r5
 2765 0034 0022     		movs	r2, #0
 2766 0036 FFF7FEFF 		bl	put_fat
 2767              	.LVL410:
 970:lib/ff/ff.c   **** 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 2768              		.loc 1 970 0
 2769 003a 08BB     		cbnz	r0, .L375
 971:lib/ff/ff.c   **** 				fs->free_clust++;
 2770              		.loc 1 971 0
 2771 003c 2269     		ldr	r2, [r4, #16]
 2772 003e 511C     		adds	r1, r2, #1
 2773 0040 03D0     		beq	.L379
 972:lib/ff/ff.c   **** 				fs->fsi_flag = 1;
 2774              		.loc 1 972 0
 2775 0042 511C     		adds	r1, r2, #1
 2776 0044 2161     		str	r1, [r4, #16]
 973:lib/ff/ff.c   **** 			}
 2777              		.loc 1 973 0
 2778 0046 0123     		movs	r3, #1
 2779 0048 6371     		strb	r3, [r4, #5]
 2780              	.L379:
 976:lib/ff/ff.c   **** 				ecl = nxt;
 2781              		.loc 1 976 0
 2782 004a 681C     		adds	r0, r5, #1
 2783              	.LVL411:
 2784 004c B042     		cmp	r0, r6
 2785 004e 12D0     		beq	.L380
 979:lib/ff/ff.c   **** 				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
 2786              		.loc 1 979 0
 2787 0050 2046     		mov	r0, r4
 2788 0052 3946     		mov	r1, r7
 2789 0054 FFF7FEFF 		bl	clust2sect
 2790              	.LVL412:
 2791 0058 0090     		str	r0, [sp, #0]
 980:lib/ff/ff.c   **** 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
 2792              		.loc 1 980 0
 2793 005a 2046     		mov	r0, r4
 2794 005c 2946     		mov	r1, r5
 2795 005e FFF7FEFF 		bl	clust2sect
 2796              	.LVL413:
 2797 0062 A578     		ldrb	r5, [r4, #2]	@ zero_extendqisi2
 2798              	.LVL414:
 2799 0064 6F1E     		subs	r7, r5, #1
 2800              	.LVL415:
 2801 0066 3A18     		adds	r2, r7, r0
 2802 0068 0192     		str	r2, [sp, #4]
 981:lib/ff/ff.c   **** 				scl = ecl = nxt;
 2803              		.loc 1 981 0
 2804 006a 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 2805 006c 0421     		movs	r1, #4
 2806 006e 6A46     		mov	r2, sp
 2807 0070 FFF7FEFF 		bl	disk_ioctl
 2808              	.LVL416:
 2809 0074 3746     		mov	r7, r6
 2810              	.LVL417:
 2811              	.L380:
 2812 0076 3546     		mov	r5, r6
 2813 0078 CBE7     		b	.L376
 2814              	.LVL418:
 2815              	.L386:
 968:lib/ff/ff.c   **** 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 2816              		.loc 1 968 0
 2817 007a 0120     		movs	r0, #1
 2818              	.LVL419:
 2819 007c 00E0     		b	.L375
 2820              	.LVL420:
 2821              	.L384:
 2822              	.LBE78:
 2823              	.LBE77:
 960:lib/ff/ff.c   **** 
 2824              		.loc 1 960 0
 2825 007e 0220     		movs	r0, #2
 2826              	.L375:
 2827              	.LVL421:
 990:lib/ff/ff.c   **** #endif
 2828              		.loc 1 990 0
 2829 0080 FEBD     		pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 2830              		.cfi_endproc
 2831              	.LFE10:
 2833              		.section	.text.f_mount,"ax",%progbits
 2834              		.align	1
 2835              		.global	f_mount
 2836              		.thumb
 2837              		.thumb_func
 2839              	f_mount:
 2840              	.LFB28:
2273:lib/ff/ff.c   **** 	FATFS *rfs;
 2841              		.loc 1 2273 0
 2842              		.cfi_startproc
 2843              		@ args = 0, pretend = 0, frame = 0
 2844              		@ frame_needed = 0, uses_anonymous_args = 0
 2845              		@ link register save eliminated.
 2846              	.LVL422:
2277:lib/ff/ff.c   **** 		return FR_INVALID_DRIVE;
 2847              		.loc 1 2277 0
 2848 0000 48B9     		cbnz	r0, .L394
2279:lib/ff/ff.c   **** 
 2849              		.loc 1 2279 0
 2850 0002 064A     		ldr	r2, .L401
 2851 0004 1368     		ldr	r3, [r2, #0]
 2852              	.LVL423:
2281:lib/ff/ff.c   **** #if _FS_LOCK
 2853              		.loc 1 2281 0
 2854 0006 03B1     		cbz	r3, .L392
2288:lib/ff/ff.c   **** 	}
 2855              		.loc 1 2288 0
 2856 0008 1870     		strb	r0, [r3, #0]
 2857              	.L392:
2291:lib/ff/ff.c   **** 		fs->fs_type = 0;		/* Clear new fs object */
 2858              		.loc 1 2291 0
 2859 000a 09B1     		cbz	r1, .L393
2292:lib/ff/ff.c   **** #if _FS_REENTRANT				/* Create sync object for the new volume */
 2860              		.loc 1 2292 0
 2861 000c 0020     		movs	r0, #0
 2862              	.LVL424:
 2863 000e 0870     		strb	r0, [r1, #0]
 2864              	.L393:
2297:lib/ff/ff.c   **** 
 2865              		.loc 1 2297 0
 2866 0010 1160     		str	r1, [r2, #0]
2299:lib/ff/ff.c   **** }
 2867              		.loc 1 2299 0
 2868 0012 0020     		movs	r0, #0
 2869 0014 7047     		bx	lr
 2870              	.LVL425:
 2871              	.L394:
2278:lib/ff/ff.c   **** 	rfs = FatFs[vol];			/* Get current fs object */
 2872              		.loc 1 2278 0
 2873 0016 0B20     		movs	r0, #11
 2874              	.LVL426:
2300:lib/ff/ff.c   **** 
 2875              		.loc 1 2300 0
 2876 0018 7047     		bx	lr
 2877              	.L402:
 2878 001a 00BF     		.align	2
 2879              	.L401:
 2880 001c 00000000 		.word	.LANCHOR1
 2881              		.cfi_endproc
 2882              	.LFE28:
 2884              		.section	.text.f_open,"ax",%progbits
 2885              		.align	1
 2886              		.global	f_open
 2887              		.thumb
 2888              		.thumb_func
 2890              	f_open:
 2891              	.LFB29:
2314:lib/ff/ff.c   **** 	FRESULT res;
 2892              		.loc 1 2314 0
 2893              		.cfi_startproc
 2894              		@ args = 0, pretend = 0, frame = 48
 2895              		@ frame_needed = 0, uses_anonymous_args = 0
 2896              	.LVL427:
 2897 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 2898              	.LCFI19:
 2899              		.cfi_def_cfa_offset 28
 2900              		.cfi_offset 4, -28
 2901              		.cfi_offset 5, -24
 2902              		.cfi_offset 6, -20
 2903              		.cfi_offset 7, -16
 2904              		.cfi_offset 8, -12
 2905              		.cfi_offset 9, -8
 2906              		.cfi_offset 14, -4
 2907 0004 8DB0     		sub	sp, sp, #52
 2908              	.LCFI20:
 2909              		.cfi_def_cfa_offset 80
 2910 0006 0191     		str	r1, [sp, #4]
 2911 0008 1746     		mov	r7, r2
2321:lib/ff/ff.c   **** 	fp->fs = 0;			/* Clear file object */
 2912              		.loc 1 2321 0
 2913 000a 0546     		mov	r5, r0
 2914 000c 0028     		cmp	r0, #0
 2915 000e 00F08280 		beq	.L418
2322:lib/ff/ff.c   **** 
 2916              		.loc 1 2322 0
 2917 0012 0023     		movs	r3, #0
 2918 0014 0360     		str	r3, [r0, #0]
 2919              	.LVL428:
2326:lib/ff/ff.c   **** #else
 2920              		.loc 1 2326 0
 2921 0016 01A8     		add	r0, sp, #4
 2922              	.LVL429:
 2923 0018 05A9     		add	r1, sp, #20
 2924 001a 02F01E02 		and	r2, r2, #30
 2925              	.LVL430:
 2926 001e FFF7FEFF 		bl	chk_mounted
 2927              	.LVL431:
2331:lib/ff/ff.c   **** 		INIT_BUF(dj);
 2928              		.loc 1 2331 0
 2929 0022 8046     		mov	r8, r0
 2930 0024 0028     		cmp	r0, #0
 2931 0026 7FD1     		bne	.L430
2332:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
 2932              		.loc 1 2332 0
 2933 0028 02A8     		add	r0, sp, #8
 2934              	.LVL432:
 2935 002a 0B90     		str	r0, [sp, #44]
2333:lib/ff/ff.c   **** 		dir = dj.dir;
 2936              		.loc 1 2333 0
 2937 002c 05A8     		add	r0, sp, #20
 2938 002e 0199     		ldr	r1, [sp, #4]
 2939 0030 FFF7FEFF 		bl	follow_path
 2940              	.LVL433:
2334:lib/ff/ff.c   **** #if !_FS_READONLY	/* R/W configuration */
 2941              		.loc 1 2334 0
 2942 0034 0A9C     		ldr	r4, [sp, #40]
 2943              	.LVL434:
2336:lib/ff/ff.c   **** 			if (!dir)	/* Current dir itself */
 2944              		.loc 1 2336 0
 2945 0036 18B9     		cbnz	r0, .L405
2338:lib/ff/ff.c   **** #if _FS_LOCK
 2946              		.loc 1 2338 0
 2947 0038 002C     		cmp	r4, #0
 2948 003a 0CBF     		ite	eq
 2949 003c 0620     		moveq	r0, #6
 2950 003e 0020     		movne	r0, #0
 2951              	.LVL435:
 2952              	.L405:
2325:lib/ff/ff.c   **** 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
 2953              		.loc 1 2325 0
 2954 0040 07F01F06 		and	r6, r7, #31
 2955              	.LVL436:
2345:lib/ff/ff.c   **** 			DWORD dw, cl;
 2956              		.loc 1 2345 0
 2957 0044 17F01C0F 		tst	r7, #28
 2958 0048 3BD0     		beq	.L406
 2959              	.LBB86:
2348:lib/ff/ff.c   **** 				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 2960              		.loc 1 2348 0
 2961 004a 48B1     		cbz	r0, .L407
2349:lib/ff/ff.c   **** #if _FS_LOCK
 2962              		.loc 1 2349 0
 2963 004c 0428     		cmp	r0, #4
 2964 004e 02D1     		bne	.L408
2353:lib/ff/ff.c   **** #endif
 2965              		.loc 1 2353 0
 2966 0050 05A8     		add	r0, sp, #20
 2967              	.LVL437:
 2968 0052 FFF7FEFF 		bl	dir_register
 2969              	.LVL438:
 2970              	.L408:
2355:lib/ff/ff.c   **** 				dir = dj.dir;					/* New entry */
 2971              		.loc 1 2355 0
 2972 0056 46F00806 		orr	r6, r6, #8
 2973              	.LVL439:
2356:lib/ff/ff.c   **** 			}
 2974              		.loc 1 2356 0
 2975 005a 0A9C     		ldr	r4, [sp, #40]
 2976              	.LVL440:
2366:lib/ff/ff.c   **** 				dw = get_fattime();					/* Created time */
 2977              		.loc 1 2366 0
 2978 005c 48B1     		cbz	r0, .L409
 2979 005e 62E0     		b	.L415
 2980              	.LVL441:
 2981              	.L407:
2359:lib/ff/ff.c   **** 					res = FR_DENIED;
 2982              		.loc 1 2359 0
 2983 0060 E07A     		ldrb	r0, [r4, #11]	@ zero_extendqisi2
 2984              	.LVL442:
 2985 0062 10F0110F 		tst	r0, #17
 2986 0066 5DD1     		bne	.L423
2362:lib/ff/ff.c   **** 						res = FR_EXIST;
 2987              		.loc 1 2362 0
 2988 0068 07F00401 		and	r1, r7, #4
 2989 006c CFB2     		uxtb	r7, r1
 2990              	.LVL443:
 2991 006e 002F     		cmp	r7, #0
 2992 0070 54D1     		bne	.L421
 2993              	.L409:
2366:lib/ff/ff.c   **** 				dw = get_fattime();					/* Created time */
 2994              		.loc 1 2366 0 discriminator 1
 2995 0072 06F00802 		and	r2, r6, #8
 2996 0076 D3B2     		uxtb	r3, r2
 2997 0078 002B     		cmp	r3, #0
 2998 007a 2FD0     		beq	.L414
2367:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_CrtTime, dw);
 2999              		.loc 1 2367 0
 3000 007c FFF7FEFF 		bl	get_fattime
 3001              	.LVL444:
2368:lib/ff/ff.c   **** 				dir[DIR_Attr] = 0;					/* Reset attribute */
 3002              		.loc 1 2368 0
 3003 0080 C4F80E00 		str	r0, [r4, #14]
2369:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
 3004              		.loc 1 2369 0
 3005 0084 0021     		movs	r1, #0
 3006 0086 E172     		strb	r1, [r4, #11]
2370:lib/ff/ff.c   **** 				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
 3007              		.loc 1 2370 0
 3008 0088 E161     		str	r1, [r4, #28]
2371:lib/ff/ff.c   **** 				st_clust(dir, 0);					/* cluster = 0 */
 3009              		.loc 1 2371 0
 3010 008a 0598     		ldr	r0, [sp, #20]
 3011              	.LVL445:
 3012              	.LBB87:
 3013              	.LBB88:
1247:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 3014              		.loc 1 1247 0
 3015 008c 678B     		ldrh	r7, [r4, #26]
 3016              	.LVL446:
1248:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 3017              		.loc 1 1248 0
 3018 008e 0278     		ldrb	r2, [r0, #0]	@ zero_extendqisi2
 3019 0090 032A     		cmp	r2, #3
1249:lib/ff/ff.c   **** 
 3020              		.loc 1 1249 0
 3021 0092 04BF     		itt	eq
 3022 0094 A28A     		ldrheq	r2, [r4, #20]
 3023 0096 47EA0247 		orreq	r7, r7, r2, lsl #16
 3024              	.LVL447:
 3025              	.LBE88:
 3026              	.LBE87:
 3027              	.LBB89:
 3028              	.LBB90:
1262:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 3029              		.loc 1 1262 0
 3030 009a 6183     		strh	r1, [r4, #26]	@ movhi
1263:lib/ff/ff.c   **** }
 3031              		.loc 1 1263 0
 3032 009c A182     		strh	r1, [r4, #20]	@ movhi
 3033              	.LBE90:
 3034              	.LBE89:
2373:lib/ff/ff.c   **** 				if (cl) {							/* Remove the cluster chain if exist */
 3035              		.loc 1 2373 0
 3036 009e 0123     		movs	r3, #1
 3037 00a0 0371     		strb	r3, [r0, #4]
2374:lib/ff/ff.c   **** 					dw = dj.fs->winsect;
 3038              		.loc 1 2374 0
 3039 00a2 DFB1     		cbz	r7, .L414
2375:lib/ff/ff.c   **** 					res = remove_chain(dj.fs, cl);
 3040              		.loc 1 2375 0
 3041 00a4 D0F83490 		ldr	r9, [r0, #52]
 3042              	.LVL448:
2376:lib/ff/ff.c   **** 					if (res == FR_OK) {
 3043              		.loc 1 2376 0
 3044 00a8 3946     		mov	r1, r7
 3045 00aa FFF7FEFF 		bl	remove_chain
 3046              	.LVL449:
2377:lib/ff/ff.c   **** 						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 3047              		.loc 1 2377 0
 3048 00ae 0028     		cmp	r0, #0
 3049 00b0 39D1     		bne	.L415
2378:lib/ff/ff.c   **** 						res = move_window(dj.fs, dw);
 3050              		.loc 1 2378 0
 3051 00b2 0598     		ldr	r0, [sp, #20]
 3052              	.LVL450:
 3053 00b4 013F     		subs	r7, r7, #1
 3054              	.LVL451:
 3055 00b6 C760     		str	r7, [r0, #12]
2379:lib/ff/ff.c   **** 					}
 3056              		.loc 1 2379 0
 3057 00b8 4946     		mov	r1, r9
 3058 00ba FFF7FEFF 		bl	move_window
 3059              	.LVL452:
 3060              	.LBE86:
2394:lib/ff/ff.c   **** 			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
 3061              		.loc 1 2394 0
 3062 00be 68B1     		cbz	r0, .L414
 3063 00c0 31E0     		b	.L415
 3064              	.LVL453:
 3065              	.L406:
2385:lib/ff/ff.c   **** 				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
 3066              		.loc 1 2385 0
 3067 00c2 0028     		cmp	r0, #0
 3068 00c4 2FD1     		bne	.L415
2386:lib/ff/ff.c   **** 					res = FR_NO_FILE;
 3069              		.loc 1 2386 0
 3070 00c6 E17A     		ldrb	r1, [r4, #11]	@ zero_extendqisi2
 3071 00c8 01F01002 		and	r2, r1, #16
 3072 00cc D3B2     		uxtb	r3, r2
 3073 00ce 3BBB     		cbnz	r3, .L422
2389:lib/ff/ff.c   **** 						res = FR_DENIED;
 3074              		.loc 1 2389 0
 3075 00d0 07F00207 		and	r7, r7, #2
 3076              	.LVL454:
 3077 00d4 FFB2     		uxtb	r7, r7
 3078 00d6 0FB1     		cbz	r7, .L414
2389:lib/ff/ff.c   **** 						res = FR_DENIED;
 3079              		.loc 1 2389 0 is_stmt 0 discriminator 1
 3080 00d8 CB07     		lsls	r3, r1, #31
 3081 00da 23D4     		bmi	.L423
 3082              	.LVL455:
 3083              	.L414:
2395:lib/ff/ff.c   **** 				mode |= FA__WRITTEN;
 3084              		.loc 1 2395 0 is_stmt 1
 3085 00dc 06F00800 		and	r0, r6, #8
 3086 00e0 C1B2     		uxtb	r1, r0
 3087 00e2 09B1     		cbz	r1, .L416
2396:lib/ff/ff.c   **** 			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
 3088              		.loc 1 2396 0
 3089 00e4 46F02006 		orr	r6, r6, #32
 3090              	.LVL456:
 3091              	.L416:
2397:lib/ff/ff.c   **** 			fp->dir_ptr = dir;
 3092              		.loc 1 2397 0
 3093 00e8 059B     		ldr	r3, [sp, #20]
 3094 00ea 5A6B     		ldr	r2, [r3, #52]
 3095 00ec EA61     		str	r2, [r5, #28]
2398:lib/ff/ff.c   **** #if _FS_LOCK
 3096              		.loc 1 2398 0
 3097 00ee 2C62     		str	r4, [r5, #32]
2419:lib/ff/ff.c   **** 			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 3098              		.loc 1 2419 0
 3099 00f0 AE71     		strb	r6, [r5, #6]
 3100              	.LVL457:
 3101              	.LBB91:
 3102              	.LBB92:
1247:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 3103              		.loc 1 1247 0
 3104 00f2 608B     		ldrh	r0, [r4, #26]
 3105              	.LVL458:
1248:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 3106              		.loc 1 1248 0
 3107 00f4 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 3108 00f6 0329     		cmp	r1, #3
1249:lib/ff/ff.c   **** 
 3109              		.loc 1 1249 0
 3110 00f8 04BF     		itt	eq
 3111 00fa A18A     		ldrheq	r1, [r4, #20]
 3112 00fc 40EA0140 		orreq	r0, r0, r1, lsl #16
 3113              	.LVL459:
 3114              	.LBE92:
 3115              	.LBE91:
2420:lib/ff/ff.c   **** 			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 3116              		.loc 1 2420 0
 3117 0100 2861     		str	r0, [r5, #16]
2421:lib/ff/ff.c   **** 			fp->fptr = 0;						/* File pointer */
 3118              		.loc 1 2421 0
 3119 0102 E269     		ldr	r2, [r4, #28]
 3120 0104 EA60     		str	r2, [r5, #12]
2422:lib/ff/ff.c   **** 			fp->dsect = 0;
 3121              		.loc 1 2422 0
 3122 0106 0020     		movs	r0, #0
 3123              	.LVL460:
 3124 0108 A860     		str	r0, [r5, #8]
2423:lib/ff/ff.c   **** #if _USE_FASTSEEK
 3125              		.loc 1 2423 0
 3126 010a A861     		str	r0, [r5, #24]
2425:lib/ff/ff.c   **** #endif
 3127              		.loc 1 2425 0
 3128 010c 6862     		str	r0, [r5, #36]
2427:lib/ff/ff.c   **** 		}
 3129              		.loc 1 2427 0
 3130 010e 2B60     		str	r3, [r5, #0]
 3131 0110 DB88     		ldrh	r3, [r3, #6]
 3132 0112 AB80     		strh	r3, [r5, #4]	@ movhi
 3133 0114 08E0     		b	.L430
 3134              	.LVL461:
 3135              	.L418:
2321:lib/ff/ff.c   **** 	fp->fs = 0;			/* Clear file object */
 3136              		.loc 1 2321 0
 3137 0116 4FF00908 		mov	r8, #9
 3138 011a 05E0     		b	.L430
 3139              	.LVL462:
 3140              	.L421:
 3141              	.LBB93:
2363:lib/ff/ff.c   **** 				}
 3142              		.loc 1 2363 0
 3143 011c 0820     		movs	r0, #8
 3144              	.LVL463:
 3145 011e 02E0     		b	.L415
 3146              	.LVL464:
 3147              	.L422:
 3148              	.LBE93:
2387:lib/ff/ff.c   **** 				} else {
 3149              		.loc 1 2387 0
 3150 0120 0420     		movs	r0, #4
 3151              	.LVL465:
 3152 0122 00E0     		b	.L415
 3153              	.LVL466:
 3154              	.L423:
2390:lib/ff/ff.c   **** 				}
 3155              		.loc 1 2390 0
 3156 0124 0720     		movs	r0, #7
 3157              	.LVL467:
 3158              	.L415:
2321:lib/ff/ff.c   **** 	fp->fs = 0;			/* Clear file object */
 3159              		.loc 1 2321 0
 3160 0126 8046     		mov	r8, r0
 3161              	.L430:
2432:lib/ff/ff.c   **** 
 3162              		.loc 1 2432 0
 3163 0128 4046     		mov	r0, r8
 3164 012a 0DB0     		add	sp, sp, #52
 3165 012c BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 3166              		.cfi_endproc
 3167              	.LFE29:
 3169              		.section	.text.f_read,"ax",%progbits
 3170              		.align	1
 3171              		.global	f_read
 3172              		.thumb
 3173              		.thumb_func
 3175              	f_read:
 3176              	.LFB30:
2447:lib/ff/ff.c   **** 	FRESULT res;
 3177              		.loc 1 2447 0
 3178              		.cfi_startproc
 3179              		@ args = 0, pretend = 0, frame = 8
 3180              		@ frame_needed = 0, uses_anonymous_args = 0
 3181              	.LVL468:
 3182 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3183              	.LCFI21:
 3184              		.cfi_def_cfa_offset 48
 3185              		.cfi_offset 0, -48
 3186              		.cfi_offset 1, -44
 3187              		.cfi_offset 2, -40
 3188              		.cfi_offset 4, -36
 3189              		.cfi_offset 5, -32
 3190              		.cfi_offset 6, -28
 3191              		.cfi_offset 7, -24
 3192              		.cfi_offset 8, -20
 3193              		.cfi_offset 9, -16
 3194              		.cfi_offset 10, -12
 3195              		.cfi_offset 11, -8
 3196              		.cfi_offset 14, -4
 3197 0004 0446     		mov	r4, r0
 3198 0006 8846     		mov	r8, r1
 3199 0008 1746     		mov	r7, r2
 3200 000a 9946     		mov	r9, r3
 3201              	.LVL469:
2454:lib/ff/ff.c   **** 
 3202              		.loc 1 2454 0
 3203 000c 0023     		movs	r3, #0
 3204              	.LVL470:
 3205 000e C9F80030 		str	r3, [r9, #0]
2456:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 3206              		.loc 1 2456 0
 3207 0012 FFF7FEFF 		bl	validate
 3208              	.LVL471:
2457:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)					/* Aborted file? */
 3209              		.loc 1 2457 0
 3210 0016 0546     		mov	r5, r0
 3211 0018 0028     		cmp	r0, #0
 3212 001a 40F08A80 		bne	.L444
2458:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 3213              		.loc 1 2458 0
 3214 001e A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 3215 0020 0806     		lsls	r0, r1, #24
 3216              	.LVL472:
 3217 0022 00F18380 		bmi	.L461
2460:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
 3218              		.loc 1 2460 0
 3219 0026 C907     		lsls	r1, r1, #31
 3220 0028 40F18280 		bpl	.L462
 3221              	.LVL473:
2462:lib/ff/ff.c   **** 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 3222              		.loc 1 2462 0
 3223 002c E068     		ldr	r0, [r4, #12]
 3224 002e A268     		ldr	r2, [r4, #8]
 3225 0030 861A     		subs	r6, r0, r2
 3226              	.LVL474:
 3227 0032 B742     		cmp	r7, r6
 3228 0034 38BF     		it	cc
 3229 0036 3E46     		movcc	r6, r7
 3230              	.LVL475:
 3231              	.L445:
2465:lib/ff/ff.c   **** 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 3232              		.loc 1 2465 0 discriminator 1
 3233 0038 002E     		cmp	r6, #0
 3234 003a 7AD0     		beq	.L444
 3235              	.L460:
2467:lib/ff/ff.c   **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 3236              		.loc 1 2467 0
 3237 003c A168     		ldr	r1, [r4, #8]
 3238 003e CB05     		lsls	r3, r1, #23
 3239 0040 4CD1     		bne	.L446
2468:lib/ff/ff.c   **** 			if (!csect) {						/* On the cluster boundary? */
 3240              		.loc 1 2468 0
 3241 0042 2068     		ldr	r0, [r4, #0]
 3242 0044 90F802A0 		ldrb	sl, [r0, #2]	@ zero_extendqisi2
 3243 0048 0AF1FF33 		add	r3, sl, #-1
 3244 004c 03EA5122 		and	r2, r3, r1, lsr #9
 3245              	.LVL476:
2469:lib/ff/ff.c   **** 				if (fp->fptr == 0) {			/* On the top of the file? */
 3246              		.loc 1 2469 0
 3247 0050 12F0FF0A 		ands	sl, r2, #255
 3248 0054 10D1     		bne	.L447
2470:lib/ff/ff.c   **** 					clst = fp->sclust;			/* Follow from the origin */
 3249              		.loc 1 2470 0
 3250 0056 09B9     		cbnz	r1, .L448
2471:lib/ff/ff.c   **** 				} else {						/* Middle or end of the file */
 3251              		.loc 1 2471 0
 3252 0058 2069     		ldr	r0, [r4, #16]
 3253              	.LVL477:
 3254 005a 08E0     		b	.L449
 3255              	.LVL478:
 3256              	.L448:
2474:lib/ff/ff.c   **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 3257              		.loc 1 2474 0
 3258 005c 636A     		ldr	r3, [r4, #36]
 3259 005e 1BB1     		cbz	r3, .L450
2475:lib/ff/ff.c   **** 					else
 3260              		.loc 1 2475 0
 3261 0060 2046     		mov	r0, r4
 3262 0062 FFF7FEFF 		bl	clmt_clust
 3263              	.LVL479:
 3264 0066 02E0     		b	.L449
 3265              	.LVL480:
 3266              	.L450:
2478:lib/ff/ff.c   **** 				}
 3267              		.loc 1 2478 0
 3268 0068 6169     		ldr	r1, [r4, #20]
 3269 006a FFF7FEFF 		bl	get_fat
 3270              	.LVL481:
 3271              	.L449:
2480:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 3272              		.loc 1 2480 0
 3273 006e 0128     		cmp	r0, #1
 3274 0070 0AD9     		bls	.L466
 3275              	.L451:
2481:lib/ff/ff.c   **** 				fp->clust = clst;				/* Update current cluster */
 3276              		.loc 1 2481 0
 3277 0072 421C     		adds	r2, r0, #1
 3278 0074 3FD0     		beq	.L467
 3279              	.L452:
2482:lib/ff/ff.c   **** 			}
 3280              		.loc 1 2482 0
 3281 0076 6061     		str	r0, [r4, #20]
 3282              	.LVL482:
 3283              	.L447:
2484:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 3284              		.loc 1 2484 0
 3285 0078 2268     		ldr	r2, [r4, #0]
 3286 007a 1046     		mov	r0, r2
 3287 007c 6169     		ldr	r1, [r4, #20]
 3288 007e 0192     		str	r2, [sp, #4]
 3289 0080 FFF7FEFF 		bl	clust2sect
 3290              	.LVL483:
2485:lib/ff/ff.c   **** 			sect += csect;
 3291              		.loc 1 2485 0
 3292 0084 019B     		ldr	r3, [sp, #4]
 3293 0086 20B9     		cbnz	r0, .L453
 3294              	.LVL484:
 3295              	.L466:
2485:lib/ff/ff.c   **** 			sect += csect;
 3296              		.loc 1 2485 0 is_stmt 0 discriminator 1
 3297 0088 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3298 008a 63F07F02 		orn	r2, r3, #127
 3299 008e A271     		strb	r2, [r4, #6]
 3300 0090 4CE0     		b	.L461
 3301              	.LVL485:
 3302              	.L453:
2486:lib/ff/ff.c   **** 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
 3303              		.loc 1 2486 0 is_stmt 1
 3304 0092 00EB0A0B 		add	fp, r0, sl
 3305              	.LVL486:
2488:lib/ff/ff.c   **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 3306              		.loc 1 2488 0
 3307 0096 770A     		lsrs	r7, r6, #9
 3308              	.LVL487:
 3309 0098 1ED0     		beq	.L454
2489:lib/ff/ff.c   **** 					cc = fp->fs->csize - csect;
 3310              		.loc 1 2489 0
 3311 009a 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 3312 009c 07EB0A01 		add	r1, r7, sl
 3313 00a0 8142     		cmp	r1, r0
2490:lib/ff/ff.c   **** 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
 3314              		.loc 1 2490 0
 3315 00a2 88BF     		it	hi
 3316 00a4 CAEB0007 		rsbhi	r7, sl, r0
 3317              	.LVL488:
2491:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
 3318              		.loc 1 2491 0
 3319 00a8 5878     		ldrb	r0, [r3, #1]	@ zero_extendqisi2
 3320 00aa 4146     		mov	r1, r8
 3321 00ac 5A46     		mov	r2, fp
 3322 00ae FBB2     		uxtb	r3, r7
 3323 00b0 FFF7FEFF 		bl	disk_read
 3324              	.LVL489:
 3325 00b4 F8B9     		cbnz	r0, .L467
 3326              	.L456:
2495:lib/ff/ff.c   **** 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
 3327              		.loc 1 2495 0
 3328 00b6 2168     		ldr	r1, [r4, #0]
 3329 00b8 0B79     		ldrb	r3, [r1, #4]	@ zero_extendqisi2
 3330 00ba 5BB1     		cbz	r3, .L457
2495:lib/ff/ff.c   **** 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
 3331              		.loc 1 2495 0 is_stmt 0 discriminator 1
 3332 00bc 4A6B     		ldr	r2, [r1, #52]
 3333 00be CBEB0200 		rsb	r0, fp, r2
 3334 00c2 B842     		cmp	r0, r7
 3335 00c4 06D2     		bcs	.L457
2496:lib/ff/ff.c   **** #else
 3336              		.loc 1 2496 0 is_stmt 1
 3337 00c6 08EB4020 		add	r0, r8, r0, lsl #9
 3338 00ca 3831     		adds	r1, r1, #56
 3339 00cc 4FF40072 		mov	r2, #512
 3340 00d0 FFF7FEFF 		bl	mem_cpy
 3341              	.LVL490:
 3342              	.L457:
2502:lib/ff/ff.c   **** 				continue;
 3343              		.loc 1 2502 0
 3344 00d4 7F02     		lsls	r7, r7, #9
 3345              	.LVL491:
2503:lib/ff/ff.c   **** 			}
 3346              		.loc 1 2503 0
 3347 00d6 1EE0     		b	.L458
 3348              	.LVL492:
 3349              	.L454:
2518:lib/ff/ff.c   **** 		}
 3350              		.loc 1 2518 0
 3351 00d8 C4F818B0 		str	fp, [r4, #24]
 3352              	.LVL493:
 3353              	.L446:
2520:lib/ff/ff.c   **** 		if (rcnt > btr) rcnt = btr;
 3354              		.loc 1 2520 0
 3355 00dc A768     		ldr	r7, [r4, #8]
 3356 00de F905     		lsls	r1, r7, #23
 3357 00e0 C80D     		lsrs	r0, r1, #23
 3358 00e2 C0F50077 		rsb	r7, r0, #512
 3359              	.LVL494:
 3360 00e6 BE42     		cmp	r6, r7
 3361 00e8 38BF     		it	cc
 3362 00ea 3746     		movcc	r7, r6
 3363              	.LVL495:
2523:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
 3364              		.loc 1 2523 0
 3365 00ec 2068     		ldr	r0, [r4, #0]
 3366 00ee A169     		ldr	r1, [r4, #24]
 3367 00f0 FFF7FEFF 		bl	move_window
 3368              	.LVL496:
 3369 00f4 28B1     		cbz	r0, .L459
 3370              	.LVL497:
 3371              	.L467:
2524:lib/ff/ff.c   **** 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 3372              		.loc 1 2524 0
 3373 00f6 A579     		ldrb	r5, [r4, #6]	@ zero_extendqisi2
 3374 00f8 65F07F01 		orn	r1, r5, #127
 3375 00fc A171     		strb	r1, [r4, #6]
 3376 00fe 0125     		movs	r5, #1
 3377 0100 17E0     		b	.L444
 3378              	.LVL498:
 3379              	.L459:
2525:lib/ff/ff.c   **** #else
 3380              		.loc 1 2525 0
 3381 0102 A268     		ldr	r2, [r4, #8]
 3382 0104 D305     		lsls	r3, r2, #23
 3383 0106 D90D     		lsrs	r1, r3, #23
 3384 0108 3831     		adds	r1, r1, #56
 3385 010a 2268     		ldr	r2, [r4, #0]
 3386 010c 4046     		mov	r0, r8
 3387 010e 5118     		adds	r1, r2, r1
 3388 0110 3A46     		mov	r2, r7
 3389 0112 FFF7FEFF 		bl	mem_cpy
 3390              	.LVL499:
 3391              	.L458:
2466:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
 3392              		.loc 1 2466 0
 3393 0116 B844     		add	r8, r8, r7
 3394              	.LVL500:
 3395 0118 A168     		ldr	r1, [r4, #8]
 3396 011a CB19     		adds	r3, r1, r7
 3397 011c A360     		str	r3, [r4, #8]
 3398 011e D9F80020 		ldr	r2, [r9, #0]
 3399 0122 D019     		adds	r0, r2, r7
 3400 0124 C9F80000 		str	r0, [r9, #0]
 3401 0128 F61B     		subs	r6, r6, r7
 3402              	.LVL501:
 3403 012a 85E7     		b	.L445
 3404              	.LVL502:
 3405              	.L461:
2459:lib/ff/ff.c   **** 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
 3406              		.loc 1 2459 0
 3407 012c 0225     		movs	r5, #2
 3408 012e 00E0     		b	.L444
 3409              	.LVL503:
 3410              	.L462:
2461:lib/ff/ff.c   **** 	remain = fp->fsize - fp->fptr;
 3411              		.loc 1 2461 0
 3412 0130 0725     		movs	r5, #7
 3413              	.LVL504:
 3414              	.L444:
2532:lib/ff/ff.c   **** 
 3415              		.loc 1 2532 0
 3416 0132 2846     		mov	r0, r5
 3417 0134 BDE8FE8F 		pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3418              		.cfi_endproc
 3419              	.LFE30:
 3421              		.section	.text.f_write,"ax",%progbits
 3422              		.align	1
 3423              		.global	f_write
 3424              		.thumb
 3425              		.thumb_func
 3427              	f_write:
 3428              	.LFB31:
2548:lib/ff/ff.c   **** 	FRESULT res;
 3429              		.loc 1 2548 0
 3430              		.cfi_startproc
 3431              		@ args = 0, pretend = 0, frame = 8
 3432              		@ frame_needed = 0, uses_anonymous_args = 0
 3433              	.LVL505:
 3434 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3435              	.LCFI22:
 3436              		.cfi_def_cfa_offset 48
 3437              		.cfi_offset 0, -48
 3438              		.cfi_offset 1, -44
 3439              		.cfi_offset 2, -40
 3440              		.cfi_offset 4, -36
 3441              		.cfi_offset 5, -32
 3442              		.cfi_offset 6, -28
 3443              		.cfi_offset 7, -24
 3444              		.cfi_offset 8, -20
 3445              		.cfi_offset 9, -16
 3446              		.cfi_offset 10, -12
 3447              		.cfi_offset 11, -8
 3448              		.cfi_offset 14, -4
 3449 0004 0446     		mov	r4, r0
 3450 0006 8846     		mov	r8, r1
 3451 0008 1746     		mov	r7, r2
 3452 000a 9946     		mov	r9, r3
 3453              	.LVL506:
2556:lib/ff/ff.c   **** 
 3454              		.loc 1 2556 0
 3455 000c 0023     		movs	r3, #0
 3456              	.LVL507:
 3457 000e C9F80030 		str	r3, [r9, #0]
2558:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 3458              		.loc 1 2558 0
 3459 0012 FFF7FEFF 		bl	validate
 3460              	.LVL508:
2559:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)				/* Aborted file? */
 3461              		.loc 1 2559 0
 3462 0016 0546     		mov	r5, r0
 3463 0018 0028     		cmp	r0, #0
 3464 001a 40F0B580 		bne	.L469
2560:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 3465              		.loc 1 2560 0
 3466 001e A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 3467              	.LVL509:
 3468 0020 0206     		lsls	r2, r0, #24
 3469 0022 00F1AE80 		bmi	.L494
2562:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
 3470              		.loc 1 2562 0
 3471 0026 00F00201 		and	r1, r0, #2
 3472 002a CAB2     		uxtb	r2, r1
 3473 002c 002A     		cmp	r2, #0
 3474 002e 00F0AA80 		beq	.L495
2564:lib/ff/ff.c   **** 
 3475              		.loc 1 2564 0
 3476 0032 A368     		ldr	r3, [r4, #8]
 3477 0034 DF42     		cmn	r7, r3
 3478 0036 28BF     		it	cs
 3479 0038 0027     		movcs	r7, #0
 3480              	.LVL510:
 3481              	.L471:
2566:lib/ff/ff.c   **** 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 3482              		.loc 1 2566 0 discriminator 1
 3483 003a FFB1     		cbz	r7, .L493
 3484              	.L492:
2568:lib/ff/ff.c   **** 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 3485              		.loc 1 2568 0
 3486 003c A168     		ldr	r1, [r4, #8]
 3487 003e CB05     		lsls	r3, r1, #23
 3488 0040 6FD1     		bne	.L472
2569:lib/ff/ff.c   **** 			if (!csect) {					/* On the cluster boundary? */
 3489              		.loc 1 2569 0
 3490 0042 2068     		ldr	r0, [r4, #0]
 3491 0044 90F802A0 		ldrb	sl, [r0, #2]	@ zero_extendqisi2
 3492 0048 0AF1FF32 		add	r2, sl, #-1
 3493 004c 02EA5123 		and	r3, r2, r1, lsr #9
 3494              	.LVL511:
2570:lib/ff/ff.c   **** 				if (fp->fptr == 0) {		/* On the top of the file? */
 3495              		.loc 1 2570 0
 3496 0050 13F0FF0A 		ands	sl, r3, #255
 3497 0054 1DD1     		bne	.L473
2571:lib/ff/ff.c   **** 					clst = fp->sclust;		/* Follow from the origin */
 3498              		.loc 1 2571 0
 3499 0056 31B9     		cbnz	r1, .L474
2572:lib/ff/ff.c   **** 					if (clst == 0)			/* When no cluster is allocated, */
 3500              		.loc 1 2572 0
 3501 0058 2169     		ldr	r1, [r4, #16]
 3502              	.LVL512:
2573:lib/ff/ff.c   **** 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 3503              		.loc 1 2573 0
 3504 005a A9B9     		cbnz	r1, .L475
2574:lib/ff/ff.c   **** 				} else {					/* Middle or end of the file */
 3505              		.loc 1 2574 0
 3506 005c FFF7FEFF 		bl	create_chain
 3507              	.LVL513:
 3508 0060 0146     		mov	r1, r0
 3509              	.LVL514:
 3510 0062 2061     		str	r0, [r4, #16]
 3511 0064 09E0     		b	.L476
 3512              	.LVL515:
 3513              	.L474:
2577:lib/ff/ff.c   **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 3514              		.loc 1 2577 0
 3515 0066 626A     		ldr	r2, [r4, #36]
 3516 0068 1AB1     		cbz	r2, .L477
2578:lib/ff/ff.c   **** 					else
 3517              		.loc 1 2578 0
 3518 006a 2046     		mov	r0, r4
 3519 006c FFF7FEFF 		bl	clmt_clust
 3520              	.LVL516:
 3521 0070 02E0     		b	.L500
 3522              	.LVL517:
 3523              	.L477:
2581:lib/ff/ff.c   **** 				}
 3524              		.loc 1 2581 0
 3525 0072 6169     		ldr	r1, [r4, #20]
 3526 0074 FFF7FEFF 		bl	create_chain
 3527              	.LVL518:
 3528              	.L500:
 3529 0078 0146     		mov	r1, r0
 3530              	.LVL519:
 3531              	.L476:
2583:lib/ff/ff.c   **** 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 3532              		.loc 1 2583 0
 3533 007a 29B9     		cbnz	r1, .L475
 3534              	.LVL520:
 3535              	.L493:
2648:lib/ff/ff.c   **** 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 3536              		.loc 1 2648 0
 3537 007c A068     		ldr	r0, [r4, #8]
 3538 007e E168     		ldr	r1, [r4, #12]
 3539 0080 8842     		cmp	r0, r1
 3540 0082 79D9     		bls	.L479
 3541              	.L478:
2648:lib/ff/ff.c   **** 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 3542              		.loc 1 2648 0 is_stmt 0 discriminator 1
 3543 0084 E060     		str	r0, [r4, #12]
 3544 0086 77E0     		b	.L479
 3545              	.LVL521:
 3546              	.L475:
2584:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 3547              		.loc 1 2584 0 is_stmt 1
 3548 0088 0129     		cmp	r1, #1
 3549 008a 13D0     		beq	.L501
 3550              	.L480:
2585:lib/ff/ff.c   **** 				fp->clust = clst;			/* Update current cluster */
 3551              		.loc 1 2585 0
 3552 008c 4B1C     		adds	r3, r1, #1
 3553 008e 55D0     		beq	.L502
 3554              	.L481:
2586:lib/ff/ff.c   **** 			}
 3555              		.loc 1 2586 0
 3556 0090 6161     		str	r1, [r4, #20]
 3557              	.LVL522:
 3558              	.L473:
2589:lib/ff/ff.c   **** 				ABORT(fp->fs, FR_DISK_ERR);
 3559              		.loc 1 2589 0
 3560 0092 2068     		ldr	r0, [r4, #0]
 3561 0094 416B     		ldr	r1, [r0, #52]
 3562 0096 A369     		ldr	r3, [r4, #24]
 3563 0098 9942     		cmp	r1, r3
 3564 009a 03D1     		bne	.L482
2589:lib/ff/ff.c   **** 				ABORT(fp->fs, FR_DISK_ERR);
 3565              		.loc 1 2589 0 is_stmt 0 discriminator 1
 3566 009c FFF7FEFF 		bl	sync_window
 3567              	.LVL523:
 3568 00a0 0028     		cmp	r0, #0
 3569 00a2 4BD1     		bne	.L502
 3570              	.L482:
2598:lib/ff/ff.c   **** 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 3571              		.loc 1 2598 0 is_stmt 1
 3572 00a4 2268     		ldr	r2, [r4, #0]
 3573 00a6 1046     		mov	r0, r2
 3574 00a8 6169     		ldr	r1, [r4, #20]
 3575 00aa 0192     		str	r2, [sp, #4]
 3576 00ac FFF7FEFF 		bl	clust2sect
 3577              	.LVL524:
2599:lib/ff/ff.c   **** 			sect += csect;
 3578              		.loc 1 2599 0
 3579 00b0 019B     		ldr	r3, [sp, #4]
 3580 00b2 20B9     		cbnz	r0, .L483
 3581              	.LVL525:
 3582              	.L501:
2599:lib/ff/ff.c   **** 			sect += csect;
 3583              		.loc 1 2599 0 is_stmt 0 discriminator 1
 3584 00b4 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3585 00b6 63F07F02 		orn	r2, r3, #127
 3586 00ba A271     		strb	r2, [r4, #6]
 3587 00bc 61E0     		b	.L494
 3588              	.LVL526:
 3589              	.L483:
2600:lib/ff/ff.c   **** 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
 3590              		.loc 1 2600 0 is_stmt 1
 3591 00be 00EB0A0B 		add	fp, r0, sl
 3592              	.LVL527:
2602:lib/ff/ff.c   **** 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 3593              		.loc 1 2602 0
 3594 00c2 7E0A     		lsrs	r6, r7, #9
 3595              	.LVL528:
 3596 00c4 20D0     		beq	.L484
2603:lib/ff/ff.c   **** 					cc = fp->fs->csize - csect;
 3597              		.loc 1 2603 0
 3598 00c6 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 3599 00c8 06EB0A01 		add	r1, r6, sl
 3600 00cc 8142     		cmp	r1, r0
2604:lib/ff/ff.c   **** 				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
 3601              		.loc 1 2604 0
 3602 00ce 88BF     		it	hi
 3603 00d0 CAEB0006 		rsbhi	r6, sl, r0
 3604              	.LVL529:
2605:lib/ff/ff.c   **** 					ABORT(fp->fs, FR_DISK_ERR);
 3605              		.loc 1 2605 0
 3606 00d4 5878     		ldrb	r0, [r3, #1]	@ zero_extendqisi2
 3607 00d6 4146     		mov	r1, r8
 3608 00d8 5A46     		mov	r2, fp
 3609 00da F3B2     		uxtb	r3, r6
 3610 00dc FFF7FEFF 		bl	disk_write
 3611              	.LVL530:
 3612 00e0 8246     		mov	sl, r0
 3613 00e2 58BB     		cbnz	r0, .L502
 3614              	.L486:
2608:lib/ff/ff.c   **** 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
 3615              		.loc 1 2608 0
 3616 00e4 2068     		ldr	r0, [r4, #0]
 3617 00e6 436B     		ldr	r3, [r0, #52]
 3618 00e8 CBEB0302 		rsb	r2, fp, r3
 3619 00ec B242     		cmp	r2, r6
 3620 00ee 09D2     		bcs	.L487
2609:lib/ff/ff.c   **** 					fp->fs->wflag = 0;
 3621              		.loc 1 2609 0
 3622 00f0 3830     		adds	r0, r0, #56
 3623 00f2 08EB4221 		add	r1, r8, r2, lsl #9
 3624 00f6 4FF40072 		mov	r2, #512
 3625 00fa FFF7FEFF 		bl	mem_cpy
 3626              	.LVL531:
2610:lib/ff/ff.c   **** 				}
 3627              		.loc 1 2610 0
 3628 00fe 2068     		ldr	r0, [r4, #0]
 3629 0100 80F804A0 		strb	sl, [r0, #4]
 3630              	.L487:
2618:lib/ff/ff.c   **** 				continue;
 3631              		.loc 1 2618 0
 3632 0104 7602     		lsls	r6, r6, #9
 3633              	.LVL532:
2619:lib/ff/ff.c   **** 			}
 3634              		.loc 1 2619 0
 3635 0106 2CE0     		b	.L488
 3636              	.LVL533:
 3637              	.L484:
2622:lib/ff/ff.c   **** 				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
 3638              		.loc 1 2622 0
 3639 0108 A068     		ldr	r0, [r4, #8]
 3640 010a E168     		ldr	r1, [r4, #12]
 3641 010c 8842     		cmp	r0, r1
 3642 010e 06D3     		bcc	.L489
2623:lib/ff/ff.c   **** 				fp->fs->winsect = sect;
 3643              		.loc 1 2623 0
 3644 0110 1846     		mov	r0, r3
 3645 0112 FFF7FEFF 		bl	sync_window
 3646              	.LVL534:
 3647 0116 88B9     		cbnz	r0, .L502
 3648              	.L490:
2624:lib/ff/ff.c   **** 			}
 3649              		.loc 1 2624 0
 3650 0118 2668     		ldr	r6, [r4, #0]
 3651              	.LVL535:
 3652 011a C6F834B0 		str	fp, [r6, #52]
 3653              	.L489:
2633:lib/ff/ff.c   **** 		}
 3654              		.loc 1 2633 0
 3655 011e C4F818B0 		str	fp, [r4, #24]
 3656              	.LVL536:
 3657              	.L472:
2635:lib/ff/ff.c   **** 		if (wcnt > btw) wcnt = btw;
 3658              		.loc 1 2635 0
 3659 0122 A268     		ldr	r2, [r4, #8]
 3660 0124 D305     		lsls	r3, r2, #23
 3661 0126 D80D     		lsrs	r0, r3, #23
 3662 0128 C0F50076 		rsb	r6, r0, #512
 3663              	.LVL537:
 3664 012c B742     		cmp	r7, r6
 3665 012e 38BF     		it	cc
 3666 0130 3E46     		movcc	r6, r7
 3667              	.LVL538:
2638:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
 3668              		.loc 1 2638 0
 3669 0132 2068     		ldr	r0, [r4, #0]
 3670 0134 A169     		ldr	r1, [r4, #24]
 3671 0136 FFF7FEFF 		bl	move_window
 3672              	.LVL539:
 3673 013a 28B1     		cbz	r0, .L491
 3674              	.LVL540:
 3675              	.L502:
2639:lib/ff/ff.c   **** 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 3676              		.loc 1 2639 0
 3677 013c A579     		ldrb	r5, [r4, #6]	@ zero_extendqisi2
 3678 013e 65F07F01 		orn	r1, r5, #127
 3679 0142 A171     		strb	r1, [r4, #6]
 3680 0144 0125     		movs	r5, #1
 3681 0146 1FE0     		b	.L469
 3682              	.LVL541:
 3683              	.L491:
2640:lib/ff/ff.c   **** 		fp->fs->wflag = 1;
 3684              		.loc 1 2640 0
 3685 0148 A168     		ldr	r1, [r4, #8]
 3686 014a CA05     		lsls	r2, r1, #23
 3687 014c D00D     		lsrs	r0, r2, #23
 3688 014e 3830     		adds	r0, r0, #56
 3689 0150 2368     		ldr	r3, [r4, #0]
 3690 0152 1818     		adds	r0, r3, r0
 3691 0154 4146     		mov	r1, r8
 3692 0156 3246     		mov	r2, r6
 3693 0158 FFF7FEFF 		bl	mem_cpy
 3694              	.LVL542:
2641:lib/ff/ff.c   **** #else
 3695              		.loc 1 2641 0
 3696 015c 2168     		ldr	r1, [r4, #0]
 3697 015e 0122     		movs	r2, #1
 3698 0160 0A71     		strb	r2, [r1, #4]
 3699              	.L488:
2567:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 3700              		.loc 1 2567 0
 3701 0162 B044     		add	r8, r8, r6
 3702              	.LVL543:
 3703 0164 A168     		ldr	r1, [r4, #8]
 3704 0166 8B19     		adds	r3, r1, r6
 3705 0168 A360     		str	r3, [r4, #8]
 3706 016a D9F80020 		ldr	r2, [r9, #0]
 3707 016e 9019     		adds	r0, r2, r6
 3708 0170 C9F80000 		str	r0, [r9, #0]
 3709 0174 BF1B     		subs	r7, r7, r6
 3710 0176 60E7     		b	.L471
 3711              	.LVL544:
 3712              	.L479:
2649:lib/ff/ff.c   **** 
 3713              		.loc 1 2649 0
 3714 0178 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3715 017a 43F02002 		orr	r2, r3, #32
 3716 017e A271     		strb	r2, [r4, #6]
2651:lib/ff/ff.c   **** }
 3717              		.loc 1 2651 0
 3718 0180 02E0     		b	.L469
 3719              	.L494:
2561:lib/ff/ff.c   **** 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 3720              		.loc 1 2561 0
 3721 0182 0225     		movs	r5, #2
 3722 0184 00E0     		b	.L469
 3723              	.LVL545:
 3724              	.L495:
2563:lib/ff/ff.c   **** 	if (fp->fptr + btw < fp->fptr) btw = 0;    /* File size cannot reach 4GB */
 3725              		.loc 1 2563 0
 3726 0186 0725     		movs	r5, #7
 3727              	.LVL546:
 3728              	.L469:
2652:lib/ff/ff.c   **** 
 3729              		.loc 1 2652 0
 3730 0188 2846     		mov	r0, r5
 3731 018a BDE8FE8F 		pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3732              		.cfi_endproc
 3733              	.LFE31:
 3735              		.section	.text.f_sync,"ax",%progbits
 3736              		.align	1
 3737              		.global	f_sync
 3738              		.thumb
 3739              		.thumb_func
 3741              	f_sync:
 3742              	.LFB32:
2664:lib/ff/ff.c   **** 	FRESULT res;
 3743              		.loc 1 2664 0
 3744              		.cfi_startproc
 3745              		@ args = 0, pretend = 0, frame = 0
 3746              		@ frame_needed = 0, uses_anonymous_args = 0
 3747              	.LVL547:
 3748 0000 70B5     		push	{r4, r5, r6, lr}
 3749              	.LCFI23:
 3750              		.cfi_def_cfa_offset 16
 3751              		.cfi_offset 4, -16
 3752              		.cfi_offset 5, -12
 3753              		.cfi_offset 6, -8
 3754              		.cfi_offset 14, -4
 3755 0002 0446     		mov	r4, r0
2670:lib/ff/ff.c   **** 	if (res == FR_OK) {
 3756              		.loc 1 2670 0
 3757 0004 FFF7FEFF 		bl	validate
 3758              	.LVL548:
2671:lib/ff/ff.c   **** 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 3759              		.loc 1 2671 0
 3760 0008 0028     		cmp	r0, #0
 3761 000a 27D1     		bne	.L504
2672:lib/ff/ff.c   **** #if !_FS_TINY	/* Write-back dirty buffer */
 3762              		.loc 1 2672 0
 3763 000c A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3764 000e 03F02001 		and	r1, r3, #32
 3765 0012 CAB2     		uxtb	r2, r1
 3766 0014 002A     		cmp	r2, #0
 3767 0016 21D0     		beq	.L504
2681:lib/ff/ff.c   **** 			if (res == FR_OK) {
 3768              		.loc 1 2681 0
 3769 0018 2068     		ldr	r0, [r4, #0]
 3770              	.LVL549:
 3771 001a E169     		ldr	r1, [r4, #28]
 3772 001c FFF7FEFF 		bl	move_window
 3773              	.LVL550:
 3774 0020 0646     		mov	r6, r0
 3775              	.LVL551:
2682:lib/ff/ff.c   **** 				dir = fp->dir_ptr;
 3776              		.loc 1 2682 0
 3777 0022 DEB9     		cbnz	r6, .L504
2683:lib/ff/ff.c   **** 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 3778              		.loc 1 2683 0
 3779 0024 256A     		ldr	r5, [r4, #32]
 3780              	.LVL552:
2684:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 3781              		.loc 1 2684 0
 3782 0026 E87A     		ldrb	r0, [r5, #11]	@ zero_extendqisi2
 3783              	.LVL553:
 3784 0028 40F02003 		orr	r3, r0, #32
 3785 002c EB72     		strb	r3, [r5, #11]
2685:lib/ff/ff.c   **** 				st_clust(dir, fp->sclust);					/* Update start cluster */
 3786              		.loc 1 2685 0
 3787 002e E168     		ldr	r1, [r4, #12]
 3788 0030 E961     		str	r1, [r5, #28]
2686:lib/ff/ff.c   **** 				tm = get_fattime();							/* Update updated time */
 3789              		.loc 1 2686 0
 3790 0032 2269     		ldr	r2, [r4, #16]
 3791              	.LVL554:
 3792              	.LBB94:
 3793              	.LBB95:
1262:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 3794              		.loc 1 1262 0
 3795 0034 6A83     		strh	r2, [r5, #26]	@ movhi
1263:lib/ff/ff.c   **** }
 3796              		.loc 1 1263 0
 3797 0036 100C     		lsrs	r0, r2, #16
 3798 0038 A882     		strh	r0, [r5, #20]	@ movhi
 3799              	.LBE95:
 3800              	.LBE94:
2687:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tm);
 3801              		.loc 1 2687 0
 3802 003a FFF7FEFF 		bl	get_fattime
 3803              	.LVL555:
2688:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_LstAccDate, 0);
 3804              		.loc 1 2688 0
 3805 003e C5F81600 		str	r0, [r5, #22]
2689:lib/ff/ff.c   **** 				fp->flag &= ~FA__WRITTEN;
 3806              		.loc 1 2689 0
 3807 0042 6E82     		strh	r6, [r5, #18]	@ movhi
2690:lib/ff/ff.c   **** 				fp->fs->wflag = 1;
 3808              		.loc 1 2690 0
 3809 0044 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3810 0046 23F02001 		bic	r1, r3, #32
 3811 004a A171     		strb	r1, [r4, #6]
2691:lib/ff/ff.c   **** 				res = sync_fs(fp->fs);
 3812              		.loc 1 2691 0
 3813 004c 2068     		ldr	r0, [r4, #0]
 3814              	.LVL556:
 3815 004e 0122     		movs	r2, #1
 3816 0050 0271     		strb	r2, [r0, #4]
2692:lib/ff/ff.c   **** 			}
 3817              		.loc 1 2692 0
 3818 0052 2068     		ldr	r0, [r4, #0]
2698:lib/ff/ff.c   **** 
 3819              		.loc 1 2698 0
 3820 0054 BDE87040 		pop	{r4, r5, r6, lr}
2692:lib/ff/ff.c   **** 			}
 3821              		.loc 1 2692 0
 3822 0058 FFF7FEBF 		b	sync_fs
 3823              	.LVL557:
 3824              	.L504:
2698:lib/ff/ff.c   **** 
 3825              		.loc 1 2698 0
 3826 005c 70BD     		pop	{r4, r5, r6, pc}
 3827              		.cfi_endproc
 3828              	.LFE32:
 3830              		.section	.text.f_close,"ax",%progbits
 3831              		.align	1
 3832              		.global	f_close
 3833              		.thumb
 3834              		.thumb_func
 3836              	f_close:
 3837              	.LFB33:
2712:lib/ff/ff.c   **** 	FRESULT res;
 3838              		.loc 1 2712 0
 3839              		.cfi_startproc
 3840              		@ args = 0, pretend = 0, frame = 0
 3841              		@ frame_needed = 0, uses_anonymous_args = 0
 3842              	.LVL558:
 3843 0000 10B5     		push	{r4, lr}
 3844              	.LCFI24:
 3845              		.cfi_def_cfa_offset 8
 3846              		.cfi_offset 4, -8
 3847              		.cfi_offset 14, -4
 3848 0002 0446     		mov	r4, r0
2726:lib/ff/ff.c   **** #if _FS_LOCK
 3849              		.loc 1 2726 0
 3850 0004 FFF7FEFF 		bl	f_sync
 3851              	.LVL559:
2741:lib/ff/ff.c   **** 	return res;
 3852              		.loc 1 2741 0
 3853 0008 00B9     		cbnz	r0, .L509
2741:lib/ff/ff.c   **** 	return res;
 3854              		.loc 1 2741 0 is_stmt 0 discriminator 1
 3855 000a 2060     		str	r0, [r4, #0]
 3856              	.L509:
2744:lib/ff/ff.c   **** 
 3857              		.loc 1 2744 0 is_stmt 1
 3858 000c 10BD     		pop	{r4, pc}
 3859              		.cfi_endproc
 3860              	.LFE33:
 3862              		.section	.text.f_chdrive,"ax",%progbits
 3863              		.align	1
 3864              		.global	f_chdrive
 3865              		.thumb
 3866              		.thumb_func
 3868              	f_chdrive:
 3869              	.LFB34:
2758:lib/ff/ff.c   **** 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
 3870              		.loc 1 2758 0
 3871              		.cfi_startproc
 3872              		@ args = 0, pretend = 0, frame = 0
 3873              		@ frame_needed = 0, uses_anonymous_args = 0
 3874              		@ link register save eliminated.
 3875              	.LVL560:
2759:lib/ff/ff.c   **** 
 3876              		.loc 1 2759 0
 3877 0000 10B9     		cbnz	r0, .L512
2761:lib/ff/ff.c   **** 
 3878              		.loc 1 2761 0
 3879 0002 024B     		ldr	r3, .L513
 3880 0004 1870     		strb	r0, [r3, #0]
2763:lib/ff/ff.c   **** }
 3881              		.loc 1 2763 0
 3882 0006 7047     		bx	lr
 3883              	.L512:
2759:lib/ff/ff.c   **** 
 3884              		.loc 1 2759 0
 3885 0008 0B20     		movs	r0, #11
 3886              	.LVL561:
2764:lib/ff/ff.c   **** 
 3887              		.loc 1 2764 0
 3888 000a 7047     		bx	lr
 3889              	.L514:
 3890              		.align	2
 3891              	.L513:
 3892 000c 00000000 		.word	.LANCHOR0
 3893              		.cfi_endproc
 3894              	.LFE34:
 3896              		.section	.text.f_chdir,"ax",%progbits
 3897              		.align	1
 3898              		.global	f_chdir
 3899              		.thumb
 3900              		.thumb_func
 3902              	f_chdir:
 3903              	.LFB35:
2771:lib/ff/ff.c   **** 	FRESULT res;
 3904              		.loc 1 2771 0
 3905              		.cfi_startproc
 3906              		@ args = 0, pretend = 0, frame = 48
 3907              		@ frame_needed = 0, uses_anonymous_args = 0
 3908              	.LVL562:
 3909 0000 10B5     		push	{r4, lr}
 3910              	.LCFI25:
 3911              		.cfi_def_cfa_offset 8
 3912              		.cfi_offset 4, -8
 3913              		.cfi_offset 14, -4
 3914 0002 8CB0     		sub	sp, sp, #48
 3915              	.LCFI26:
 3916              		.cfi_def_cfa_offset 56
 3917 0004 0CAB     		add	r3, sp, #48
 3918 0006 43F82C0D 		str	r0, [r3, #-44]!
2777:lib/ff/ff.c   **** 	if (res == FR_OK) {
 3919              		.loc 1 2777 0
 3920 000a 1846     		mov	r0, r3
 3921              	.LVL563:
 3922 000c 05A9     		add	r1, sp, #20
 3923 000e 0022     		movs	r2, #0
 3924 0010 FFF7FEFF 		bl	chk_mounted
 3925              	.LVL564:
2778:lib/ff/ff.c   **** 		INIT_BUF(dj);
 3926              		.loc 1 2778 0
 3927 0014 00BB     		cbnz	r0, .L524
2779:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the path */
 3928              		.loc 1 2779 0
 3929 0016 02A8     		add	r0, sp, #8
 3930              	.LVL565:
 3931 0018 0B90     		str	r0, [sp, #44]
2780:lib/ff/ff.c   **** 		FREE_BUF();
 3932              		.loc 1 2780 0
 3933 001a 05A8     		add	r0, sp, #20
 3934              	.LVL566:
 3935 001c 0199     		ldr	r1, [sp, #4]
 3936 001e FFF7FEFF 		bl	follow_path
 3937              	.LVL567:
2782:lib/ff/ff.c   **** 			if (!dj.dir) {
 3938              		.loc 1 2782 0
 3939 0022 A0B9     		cbnz	r0, .L517
2783:lib/ff/ff.c   **** 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
 3940              		.loc 1 2783 0
 3941 0024 0A9B     		ldr	r3, [sp, #40]
 3942 0026 1BB9     		cbnz	r3, .L518
2784:lib/ff/ff.c   **** 			} else {
 3943              		.loc 1 2784 0
 3944 0028 0799     		ldr	r1, [sp, #28]
 3945 002a 059B     		ldr	r3, [sp, #20]
 3946 002c 9961     		str	r1, [r3, #24]
 3947 002e 13E0     		b	.L524
 3948              	.L518:
2786:lib/ff/ff.c   **** 					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
 3949              		.loc 1 2786 0
 3950 0030 DA7A     		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 3951 0032 02F01001 		and	r1, r2, #16
 3952 0036 CAB2     		uxtb	r2, r1
 3953 0038 6AB1     		cbz	r2, .L522
2787:lib/ff/ff.c   **** 				else
 3954              		.loc 1 2787 0
 3955 003a 0599     		ldr	r1, [sp, #20]
 3956              	.LVL568:
 3957              	.LBB98:
 3958              	.LBB99:
1247:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 3959              		.loc 1 1247 0
 3960 003c 5A8B     		ldrh	r2, [r3, #26]
 3961              	.LVL569:
1248:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 3962              		.loc 1 1248 0
 3963 003e 0C78     		ldrb	r4, [r1, #0]	@ zero_extendqisi2
 3964 0040 032C     		cmp	r4, #3
1249:lib/ff/ff.c   **** 
 3965              		.loc 1 1249 0
 3966 0042 04BF     		itt	eq
 3967 0044 9B8A     		ldrheq	r3, [r3, #20]
 3968              	.LVL570:
 3969 0046 42EA0342 		orreq	r2, r2, r3, lsl #16
 3970              	.LVL571:
 3971              	.LBE99:
 3972              	.LBE98:
2787:lib/ff/ff.c   **** 				else
 3973              		.loc 1 2787 0
 3974 004a 8A61     		str	r2, [r1, #24]
 3975 004c 04E0     		b	.L524
 3976              	.LVL572:
 3977              	.L517:
2792:lib/ff/ff.c   **** 	}
 3978              		.loc 1 2792 0
 3979 004e 0428     		cmp	r0, #4
 3980 0050 08BF     		it	eq
 3981 0052 0520     		moveq	r0, #5
 3982              	.LVL573:
 3983 0054 00E0     		b	.L524
 3984              	.LVL574:
 3985              	.L522:
2789:lib/ff/ff.c   **** 			}
 3986              		.loc 1 2789 0
 3987 0056 0520     		movs	r0, #5
 3988              	.LVL575:
 3989              	.L524:
2796:lib/ff/ff.c   **** 
 3990              		.loc 1 2796 0
 3991 0058 0CB0     		add	sp, sp, #48
 3992 005a 10BD     		pop	{r4, pc}
 3993              		.cfi_endproc
 3994              	.LFE35:
 3996              		.section	.text.f_getcwd,"ax",%progbits
 3997              		.align	1
 3998              		.global	f_getcwd
 3999              		.thumb
 4000              		.thumb_func
 4002              	f_getcwd:
 4003              	.LFB36:
2804:lib/ff/ff.c   **** 	FRESULT res;
 4004              		.loc 1 2804 0
 4005              		.cfi_startproc
 4006              		@ args = 0, pretend = 0, frame = 72
 4007              		@ frame_needed = 0, uses_anonymous_args = 0
 4008              	.LVL576:
 4009 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 4010              	.LCFI27:
 4011              		.cfi_def_cfa_offset 20
 4012              		.cfi_offset 4, -20
 4013              		.cfi_offset 5, -16
 4014              		.cfi_offset 6, -12
 4015              		.cfi_offset 7, -8
 4016              		.cfi_offset 14, -4
 4017 0002 93B0     		sub	sp, sp, #76
 4018              	.LCFI28:
 4019              		.cfi_def_cfa_offset 96
 4020 0004 12AB     		add	r3, sp, #72
 4021 0006 43F8440D 		str	r0, [r3, #-68]!
 4022 000a 0E46     		mov	r6, r1
2814:lib/ff/ff.c   **** 	res = chk_mounted((const TCHAR**)&buff, &dj.fs, 0);	/* Get current volume */
 4023              		.loc 1 2814 0
 4024 000c 0022     		movs	r2, #0
 4025 000e 0270     		strb	r2, [r0, #0]
 4026              	.LVL577:
2815:lib/ff/ff.c   **** 	if (res == FR_OK) {
 4027              		.loc 1 2815 0
 4028 0010 1846     		mov	r0, r3
 4029 0012 0BA9     		add	r1, sp, #44
 4030              	.LVL578:
 4031 0014 FFF7FEFF 		bl	chk_mounted
 4032              	.LVL579:
2816:lib/ff/ff.c   **** 		INIT_BUF(dj);
 4033              		.loc 1 2816 0
 4034 0018 0546     		mov	r5, r0
 4035 001a 0028     		cmp	r0, #0
 4036 001c 7FD1     		bne	.L526
2817:lib/ff/ff.c   **** 		i = len;			/* Bottom of buffer (dir stack base) */
 4037              		.loc 1 2817 0
 4038 001e 02A8     		add	r0, sp, #8
 4039              	.LVL580:
 4040 0020 1190     		str	r0, [sp, #68]
 4041              	.LVL581:
2819:lib/ff/ff.c   **** 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
 4042              		.loc 1 2819 0
 4043 0022 0B99     		ldr	r1, [sp, #44]
 4044 0024 8A69     		ldr	r2, [r1, #24]
 4045 0026 0D92     		str	r2, [sp, #52]
2820:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 1);			/* Get parent dir */
 4046              		.loc 1 2820 0
 4047 0028 3446     		mov	r4, r6
 4048              	.LVL582:
 4049              	.L527:
2820:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 1);			/* Get parent dir */
 4050              		.loc 1 2820 0 is_stmt 0 discriminator 1
 4051 002a 0D9F     		ldr	r7, [sp, #52]
 4052              	.LVL583:
 4053 002c 002F     		cmp	r7, #0
 4054 002e 5DD0     		beq	.L528
 4055              	.L538:
2821:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 4056              		.loc 1 2821 0 is_stmt 1
 4057 0030 0BA8     		add	r0, sp, #44
 4058 0032 0121     		movs	r1, #1
 4059 0034 FFF7FEFF 		bl	dir_sdi
 4060              	.LVL584:
2822:lib/ff/ff.c   **** 			res = dir_read(&dj, 0);
 4061              		.loc 1 2822 0
 4062 0038 0146     		mov	r1, r0
 4063 003a 0028     		cmp	r0, #0
 4064 003c 51D1     		bne	.L542
2823:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 4065              		.loc 1 2823 0
 4066 003e 0BA8     		add	r0, sp, #44
 4067              	.LVL585:
 4068 0040 FFF7FEFF 		bl	dir_read
 4069              	.LVL586:
2824:lib/ff/ff.c   **** 			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
 4070              		.loc 1 2824 0
 4071 0044 0028     		cmp	r0, #0
 4072 0046 4ED1     		bne	.L544
2825:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 0);
 4073              		.loc 1 2825 0
 4074 0048 1098     		ldr	r0, [sp, #64]
 4075              	.LVL587:
 4076              	.LBB104:
 4077              	.LBB105:
1247:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 4078              		.loc 1 1247 0
 4079 004a 438B     		ldrh	r3, [r0, #26]
 4080              	.LVL588:
 4081              		.loc 1 4323 0
 4082 004c 0B99     		ldr	r1, [sp, #44]
1248:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 4083              		.loc 1 1248 0
 4084 004e 0A78     		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 4085 0050 032A     		cmp	r2, #3
1249:lib/ff/ff.c   **** 
 4086              		.loc 1 1249 0
 4087 0052 04BF     		itt	eq
 4088 0054 808A     		ldrheq	r0, [r0, #20]
 4089              	.LVL589:
 4090 0056 43EA0043 		orreq	r3, r3, r0, lsl #16
 4091              	.LVL590:
 4092              	.LBE105:
 4093              	.LBE104:
2825:lib/ff/ff.c   **** 			res = dir_sdi(&dj, 0);
 4094              		.loc 1 2825 0
 4095 005a 0D93     		str	r3, [sp, #52]
2826:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 4096              		.loc 1 2826 0
 4097 005c 0BA8     		add	r0, sp, #44
 4098 005e 0021     		movs	r1, #0
 4099 0060 FFF7FEFF 		bl	dir_sdi
 4100              	.LVL591:
2827:lib/ff/ff.c   **** 			do {							/* Find the entry links to the child dir */
 4101              		.loc 1 2827 0
 4102 0064 0028     		cmp	r0, #0
 4103 0066 3ED1     		bne	.L544
 4104              	.L549:
2829:lib/ff/ff.c   **** 				if (res != FR_OK) break;
 4105              		.loc 1 2829 0
 4106 0068 0BA8     		add	r0, sp, #44
 4107              	.LVL592:
 4108 006a 0021     		movs	r1, #0
 4109 006c FFF7FEFF 		bl	dir_read
 4110              	.LVL593:
2830:lib/ff/ff.c   **** 				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
 4111              		.loc 1 2830 0
 4112 0070 A8B9     		cbnz	r0, .L530
2831:lib/ff/ff.c   **** 				res = dir_next(&dj, 0);	
 4113              		.loc 1 2831 0
 4114 0072 1098     		ldr	r0, [sp, #64]
 4115              	.LVL594:
 4116              	.LBB106:
 4117              	.LBB107:
1247:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 4118              		.loc 1 1247 0
 4119 0074 438B     		ldrh	r3, [r0, #26]
 4120              	.LVL595:
 4121              		.loc 1 4323 0
 4122 0076 0B99     		ldr	r1, [sp, #44]
1248:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 4123              		.loc 1 1248 0
 4124 0078 0A78     		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 4125 007a 032A     		cmp	r2, #3
1249:lib/ff/ff.c   **** 
 4126              		.loc 1 1249 0
 4127 007c 04BF     		itt	eq
 4128 007e 808A     		ldrheq	r0, [r0, #20]
 4129              	.LVL596:
 4130 0080 43EA0043 		orreq	r3, r3, r0, lsl #16
 4131              	.LVL597:
 4132              	.LBE107:
 4133              	.LBE106:
2840:lib/ff/ff.c   **** 			tp = fno.fname;
 4134              		.loc 1 2840 0
 4135 0084 0BA8     		add	r0, sp, #44
2831:lib/ff/ff.c   **** 				res = dir_next(&dj, 0);	
 4136              		.loc 1 2831 0
 4137 0086 9F42     		cmp	r7, r3
 4138 0088 04D1     		bne	.L532
2840:lib/ff/ff.c   **** 			tp = fno.fname;
 4139              		.loc 1 2840 0
 4140 008a 05A9     		add	r1, sp, #20
 4141 008c FFF7FEFF 		bl	get_fileinfo
 4142              	.LVL598:
2843:lib/ff/ff.c   **** 			if (i < n + 3) {
 4143              		.loc 1 2843 0
 4144 0090 0023     		movs	r3, #0
 4145 0092 09E0     		b	.L533
 4146              	.LVL599:
 4147              	.L532:
2832:lib/ff/ff.c   **** 			} while (res == FR_OK);
 4148              		.loc 1 2832 0
 4149 0094 0021     		movs	r1, #0
 4150 0096 FFF7FEFF 		bl	dir_next
 4151              	.LVL600:
2833:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
 4152              		.loc 1 2833 0
 4153 009a 0028     		cmp	r0, #0
 4154 009c E4D0     		beq	.L549
 4155              	.L530:
2834:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 4156              		.loc 1 2834 0
 4157 009e 0428     		cmp	r0, #4
 4158 00a0 14BF     		ite	ne
 4159 00a2 0546     		movne	r5, r0
 4160 00a4 0225     		moveq	r5, #2
 4161 00a6 21E0     		b	.L528
 4162              	.LVL601:
 4163              	.L533:
2800:lib/ff/ff.c   **** 	TCHAR *buff,	/* Pointer to the directory path */
 4164              		.loc 1 2800 0 discriminator 1
 4165 00a8 05A8     		add	r0, sp, #20
 4166 00aa C118     		adds	r1, r0, r3
2843:lib/ff/ff.c   **** 			if (i < n + 3) {
 4167              		.loc 1 2843 0 discriminator 1
 4168 00ac 91F90920 		ldrsb	r2, [r1, #9]
 4169 00b0 0AB1     		cbz	r2, .L554
 4170              	.L535:
2843:lib/ff/ff.c   **** 			if (i < n + 3) {
 4171              		.loc 1 2843 0 is_stmt 0 discriminator 2
 4172 00b2 0133     		adds	r3, r3, #1
 4173              	.LVL602:
 4174 00b4 F8E7     		b	.L533
 4175              	.L554:
2843:lib/ff/ff.c   **** 			if (i < n + 3) {
 4176              		.loc 1 2843 0
 4177 00b6 1A46     		mov	r2, r3
2844:lib/ff/ff.c   **** 				res = FR_NOT_ENOUGH_CORE; break;
 4178              		.loc 1 2844 0 is_stmt 1
 4179 00b8 D81C     		adds	r0, r3, #3
 4180 00ba 8442     		cmp	r4, r0
 4181 00bc 15D3     		bcc	.L555
 4182              	.LVL603:
 4183              	.L553:
2847:lib/ff/ff.c   **** 			buff[--i] = '/';
 4184              		.loc 1 2847 0 discriminator 1
 4185 00be 13F1FF33 		adds	r3, r3, #-1
 4186 00c2 08D3     		bcc	.L556
 4187              	.L537:
 4188              	.LVL604:
2847:lib/ff/ff.c   **** 			buff[--i] = '/';
 4189              		.loc 1 2847 0 is_stmt 0 discriminator 2
 4190 00c4 12A8     		add	r0, sp, #72
 4191 00c6 C718     		adds	r7, r0, r3
 4192 00c8 17F82B7C 		ldrb	r7, [r7, #-43]	@ zero_extendqisi2
2800:lib/ff/ff.c   **** 	TCHAR *buff,	/* Pointer to the directory path */
 4193              		.loc 1 2800 0 is_stmt 1 discriminator 2
 4194 00cc E118     		adds	r1, r4, r3
 4195 00ce 881A     		subs	r0, r1, r2
 4196              	.LVL605:
2847:lib/ff/ff.c   **** 			buff[--i] = '/';
 4197              		.loc 1 2847 0 discriminator 2
 4198 00d0 0199     		ldr	r1, [sp, #4]
 4199 00d2 0F54     		strb	r7, [r1, r0]
 4200 00d4 F3E7     		b	.L553
 4201              	.LVL606:
 4202              	.L556:
 4203 00d6 D743     		mvns	r7, r2
2848:lib/ff/ff.c   **** 		}
 4204              		.loc 1 2848 0
 4205 00d8 E419     		adds	r4, r4, r7
 4206              	.LVL607:
 4207 00da 2F21     		movs	r1, #47
 4208 00dc 019A     		ldr	r2, [sp, #4]
 4209 00de 1155     		strb	r1, [r2, r4]
 4210 00e0 A3E7     		b	.L527
 4211              	.LVL608:
 4212              	.L542:
2821:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 4213              		.loc 1 2821 0
 4214 00e2 0546     		mov	r5, r0
 4215 00e4 02E0     		b	.L528
 4216              	.L544:
2826:lib/ff/ff.c   **** 			if (res != FR_OK) break;
 4217              		.loc 1 2826 0
 4218 00e6 0546     		mov	r5, r0
 4219 00e8 00E0     		b	.L528
 4220              	.LVL609:
 4221              	.L555:
2845:lib/ff/ff.c   **** 			}
 4222              		.loc 1 2845 0
 4223 00ea 1125     		movs	r5, #17
 4224              	.LVL610:
 4225              	.L528:
2850:lib/ff/ff.c   **** 		if (res == FR_OK) {
 4226              		.loc 1 2850 0
 4227 00ec 019B     		ldr	r3, [sp, #4]
 4228              	.LVL611:
2851:lib/ff/ff.c   **** 			*tp++ = '0' + CurrVol;			/* Put drive number */
 4229              		.loc 1 2851 0
 4230 00ee A5B9     		cbnz	r5, .L539
2852:lib/ff/ff.c   **** 			*tp++ = ':';
 4231              		.loc 1 2852 0
 4232 00f0 0C4A     		ldr	r2, .L557
 4233 00f2 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 4234 00f4 3030     		adds	r0, r0, #48
 4235 00f6 1870     		strb	r0, [r3, #0]
 4236              	.LVL612:
2853:lib/ff/ff.c   **** 			if (i == len) {					/* Root-dir */
 4237              		.loc 1 2853 0
 4238 00f8 3A21     		movs	r1, #58
 4239 00fa 5970     		strb	r1, [r3, #1]
 4240              	.LVL613:
2854:lib/ff/ff.c   **** 				*tp++ = '/';
 4241              		.loc 1 2854 0
 4242 00fc B442     		cmp	r4, r6
 4243 00fe 03D1     		bne	.L540
2855:lib/ff/ff.c   **** 			} else {						/* Sub-dir */
 4244              		.loc 1 2855 0
 4245 0100 2F21     		movs	r1, #47
 4246 0102 9970     		strb	r1, [r3, #2]
 4247 0104 0333     		adds	r3, r3, #3
 4248              	.LVL614:
 4249 0106 08E0     		b	.L539
 4250              	.LVL615:
 4251              	.L540:
2853:lib/ff/ff.c   **** 			if (i == len) {					/* Root-dir */
 4252              		.loc 1 2853 0
 4253 0108 9A1C     		adds	r2, r3, #2
 4254              	.LVL616:
 4255              	.L541:
2858:lib/ff/ff.c   **** 				while (i < len);
 4256              		.loc 1 2858 0 discriminator 1
 4257 010a 019B     		ldr	r3, [sp, #4]
 4258              	.LVL617:
 4259 010c 185D     		ldrb	r0, [r3, r4]	@ zero_extendqisi2
 4260 010e 02F8010B 		strb	r0, [r2], #1
 4261 0112 1346     		mov	r3, r2
 4262              	.LVL618:
 4263 0114 0134     		adds	r4, r4, #1
 4264              	.LVL619:
2859:lib/ff/ff.c   **** 			}
 4265              		.loc 1 2859 0 discriminator 1
 4266 0116 B442     		cmp	r4, r6
 4267 0118 F7D3     		bcc	.L541
 4268              	.LVL620:
 4269              	.L539:
2862:lib/ff/ff.c   **** 		FREE_BUF();
 4270              		.loc 1 2862 0
 4271 011a 0022     		movs	r2, #0
 4272 011c 1A70     		strb	r2, [r3, #0]
 4273              	.LVL621:
 4274              	.L526:
2867:lib/ff/ff.c   **** #endif /* _FS_RPATH >= 2 */
 4275              		.loc 1 2867 0
 4276 011e 2846     		mov	r0, r5
 4277 0120 13B0     		add	sp, sp, #76
 4278 0122 F0BD     		pop	{r4, r5, r6, r7, pc}
 4279              	.L558:
 4280              		.align	2
 4281              	.L557:
 4282 0124 00000000 		.word	.LANCHOR0
 4283              		.cfi_endproc
 4284              	.LFE36:
 4286              		.section	.text.f_lseek,"ax",%progbits
 4287              		.align	1
 4288              		.global	f_lseek
 4289              		.thumb
 4290              		.thumb_func
 4292              	f_lseek:
 4293              	.LFB37:
2882:lib/ff/ff.c   **** 	FRESULT res;
 4294              		.loc 1 2882 0
 4295              		.cfi_startproc
 4296              		@ args = 0, pretend = 0, frame = 0
 4297              		@ frame_needed = 0, uses_anonymous_args = 0
 4298              	.LVL622:
 4299 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4300              	.LCFI29:
 4301              		.cfi_def_cfa_offset 40
 4302              		.cfi_offset 3, -40
 4303              		.cfi_offset 4, -36
 4304              		.cfi_offset 5, -32
 4305              		.cfi_offset 6, -28
 4306              		.cfi_offset 7, -24
 4307              		.cfi_offset 8, -20
 4308              		.cfi_offset 9, -16
 4309              		.cfi_offset 10, -12
 4310              		.cfi_offset 11, -8
 4311              		.cfi_offset 14, -4
 4312 0004 0446     		mov	r4, r0
 4313 0006 0D46     		mov	r5, r1
2886:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 4314              		.loc 1 2886 0
 4315 0008 FFF7FEFF 		bl	validate
 4316              	.LVL623:
2887:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)			/* Check abort flag */
 4317              		.loc 1 2887 0
 4318 000c 0646     		mov	r6, r0
 4319 000e 0028     		cmp	r0, #0
 4320 0010 40F0DA80 		bne	.L560
2888:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 4321              		.loc 1 2888 0
 4322 0014 A779     		ldrb	r7, [r4, #6]	@ zero_extendqisi2
 4323 0016 3806     		lsls	r0, r7, #24
 4324              	.LVL624:
 4325 0018 00F1D380 		bmi	.L591
2892:lib/ff/ff.c   **** 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
 4326              		.loc 1 2892 0
 4327 001c 636A     		ldr	r3, [r4, #36]
 4328 001e 002B     		cmp	r3, #0
 4329 0020 5CD0     		beq	.L561
 4330              	.LBB108:
2895:lib/ff/ff.c   **** 			tbl = fp->cltbl;
 4331              		.loc 1 2895 0
 4332 0022 691C     		adds	r1, r5, #1
 4333 0024 32D1     		bne	.L562
 4334              	.LVL625:
2897:lib/ff/ff.c   **** 			cl = fp->sclust;			/* Top of the chain */
 4335              		.loc 1 2897 0
 4336 0026 1D46     		mov	r5, r3
 4337              	.LVL626:
 4338 0028 55F804BB 		ldr	fp, [r5], #4
 4339              	.LVL627:
2898:lib/ff/ff.c   **** 			if (cl) {
 4340              		.loc 1 2898 0
 4341 002c D4F81080 		ldr	r8, [r4, #16]
 4342              	.LVL628:
2899:lib/ff/ff.c   **** 				do {
 4343              		.loc 1 2899 0
 4344 0030 0227     		movs	r7, #2
 4345 0032 B8F1000F 		cmp	r8, #0
 4346 0036 21D0     		beq	.L563
 4347              	.LVL629:
 4348              	.L568:
2905:lib/ff/ff.c   **** 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
 4349              		.loc 1 2905 0
 4350 0038 C146     		mov	r9, r8
2902:lib/ff/ff.c   **** 					do {
 4351              		.loc 1 2902 0
 4352 003a 4FF0000A 		mov	sl, #0
 4353              	.LVL630:
 4354              	.L566:
2904:lib/ff/ff.c   **** 						cl = get_fat(fp->fs, cl);
 4355              		.loc 1 2904 0
 4356 003e 0AF1010A 		add	sl, sl, #1
 4357              	.LVL631:
2905:lib/ff/ff.c   **** 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
 4358              		.loc 1 2905 0
 4359 0042 2068     		ldr	r0, [r4, #0]
 4360 0044 4946     		mov	r1, r9
 4361 0046 FFF7FEFF 		bl	get_fat
 4362              	.LVL632:
2906:lib/ff/ff.c   **** 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4363              		.loc 1 2906 0
 4364 004a 0128     		cmp	r0, #1
 4365 004c 40F2A280 		bls	.L615
 4366              	.L564:
2907:lib/ff/ff.c   **** 					} while (cl == pcl + 1);
 4367              		.loc 1 2907 0
 4368 0050 421C     		adds	r2, r0, #1
 4369 0052 00F08B80 		beq	.L614
 4370              	.L565:
2908:lib/ff/ff.c   **** 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 4371              		.loc 1 2908 0
 4372 0056 09F10102 		add	r2, r9, #1
 4373 005a 8146     		mov	r9, r0
 4374              	.LVL633:
 4375 005c 9042     		cmp	r0, r2
 4376 005e EED0     		beq	.L566
2902:lib/ff/ff.c   **** 					do {
 4377              		.loc 1 2902 0
 4378 0060 0237     		adds	r7, r7, #2
 4379              	.LVL634:
2909:lib/ff/ff.c   **** 						*tbl++ = ncl; *tbl++ = tcl;
 4380              		.loc 1 2909 0
 4381 0062 5F45     		cmp	r7, fp
 4382 0064 04D8     		bhi	.L567
2910:lib/ff/ff.c   **** 					}
 4383              		.loc 1 2910 0
 4384 0066 C5F800A0 		str	sl, [r5, #0]
 4385              	.LVL635:
 4386 006a C5F80480 		str	r8, [r5, #4]
 4387 006e 0835     		adds	r5, r5, #8
 4388              	.LVL636:
 4389              	.L567:
2912:lib/ff/ff.c   **** 			}
 4390              		.loc 1 2912 0
 4391 0070 2168     		ldr	r1, [r4, #0]
 4392 0072 CB69     		ldr	r3, [r1, #28]
 4393 0074 9842     		cmp	r0, r3
 4394 0076 01D2     		bcs	.L563
 4395              	.L593:
2905:lib/ff/ff.c   **** 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
 4396              		.loc 1 2905 0
 4397 0078 8046     		mov	r8, r0
 4398              	.LVL637:
 4399 007a DDE7     		b	.L568
 4400              	.LVL638:
 4401              	.L563:
2914:lib/ff/ff.c   **** 			if (ulen <= tlen)
 4402              		.loc 1 2914 0
 4403 007c 606A     		ldr	r0, [r4, #36]
 4404 007e 0760     		str	r7, [r0, #0]
2915:lib/ff/ff.c   **** 				*tbl = 0;		/* Terminate table */
 4405              		.loc 1 2915 0
 4406 0080 5F45     		cmp	r7, fp
 4407 0082 00F2A080 		bhi	.L594
2916:lib/ff/ff.c   **** 			else
 4408              		.loc 1 2916 0
 4409 0086 0022     		movs	r2, #0
 4410 0088 2A60     		str	r2, [r5, #0]
 4411 008a 9DE0     		b	.L560
 4412              	.LVL639:
 4413              	.L562:
2921:lib/ff/ff.c   **** 				ofs = fp->fsize;
 4414              		.loc 1 2921 0
 4415 008c E068     		ldr	r0, [r4, #12]
 4416 008e 8542     		cmp	r5, r0
 4417 0090 28BF     		it	cs
 4418 0092 0546     		movcs	r5, r0
 4419              	.LVL640:
2923:lib/ff/ff.c   **** 			if (ofs) {
 4420              		.loc 1 2923 0
 4421 0094 A560     		str	r5, [r4, #8]
2924:lib/ff/ff.c   **** 				fp->clust = clmt_clust(fp, ofs - 1);
 4422              		.loc 1 2924 0
 4423 0096 002D     		cmp	r5, #0
 4424 0098 00F09680 		beq	.L560
2925:lib/ff/ff.c   **** 				dsc = clust2sect(fp->fs, fp->clust);
 4425              		.loc 1 2925 0
 4426 009c 05F1FF38 		add	r8, r5, #-1
 4427 00a0 2046     		mov	r0, r4
 4428 00a2 4146     		mov	r1, r8
 4429 00a4 FFF7FEFF 		bl	clmt_clust
 4430              	.LVL641:
 4431 00a8 0146     		mov	r1, r0
 4432 00aa 6061     		str	r0, [r4, #20]
2926:lib/ff/ff.c   **** 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
 4433              		.loc 1 2926 0
 4434 00ac D4F80090 		ldr	r9, [r4, #0]
 4435 00b0 4846     		mov	r0, r9
 4436 00b2 FFF7FEFF 		bl	clust2sect
 4437              	.LVL642:
2927:lib/ff/ff.c   **** 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
 4438              		.loc 1 2927 0
 4439 00b6 18B9     		cbnz	r0, .L570
2927:lib/ff/ff.c   **** 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
 4440              		.loc 1 2927 0 is_stmt 0 discriminator 1
 4441 00b8 67F07F07 		orn	r7, r7, #127
 4442 00bc A771     		strb	r7, [r4, #6]
 4443 00be 80E0     		b	.L591
 4444              	.L570:
2928:lib/ff/ff.c   **** 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
 4445              		.loc 1 2928 0 is_stmt 1
 4446 00c0 99F80220 		ldrb	r2, [r9, #2]	@ zero_extendqisi2
 4447              	.LVL643:
2929:lib/ff/ff.c   **** #if !_FS_TINY
 4448              		.loc 1 2929 0
 4449 00c4 ED05     		lsls	r5, r5, #23
 4450              	.LVL644:
 4451 00c6 7FD0     		beq	.L560
2928:lib/ff/ff.c   **** 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
 4452              		.loc 1 2928 0 discriminator 1
 4453 00c8 551E     		subs	r5, r2, #1
 4454 00ca 05EA5828 		and	r8, r5, r8, lsr #9
 4455              	.LVL645:
 4456 00ce 00EB0801 		add	r1, r0, r8
2929:lib/ff/ff.c   **** #if !_FS_TINY
 4457              		.loc 1 2929 0 discriminator 1
 4458 00d2 A369     		ldr	r3, [r4, #24]
 4459 00d4 9942     		cmp	r1, r3
 4460 00d6 77D0     		beq	.L560
2941:lib/ff/ff.c   **** 				}
 4461              		.loc 1 2941 0
 4462 00d8 A161     		str	r1, [r4, #24]
 4463 00da 75E0     		b	.L560
 4464              	.LVL646:
 4465              	.L561:
 4466              	.LBE108:
 4467              	.LBB109:
2952:lib/ff/ff.c   **** #if !_FS_READONLY
 4468              		.loc 1 2952 0
 4469 00dc E068     		ldr	r0, [r4, #12]
 4470 00de 8542     		cmp	r5, r0
 4471 00e0 05D9     		bls	.L572
2954:lib/ff/ff.c   **** #endif
 4472              		.loc 1 2954 0
 4473 00e2 07F00207 		and	r7, r7, #2
 4474 00e6 FFB2     		uxtb	r7, r7
 4475 00e8 002F     		cmp	r7, #0
 4476 00ea 08BF     		it	eq
 4477 00ec 0546     		moveq	r5, r0
 4478              	.LVL647:
 4479              	.L572:
2958:lib/ff/ff.c   **** 		fp->fptr = nsect = 0;
 4480              		.loc 1 2958 0
 4481 00ee A168     		ldr	r1, [r4, #8]
 4482              	.LVL648:
2959:lib/ff/ff.c   **** 		if (ofs) {
 4483              		.loc 1 2959 0
 4484 00f0 0022     		movs	r2, #0
 4485 00f2 A260     		str	r2, [r4, #8]
2960:lib/ff/ff.c   **** 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 4486              		.loc 1 2960 0
 4487 00f4 0DB9     		cbnz	r5, .L573
 4488              	.LVL649:
 4489              	.L580:
2959:lib/ff/ff.c   **** 		if (ofs) {
 4490              		.loc 1 2959 0
 4491 00f6 0025     		movs	r5, #0
 4492              	.LVL650:
 4493 00f8 53E0     		b	.L574
 4494              	.LVL651:
 4495              	.L573:
2961:lib/ff/ff.c   **** 			if (ifptr > 0 &&
 4496              		.loc 1 2961 0
 4497 00fa 2068     		ldr	r0, [r4, #0]
 4498 00fc 8378     		ldrb	r3, [r0, #2]	@ zero_extendqisi2
 4499 00fe 5F02     		lsls	r7, r3, #9
 4500              	.LVL652:
2962:lib/ff/ff.c   **** 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 4501              		.loc 1 2962 0
 4502 0100 69B1     		cbz	r1, .L575
2963:lib/ff/ff.c   **** 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 4503              		.loc 1 2963 0 discriminator 1
 4504 0102 4B1E     		subs	r3, r1, #1
 4505 0104 691E     		subs	r1, r5, #1
 4506              	.LVL653:
 4507 0106 B1FBF7F1 		udiv	r1, r1, r7
 4508 010a B3FBF7F2 		udiv	r2, r3, r7
2962:lib/ff/ff.c   **** 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 4509              		.loc 1 2962 0 discriminator 1
 4510 010e 9142     		cmp	r1, r2
 4511 0110 05D3     		bcc	.L575
2964:lib/ff/ff.c   **** 				ofs -= fp->fptr;
 4512              		.loc 1 2964 0
 4513 0112 7842     		negs	r0, r7
 4514 0114 0340     		ands	r3, r3, r0
 4515 0116 A360     		str	r3, [r4, #8]
2965:lib/ff/ff.c   **** 				clst = fp->clust;
 4516              		.loc 1 2965 0
 4517 0118 ED1A     		subs	r5, r5, r3
 4518              	.LVL654:
2966:lib/ff/ff.c   **** 			} else {									/* When seek to back cluster, */
 4519              		.loc 1 2966 0
 4520 011a 6169     		ldr	r1, [r4, #20]
 4521              	.LVL655:
 4522 011c 0AE0     		b	.L576
 4523              	.LVL656:
 4524              	.L575:
2968:lib/ff/ff.c   **** #if !_FS_READONLY
 4525              		.loc 1 2968 0
 4526 011e 2169     		ldr	r1, [r4, #16]
 4527              	.LVL657:
2970:lib/ff/ff.c   **** 					clst = create_chain(fp->fs, 0);
 4528              		.loc 1 2970 0
 4529 0120 39B9     		cbnz	r1, .L577
2971:lib/ff/ff.c   **** 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 4530              		.loc 1 2971 0
 4531 0122 FFF7FEFF 		bl	create_chain
 4532              	.LVL658:
 4533 0126 0146     		mov	r1, r0
 4534              	.LVL659:
2972:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4535              		.loc 1 2972 0
 4536 0128 0128     		cmp	r0, #1
 4537 012a 33D0     		beq	.L615
 4538              	.L578:
2973:lib/ff/ff.c   **** 					fp->sclust = clst;
 4539              		.loc 1 2973 0
 4540 012c 431C     		adds	r3, r0, #1
 4541 012e 1DD0     		beq	.L614
 4542              	.L579:
2974:lib/ff/ff.c   **** 				}
 4543              		.loc 1 2974 0
 4544 0130 2061     		str	r0, [r4, #16]
 4545              	.LVL660:
 4546              	.L577:
2977:lib/ff/ff.c   **** 			}
 4547              		.loc 1 2977 0
 4548 0132 6161     		str	r1, [r4, #20]
 4549              	.L576:
2979:lib/ff/ff.c   **** 				while (ofs > bcs) {						/* Cluster following loop */
 4550              		.loc 1 2979 0
 4551 0134 0029     		cmp	r1, #0
 4552 0136 DED0     		beq	.L580
 4553 0138 0AE0     		b	.L613
 4554              	.L585:
2991:lib/ff/ff.c   **** 					fp->clust = clst;
 4555              		.loc 1 2991 0
 4556 013a 0129     		cmp	r1, #1
 4557 013c 2AD9     		bls	.L615
2991:lib/ff/ff.c   **** 					fp->clust = clst;
 4558              		.loc 1 2991 0 is_stmt 0 discriminator 2
 4559 013e 2068     		ldr	r0, [r4, #0]
 4560 0140 C269     		ldr	r2, [r0, #28]
 4561 0142 9142     		cmp	r1, r2
 4562 0144 26D2     		bcs	.L615
 4563              	.L587:
2992:lib/ff/ff.c   **** 					fp->fptr += bcs;
 4564              		.loc 1 2992 0 is_stmt 1
 4565 0146 6161     		str	r1, [r4, #20]
2993:lib/ff/ff.c   **** 					ofs -= bcs;
 4566              		.loc 1 2993 0
 4567 0148 A368     		ldr	r3, [r4, #8]
 4568 014a D819     		adds	r0, r3, r7
 4569 014c A060     		str	r0, [r4, #8]
2994:lib/ff/ff.c   **** 				}
 4570              		.loc 1 2994 0
 4571 014e ED1B     		subs	r5, r5, r7
 4572              	.LVL661:
 4573              	.L613:
2980:lib/ff/ff.c   **** #if !_FS_READONLY
 4574              		.loc 1 2980 0 discriminator 1
 4575 0150 BD42     		cmp	r5, r7
 4576 0152 16D9     		bls	.L583
 4577              	.L588:
2982:lib/ff/ff.c   **** 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 4578              		.loc 1 2982 0
 4579 0154 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4580 0156 03F00202 		and	r2, r3, #2
 4581 015a D3B2     		uxtb	r3, r2
2983:lib/ff/ff.c   **** 						if (clst == 0) {				/* When disk gets full, clip file size */
 4582              		.loc 1 2983 0
 4583 015c 2068     		ldr	r0, [r4, #0]
2982:lib/ff/ff.c   **** 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 4584              		.loc 1 2982 0
 4585 015e 5BB1     		cbz	r3, .L582
2983:lib/ff/ff.c   **** 						if (clst == 0) {				/* When disk gets full, clip file size */
 4586              		.loc 1 2983 0
 4587 0160 FFF7FEFF 		bl	create_chain
 4588              	.LVL662:
2984:lib/ff/ff.c   **** 							ofs = bcs; break;
 4589              		.loc 1 2984 0
 4590 0164 0146     		mov	r1, r0
 4591 0166 58B1     		cbz	r0, .L616
 4592              	.L584:
2990:lib/ff/ff.c   **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 4593              		.loc 1 2990 0
 4594 0168 481C     		adds	r0, r1, #1
 4595              	.LVL663:
 4596 016a E6D1     		bne	.L585
 4597              	.LVL664:
 4598              	.L614:
2990:lib/ff/ff.c   **** 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 4599              		.loc 1 2990 0 is_stmt 0 discriminator 1
 4600 016c A679     		ldrb	r6, [r4, #6]	@ zero_extendqisi2
 4601 016e 66F07F01 		orn	r1, r6, #127
 4602 0172 A171     		strb	r1, [r4, #6]
 4603 0174 0126     		movs	r6, #1
 4604 0176 27E0     		b	.L560
 4605              	.LVL665:
 4606              	.L582:
2989:lib/ff/ff.c   **** 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 4607              		.loc 1 2989 0 is_stmt 1
 4608 0178 FFF7FEFF 		bl	get_fat
 4609              	.LVL666:
 4610 017c 0146     		mov	r1, r0
 4611              	.LVL667:
 4612 017e F3E7     		b	.L584
 4613              	.L616:
2984:lib/ff/ff.c   **** 							ofs = bcs; break;
 4614              		.loc 1 2984 0
 4615 0180 3D46     		mov	r5, r7
 4616              	.LVL668:
 4617              	.L583:
2996:lib/ff/ff.c   **** 				if (ofs % SS(fp->fs)) {
 4618              		.loc 1 2996 0
 4619 0182 A268     		ldr	r2, [r4, #8]
 4620 0184 5319     		adds	r3, r2, r5
 4621 0186 A360     		str	r3, [r4, #8]
2997:lib/ff/ff.c   **** 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
 4622              		.loc 1 2997 0
 4623 0188 EA05     		lsls	r2, r5, #23
 4624 018a B4D0     		beq	.L580
2998:lib/ff/ff.c   **** 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 4625              		.loc 1 2998 0
 4626 018c 2068     		ldr	r0, [r4, #0]
 4627 018e FFF7FEFF 		bl	clust2sect
 4628              	.LVL669:
2999:lib/ff/ff.c   **** 					nsect += ofs / SS(fp->fs);
 4629              		.loc 1 2999 0
 4630 0192 20B9     		cbnz	r0, .L589
 4631              	.LVL670:
 4632              	.L615:
2999:lib/ff/ff.c   **** 					nsect += ofs / SS(fp->fs);
 4633              		.loc 1 2999 0 is_stmt 0 discriminator 1
 4634 0194 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4635 0196 63F07F00 		orn	r0, r3, #127
 4636 019a A071     		strb	r0, [r4, #6]
 4637 019c 11E0     		b	.L591
 4638              	.LVL671:
 4639              	.L589:
3000:lib/ff/ff.c   **** 				}
 4640              		.loc 1 3000 0 is_stmt 1
 4641 019e 00EB5525 		add	r5, r0, r5, lsr #9
 4642              	.LVL672:
 4643              	.L574:
3004:lib/ff/ff.c   **** #if !_FS_TINY
 4644              		.loc 1 3004 0
 4645 01a2 A168     		ldr	r1, [r4, #8]
 4646 01a4 CA05     		lsls	r2, r1, #23
 4647 01a6 03D0     		beq	.L590
3004:lib/ff/ff.c   **** #if !_FS_TINY
 4648              		.loc 1 3004 0 is_stmt 0 discriminator 1
 4649 01a8 A069     		ldr	r0, [r4, #24]
 4650 01aa 8542     		cmp	r5, r0
3016:lib/ff/ff.c   **** 		}
 4651              		.loc 1 3016 0 is_stmt 1 discriminator 1
 4652 01ac 18BF     		it	ne
 4653 01ae A561     		strne	r5, [r4, #24]
 4654              	.L590:
3019:lib/ff/ff.c   **** 			fp->fsize = fp->fptr;
 4655              		.loc 1 3019 0
 4656 01b0 E268     		ldr	r2, [r4, #12]
 4657 01b2 9142     		cmp	r1, r2
 4658 01b4 08D9     		bls	.L560
3020:lib/ff/ff.c   **** 			fp->flag |= FA__WRITTEN;
 4659              		.loc 1 3020 0
 4660 01b6 E160     		str	r1, [r4, #12]
3021:lib/ff/ff.c   **** 		}
 4661              		.loc 1 3021 0
 4662 01b8 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 4663 01ba 43F02001 		orr	r1, r3, #32
 4664 01be A171     		strb	r1, [r4, #6]
 4665 01c0 02E0     		b	.L560
 4666              	.LVL673:
 4667              	.L591:
 4668              	.LBE109:
2889:lib/ff/ff.c   **** 
 4669              		.loc 1 2889 0
 4670 01c2 0226     		movs	r6, #2
 4671 01c4 00E0     		b	.L560
 4672              	.LVL674:
 4673              	.L594:
 4674              	.LBB110:
2918:lib/ff/ff.c   **** 
 4675              		.loc 1 2918 0
 4676 01c6 1126     		movs	r6, #17
 4677              	.LVL675:
 4678              	.L560:
 4679              	.LBE110:
3027:lib/ff/ff.c   **** 
 4680              		.loc 1 3027 0
 4681 01c8 3046     		mov	r0, r6
 4682 01ca BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 4683              		.cfi_endproc
 4684              	.LFE37:
 4686              		.section	.text.f_opendir,"ax",%progbits
 4687              		.align	1
 4688              		.global	f_opendir
 4689              		.thumb
 4690              		.thumb_func
 4692              	f_opendir:
 4693              	.LFB38:
3040:lib/ff/ff.c   **** 	FRESULT res;
 4694              		.loc 1 3040 0
 4695              		.cfi_startproc
 4696              		@ args = 0, pretend = 0, frame = 24
 4697              		@ frame_needed = 0, uses_anonymous_args = 0
 4698              	.LVL676:
 4699 0000 30B5     		push	{r4, r5, lr}
 4700              	.LCFI30:
 4701              		.cfi_def_cfa_offset 12
 4702              		.cfi_offset 4, -12
 4703              		.cfi_offset 5, -8
 4704              		.cfi_offset 14, -4
 4705 0002 87B0     		sub	sp, sp, #28
 4706              	.LCFI31:
 4707              		.cfi_def_cfa_offset 40
 4708 0004 0191     		str	r1, [sp, #4]
3046:lib/ff/ff.c   **** 
 4709              		.loc 1 3046 0
 4710 0006 0446     		mov	r4, r0
 4711 0008 50B3     		cbz	r0, .L624
3048:lib/ff/ff.c   **** 	fs = dj->fs;
 4712              		.loc 1 3048 0
 4713 000a 01A8     		add	r0, sp, #4
 4714              	.LVL677:
 4715 000c 2146     		mov	r1, r4
 4716 000e 0022     		movs	r2, #0
 4717 0010 FFF7FEFF 		bl	chk_mounted
 4718              	.LVL678:
3049:lib/ff/ff.c   **** 	if (res == FR_OK) {
 4719              		.loc 1 3049 0
 4720 0014 2568     		ldr	r5, [r4, #0]
 4721              	.LVL679:
3050:lib/ff/ff.c   **** 		INIT_BUF(*dj);
 4722              		.loc 1 3050 0
 4723 0016 00BB     		cbnz	r0, .L619
3051:lib/ff/ff.c   **** 		res = follow_path(dj, path);			/* Follow the path to the directory */
 4724              		.loc 1 3051 0
 4725 0018 03AB     		add	r3, sp, #12
 4726 001a A361     		str	r3, [r4, #24]
3052:lib/ff/ff.c   **** 		FREE_BUF();
 4727              		.loc 1 3052 0
 4728 001c 2046     		mov	r0, r4
 4729              	.LVL680:
 4730 001e 0199     		ldr	r1, [sp, #4]
 4731 0020 FFF7FEFF 		bl	follow_path
 4732              	.LVL681:
3054:lib/ff/ff.c   **** 			if (dj->dir) {						/* It is not the root dir */
 4733              		.loc 1 3054 0
 4734 0024 A0B9     		cbnz	r0, .L620
3055:lib/ff/ff.c   **** 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
 4735              		.loc 1 3055 0
 4736 0026 6069     		ldr	r0, [r4, #20]
 4737              	.LVL682:
 4738 0028 60B1     		cbz	r0, .L621
3056:lib/ff/ff.c   **** 					dj->sclust = ld_clust(fs, dj->dir);
 4739              		.loc 1 3056 0
 4740 002a C27A     		ldrb	r2, [r0, #11]	@ zero_extendqisi2
 4741 002c 02F01001 		and	r1, r2, #16
 4742 0030 CBB2     		uxtb	r3, r1
 4743 0032 8BB1     		cbz	r3, .L626
 4744              	.LVL683:
 4745              	.LBB113:
 4746              	.LBB114:
1247:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 4747              		.loc 1 1247 0
 4748 0034 428B     		ldrh	r2, [r0, #26]
 4749              	.LVL684:
1248:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 4750              		.loc 1 1248 0
 4751 0036 2978     		ldrb	r1, [r5, #0]	@ zero_extendqisi2
 4752 0038 0329     		cmp	r1, #3
1249:lib/ff/ff.c   **** 
 4753              		.loc 1 1249 0
 4754 003a 04BF     		itt	eq
 4755 003c 808A     		ldrheq	r0, [r0, #20]
 4756              	.LVL685:
 4757 003e 42EA0042 		orreq	r2, r2, r0, lsl #16
 4758              	.LVL686:
 4759              	.LBE114:
 4760              	.LBE113:
3057:lib/ff/ff.c   **** 				} else {						/* The object is not a directory */
 4761              		.loc 1 3057 0
 4762 0042 A260     		str	r2, [r4, #8]
 4763              	.LVL687:
 4764              	.L621:
3063:lib/ff/ff.c   **** 				res = dir_sdi(dj, 0);			/* Rewind dir */
 4765              		.loc 1 3063 0
 4766 0044 E888     		ldrh	r0, [r5, #6]
 4767 0046 A080     		strh	r0, [r4, #4]	@ movhi
3064:lib/ff/ff.c   **** 			}
 4768              		.loc 1 3064 0
 4769 0048 2046     		mov	r0, r4
 4770 004a 0021     		movs	r1, #0
 4771 004c FFF7FEFF 		bl	dir_sdi
 4772              	.LVL688:
 4773              	.L620:
3067:lib/ff/ff.c   **** 		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
 4774              		.loc 1 3067 0
 4775 0050 0428     		cmp	r0, #4
 4776 0052 01D0     		beq	.L626
3068:lib/ff/ff.c   **** 	} else {
 4777              		.loc 1 3068 0
 4778 0054 28B1     		cbz	r0, .L629
 4779 0056 00E0     		b	.L619
 4780              	.LVL689:
 4781              	.L626:
3067:lib/ff/ff.c   **** 		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
 4782              		.loc 1 3067 0
 4783 0058 0520     		movs	r0, #5
 4784              	.L619:
3070:lib/ff/ff.c   **** 	}
 4785              		.loc 1 3070 0
 4786 005a 0023     		movs	r3, #0
 4787 005c 2360     		str	r3, [r4, #0]
 4788 005e 00E0     		b	.L629
 4789              	.LVL690:
 4790              	.L624:
3046:lib/ff/ff.c   **** 
 4791              		.loc 1 3046 0
 4792 0060 0920     		movs	r0, #9
 4793              	.LVL691:
 4794              	.L629:
3074:lib/ff/ff.c   **** 
 4795              		.loc 1 3074 0
 4796 0062 07B0     		add	sp, sp, #28
 4797 0064 30BD     		pop	{r4, r5, pc}
 4798              		.cfi_endproc
 4799              	.LFE38:
 4801              		.section	.text.f_readdir,"ax",%progbits
 4802              		.align	1
 4803              		.global	f_readdir
 4804              		.thumb
 4805              		.thumb_func
 4807              	f_readdir:
 4808              	.LFB39:
3087:lib/ff/ff.c   **** 	FRESULT res;
 4809              		.loc 1 3087 0
 4810              		.cfi_startproc
 4811              		@ args = 0, pretend = 0, frame = 16
 4812              		@ frame_needed = 0, uses_anonymous_args = 0
 4813              	.LVL692:
 4814 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 4815              	.LCFI32:
 4816              		.cfi_def_cfa_offset 32
 4817              		.cfi_offset 0, -32
 4818              		.cfi_offset 1, -28
 4819              		.cfi_offset 2, -24
 4820              		.cfi_offset 3, -20
 4821              		.cfi_offset 4, -16
 4822              		.cfi_offset 5, -12
 4823              		.cfi_offset 6, -8
 4824              		.cfi_offset 14, -4
 4825 0002 0546     		mov	r5, r0
 4826 0004 0E46     		mov	r6, r1
3092:lib/ff/ff.c   **** 	if (res == FR_OK) {
 4827              		.loc 1 3092 0
 4828 0006 FFF7FEFF 		bl	validate
 4829              	.LVL693:
3093:lib/ff/ff.c   **** 		if (!fno) {
 4830              		.loc 1 3093 0
 4831 000a 0446     		mov	r4, r0
 4832 000c F0B9     		cbnz	r0, .L635
3094:lib/ff/ff.c   **** 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
 4833              		.loc 1 3094 0
 4834 000e 26B9     		cbnz	r6, .L636
3095:lib/ff/ff.c   **** 		} else {
 4835              		.loc 1 3095 0
 4836 0010 2846     		mov	r0, r5
 4837              	.LVL694:
 4838 0012 2146     		mov	r1, r4
 4839 0014 FFF7FEFF 		bl	dir_sdi
 4840              	.LVL695:
 4841 0018 17E0     		b	.L640
 4842              	.LVL696:
 4843              	.L636:
3097:lib/ff/ff.c   **** 			res = dir_read(dj, 0);			/* Read an item */
 4844              		.loc 1 3097 0
 4845 001a 01AB     		add	r3, sp, #4
 4846 001c AB61     		str	r3, [r5, #24]
3098:lib/ff/ff.c   **** 			if (res == FR_NO_FILE) {		/* Reached end of dir */
 4847              		.loc 1 3098 0
 4848 001e 2846     		mov	r0, r5
 4849              	.LVL697:
 4850 0020 2146     		mov	r1, r4
 4851 0022 FFF7FEFF 		bl	dir_read
 4852              	.LVL698:
3099:lib/ff/ff.c   **** 				dj->sect = 0;
 4853              		.loc 1 3099 0
 4854 0026 0428     		cmp	r0, #4
 4855 0028 01D1     		bne	.L637
3100:lib/ff/ff.c   **** 				res = FR_OK;
 4856              		.loc 1 3100 0
 4857 002a 2C61     		str	r4, [r5, #16]
 4858              	.LVL699:
 4859 002c 00E0     		b	.L638
 4860              	.LVL700:
 4861              	.L637:
3103:lib/ff/ff.c   **** 				get_fileinfo(dj, fno);		/* Get the object information */
 4862              		.loc 1 3103 0
 4863 002e 60B9     		cbnz	r0, .L640
 4864              	.LVL701:
 4865              	.L638:
3104:lib/ff/ff.c   **** 				res = dir_next(dj, 0);		/* Increment index for next */
 4866              		.loc 1 3104 0
 4867 0030 2846     		mov	r0, r5
 4868 0032 3146     		mov	r1, r6
 4869 0034 FFF7FEFF 		bl	get_fileinfo
 4870              	.LVL702:
3105:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) {
 4871              		.loc 1 3105 0
 4872 0038 2846     		mov	r0, r5
 4873 003a 0021     		movs	r1, #0
 4874 003c FFF7FEFF 		bl	dir_next
 4875              	.LVL703:
3106:lib/ff/ff.c   **** 					dj->sect = 0;
 4876              		.loc 1 3106 0
 4877 0040 0428     		cmp	r0, #4
 4878 0042 02D1     		bne	.L640
3107:lib/ff/ff.c   **** 					res = FR_OK;
 4879              		.loc 1 3107 0
 4880 0044 0020     		movs	r0, #0
 4881              	.LVL704:
 4882 0046 2861     		str	r0, [r5, #16]
 4883              	.LVL705:
 4884 0048 00E0     		b	.L635
 4885              	.LVL706:
 4886              	.L640:
3106:lib/ff/ff.c   **** 					dj->sect = 0;
 4887              		.loc 1 3106 0
 4888 004a 0446     		mov	r4, r0
 4889              	.L635:
 4890              	.LVL707:
3116:lib/ff/ff.c   **** 
 4891              		.loc 1 3116 0
 4892 004c 2046     		mov	r0, r4
 4893 004e 04B0     		add	sp, sp, #16
 4894 0050 70BD     		pop	{r4, r5, r6, pc}
 4895              		.cfi_endproc
 4896              	.LFE39:
 4898              		.section	.text.f_stat,"ax",%progbits
 4899              		.align	1
 4900              		.global	f_stat
 4901              		.thumb
 4902              		.thumb_func
 4904              	f_stat:
 4905              	.LFB40:
3129:lib/ff/ff.c   **** 	FRESULT res;
 4906              		.loc 1 3129 0
 4907              		.cfi_startproc
 4908              		@ args = 0, pretend = 0, frame = 48
 4909              		@ frame_needed = 0, uses_anonymous_args = 0
 4910              	.LVL708:
 4911 0000 30B5     		push	{r4, r5, lr}
 4912              	.LCFI33:
 4913              		.cfi_def_cfa_offset 12
 4914              		.cfi_offset 4, -12
 4915              		.cfi_offset 5, -8
 4916              		.cfi_offset 14, -4
 4917 0002 8DB0     		sub	sp, sp, #52
 4918              	.LCFI34:
 4919              		.cfi_def_cfa_offset 64
 4920 0004 0CAB     		add	r3, sp, #48
 4921 0006 43F82C0D 		str	r0, [r3, #-44]!
 4922 000a 0D46     		mov	r5, r1
3135:lib/ff/ff.c   **** 	if (res == FR_OK) {
 4923              		.loc 1 3135 0
 4924 000c 1846     		mov	r0, r3
 4925              	.LVL709:
 4926 000e 05A9     		add	r1, sp, #20
 4927              	.LVL710:
 4928 0010 0022     		movs	r2, #0
 4929 0012 FFF7FEFF 		bl	chk_mounted
 4930              	.LVL711:
3136:lib/ff/ff.c   **** 		INIT_BUF(dj);
 4931              		.loc 1 3136 0
 4932 0016 0446     		mov	r4, r0
 4933 0018 78B9     		cbnz	r0, .L642
3137:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
 4934              		.loc 1 3137 0
 4935 001a 02A8     		add	r0, sp, #8
 4936              	.LVL712:
 4937 001c 0B90     		str	r0, [sp, #44]
3138:lib/ff/ff.c   **** 		if (res == FR_OK) {				/* Follow completed */
 4938              		.loc 1 3138 0
 4939 001e 05A8     		add	r0, sp, #20
 4940              	.LVL713:
 4941 0020 0199     		ldr	r1, [sp, #4]
 4942 0022 FFF7FEFF 		bl	follow_path
 4943              	.LVL714:
3139:lib/ff/ff.c   **** 			if (dj.dir)		/* Found an object */
 4944              		.loc 1 3139 0
 4945 0026 0446     		mov	r4, r0
 4946 0028 38B9     		cbnz	r0, .L642
3140:lib/ff/ff.c   **** 				get_fileinfo(&dj, fno);
 4947              		.loc 1 3140 0
 4948 002a 0A99     		ldr	r1, [sp, #40]
 4949 002c 21B1     		cbz	r1, .L643
3141:lib/ff/ff.c   **** 			else			/* It is root dir */
 4950              		.loc 1 3141 0
 4951 002e 05A8     		add	r0, sp, #20
 4952              	.LVL715:
 4953 0030 2946     		mov	r1, r5
 4954 0032 FFF7FEFF 		bl	get_fileinfo
 4955              	.LVL716:
 4956 0036 00E0     		b	.L642
 4957              	.LVL717:
 4958              	.L643:
3143:lib/ff/ff.c   **** 		}
 4959              		.loc 1 3143 0
 4960 0038 0624     		movs	r4, #6
 4961              	.LVL718:
 4962              	.L642:
3149:lib/ff/ff.c   **** 
 4963              		.loc 1 3149 0
 4964 003a 2046     		mov	r0, r4
 4965 003c 0DB0     		add	sp, sp, #52
 4966 003e 30BD     		pop	{r4, r5, pc}
 4967              		.cfi_endproc
 4968              	.LFE40:
 4970              		.section	.text.f_getfree,"ax",%progbits
 4971              		.align	1
 4972              		.global	f_getfree
 4973              		.thumb
 4974              		.thumb_func
 4976              	f_getfree:
 4977              	.LFB41:
3163:lib/ff/ff.c   **** 	FRESULT res;
 4978              		.loc 1 3163 0
 4979              		.cfi_startproc
 4980              		@ args = 0, pretend = 0, frame = 8
 4981              		@ frame_needed = 0, uses_anonymous_args = 0
 4982              	.LVL719:
 4983 0000 2DE9F347 		push	{r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 4984              	.LCFI35:
 4985              		.cfi_def_cfa_offset 40
 4986              		.cfi_offset 0, -40
 4987              		.cfi_offset 1, -36
 4988              		.cfi_offset 4, -32
 4989              		.cfi_offset 5, -28
 4990              		.cfi_offset 6, -24
 4991              		.cfi_offset 7, -20
 4992              		.cfi_offset 8, -16
 4993              		.cfi_offset 9, -12
 4994              		.cfi_offset 10, -8
 4995              		.cfi_offset 14, -4
 4996 0004 02AB     		add	r3, sp, #8
 4997 0006 43F8040D 		str	r0, [r3, #-4]!
 4998 000a 8846     		mov	r8, r1
 4999 000c 1446     		mov	r4, r2
3172:lib/ff/ff.c   **** 	fs = *fatfs;
 5000              		.loc 1 3172 0
 5001 000e 1846     		mov	r0, r3
 5002              	.LVL720:
 5003 0010 1146     		mov	r1, r2
 5004              	.LVL721:
 5005 0012 0022     		movs	r2, #0
 5006              	.LVL722:
 5007 0014 FFF7FEFF 		bl	chk_mounted
 5008              	.LVL723:
3173:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5009              		.loc 1 3173 0
 5010 0018 2468     		ldr	r4, [r4, #0]
 5011              	.LVL724:
3174:lib/ff/ff.c   **** 		/* If free_clust is valid, return it without full cluster scan */
 5012              		.loc 1 3174 0
 5013 001a 0546     		mov	r5, r0
 5014 001c 0028     		cmp	r0, #0
 5015 001e 4DD1     		bne	.L645
3176:lib/ff/ff.c   **** 			*nclst = fs->free_clust;
 5016              		.loc 1 3176 0
 5017 0020 2069     		ldr	r0, [r4, #16]
 5018              	.LVL725:
 5019 0022 E769     		ldr	r7, [r4, #28]
 5020 0024 BA1E     		subs	r2, r7, #2
 5021 0026 9042     		cmp	r0, r2
 5022 0028 02D8     		bhi	.L646
3177:lib/ff/ff.c   **** 		} else {
 5023              		.loc 1 3177 0
 5024 002a C8F80000 		str	r0, [r8, #0]
 5025 002e 45E0     		b	.L645
 5026              	.L646:
3180:lib/ff/ff.c   **** 			n = 0;
 5027              		.loc 1 3180 0
 5028 0030 94F80090 		ldrb	r9, [r4, #0]	@ zero_extendqisi2
 5029              	.LVL726:
3182:lib/ff/ff.c   **** 				clst = 2;
 5030              		.loc 1 3182 0
 5031 0034 B9F1010F 		cmp	r9, #1
 5032 0038 10D1     		bne	.L647
 5033 003a 0227     		movs	r7, #2
 5034 003c 2E46     		mov	r6, r5
 5035              	.LVL727:
 5036              	.L650:
3185:lib/ff/ff.c   **** 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 5037              		.loc 1 3185 0
 5038 003e 2046     		mov	r0, r4
 5039 0040 3946     		mov	r1, r7
 5040 0042 FFF7FEFF 		bl	get_fat
 5041              	.LVL728:
3186:lib/ff/ff.c   **** 					if (stat == 1) { res = FR_INT_ERR; break; }
 5042              		.loc 1 3186 0
 5043 0046 431C     		adds	r3, r0, #1
 5044 0048 2BD0     		beq	.L658
3187:lib/ff/ff.c   **** 					if (stat == 0) n++;
 5045              		.loc 1 3187 0
 5046 004a 0128     		cmp	r0, #1
 5047 004c 2BD0     		beq	.L659
3188:lib/ff/ff.c   **** 				} while (++clst < fs->n_fatent);
 5048              		.loc 1 3188 0
 5049 004e 00B9     		cbnz	r0, .L649
3188:lib/ff/ff.c   **** 				} while (++clst < fs->n_fatent);
 5050              		.loc 1 3188 0 is_stmt 0 discriminator 1
 5051 0050 0136     		adds	r6, r6, #1
 5052              	.LVL729:
 5053              	.L649:
3189:lib/ff/ff.c   **** 			} else {
 5054              		.loc 1 3189 0 is_stmt 1
 5055 0052 0137     		adds	r7, r7, #1
 5056              	.LVL730:
 5057 0054 E169     		ldr	r1, [r4, #28]
 5058 0056 8F42     		cmp	r7, r1
 5059 0058 F1D3     		bcc	.L650
 5060 005a 27E0     		b	.L648
 5061              	.LVL731:
 5062              	.L647:
3192:lib/ff/ff.c   **** 				i = 0; p = 0;
 5063              		.loc 1 3192 0
 5064 005c A16A     		ldr	r1, [r4, #40]
 5065              	.LVL732:
3193:lib/ff/ff.c   **** 				do {
 5066              		.loc 1 3193 0
 5067 005e 2B46     		mov	r3, r5
 5068 0060 2A46     		mov	r2, r5
3181:lib/ff/ff.c   **** 			if (fat == FS_FAT12) {
 5069              		.loc 1 3181 0
 5070 0062 2E46     		mov	r6, r5
 5071              	.LVL733:
 5072              	.L656:
3195:lib/ff/ff.c   **** 						res = move_window(fs, sect++);
 5073              		.loc 1 3195 0
 5074 0064 52B9     		cbnz	r2, .L651
3196:lib/ff/ff.c   **** 						if (res != FR_OK) break;
 5075              		.loc 1 3196 0
 5076 0066 01F1010A 		add	sl, r1, #1
 5077              	.LVL734:
 5078 006a 2046     		mov	r0, r4
 5079 006c FFF7FEFF 		bl	move_window
 5080              	.LVL735:
3197:lib/ff/ff.c   **** 						p = fs->win;
 5081              		.loc 1 3197 0
 5082 0070 D8B9     		cbnz	r0, .L660
3198:lib/ff/ff.c   **** 						i = SS(fs);
 5083              		.loc 1 3198 0
 5084 0072 04F13803 		add	r3, r4, #56
 5085              	.LVL736:
3196:lib/ff/ff.c   **** 						if (res != FR_OK) break;
 5086              		.loc 1 3196 0
 5087 0076 5146     		mov	r1, sl
3199:lib/ff/ff.c   **** 					}
 5088              		.loc 1 3199 0
 5089 0078 4FF40072 		mov	r2, #512
 5090              	.LVL737:
 5091              	.L651:
3201:lib/ff/ff.c   **** 						if (LD_WORD(p) == 0) n++;
 5092              		.loc 1 3201 0
 5093 007c B9F1020F 		cmp	r9, #2
 5094 0080 05D1     		bne	.L652
3202:lib/ff/ff.c   **** 						p += 2; i -= 2;
 5095              		.loc 1 3202 0
 5096 0082 1888     		ldrh	r0, [r3, #0]
 5097 0084 00B9     		cbnz	r0, .L653
3202:lib/ff/ff.c   **** 						p += 2; i -= 2;
 5098              		.loc 1 3202 0 is_stmt 0 discriminator 1
 5099 0086 0136     		adds	r6, r6, #1
 5100              	.LVL738:
 5101              	.L653:
3203:lib/ff/ff.c   **** 					} else {
 5102              		.loc 1 3203 0 is_stmt 1
 5103 0088 0233     		adds	r3, r3, #2
 5104              	.LVL739:
 5105 008a 023A     		subs	r2, r2, #2
 5106              	.LVL740:
 5107 008c 06E0     		b	.L654
 5108              	.L652:
3205:lib/ff/ff.c   **** 						p += 4; i -= 4;
 5109              		.loc 1 3205 0
 5110 008e 1868     		ldr	r0, [r3, #0]
 5111 0090 20F07040 		bic	r0, r0, #-268435456
 5112 0094 00B9     		cbnz	r0, .L655
3205:lib/ff/ff.c   **** 						p += 4; i -= 4;
 5113              		.loc 1 3205 0 is_stmt 0 discriminator 1
 5114 0096 0136     		adds	r6, r6, #1
 5115              	.LVL741:
 5116              	.L655:
3206:lib/ff/ff.c   **** 					}
 5117              		.loc 1 3206 0 is_stmt 1
 5118 0098 0433     		adds	r3, r3, #4
 5119              	.LVL742:
 5120 009a 043A     		subs	r2, r2, #4
 5121              	.LVL743:
 5122              	.L654:
3208:lib/ff/ff.c   **** 			}
 5123              		.loc 1 3208 0
 5124 009c 013F     		subs	r7, r7, #1
 5125              	.LVL744:
 5126 009e E1D1     		bne	.L656
 5127 00a0 04E0     		b	.L648
 5128              	.LVL745:
 5129              	.L658:
3186:lib/ff/ff.c   **** 					if (stat == 1) { res = FR_INT_ERR; break; }
 5130              		.loc 1 3186 0
 5131 00a2 0125     		movs	r5, #1
 5132 00a4 02E0     		b	.L648
 5133              	.L659:
3187:lib/ff/ff.c   **** 					if (stat == 0) n++;
 5134              		.loc 1 3187 0
 5135 00a6 0225     		movs	r5, #2
 5136 00a8 00E0     		b	.L648
 5137              	.LVL746:
 5138              	.L660:
3196:lib/ff/ff.c   **** 						if (res != FR_OK) break;
 5139              		.loc 1 3196 0
 5140 00aa 0546     		mov	r5, r0
 5141              	.LVL747:
 5142              	.L648:
3210:lib/ff/ff.c   **** 			if (fat == FS_FAT32) fs->fsi_flag = 1;
 5143              		.loc 1 3210 0
 5144 00ac 2661     		str	r6, [r4, #16]
3211:lib/ff/ff.c   **** 			*nclst = n;
 5145              		.loc 1 3211 0
 5146 00ae B9F1030F 		cmp	r9, #3
 5147 00b2 01D1     		bne	.L657
3211:lib/ff/ff.c   **** 			*nclst = n;
 5148              		.loc 1 3211 0 is_stmt 0 discriminator 1
 5149 00b4 0123     		movs	r3, #1
 5150 00b6 6371     		strb	r3, [r4, #5]
 5151              	.L657:
3212:lib/ff/ff.c   **** 		}
 5152              		.loc 1 3212 0 is_stmt 1
 5153 00b8 C8F80060 		str	r6, [r8, #0]
 5154              	.LVL748:
 5155              	.L645:
3216:lib/ff/ff.c   **** 
 5156              		.loc 1 3216 0
 5157 00bc 2846     		mov	r0, r5
 5158 00be BDE8FC87 		pop	{r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}
 5159              		.cfi_endproc
 5160              	.LFE41:
 5162              		.section	.text.f_truncate,"ax",%progbits
 5163              		.align	1
 5164              		.global	f_truncate
 5165              		.thumb
 5166              		.thumb_func
 5168              	f_truncate:
 5169              	.LFB42:
3228:lib/ff/ff.c   **** 	FRESULT res;
 5170              		.loc 1 3228 0
 5171              		.cfi_startproc
 5172              		@ args = 0, pretend = 0, frame = 0
 5173              		@ frame_needed = 0, uses_anonymous_args = 0
 5174              	.LVL749:
 5175 0000 70B5     		push	{r4, r5, r6, lr}
 5176              	.LCFI36:
 5177              		.cfi_def_cfa_offset 16
 5178              		.cfi_offset 4, -16
 5179              		.cfi_offset 5, -12
 5180              		.cfi_offset 6, -8
 5181              		.cfi_offset 14, -4
 5182 0002 0446     		mov	r4, r0
3233:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5183              		.loc 1 3233 0
 5184 0004 FFF7FEFF 		bl	validate
 5185              	.LVL750:
3234:lib/ff/ff.c   **** 		if (fp->flag & FA__ERROR) {			/* Check abort flag */
 5186              		.loc 1 3234 0
 5187 0008 0546     		mov	r5, r0
 5188 000a 0028     		cmp	r0, #0
 5189 000c 3DD1     		bne	.L680
3235:lib/ff/ff.c   **** 			res = FR_INT_ERR;
 5190              		.loc 1 3235 0
 5191 000e A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 5192 0010 1906     		lsls	r1, r3, #24
 5193 0012 34D4     		bmi	.L675
3238:lib/ff/ff.c   **** 				res = FR_DENIED;
 5194              		.loc 1 3238 0
 5195 0014 03F00202 		and	r2, r3, #2
 5196 0018 D0B2     		uxtb	r0, r2
 5197              	.LVL751:
 5198 001a 0028     		cmp	r0, #0
 5199 001c 31D0     		beq	.L676
 5200              	.LVL752:
3243:lib/ff/ff.c   **** 			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
 5201              		.loc 1 3243 0
 5202 001e A668     		ldr	r6, [r4, #8]
 5203 0020 E168     		ldr	r1, [r4, #12]
 5204 0022 B142     		cmp	r1, r6
 5205 0024 31D9     		bls	.L680
 5206              	.L671:
3244:lib/ff/ff.c   **** 			fp->flag |= FA__WRITTEN;
 5207              		.loc 1 3244 0
 5208 0026 E660     		str	r6, [r4, #12]
3245:lib/ff/ff.c   **** 			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 5209              		.loc 1 3245 0
 5210 0028 43F02003 		orr	r3, r3, #32
 5211 002c A371     		strb	r3, [r4, #6]
3247:lib/ff/ff.c   **** 				fp->sclust = 0;
 5212              		.loc 1 3247 0
 5213 002e 2068     		ldr	r0, [r4, #0]
3246:lib/ff/ff.c   **** 				res = remove_chain(fp->fs, fp->sclust);
 5214              		.loc 1 3246 0
 5215 0030 2EB9     		cbnz	r6, .L666
3247:lib/ff/ff.c   **** 				fp->sclust = 0;
 5216              		.loc 1 3247 0
 5217 0032 2169     		ldr	r1, [r4, #16]
 5218 0034 FFF7FEFF 		bl	remove_chain
 5219              	.LVL753:
 5220 0038 0546     		mov	r5, r0
 5221              	.LVL754:
3248:lib/ff/ff.c   **** 			} else {				/* When truncate a part of the file, remove remaining clusters */
 5222              		.loc 1 3248 0
 5223 003a 2661     		str	r6, [r4, #16]
 5224 003c 19E0     		b	.L667
 5225              	.LVL755:
 5226              	.L666:
3250:lib/ff/ff.c   **** 				res = FR_OK;
 5227              		.loc 1 3250 0
 5228 003e 6169     		ldr	r1, [r4, #20]
 5229 0040 FFF7FEFF 		bl	get_fat
 5230              	.LVL756:
 5231 0044 0646     		mov	r6, r0
 5232              	.LVL757:
3252:lib/ff/ff.c   **** 				if (ncl == 1) res = FR_INT_ERR;
 5233              		.loc 1 3252 0
 5234 0046 421C     		adds	r2, r0, #1
 5235 0048 1DD0     		beq	.L677
3253:lib/ff/ff.c   **** 				if (res == FR_OK && ncl < fp->fs->n_fatent) {
 5236              		.loc 1 3253 0
 5237 004a 0128     		cmp	r0, #1
 5238 004c 01D1     		bne	.L684
 5239 004e 0225     		movs	r5, #2
 5240 0050 10E0     		b	.L673
 5241              	.L684:
3254:lib/ff/ff.c   **** 					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
 5242              		.loc 1 3254 0
 5243 0052 2068     		ldr	r0, [r4, #0]
 5244              	.LVL758:
 5245 0054 C269     		ldr	r2, [r0, #28]
 5246 0056 9642     		cmp	r6, r2
 5247 0058 17D2     		bcs	.L680
 5248              	.L674:
3255:lib/ff/ff.c   **** 					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 5249              		.loc 1 3255 0
 5250 005a 6169     		ldr	r1, [r4, #20]
 5251 005c 6FF07042 		mvn	r2, #-268435456
 5252 0060 FFF7FEFF 		bl	put_fat
 5253              	.LVL759:
3256:lib/ff/ff.c   **** 				}
 5254              		.loc 1 3256 0
 5255 0064 0546     		mov	r5, r0
 5256 0066 28B9     		cbnz	r0, .L673
3256:lib/ff/ff.c   **** 				}
 5257              		.loc 1 3256 0 is_stmt 0 discriminator 1
 5258 0068 2068     		ldr	r0, [r4, #0]
 5259              	.LVL760:
 5260 006a 3146     		mov	r1, r6
 5261 006c FFF7FEFF 		bl	remove_chain
 5262              	.LVL761:
 5263 0070 0546     		mov	r5, r0
 5264              	.LVL762:
 5265              	.L667:
3260:lib/ff/ff.c   **** 	}
 5266              		.loc 1 3260 0 is_stmt 1
 5267 0072 55B1     		cbz	r5, .L680
 5268              	.LVL763:
 5269              	.L673:
3260:lib/ff/ff.c   **** 	}
 5270              		.loc 1 3260 0 is_stmt 0 discriminator 1
 5271 0074 A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 5272 0076 60F07F01 		orn	r1, r0, #127
 5273 007a A171     		strb	r1, [r4, #6]
 5274 007c 05E0     		b	.L680
 5275              	.LVL764:
 5276              	.L675:
3236:lib/ff/ff.c   **** 		} else {
 5277              		.loc 1 3236 0 is_stmt 1
 5278 007e 0225     		movs	r5, #2
 5279 0080 03E0     		b	.L680
 5280              	.LVL765:
 5281              	.L676:
3239:lib/ff/ff.c   **** 		}
 5282              		.loc 1 3239 0
 5283 0082 0725     		movs	r5, #7
 5284              	.LVL766:
 5285 0084 01E0     		b	.L680
 5286              	.LVL767:
 5287              	.L677:
3252:lib/ff/ff.c   **** 				if (ncl == 1) res = FR_INT_ERR;
 5288              		.loc 1 3252 0
 5289 0086 0125     		movs	r5, #1
 5290 0088 F4E7     		b	.L673
 5291              	.LVL768:
 5292              	.L680:
3264:lib/ff/ff.c   **** 
 5293              		.loc 1 3264 0
 5294 008a 2846     		mov	r0, r5
 5295 008c 70BD     		pop	{r4, r5, r6, pc}
 5296              		.cfi_endproc
 5297              	.LFE42:
 5299              		.section	.text.f_unlink,"ax",%progbits
 5300              		.align	1
 5301              		.global	f_unlink
 5302              		.thumb
 5303              		.thumb_func
 5305              	f_unlink:
 5306              	.LFB43:
3276:lib/ff/ff.c   **** 	FRESULT res;
 5307              		.loc 1 3276 0
 5308              		.cfi_startproc
 5309              		@ args = 0, pretend = 0, frame = 80
 5310              		@ frame_needed = 0, uses_anonymous_args = 0
 5311              	.LVL769:
 5312 0000 10B5     		push	{r4, lr}
 5313              	.LCFI37:
 5314              		.cfi_def_cfa_offset 8
 5315              		.cfi_offset 4, -8
 5316              		.cfi_offset 14, -4
 5317 0002 94B0     		sub	sp, sp, #80
 5318              	.LCFI38:
 5319              		.cfi_def_cfa_offset 88
 5320 0004 14AB     		add	r3, sp, #80
 5321 0006 43F84C0D 		str	r0, [r3, #-76]!
3284:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5322              		.loc 1 3284 0
 5323 000a 1846     		mov	r0, r3
 5324              	.LVL770:
 5325 000c 06A9     		add	r1, sp, #24
 5326 000e 0122     		movs	r2, #1
 5327 0010 FFF7FEFF 		bl	chk_mounted
 5328              	.LVL771:
3285:lib/ff/ff.c   **** 		INIT_BUF(dj);
 5329              		.loc 1 3285 0
 5330 0014 0346     		mov	r3, r0
 5331 0016 0028     		cmp	r0, #0
 5332 0018 5AD1     		bne	.L706
3286:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the file path */
 5333              		.loc 1 3286 0
 5334 001a 03A8     		add	r0, sp, #12
 5335              	.LVL772:
 5336 001c 0C90     		str	r0, [sp, #48]
3287:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 5337              		.loc 1 3287 0
 5338 001e 06A8     		add	r0, sp, #24
 5339              	.LVL773:
 5340 0020 0199     		ldr	r1, [sp, #4]
 5341 0022 FFF7FEFF 		bl	follow_path
 5342              	.LVL774:
3288:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
 5343              		.loc 1 3288 0
 5344 0026 0346     		mov	r3, r0
 5345 0028 0028     		cmp	r0, #0
 5346 002a 51D1     		bne	.L706
3288:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
 5347              		.loc 1 3288 0 is_stmt 0 discriminator 1
 5348 002c 0C99     		ldr	r1, [sp, #48]
 5349 002e CA7A     		ldrb	r2, [r1, #11]	@ zero_extendqisi2
 5350 0030 02F02003 		and	r3, r2, #32
 5351 0034 D8B2     		uxtb	r0, r3
 5352              	.LVL775:
 5353 0036 0028     		cmp	r0, #0
 5354 0038 33D1     		bne	.L697
 5355              	.LVL776:
3294:lib/ff/ff.c   **** 			if (!dir) {
 5356              		.loc 1 3294 0 is_stmt 1
 5357 003a 0B9A     		ldr	r2, [sp, #44]
 5358              	.LVL777:
3295:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
 5359              		.loc 1 3295 0
 5360 003c 32B1     		cbz	r2, .L715
 5361              	.L714:
3298:lib/ff/ff.c   **** 					res = FR_DENIED;		/* Cannot remove R/O object */
 5362              		.loc 1 3298 0
 5363 003e D47A     		ldrb	r4, [r2, #11]	@ zero_extendqisi2
3299:lib/ff/ff.c   **** 			}
 5364              		.loc 1 3299 0
 5365 0040 14F0010F 		tst	r4, #1
 5366 0044 0CBF     		ite	eq
 5367 0046 0023     		moveq	r3, #0
 5368 0048 0723     		movne	r3, #7
 5369 004a 00E0     		b	.L689
 5370              	.L715:
3296:lib/ff/ff.c   **** 			} else {
 5371              		.loc 1 3296 0
 5372 004c 0623     		movs	r3, #6
 5373              	.L689:
 5374              	.LVL778:
 5375              	.LBB117:
 5376              	.LBB118:
1247:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 5377              		.loc 1 1247 0
 5378 004e 548B     		ldrh	r4, [r2, #26]
 5379              	.LVL779:
 5380              		.loc 1 4323 0
 5381 0050 0699     		ldr	r1, [sp, #24]
1248:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 5382              		.loc 1 1248 0
 5383 0052 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 5384 0054 0328     		cmp	r0, #3
1249:lib/ff/ff.c   **** 
 5385              		.loc 1 1249 0
 5386 0056 04BF     		itt	eq
 5387 0058 908A     		ldrheq	r0, [r2, #20]
 5388 005a 44EA0044 		orreq	r4, r4, r0, lsl #16
 5389              	.LVL780:
 5390              	.LBE118:
 5391              	.LBE117:
3302:lib/ff/ff.c   **** 				if (dclst < 2) {
 5392              		.loc 1 3302 0
 5393 005e 002B     		cmp	r3, #0
 5394 0060 36D1     		bne	.L706
3302:lib/ff/ff.c   **** 				if (dclst < 2) {
 5395              		.loc 1 3302 0 is_stmt 0 discriminator 1
 5396 0062 D37A     		ldrb	r3, [r2, #11]	@ zero_extendqisi2
 5397              	.LVL781:
 5398 0064 03F01002 		and	r2, r3, #16
 5399              	.LVL782:
 5400 0068 D1B2     		uxtb	r1, r2
 5401 006a E1B1     		cbz	r1, .L692
3303:lib/ff/ff.c   **** 					res = FR_INT_ERR;
 5402              		.loc 1 3303 0 is_stmt 1
 5403 006c 012C     		cmp	r4, #1
 5404 006e 2CD9     		bls	.L699
3306:lib/ff/ff.c   **** 					sdj.sclust = dclst;
 5405              		.loc 1 3306 0
 5406 0070 0DA8     		add	r0, sp, #52
 5407 0072 06A9     		add	r1, sp, #24
 5408 0074 1C22     		movs	r2, #28
 5409 0076 FFF7FEFF 		bl	mem_cpy
 5410              	.LVL783:
3307:lib/ff/ff.c   **** 					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
 5411              		.loc 1 3307 0
 5412 007a 0F94     		str	r4, [sp, #60]
3308:lib/ff/ff.c   **** 					if (res == FR_OK) {
 5413              		.loc 1 3308 0
 5414 007c 0DA8     		add	r0, sp, #52
 5415 007e 0221     		movs	r1, #2
 5416 0080 FFF7FEFF 		bl	dir_sdi
 5417              	.LVL784:
3309:lib/ff/ff.c   **** 						res = dir_read(&sdj, 0);	/* Read an item */
 5418              		.loc 1 3309 0
 5419 0084 0346     		mov	r3, r0
 5420 0086 18BB     		cbnz	r0, .L706
3310:lib/ff/ff.c   **** 						if (res == FR_OK		/* Not empty dir */
 5421              		.loc 1 3310 0
 5422 0088 0DA8     		add	r0, sp, #52
 5423              	.LVL785:
 5424 008a 1946     		mov	r1, r3
 5425 008c FFF7FEFF 		bl	dir_read
 5426              	.LVL786:
3311:lib/ff/ff.c   **** #if _FS_RPATH
 5427              		.loc 1 3311 0
 5428 0090 0346     		mov	r3, r0
 5429 0092 E0B1     		cbz	r0, .L701
3313:lib/ff/ff.c   **** #endif
 5430              		.loc 1 3313 0
 5431 0094 0698     		ldr	r0, [sp, #24]
 5432              	.LVL787:
 5433 0096 8269     		ldr	r2, [r0, #24]
 5434 0098 9442     		cmp	r4, r2
 5435 009a 18D0     		beq	.L701
 5436              	.LVL788:
3316:lib/ff/ff.c   **** 					}
 5437              		.loc 1 3316 0
 5438 009c 042B     		cmp	r3, #4
 5439 009e 02D0     		beq	.L692
 5440 00a0 16E0     		b	.L706
 5441              	.LVL789:
 5442              	.L697:
3289:lib/ff/ff.c   **** #if _FS_LOCK
 5443              		.loc 1 3289 0
 5444 00a2 0623     		movs	r3, #6
 5445              	.LVL790:
 5446 00a4 14E0     		b	.L706
 5447              	.LVL791:
 5448              	.L692:
3321:lib/ff/ff.c   **** 				if (res == FR_OK) {
 5449              		.loc 1 3321 0
 5450 00a6 06A8     		add	r0, sp, #24
 5451 00a8 FFF7FEFF 		bl	dir_remove
 5452              	.LVL792:
3322:lib/ff/ff.c   **** 					if (dclst)				/* Remove the cluster chain if exist */
 5453              		.loc 1 3322 0
 5454 00ac 0346     		mov	r3, r0
 5455 00ae 78B9     		cbnz	r0, .L706
 5456              	.L696:
3323:lib/ff/ff.c   **** 						res = remove_chain(dj.fs, dclst);
 5457              		.loc 1 3323 0
 5458 00b0 24B9     		cbnz	r4, .L693
 5459              	.L694:
3325:lib/ff/ff.c   **** 				}
 5460              		.loc 1 3325 0
 5461 00b2 0698     		ldr	r0, [sp, #24]
 5462              	.LVL793:
 5463 00b4 FFF7FEFF 		bl	sync_fs
 5464              	.LVL794:
 5465 00b8 0346     		mov	r3, r0
 5466              	.LVL795:
 5467 00ba 09E0     		b	.L706
 5468              	.L693:
3324:lib/ff/ff.c   **** 					if (res == FR_OK) res = sync_fs(dj.fs);
 5469              		.loc 1 3324 0
 5470 00bc 0698     		ldr	r0, [sp, #24]
 5471              	.LVL796:
 5472 00be 2146     		mov	r1, r4
 5473 00c0 FFF7FEFF 		bl	remove_chain
 5474              	.LVL797:
3325:lib/ff/ff.c   **** 				}
 5475              		.loc 1 3325 0
 5476 00c4 0346     		mov	r3, r0
 5477 00c6 18B9     		cbnz	r0, .L706
 5478 00c8 F3E7     		b	.L694
 5479              	.LVL798:
 5480              	.L699:
3304:lib/ff/ff.c   **** 				} else {
 5481              		.loc 1 3304 0
 5482 00ca 0223     		movs	r3, #2
 5483 00cc 00E0     		b	.L706
 5484              	.LVL799:
 5485              	.L701:
3313:lib/ff/ff.c   **** #endif
 5486              		.loc 1 3313 0
 5487 00ce 0723     		movs	r3, #7
 5488              	.LVL800:
 5489              	.L706:
3333:lib/ff/ff.c   **** 
 5490              		.loc 1 3333 0
 5491 00d0 1846     		mov	r0, r3
 5492 00d2 14B0     		add	sp, sp, #80
 5493 00d4 10BD     		pop	{r4, pc}
 5494              		.cfi_endproc
 5495              	.LFE43:
 5497              		.section	.text.f_mkdir,"ax",%progbits
 5498              		.align	1
 5499              		.global	f_mkdir
 5500              		.thumb
 5501              		.thumb_func
 5503              	f_mkdir:
 5504              	.LFB44:
3345:lib/ff/ff.c   **** 	FRESULT res;
 5505              		.loc 1 3345 0
 5506              		.cfi_startproc
 5507              		@ args = 0, pretend = 0, frame = 48
 5508              		@ frame_needed = 0, uses_anonymous_args = 0
 5509              	.LVL801:
 5510 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5511              	.LCFI39:
 5512              		.cfi_def_cfa_offset 36
 5513              		.cfi_offset 4, -36
 5514              		.cfi_offset 5, -32
 5515              		.cfi_offset 6, -28
 5516              		.cfi_offset 7, -24
 5517              		.cfi_offset 8, -20
 5518              		.cfi_offset 9, -16
 5519              		.cfi_offset 10, -12
 5520              		.cfi_offset 11, -8
 5521              		.cfi_offset 14, -4
 5522 0004 8DB0     		sub	sp, sp, #52
 5523              	.LCFI40:
 5524              		.cfi_def_cfa_offset 88
 5525 0006 0CAC     		add	r4, sp, #48
 5526 0008 44F82C0D 		str	r0, [r4, #-44]!
3349:lib/ff/ff.c   **** 	DEF_NAMEBUF;
 5527              		.loc 1 3349 0
 5528 000c FFF7FEFF 		bl	get_fattime
 5529              	.LVL802:
 5530 0010 8146     		mov	r9, r0
 5531              	.LVL803:
3353:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5532              		.loc 1 3353 0
 5533 0012 2046     		mov	r0, r4
 5534              	.LVL804:
 5535 0014 05A9     		add	r1, sp, #20
 5536 0016 0122     		movs	r2, #1
 5537 0018 FFF7FEFF 		bl	chk_mounted
 5538              	.LVL805:
3354:lib/ff/ff.c   **** 		INIT_BUF(dj);
 5539              		.loc 1 3354 0
 5540 001c 0446     		mov	r4, r0
 5541 001e 0028     		cmp	r0, #0
 5542 0020 40F09380 		bne	.L736
3355:lib/ff/ff.c   **** 		res = follow_path(&dj, path);			/* Follow the file path */
 5543              		.loc 1 3355 0
 5544 0024 02AB     		add	r3, sp, #8
 5545 0026 0B93     		str	r3, [sp, #44]
3356:lib/ff/ff.c   **** 		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 5546              		.loc 1 3356 0
 5547 0028 05A8     		add	r0, sp, #20
 5548              	.LVL806:
 5549 002a 0199     		ldr	r1, [sp, #4]
 5550 002c FFF7FEFF 		bl	follow_path
 5551              	.LVL807:
3357:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
 5552              		.loc 1 3357 0
 5553 0030 0446     		mov	r4, r0
 5554 0032 C8B1     		cbz	r0, .L730
3358:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 5555              		.loc 1 3358 0
 5556 0034 0428     		cmp	r0, #4
 5557 0036 40F08880 		bne	.L736
3358:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 5558              		.loc 1 3358 0 is_stmt 0 discriminator 1
 5559 003a 0B98     		ldr	r0, [sp, #44]
 5560              	.LVL808:
 5561 003c C17A     		ldrb	r1, [r0, #11]	@ zero_extendqisi2
 5562 003e 01F02002 		and	r2, r1, #32
 5563 0042 D1B2     		uxtb	r1, r2
 5564 0044 91B9     		cbnz	r1, .L731
 5565              	.LVL809:
3361:lib/ff/ff.c   **** 			res = FR_OK;
 5566              		.loc 1 3361 0 is_stmt 1
 5567 0046 0598     		ldr	r0, [sp, #20]
 5568 0048 FFF7FEFF 		bl	create_chain
 5569              	.LVL810:
3363:lib/ff/ff.c   **** 			if (dcl == 1) res = FR_INT_ERR;
 5570              		.loc 1 3363 0
 5571 004c 0646     		mov	r6, r0
 5572 004e 78B1     		cbz	r0, .L735
3364:lib/ff/ff.c   **** 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 5573              		.loc 1 3364 0
 5574 0050 012E     		cmp	r6, #1
 5575 0052 03D0     		beq	.L732
3365:lib/ff/ff.c   **** 			if (res == FR_OK)					/* Flush FAT */
 5576              		.loc 1 3365 0
 5577 0054 0124     		movs	r4, #1
 5578 0056 701C     		adds	r0, r6, #1
 5579              	.LVL811:
 5580 0058 01D0     		beq	.L728
 5581 005a 0BE0     		b	.L740
 5582              	.LVL812:
 5583              	.L732:
3364:lib/ff/ff.c   **** 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 5584              		.loc 1 3364 0
 5585 005c 0224     		movs	r4, #2
 5586              	.LVL813:
 5587              	.L728:
3392:lib/ff/ff.c   **** 			} else {
 5588              		.loc 1 3392 0
 5589 005e 0598     		ldr	r0, [sp, #20]
 5590 0060 3146     		mov	r1, r6
 5591 0062 FFF7FEFF 		bl	remove_chain
 5592              	.LVL814:
 5593 0066 70E0     		b	.L736
 5594              	.LVL815:
 5595              	.L730:
3357:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
 5596              		.loc 1 3357 0
 5597 0068 0824     		movs	r4, #8
 5598 006a 6EE0     		b	.L736
 5599              	.LVL816:
 5600              	.L731:
3359:lib/ff/ff.c   **** 		if (res == FR_NO_FILE) {				/* Can create a new directory */
 5601              		.loc 1 3359 0
 5602 006c 0624     		movs	r4, #6
 5603              	.LVL817:
 5604 006e 6CE0     		b	.L736
 5605              	.LVL818:
 5606              	.L735:
3363:lib/ff/ff.c   **** 			if (dcl == 1) res = FR_INT_ERR;
 5607              		.loc 1 3363 0
 5608 0070 0724     		movs	r4, #7
 5609 0072 F4E7     		b	.L728
 5610              	.LVL819:
 5611              	.L740:
3367:lib/ff/ff.c   **** 			if (res == FR_OK) {					/* Initialize the new directory table */
 5612              		.loc 1 3367 0
 5613 0074 0598     		ldr	r0, [sp, #20]
 5614 0076 FFF7FEFF 		bl	sync_window
 5615              	.LVL820:
3368:lib/ff/ff.c   **** 				dsc = clust2sect(dj.fs, dcl);
 5616              		.loc 1 3368 0
 5617 007a 0446     		mov	r4, r0
 5618 007c 0028     		cmp	r0, #0
 5619 007e EED1     		bne	.L728
 5620              	.L729:
3369:lib/ff/ff.c   **** 				dir = dj.fs->win;
 5621              		.loc 1 3369 0
 5622 0080 059D     		ldr	r5, [sp, #20]
 5623 0082 2846     		mov	r0, r5
 5624              	.LVL821:
 5625 0084 3146     		mov	r1, r6
 5626 0086 FFF7FEFF 		bl	clust2sect
 5627              	.LVL822:
 5628 008a 8046     		mov	r8, r0
 5629              	.LVL823:
3370:lib/ff/ff.c   **** 				mem_set(dir, 0, SS(dj.fs));
 5630              		.loc 1 3370 0
 5631 008c 05F13807 		add	r7, r5, #56
 5632              	.LVL824:
3371:lib/ff/ff.c   **** 				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
 5633              		.loc 1 3371 0
 5634 0090 3846     		mov	r0, r7
 5635              	.LVL825:
 5636 0092 2146     		mov	r1, r4
 5637 0094 4FF40072 		mov	r2, #512
 5638 0098 FFF7FEFF 		bl	mem_set
 5639              	.LVL826:
3372:lib/ff/ff.c   **** 				dir[DIR_Name] = '.';
 5640              		.loc 1 3372 0
 5641 009c 3846     		mov	r0, r7
 5642 009e 2021     		movs	r1, #32
 5643 00a0 0B22     		movs	r2, #11
 5644 00a2 FFF7FEFF 		bl	mem_set
 5645              	.LVL827:
3373:lib/ff/ff.c   **** 				dir[DIR_Attr] = AM_DIR;
 5646              		.loc 1 3373 0
 5647 00a6 2E24     		movs	r4, #46
 5648 00a8 85F83840 		strb	r4, [r5, #56]
3374:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tm);
 5649              		.loc 1 3374 0
 5650 00ac 1023     		movs	r3, #16
 5651 00ae 85F84330 		strb	r3, [r5, #67]
3375:lib/ff/ff.c   **** 				st_clust(dir, dcl);
 5652              		.loc 1 3375 0
 5653 00b2 C5F84E90 		str	r9, [r5, #78]
 5654              	.LVL828:
 5655              	.LBB119:
 5656              	.LBB120:
1262:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 5657              		.loc 1 1262 0
 5658 00b6 1FFA86FB 		uxth	fp, r6
 5659 00ba A5F852B0 		strh	fp, [r5, #82]	@ movhi
1263:lib/ff/ff.c   **** }
 5660              		.loc 1 1263 0
 5661 00be 26FA03FA 		lsr	sl, r6, r3
 5662 00c2 A5F84CA0 		strh	sl, [r5, #76]	@ movhi
 5663              	.LBE120:
 5664              	.LBE119:
3377:lib/ff/ff.c   **** 				dir[33] = '.'; pcl = dj.sclust;
 5665              		.loc 1 3377 0
 5666 00c6 05F15800 		add	r0, r5, #88
 5667 00ca 3946     		mov	r1, r7
 5668 00cc 2022     		movs	r2, #32
 5669 00ce FFF7FEFF 		bl	mem_cpy
 5670              	.LVL829:
3378:lib/ff/ff.c   **** 				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 5671              		.loc 1 3378 0
 5672 00d2 85F85940 		strb	r4, [r5, #89]
 5673 00d6 0798     		ldr	r0, [sp, #28]
 5674              	.LVL830:
3379:lib/ff/ff.c   **** 					pcl = 0;
 5675              		.loc 1 3379 0
 5676 00d8 059A     		ldr	r2, [sp, #20]
 5677 00da 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 5678 00dc 0329     		cmp	r1, #3
 5679 00de 03D1     		bne	.L722
3379:lib/ff/ff.c   **** 					pcl = 0;
 5680              		.loc 1 3379 0 is_stmt 0 discriminator 1
 5681 00e0 D46A     		ldr	r4, [r2, #44]
3380:lib/ff/ff.c   **** 				st_clust(dir+SZ_DIR, pcl);
 5682              		.loc 1 3380 0 is_stmt 1 discriminator 1
 5683 00e2 A042     		cmp	r0, r4
 5684 00e4 08BF     		it	eq
 5685 00e6 0020     		moveq	r0, #0
 5686              	.LVL831:
 5687              	.L722:
 5688              	.LBB121:
 5689              	.LBB122:
1262:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 5690              		.loc 1 1262 0
 5691 00e8 A5F87200 		strh	r0, [r5, #114]	@ movhi
1263:lib/ff/ff.c   **** }
 5692              		.loc 1 1263 0
 5693 00ec 030C     		lsrs	r3, r0, #16
 5694 00ee A5F86C30 		strh	r3, [r5, #108]	@ movhi
 5695              	.LBE122:
 5696              	.LBE121:
3382:lib/ff/ff.c   **** 					dj.fs->winsect = dsc++;
 5697              		.loc 1 3382 0
 5698 00f2 9578     		ldrb	r5, [r2, #2]	@ zero_extendqisi2
 5699              	.LVL832:
 5700              	.L723:
3382:lib/ff/ff.c   **** 					dj.fs->winsect = dsc++;
 5701              		.loc 1 3382 0 is_stmt 0 discriminator 1
 5702 00f4 A5B1     		cbz	r5, .L741
 5703              	.L725:
3383:lib/ff/ff.c   **** 					dj.fs->wflag = 1;
 5704              		.loc 1 3383 0 is_stmt 1
 5705 00f6 0598     		ldr	r0, [sp, #20]
 5706 00f8 C0F83480 		str	r8, [r0, #52]
 5707 00fc 08F10108 		add	r8, r8, #1
 5708              	.LVL833:
3384:lib/ff/ff.c   **** 					res = sync_window(dj.fs);
 5709              		.loc 1 3384 0
 5710 0100 0124     		movs	r4, #1
 5711 0102 0471     		strb	r4, [r0, #4]
3385:lib/ff/ff.c   **** 					if (res != FR_OK) break;
 5712              		.loc 1 3385 0
 5713 0104 FFF7FEFF 		bl	sync_window
 5714              	.LVL834:
3386:lib/ff/ff.c   **** 					mem_set(dir, 0, SS(dj.fs));
 5715              		.loc 1 3386 0
 5716 0108 0446     		mov	r4, r0
 5717 010a 0028     		cmp	r0, #0
 5718 010c A7D1     		bne	.L728
3387:lib/ff/ff.c   **** 				}
 5719              		.loc 1 3387 0
 5720 010e 3846     		mov	r0, r7
 5721              	.LVL835:
 5722 0110 2146     		mov	r1, r4
 5723 0112 4FF40072 		mov	r2, #512
 5724 0116 FFF7FEFF 		bl	mem_set
 5725              	.LVL836:
3382:lib/ff/ff.c   **** 					dj.fs->winsect = dsc++;
 5726              		.loc 1 3382 0
 5727 011a 013D     		subs	r5, r5, #1
 5728              	.LVL837:
 5729 011c EDB2     		uxtb	r5, r5
 5730              	.LVL838:
 5731 011e E9E7     		b	.L723
 5732              	.LVL839:
 5733              	.L741:
3390:lib/ff/ff.c   **** 			if (res != FR_OK) {
 5734              		.loc 1 3390 0 discriminator 1
 5735 0120 05A8     		add	r0, sp, #20
 5736 0122 FFF7FEFF 		bl	dir_register
 5737              	.LVL840:
3391:lib/ff/ff.c   **** 				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
 5738              		.loc 1 3391 0 discriminator 1
 5739 0126 0446     		mov	r4, r0
 5740 0128 0028     		cmp	r0, #0
 5741 012a 98D1     		bne	.L728
 5742              	.L726:
3394:lib/ff/ff.c   **** 				dir[DIR_Attr] = AM_DIR;				/* Attribute */
 5743              		.loc 1 3394 0
 5744 012c 0A98     		ldr	r0, [sp, #40]
 5745              	.LVL841:
3395:lib/ff/ff.c   **** 				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
 5746              		.loc 1 3395 0
 5747 012e 1022     		movs	r2, #16
 5748 0130 C272     		strb	r2, [r0, #11]
3396:lib/ff/ff.c   **** 				st_clust(dir, dcl);					/* Table start cluster */
 5749              		.loc 1 3396 0
 5750 0132 C0F81690 		str	r9, [r0, #22]
 5751              	.LVL842:
 5752              	.LBB123:
 5753              	.LBB124:
1262:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 5754              		.loc 1 1262 0
 5755 0136 A0F81AB0 		strh	fp, [r0, #26]	@ movhi
1263:lib/ff/ff.c   **** }
 5756              		.loc 1 1263 0
 5757 013a A0F814A0 		strh	sl, [r0, #20]	@ movhi
 5758              	.LBE124:
 5759              	.LBE123:
3398:lib/ff/ff.c   **** 				res = sync_fs(dj.fs);
 5760              		.loc 1 3398 0
 5761 013e 0598     		ldr	r0, [sp, #20]
 5762              	.LVL843:
 5763 0140 0121     		movs	r1, #1
 5764 0142 0171     		strb	r1, [r0, #4]
3399:lib/ff/ff.c   **** 			}
 5765              		.loc 1 3399 0
 5766 0144 FFF7FEFF 		bl	sync_fs
 5767              	.LVL844:
 5768 0148 0446     		mov	r4, r0
 5769              	.LVL845:
 5770              	.L736:
3406:lib/ff/ff.c   **** 
 5771              		.loc 1 3406 0
 5772 014a 2046     		mov	r0, r4
 5773 014c 0DB0     		add	sp, sp, #52
 5774 014e BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
 5775              		.cfi_endproc
 5776              	.LFE44:
 5778              		.section	.text.f_chmod,"ax",%progbits
 5779              		.align	1
 5780              		.global	f_chmod
 5781              		.thumb
 5782              		.thumb_func
 5784              	f_chmod:
 5785              	.LFB45:
3420:lib/ff/ff.c   **** 	FRESULT res;
 5786              		.loc 1 3420 0
 5787              		.cfi_startproc
 5788              		@ args = 0, pretend = 0, frame = 48
 5789              		@ frame_needed = 0, uses_anonymous_args = 0
 5790              	.LVL846:
 5791 0000 30B5     		push	{r4, r5, lr}
 5792              	.LCFI41:
 5793              		.cfi_def_cfa_offset 12
 5794              		.cfi_offset 4, -12
 5795              		.cfi_offset 5, -8
 5796              		.cfi_offset 14, -4
 5797 0002 8DB0     		sub	sp, sp, #52
 5798              	.LCFI42:
 5799              		.cfi_def_cfa_offset 64
 5800 0004 0CAB     		add	r3, sp, #48
 5801 0006 43F82C0D 		str	r0, [r3, #-44]!
 5802 000a 0C46     		mov	r4, r1
 5803 000c 1546     		mov	r5, r2
3427:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5804              		.loc 1 3427 0
 5805 000e 1846     		mov	r0, r3
 5806              	.LVL847:
 5807 0010 05A9     		add	r1, sp, #20
 5808              	.LVL848:
 5809 0012 0122     		movs	r2, #1
 5810              	.LVL849:
 5811 0014 FFF7FEFF 		bl	chk_mounted
 5812              	.LVL850:
3428:lib/ff/ff.c   **** 		INIT_BUF(dj);
 5813              		.loc 1 3428 0
 5814 0018 F0B9     		cbnz	r0, .L749
3429:lib/ff/ff.c   **** 		res = follow_path(&dj, path);		/* Follow the file path */
 5815              		.loc 1 3429 0
 5816 001a 02A8     		add	r0, sp, #8
 5817              	.LVL851:
 5818 001c 0B90     		str	r0, [sp, #44]
3430:lib/ff/ff.c   **** 		FREE_BUF();
 5819              		.loc 1 3430 0
 5820 001e 05A8     		add	r0, sp, #20
 5821              	.LVL852:
 5822 0020 0199     		ldr	r1, [sp, #4]
 5823 0022 FFF7FEFF 		bl	follow_path
 5824              	.LVL853:
3432:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 5825              		.loc 1 3432 0
 5826 0026 B8B9     		cbnz	r0, .L749
3432:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 5827              		.loc 1 3432 0 is_stmt 0 discriminator 1
 5828 0028 0B99     		ldr	r1, [sp, #44]
 5829 002a CA7A     		ldrb	r2, [r1, #11]	@ zero_extendqisi2
 5830 002c 02F02003 		and	r3, r2, #32
 5831 0030 D8B2     		uxtb	r0, r3
 5832              	.LVL854:
 5833 0032 80B9     		cbnz	r0, .L747
 5834              	.LVL855:
3435:lib/ff/ff.c   **** 			if (!dir) {						/* Is it a root directory? */
 5835              		.loc 1 3435 0 is_stmt 1
 5836 0034 0A9B     		ldr	r3, [sp, #40]
 5837              	.LVL856:
3436:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
 5838              		.loc 1 3436 0
 5839 0036 73B1     		cbz	r3, .L747
 5840              	.L751:
3439:lib/ff/ff.c   **** 				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 5841              		.loc 1 3439 0
 5842 0038 05F02702 		and	r2, r5, #39
 5843              	.LVL857:
3440:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
 5844              		.loc 1 3440 0
 5845 003c D97A     		ldrb	r1, [r3, #11]	@ zero_extendqisi2
 5846 003e 21EA0201 		bic	r1, r1, r2
 5847 0042 1440     		ands	r4, r4, r2
 5848 0044 41EA0400 		orr	r0, r1, r4
 5849 0048 D872     		strb	r0, [r3, #11]
3441:lib/ff/ff.c   **** 				res = sync_fs(dj.fs);
 5850              		.loc 1 3441 0
 5851 004a 0598     		ldr	r0, [sp, #20]
 5852 004c 0123     		movs	r3, #1
 5853              	.LVL858:
 5854 004e 0371     		strb	r3, [r0, #4]
3442:lib/ff/ff.c   **** 			}
 5855              		.loc 1 3442 0
 5856 0050 FFF7FEFF 		bl	sync_fs
 5857              	.LVL859:
 5858 0054 00E0     		b	.L749
 5859              	.LVL860:
 5860              	.L747:
3433:lib/ff/ff.c   **** 		if (res == FR_OK) {
 5861              		.loc 1 3433 0
 5862 0056 0620     		movs	r0, #6
 5863              	.LVL861:
 5864              	.L749:
3448:lib/ff/ff.c   **** 
 5865              		.loc 1 3448 0
 5866 0058 0DB0     		add	sp, sp, #52
 5867 005a 30BD     		pop	{r4, r5, pc}
 5868              		.cfi_endproc
 5869              	.LFE45:
 5871              		.section	.text.f_utime,"ax",%progbits
 5872              		.align	1
 5873              		.global	f_utime
 5874              		.thumb
 5875              		.thumb_func
 5877              	f_utime:
 5878              	.LFB46:
3461:lib/ff/ff.c   **** 	FRESULT res;
 5879              		.loc 1 3461 0
 5880              		.cfi_startproc
 5881              		@ args = 0, pretend = 0, frame = 48
 5882              		@ frame_needed = 0, uses_anonymous_args = 0
 5883              	.LVL862:
 5884 0000 10B5     		push	{r4, lr}
 5885              	.LCFI43:
 5886              		.cfi_def_cfa_offset 8
 5887              		.cfi_offset 4, -8
 5888              		.cfi_offset 14, -4
 5889 0002 8CB0     		sub	sp, sp, #48
 5890              	.LCFI44:
 5891              		.cfi_def_cfa_offset 56
 5892 0004 0CAB     		add	r3, sp, #48
 5893 0006 43F82C0D 		str	r0, [r3, #-44]!
 5894 000a 0C46     		mov	r4, r1
3468:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5895              		.loc 1 3468 0
 5896 000c 1846     		mov	r0, r3
 5897              	.LVL863:
 5898 000e 05A9     		add	r1, sp, #20
 5899              	.LVL864:
 5900 0010 0122     		movs	r2, #1
 5901 0012 FFF7FEFF 		bl	chk_mounted
 5902              	.LVL865:
3469:lib/ff/ff.c   **** 		INIT_BUF(dj);
 5903              		.loc 1 3469 0
 5904 0016 C8B9     		cbnz	r0, .L759
3470:lib/ff/ff.c   **** 		res = follow_path(&dj, path);	/* Follow the file path */
 5905              		.loc 1 3470 0
 5906 0018 02A8     		add	r0, sp, #8
 5907              	.LVL866:
 5908 001a 0B90     		str	r0, [sp, #44]
3471:lib/ff/ff.c   **** 		FREE_BUF();
 5909              		.loc 1 3471 0
 5910 001c 05A8     		add	r0, sp, #20
 5911              	.LVL867:
 5912 001e 0199     		ldr	r1, [sp, #4]
 5913 0020 FFF7FEFF 		bl	follow_path
 5914              	.LVL868:
3473:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 5915              		.loc 1 3473 0
 5916 0024 90B9     		cbnz	r0, .L759
3473:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 5917              		.loc 1 3473 0 is_stmt 0 discriminator 1
 5918 0026 0B99     		ldr	r1, [sp, #44]
 5919 0028 CA7A     		ldrb	r2, [r1, #11]	@ zero_extendqisi2
 5920 002a 02F02003 		and	r3, r2, #32
 5921 002e D8B2     		uxtb	r0, r3
 5922              	.LVL869:
 5923 0030 58B9     		cbnz	r0, .L757
 5924              	.LVL870:
3476:lib/ff/ff.c   **** 			if (!dir) {					/* Root directory */
 5925              		.loc 1 3476 0 is_stmt 1
 5926 0032 0A99     		ldr	r1, [sp, #40]
 5927              	.LVL871:
3477:lib/ff/ff.c   **** 				res = FR_INVALID_NAME;
 5928              		.loc 1 3477 0
 5929 0034 49B1     		cbz	r1, .L757
 5930              	.L761:
3480:lib/ff/ff.c   **** 				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 5931              		.loc 1 3480 0
 5932 0036 E288     		ldrh	r2, [r4, #6]
 5933 0038 CA82     		strh	r2, [r1, #22]	@ movhi
3481:lib/ff/ff.c   **** 				dj.fs->wflag = 1;
 5934              		.loc 1 3481 0
 5935 003a A388     		ldrh	r3, [r4, #4]
 5936 003c 0B83     		strh	r3, [r1, #24]	@ movhi
3482:lib/ff/ff.c   **** 				res = sync_fs(dj.fs);
 5937              		.loc 1 3482 0
 5938 003e 0598     		ldr	r0, [sp, #20]
 5939 0040 0121     		movs	r1, #1
 5940              	.LVL872:
 5941 0042 0171     		strb	r1, [r0, #4]
3483:lib/ff/ff.c   **** 			}
 5942              		.loc 1 3483 0
 5943 0044 FFF7FEFF 		bl	sync_fs
 5944              	.LVL873:
 5945 0048 00E0     		b	.L759
 5946              	.LVL874:
 5947              	.L757:
3474:lib/ff/ff.c   **** 		if (res == FR_OK) {
 5948              		.loc 1 3474 0
 5949 004a 0620     		movs	r0, #6
 5950              	.LVL875:
 5951              	.L759:
3489:lib/ff/ff.c   **** 
 5952              		.loc 1 3489 0
 5953 004c 0CB0     		add	sp, sp, #48
 5954 004e 10BD     		pop	{r4, pc}
 5955              		.cfi_endproc
 5956              	.LFE46:
 5958              		.section	.text.f_rename,"ax",%progbits
 5959              		.align	1
 5960              		.global	f_rename
 5961              		.thumb
 5962              		.thumb_func
 5964              	f_rename:
 5965              	.LFB47:
3502:lib/ff/ff.c   **** 	FRESULT res;
 5966              		.loc 1 3502 0
 5967              		.cfi_startproc
 5968              		@ args = 0, pretend = 0, frame = 104
 5969              		@ frame_needed = 0, uses_anonymous_args = 0
 5970              	.LVL876:
 5971 0000 30B5     		push	{r4, r5, lr}
 5972              	.LCFI45:
 5973              		.cfi_def_cfa_offset 12
 5974              		.cfi_offset 4, -12
 5975              		.cfi_offset 5, -8
 5976              		.cfi_offset 14, -4
 5977 0002 9BB0     		sub	sp, sp, #108
 5978              	.LCFI46:
 5979              		.cfi_def_cfa_offset 120
 5980 0004 1AAB     		add	r3, sp, #104
 5981 0006 43F8640D 		str	r0, [r3, #-100]!
 5982 000a 0C46     		mov	r4, r1
3510:lib/ff/ff.c   **** 	if (res == FR_OK) {
 5983              		.loc 1 3510 0
 5984 000c 1846     		mov	r0, r3
 5985              	.LVL877:
 5986 000e 0CA9     		add	r1, sp, #48
 5987              	.LVL878:
 5988 0010 0122     		movs	r2, #1
 5989 0012 FFF7FEFF 		bl	chk_mounted
 5990              	.LVL879:
3511:lib/ff/ff.c   **** 		djn.fs = djo.fs;
 5991              		.loc 1 3511 0
 5992 0016 0028     		cmp	r0, #0
 5993 0018 77D1     		bne	.L780
3512:lib/ff/ff.c   **** 		INIT_BUF(djo);
 5994              		.loc 1 3512 0
 5995 001a 0C98     		ldr	r0, [sp, #48]
 5996              	.LVL880:
 5997 001c 1390     		str	r0, [sp, #76]
3513:lib/ff/ff.c   **** 		res = follow_path(&djo, path_old);		/* Check old object */
 5998              		.loc 1 3513 0
 5999 001e 03A9     		add	r1, sp, #12
 6000 0020 1291     		str	r1, [sp, #72]
3514:lib/ff/ff.c   **** 		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
 6001              		.loc 1 3514 0
 6002 0022 0CA8     		add	r0, sp, #48
 6003              	.LVL881:
 6004 0024 0199     		ldr	r1, [sp, #4]
 6005 0026 FFF7FEFF 		bl	follow_path
 6006              	.LVL882:
3515:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 6007              		.loc 1 3515 0
 6008 002a 0028     		cmp	r0, #0
 6009 002c 6DD1     		bne	.L780
3515:lib/ff/ff.c   **** 			res = FR_INVALID_NAME;
 6010              		.loc 1 3515 0 is_stmt 0 discriminator 1
 6011 002e 129A     		ldr	r2, [sp, #72]
 6012 0030 D37A     		ldrb	r3, [r2, #11]	@ zero_extendqisi2
 6013 0032 03F02000 		and	r0, r3, #32
 6014              	.LVL883:
 6015 0036 C1B2     		uxtb	r1, r0
 6016 0038 0029     		cmp	r1, #0
 6017 003a 5BD1     		bne	.L774
 6018              	.LVL884:
3521:lib/ff/ff.c   **** 				res = FR_NO_FILE;
 6019              		.loc 1 3521 0 is_stmt 1
 6020 003c 1199     		ldr	r1, [sp, #68]
 6021 003e 0029     		cmp	r1, #0
 6022 0040 56D0     		beq	.L785
 6023              	.L784:
3524:lib/ff/ff.c   **** 				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
 6024              		.loc 1 3524 0
 6025 0042 06A8     		add	r0, sp, #24
 6026 0044 0B31     		adds	r1, r1, #11
 6027 0046 1522     		movs	r2, #21
 6028 0048 FFF7FEFF 		bl	mem_cpy
 6029              	.LVL885:
3525:lib/ff/ff.c   **** 				res = follow_path(&djn, path_new);
 6030              		.loc 1 3525 0
 6031 004c 13A8     		add	r0, sp, #76
 6032 004e 0CA9     		add	r1, sp, #48
 6033 0050 1C22     		movs	r2, #28
 6034 0052 FFF7FEFF 		bl	mem_cpy
 6035              	.LVL886:
3526:lib/ff/ff.c   **** 				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
 6036              		.loc 1 3526 0
 6037 0056 13A8     		add	r0, sp, #76
 6038 0058 2146     		mov	r1, r4
 6039 005a FFF7FEFF 		bl	follow_path
 6040              	.LVL887:
3527:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
 6041              		.loc 1 3527 0
 6042 005e 0028     		cmp	r0, #0
 6043 0060 44D0     		beq	.L775
3528:lib/ff/ff.c   **** /* Start critical section that any interruption can cause a cross-link */
 6044              		.loc 1 3528 0
 6045 0062 0428     		cmp	r0, #4
 6046 0064 51D1     		bne	.L780
3530:lib/ff/ff.c   **** 					if (res == FR_OK) {
 6047              		.loc 1 3530 0
 6048 0066 13A8     		add	r0, sp, #76
 6049              	.LVL888:
 6050 0068 FFF7FEFF 		bl	dir_register
 6051              	.LVL889:
3531:lib/ff/ff.c   **** 						dir = djn.dir;					/* Copy object information except for name */
 6052              		.loc 1 3531 0
 6053 006c 0028     		cmp	r0, #0
 6054 006e 4CD1     		bne	.L780
3532:lib/ff/ff.c   **** 						mem_cpy(dir+13, buf+2, 19);
 6055              		.loc 1 3532 0
 6056 0070 189C     		ldr	r4, [sp, #96]
 6057              	.LVL890:
3533:lib/ff/ff.c   **** 						dir[DIR_Attr] = buf[0] | AM_ARC;
 6058              		.loc 1 3533 0
 6059 0072 04F10D00 		add	r0, r4, #13
 6060              	.LVL891:
 6061 0076 0DF11A01 		add	r1, sp, #26
 6062 007a 1322     		movs	r2, #19
 6063 007c FFF7FEFF 		bl	mem_cpy
 6064              	.LVL892:
3534:lib/ff/ff.c   **** 						djo.fs->wflag = 1;
 6065              		.loc 1 3534 0
 6066 0080 9DF81850 		ldrb	r5, [sp, #24]	@ zero_extendqisi2
 6067 0084 45F02002 		orr	r2, r5, #32
 6068 0088 E272     		strb	r2, [r4, #11]
3535:lib/ff/ff.c   **** 						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the direct
 6069              		.loc 1 3535 0
 6070 008a 0C9D     		ldr	r5, [sp, #48]
 6071 008c 0123     		movs	r3, #1
 6072 008e 2B71     		strb	r3, [r5, #4]
3536:lib/ff/ff.c   **** 							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
 6073              		.loc 1 3536 0
 6074 0090 1598     		ldr	r0, [sp, #84]
 6075 0092 0E99     		ldr	r1, [sp, #56]
 6076 0094 8142     		cmp	r1, r0
 6077 0096 2FD0     		beq	.L771
3536:lib/ff/ff.c   **** 							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
 6078              		.loc 1 3536 0 is_stmt 0 discriminator 1
 6079 0098 E27A     		ldrb	r2, [r4, #11]	@ zero_extendqisi2
 6080 009a 02F01003 		and	r3, r2, #16
 6081 009e D8B2     		uxtb	r0, r3
 6082 00a0 50B3     		cbz	r0, .L771
 6083              	.LVL893:
 6084              	.LBB129:
 6085              	.LBB130:
1247:lib/ff/ff.c   **** 	if (fs->fs_type == FS_FAT32)
 6086              		.loc 1 1247 0 is_stmt 1
 6087 00a2 618B     		ldrh	r1, [r4, #26]
 6088              	.LVL894:
1248:lib/ff/ff.c   **** 		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 6089              		.loc 1 1248 0
 6090 00a4 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 6091 00a6 032A     		cmp	r2, #3
1249:lib/ff/ff.c   **** 
 6092              		.loc 1 1249 0
 6093 00a8 04BF     		itt	eq
 6094 00aa A28A     		ldrheq	r2, [r4, #20]
 6095 00ac 41EA0241 		orreq	r1, r1, r2, lsl #16
 6096              	.LVL895:
 6097              	.LBE130:
 6098              	.LBE129:
3537:lib/ff/ff.c   **** 							if (!dw) {
 6099              		.loc 1 3537 0
 6100 00b0 2846     		mov	r0, r5
 6101 00b2 FFF7FEFF 		bl	clust2sect
 6102              	.LVL896:
3538:lib/ff/ff.c   **** 								res = FR_INT_ERR;
 6103              		.loc 1 3538 0
 6104 00b6 0146     		mov	r1, r0
 6105 00b8 30B3     		cbz	r0, .L776
3541:lib/ff/ff.c   **** 								dir = djo.fs->win+SZ_DIR;	/* .. entry */
 6106              		.loc 1 3541 0
 6107 00ba 2846     		mov	r0, r5
 6108              	.LVL897:
 6109 00bc FFF7FEFF 		bl	move_window
 6110              	.LVL898:
3542:lib/ff/ff.c   **** 								if (res == FR_OK && dir[1] == '.') {
 6111              		.loc 1 3542 0
 6112 00c0 0C9B     		ldr	r3, [sp, #48]
 6113              	.LVL899:
3543:lib/ff/ff.c   **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 6114              		.loc 1 3543 0
 6115 00c2 10BB     		cbnz	r0, .L780
3543:lib/ff/ff.c   **** 									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 6116              		.loc 1 3543 0 is_stmt 0 discriminator 1
 6117 00c4 93F85910 		ldrb	r1, [r3, #89]	@ zero_extendqisi2
 6118 00c8 2E29     		cmp	r1, #46
 6119 00ca 15D1     		bne	.L771
3544:lib/ff/ff.c   **** 									st_clust(dir, dw);
 6120              		.loc 1 3544 0 is_stmt 1
 6121 00cc 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6122 00ce 032A     		cmp	r2, #3
 6123 00d0 03D1     		bne	.L769
3544:lib/ff/ff.c   **** 									st_clust(dir, dw);
 6124              		.loc 1 3544 0 is_stmt 0 discriminator 2
 6125 00d2 DA6A     		ldr	r2, [r3, #44]
 6126 00d4 1599     		ldr	r1, [sp, #84]
 6127 00d6 9142     		cmp	r1, r2
 6128 00d8 00D0     		beq	.L770
 6129              	.L769:
3544:lib/ff/ff.c   **** 									st_clust(dir, dw);
 6130              		.loc 1 3544 0 discriminator 1
 6131 00da 1598     		ldr	r0, [sp, #84]
 6132              	.LVL900:
 6133              	.L770:
 6134              	.LBB131:
 6135              	.LBB132:
1262:lib/ff/ff.c   **** 	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 6136              		.loc 1 1262 0 is_stmt 1 discriminator 3
 6137 00dc A3F87200 		strh	r0, [r3, #114]	@ movhi
1263:lib/ff/ff.c   **** }
 6138              		.loc 1 1263 0 discriminator 3
 6139 00e0 000C     		lsrs	r0, r0, #16
 6140              	.LVL901:
 6141 00e2 A3F86C00 		strh	r0, [r3, #108]	@ movhi
 6142              	.LBE132:
 6143              	.LBE131:
3546:lib/ff/ff.c   **** 								}
 6144              		.loc 1 3546 0 discriminator 3
 6145 00e6 0122     		movs	r2, #1
 6146 00e8 1A71     		strb	r2, [r3, #4]
 6147 00ea 05E0     		b	.L771
 6148              	.LVL902:
 6149              	.L775:
3527:lib/ff/ff.c   **** 				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
 6150              		.loc 1 3527 0
 6151 00ec 0820     		movs	r0, #8
 6152              	.LVL903:
 6153 00ee 0CE0     		b	.L780
 6154              	.LVL904:
 6155              	.L785:
3522:lib/ff/ff.c   **** 			} else {
 6156              		.loc 1 3522 0
 6157 00f0 0420     		movs	r0, #4
 6158 00f2 0AE0     		b	.L780
 6159              	.LVL905:
 6160              	.L774:
3516:lib/ff/ff.c   **** #if _FS_LOCK
 6161              		.loc 1 3516 0
 6162 00f4 0620     		movs	r0, #6
 6163              	.LVL906:
 6164 00f6 08E0     		b	.L780
 6165              	.LVL907:
 6166              	.L771:
3551:lib/ff/ff.c   **** 							if (res == FR_OK)
 6167              		.loc 1 3551 0
 6168 00f8 0CA8     		add	r0, sp, #48
 6169 00fa FFF7FEFF 		bl	dir_remove
 6170              	.LVL908:
3552:lib/ff/ff.c   **** 								res = sync_fs(djo.fs);
 6171              		.loc 1 3552 0
 6172 00fe 20B9     		cbnz	r0, .L780
3553:lib/ff/ff.c   **** 						}
 6173              		.loc 1 3553 0
 6174 0100 0C98     		ldr	r0, [sp, #48]
 6175              	.LVL909:
 6176 0102 FFF7FEFF 		bl	sync_fs
 6177              	.LVL910:
 6178 0106 00E0     		b	.L780
 6179              	.LVL911:
 6180              	.L776:
3539:lib/ff/ff.c   **** 							} else {
 6181              		.loc 1 3539 0
 6182 0108 0220     		movs	r0, #2
 6183              	.LVL912:
 6184              	.L780:
3564:lib/ff/ff.c   **** 
 6185              		.loc 1 3564 0
 6186 010a 1BB0     		add	sp, sp, #108
 6187 010c 30BD     		pop	{r4, r5, pc}
 6188              		.cfi_endproc
 6189              	.LFE47:
 6191              		.section	.text.f_getlabel,"ax",%progbits
 6192              		.align	1
 6193              		.global	f_getlabel
 6194              		.thumb
 6195              		.thumb_func
 6197              	f_getlabel:
 6198              	.LFB48:
3583:lib/ff/ff.c   **** 	FRESULT res;
 6199              		.loc 1 3583 0
 6200              		.cfi_startproc
 6201              		@ args = 0, pretend = 0, frame = 40
 6202              		@ frame_needed = 0, uses_anonymous_args = 0
 6203              	.LVL913:
 6204 0000 70B5     		push	{r4, r5, r6, lr}
 6205              	.LCFI47:
 6206              		.cfi_def_cfa_offset 16
 6207              		.cfi_offset 4, -16
 6208              		.cfi_offset 5, -12
 6209              		.cfi_offset 6, -8
 6210              		.cfi_offset 14, -4
 6211 0002 8AB0     		sub	sp, sp, #40
 6212              	.LCFI48:
 6213              		.cfi_def_cfa_offset 56
 6214 0004 0AAB     		add	r3, sp, #40
 6215 0006 43F8240D 		str	r0, [r3, #-36]!
 6216 000a 0D46     		mov	r5, r1
 6217 000c 1646     		mov	r6, r2
3590:lib/ff/ff.c   **** 
 6218              		.loc 1 3590 0
 6219 000e 1846     		mov	r0, r3
 6220              	.LVL914:
 6221 0010 03A9     		add	r1, sp, #12
 6222              	.LVL915:
 6223 0012 0022     		movs	r2, #0
 6224              	.LVL916:
 6225 0014 FFF7FEFF 		bl	chk_mounted
 6226              	.LVL917:
3593:lib/ff/ff.c   **** 		dj.sclust = 0;					/* Open root dir */
 6227              		.loc 1 3593 0
 6228 0018 0446     		mov	r4, r0
 6229 001a 68BB     		cbnz	r0, .L801
3593:lib/ff/ff.c   **** 		dj.sclust = 0;					/* Open root dir */
 6230              		.loc 1 3593 0 is_stmt 0 discriminator 1
 6231 001c DDB1     		cbz	r5, .L790
3594:lib/ff/ff.c   **** 		res = dir_sdi(&dj, 0);
 6232              		.loc 1 3594 0 is_stmt 1
 6233 001e 0590     		str	r0, [sp, #20]
3595:lib/ff/ff.c   **** 		if (res == FR_OK) {
 6234              		.loc 1 3595 0
 6235 0020 03A8     		add	r0, sp, #12
 6236              	.LVL918:
 6237 0022 2146     		mov	r1, r4
 6238 0024 FFF7FEFF 		bl	dir_sdi
 6239              	.LVL919:
3596:lib/ff/ff.c   **** 			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
 6240              		.loc 1 3596 0
 6241 0028 28BB     		cbnz	r0, .L794
3597:lib/ff/ff.c   **** 			if (res == FR_OK) {			/* A volume label is exist */
 6242              		.loc 1 3597 0
 6243 002a 03A8     		add	r0, sp, #12
 6244              	.LVL920:
 6245 002c 0121     		movs	r1, #1
 6246 002e FFF7FEFF 		bl	dir_read
 6247              	.LVL921:
3598:lib/ff/ff.c   **** #if _LFN_UNICODE
 6248              		.loc 1 3598 0
 6249 0032 68B9     		cbnz	r0, .L789
3609:lib/ff/ff.c   **** #endif
 6250              		.loc 1 3609 0
 6251 0034 2846     		mov	r0, r5
 6252              	.LVL922:
 6253 0036 0899     		ldr	r1, [sp, #32]
 6254 0038 0B22     		movs	r2, #11
 6255 003a FFF7FEFF 		bl	mem_cpy
 6256              	.LVL923:
3611:lib/ff/ff.c   **** 				do {
 6257              		.loc 1 3611 0
 6258 003e 0B20     		movs	r0, #11
 6259              	.LVL924:
 6260              	.L791:
3613:lib/ff/ff.c   **** 					if (!j) break;
 6261              		.loc 1 3613 0
 6262 0040 0022     		movs	r2, #0
 6263 0042 2A54     		strb	r2, [r5, r0]
3614:lib/ff/ff.c   **** 				} while (label[--j] == ' ');
 6264              		.loc 1 3614 0
 6265 0044 38B1     		cbz	r0, .L790
3615:lib/ff/ff.c   **** 			}
 6266              		.loc 1 3615 0
 6267 0046 0138     		subs	r0, r0, #1
 6268              	.LVL925:
 6269 0048 2956     		ldrsb	r1, [r5, r0]
 6270 004a 2029     		cmp	r1, #32
 6271 004c F8D0     		beq	.L791
 6272 004e 02E0     		b	.L790
 6273              	.LVL926:
 6274              	.L789:
3617:lib/ff/ff.c   **** 				label[0] = 0;
 6275              		.loc 1 3617 0
 6276 0050 0428     		cmp	r0, #4
 6277 0052 10D1     		bne	.L794
3618:lib/ff/ff.c   **** 				res = FR_OK;
 6278              		.loc 1 3618 0
 6279 0054 2C70     		strb	r4, [r5, #0]
 6280              	.LVL927:
 6281              	.L790:
3625:lib/ff/ff.c   **** 		res = move_window(dj.fs, dj.fs->volbase);
 6282              		.loc 1 3625 0 discriminator 1
 6283 0056 7EB1     		cbz	r6, .L801
3626:lib/ff/ff.c   **** 		if (res == FR_OK) {
 6284              		.loc 1 3626 0
 6285 0058 0398     		ldr	r0, [sp, #12]
 6286 005a 416A     		ldr	r1, [r0, #36]
 6287 005c FFF7FEFF 		bl	move_window
 6288              	.LVL928:
3627:lib/ff/ff.c   **** 			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
 6289              		.loc 1 3627 0
 6290 0060 0446     		mov	r4, r0
 6291 0062 48B9     		cbnz	r0, .L801
3628:lib/ff/ff.c   **** 			*sn = LD_DWORD(&dj.fs->win[i]);
 6292              		.loc 1 3628 0
 6293 0064 039B     		ldr	r3, [sp, #12]
 6294 0066 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6295              	.LVL929:
3629:lib/ff/ff.c   **** 		}
 6296              		.loc 1 3629 0
 6297 0068 032A     		cmp	r2, #3
 6298 006a 14BF     		ite	ne
 6299 006c 5F20     		movne	r0, #95
 6300 006e 7B20     		moveq	r0, #123
 6301              	.LVL930:
 6302 0070 1958     		ldr	r1, [r3, r0]
 6303 0072 3160     		str	r1, [r6, #0]
 6304 0074 00E0     		b	.L801
 6305              	.LVL931:
 6306              	.L794:
3596:lib/ff/ff.c   **** 			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
 6307              		.loc 1 3596 0
 6308 0076 0446     		mov	r4, r0
 6309              	.LVL932:
 6310              	.L801:
3634:lib/ff/ff.c   **** 
 6311              		.loc 1 3634 0
 6312 0078 2046     		mov	r0, r4
 6313 007a 0AB0     		add	sp, sp, #40
 6314 007c 70BD     		pop	{r4, r5, r6, pc}
 6315              		.cfi_endproc
 6316              	.LFE48:
 6318              		.section	.text.f_setlabel,"ax",%progbits
 6319              		.align	1
 6320              		.global	f_setlabel
 6321              		.thumb
 6322              		.thumb_func
 6324              	f_setlabel:
 6325              	.LFB49:
3646:lib/ff/ff.c   **** 	FRESULT res;
 6326              		.loc 1 3646 0
 6327              		.cfi_startproc
 6328              		@ args = 0, pretend = 0, frame = 48
 6329              		@ frame_needed = 0, uses_anonymous_args = 0
 6330              	.LVL933:
 6331 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 6332              	.LCFI49:
 6333              		.cfi_def_cfa_offset 20
 6334              		.cfi_offset 4, -20
 6335              		.cfi_offset 5, -16
 6336              		.cfi_offset 6, -12
 6337              		.cfi_offset 7, -8
 6338              		.cfi_offset 14, -4
 6339 0002 8DB0     		sub	sp, sp, #52
 6340              	.LCFI50:
 6341              		.cfi_def_cfa_offset 72
 6342 0004 0CAB     		add	r3, sp, #48
 6343 0006 43F82C0D 		str	r0, [r3, #-44]!
3656:lib/ff/ff.c   **** 	if (res) LEAVE_FF(dj.fs, res);
 6344              		.loc 1 3656 0
 6345 000a 1846     		mov	r0, r3
 6346              	.LVL934:
 6347 000c 05A9     		add	r1, sp, #20
 6348 000e 0122     		movs	r2, #1
 6349 0010 FFF7FEFF 		bl	chk_mounted
 6350              	.LVL935:
 6351 0014 0446     		mov	r4, r0
 6352              	.LVL936:
3657:lib/ff/ff.c   **** 
 6353              		.loc 1 3657 0
 6354 0016 0028     		cmp	r0, #0
 6355 0018 40F0A480 		bne	.L847
3660:lib/ff/ff.c   **** 	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
 6356              		.loc 1 3660 0
 6357 001c 8DF80800 		strb	r0, [sp, #8]
 6358              	.LVL937:
3661:lib/ff/ff.c   **** 	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
 6359              		.loc 1 3661 0
 6360 0020 019C     		ldr	r4, [sp, #4]
 6361              	.LVL938:
 6362              	.L814:
3661:lib/ff/ff.c   **** 	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
 6363              		.loc 1 3661 0 is_stmt 0 discriminator 1
 6364 0022 2156     		ldrsb	r1, [r4, r0]
 6365 0024 39B1     		cbz	r1, .L851
 6366              	.L815:
3661:lib/ff/ff.c   **** 	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
 6367              		.loc 1 3661 0 discriminator 2
 6368 0026 0130     		adds	r0, r0, #1
 6369              	.LVL939:
 6370 0028 FBE7     		b	.L814
 6371              	.L817:
3643:lib/ff/ff.c   **** 	const TCHAR* label	/* Pointer to the volume label to set */
 6372              		.loc 1 3643 0 is_stmt 1 discriminator 2
 6373 002a 2218     		adds	r2, r4, r0
3662:lib/ff/ff.c   **** 	if (sl) {	/* Create volume label in directory form */
 6374              		.loc 1 3662 0 discriminator 2
 6375 002c 12F9013C 		ldrsb	r3, [r2, #-1]
 6376 0030 202B     		cmp	r3, #32
 6377 0032 0CD1     		bne	.L856
 6378              	.L819:
3662:lib/ff/ff.c   **** 	if (sl) {	/* Create volume label in directory form */
 6379              		.loc 1 3662 0 is_stmt 0 discriminator 1
 6380 0034 0138     		subs	r0, r0, #1
 6381              	.LVL940:
 6382              	.L851:
 6383 0036 0028     		cmp	r0, #0
 6384 0038 F7D1     		bne	.L817
 6385              	.L830:
3692:lib/ff/ff.c   **** 	res = dir_sdi(&dj, 0);
 6386              		.loc 1 3692 0 is_stmt 1
 6387 003a 0021     		movs	r1, #0
 6388 003c 0791     		str	r1, [sp, #28]
3693:lib/ff/ff.c   **** 	if (res == FR_OK) {
 6389              		.loc 1 3693 0
 6390 003e 05A8     		add	r0, sp, #20
 6391              	.LVL941:
 6392 0040 FFF7FEFF 		bl	dir_sdi
 6393              	.LVL942:
3694:lib/ff/ff.c   **** 		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
 6394              		.loc 1 3694 0
 6395 0044 0446     		mov	r4, r0
 6396 0046 0028     		cmp	r0, #0
 6397 0048 40F08C80 		bne	.L847
 6398 004c 34E0     		b	.L857
 6399              	.LVL943:
 6400              	.L856:
3662:lib/ff/ff.c   **** 	if (sl) {	/* Create volume label in directory form */
 6401              		.loc 1 3662 0
 6402 004e 0023     		movs	r3, #0
 6403 0050 1D46     		mov	r5, r3
 6404              	.L827:
 6405              	.LVL944:
3669:lib/ff/ff.c   **** 			if (IsDBCS1(w))
 6406              		.loc 1 3669 0
 6407 0052 625D     		ldrb	r2, [r4, r5]	@ zero_extendqisi2
 6408              	.LVL945:
 6409 0054 691C     		adds	r1, r5, #1
 6410              	.LVL946:
3670:lib/ff/ff.c   **** 				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? (w << 8) | (BYTE)label[i++] : 0;
 6411              		.loc 1 3670 0
 6412 0056 02F17F06 		add	r6, r2, #127
 6413 005a F6B2     		uxtb	r6, r6
 6414 005c 1E2E     		cmp	r6, #30
 6415 005e 04D9     		bls	.L820
3670:lib/ff/ff.c   **** 				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? (w << 8) | (BYTE)label[i++] : 0;
 6416              		.loc 1 3670 0 is_stmt 0 discriminator 1
 6417 0060 02F12006 		add	r6, r2, #32
 6418 0064 F6B2     		uxtb	r6, r6
 6419 0066 1C2E     		cmp	r6, #28
 6420 0068 14D8     		bhi	.L821
 6421              	.L820:
3671:lib/ff/ff.c   **** #if _USE_LFN
 6422              		.loc 1 3671 0 is_stmt 1
 6423 006a 092B     		cmp	r3, #9
 6424 006c 11D8     		bhi	.L840
3671:lib/ff/ff.c   **** #if _USE_LFN
 6425              		.loc 1 3671 0 is_stmt 0 discriminator 1
 6426 006e 8142     		cmp	r1, r0
 6427 0070 0FD2     		bcs	.L840
 6428 0072 675C     		ldrb	r7, [r4, r1]	@ zero_extendqisi2
 6429 0074 FEB2     		uxtb	r6, r7
 6430 0076 A6F1400C 		sub	ip, r6, #64
 6431 007a BCF13E0F 		cmp	ip, #62
 6432 007e 04D9     		bls	.L822
3671:lib/ff/ff.c   **** #if _USE_LFN
 6433              		.loc 1 3671 0 discriminator 2
 6434 0080 17F0800F 		tst	r7, #128
 6435 0084 05D0     		beq	.L840
3671:lib/ff/ff.c   **** #if _USE_LFN
 6436              		.loc 1 3671 0 discriminator 1
 6437 0086 FC2E     		cmp	r6, #252
 6438 0088 03D8     		bhi	.L840
 6439              	.L822:
 6440 008a 46EA0222 		orr	r2, r6, r2, lsl #8
 6441              	.LVL947:
 6442 008e A91C     		adds	r1, r5, #2
 6443              	.LVL948:
 6444 0090 00E0     		b	.L821
 6445              	.LVL949:
 6446              	.L840:
3671:lib/ff/ff.c   **** #if _USE_LFN
 6447              		.loc 1 3671 0
 6448 0092 0022     		movs	r2, #0
 6449              	.LVL950:
 6450              	.L821:
3675:lib/ff/ff.c   **** #ifdef _EXCVT
 6451              		.loc 1 3675 0 is_stmt 1
 6452 0094 A2F16105 		sub	r5, r2, #97
 6453 0098 192D     		cmp	r5, #25
 6454 009a 02D8     		bhi	.L823
3675:lib/ff/ff.c   **** #ifdef _EXCVT
 6455              		.loc 1 3675 0 is_stmt 0 discriminator 1
 6456 009c 203A     		subs	r2, r2, #32
 6457              	.LVL951:
 6458 009e 92B2     		uxth	r2, r2
 6459              	.LVL952:
 6460 00a0 01E0     		b	.L824
 6461              	.L823:
3683:lib/ff/ff.c   **** 				LEAVE_FF(dj.fs, FR_INVALID_NAME);
 6462              		.loc 1 3683 0 is_stmt 1
 6463 00a2 002A     		cmp	r2, #0
 6464 00a4 43D0     		beq	.L845
 6465              	.LVL953:
 6466              	.L824:
 6467 00a6 314E     		ldr	r6, .L859
 6468              	.LVL954:
 6469              	.L826:
 6470              	.LBB135:
 6471              	.LBB136:
 576:lib/ff/ff.c   **** 	return *str;
 6472              		.loc 1 576 0
 6473 00a8 16F8015F 		ldrb	r5, [r6, #1]!	@ zero_extendqisi2
 6474 00ac 002D     		cmp	r5, #0
 6475 00ae 3AD0     		beq	.L825
 6476 00b0 6DB2     		sxtb	r5, r5
 6477 00b2 9542     		cmp	r5, r2
 6478 00b4 F8D1     		bne	.L826
 6479 00b6 3AE0     		b	.L845
 6480              	.LVL955:
 6481              	.L857:
 6482              	.LBE136:
 6483              	.LBE135:
3695:lib/ff/ff.c   **** 		if (res == FR_OK) {			/* A volume label is found */
 6484              		.loc 1 3695 0
 6485 00b8 05A8     		add	r0, sp, #20
 6486              	.LVL956:
 6487 00ba 0121     		movs	r1, #1
 6488 00bc FFF7FEFF 		bl	dir_read
 6489              	.LVL957:
3696:lib/ff/ff.c   **** 			if (vn[0]) {
 6490              		.loc 1 3696 0
 6491 00c0 60B9     		cbnz	r0, .L831
3697:lib/ff/ff.c   **** 				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
 6492              		.loc 1 3697 0
 6493 00c2 9DF80810 		ldrb	r1, [sp, #8]	@ zero_extendqisi2
 6494 00c6 29B1     		cbz	r1, .L832
3698:lib/ff/ff.c   **** 				tm = get_fattime();
 6495              		.loc 1 3698 0
 6496 00c8 0A98     		ldr	r0, [sp, #40]
 6497              	.LVL958:
 6498 00ca 02A9     		add	r1, sp, #8
 6499 00cc 0B22     		movs	r2, #11
 6500 00ce FFF7FEFF 		bl	mem_cpy
 6501              	.LVL959:
 6502 00d2 1CE0     		b	.L855
 6503              	.LVL960:
 6504              	.L832:
3702:lib/ff/ff.c   **** 			}
 6505              		.loc 1 3702 0
 6506 00d4 E524     		movs	r4, #229
 6507 00d6 0A98     		ldr	r0, [sp, #40]
 6508              	.LVL961:
 6509 00d8 0470     		strb	r4, [r0, #0]
 6510 00da 1DE0     		b	.L854
 6511              	.LVL962:
 6512              	.L831:
3707:lib/ff/ff.c   **** 				res = FR_OK;
 6513              		.loc 1 3707 0
 6514 00dc 0428     		cmp	r0, #4
 6515 00de 20D1     		bne	.L843
 6516              	.LVL963:
3709:lib/ff/ff.c   **** 					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
 6517              		.loc 1 3709 0
 6518 00e0 9DF80800 		ldrb	r0, [sp, #8]	@ zero_extendqisi2
 6519 00e4 0028     		cmp	r0, #0
 6520 00e6 3DD0     		beq	.L847
3710:lib/ff/ff.c   **** 					if (res == FR_OK) {
 6521              		.loc 1 3710 0
 6522 00e8 05A8     		add	r0, sp, #20
 6523 00ea FFF7FEFF 		bl	dir_alloc.constprop.9
 6524              	.LVL964:
3711:lib/ff/ff.c   **** 						mem_set(dj.dir, 0, SZ_DIR);	/* Set volume label */
 6525              		.loc 1 3711 0
 6526 00ee 0446     		mov	r4, r0
 6527 00f0 0028     		cmp	r0, #0
 6528 00f2 37D1     		bne	.L847
3712:lib/ff/ff.c   **** 						mem_cpy(dj.dir, vn, 11);
 6529              		.loc 1 3712 0
 6530 00f4 0A98     		ldr	r0, [sp, #40]
 6531              	.LVL965:
 6532 00f6 2146     		mov	r1, r4
 6533 00f8 2022     		movs	r2, #32
 6534 00fa FFF7FEFF 		bl	mem_set
 6535              	.LVL966:
3713:lib/ff/ff.c   **** 						dj.dir[DIR_Attr] = AM_VOL;
 6536              		.loc 1 3713 0
 6537 00fe 0A98     		ldr	r0, [sp, #40]
 6538 0100 02A9     		add	r1, sp, #8
 6539 0102 0B22     		movs	r2, #11
 6540 0104 FFF7FEFF 		bl	mem_cpy
 6541              	.LVL967:
3714:lib/ff/ff.c   **** 						tm = get_fattime();
 6542              		.loc 1 3714 0
 6543 0108 0822     		movs	r2, #8
 6544 010a 0A9B     		ldr	r3, [sp, #40]
 6545 010c DA72     		strb	r2, [r3, #11]
 6546              	.L855:
3715:lib/ff/ff.c   **** 						ST_DWORD(dj.dir+DIR_WrtTime, tm);
 6547              		.loc 1 3715 0
 6548 010e FFF7FEFF 		bl	get_fattime
 6549              	.LVL968:
3716:lib/ff/ff.c   **** 						dj.fs->wflag = 1;
 6550              		.loc 1 3716 0
 6551 0112 0A9A     		ldr	r2, [sp, #40]
 6552 0114 C2F81600 		str	r0, [r2, #22]
 6553              	.LVL969:
 6554              	.L854:
3717:lib/ff/ff.c   **** 						res = sync_fs(dj.fs);
 6555              		.loc 1 3717 0
 6556 0118 0598     		ldr	r0, [sp, #20]
 6557 011a 0123     		movs	r3, #1
 6558 011c 0371     		strb	r3, [r0, #4]
3718:lib/ff/ff.c   **** 					}
 6559              		.loc 1 3718 0
 6560 011e FFF7FEFF 		bl	sync_fs
 6561              	.LVL970:
 6562              	.L843:
3707:lib/ff/ff.c   **** 				res = FR_OK;
 6563              		.loc 1 3707 0
 6564 0122 0446     		mov	r4, r0
 6565 0124 1EE0     		b	.L847
 6566              	.LVL971:
 6567              	.L825:
3683:lib/ff/ff.c   **** 				LEAVE_FF(dj.fs, FR_INVALID_NAME);
 6568              		.loc 1 3683 0
 6569 0126 FF2A     		cmp	r2, #255
 6570 0128 03D8     		bhi	.L858
 6571              	.L834:
 6572 012a 0A2B     		cmp	r3, #10
 6573 012c 09D9     		bls	.L836
 6574              	.LVL972:
 6575              	.L845:
3684:lib/ff/ff.c   **** 			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
 6576              		.loc 1 3684 0
 6577 012e 0624     		movs	r4, #6
 6578 0130 18E0     		b	.L847
 6579              	.LVL973:
 6580              	.L858:
3683:lib/ff/ff.c   **** 				LEAVE_FF(dj.fs, FR_INVALID_NAME);
 6581              		.loc 1 3683 0
 6582 0132 092B     		cmp	r3, #9
 6583 0134 FBD8     		bhi	.L845
 6584              	.L853:
3685:lib/ff/ff.c   **** 			vn[j++] = (BYTE)w;
 6585              		.loc 1 3685 0 discriminator 1
 6586 0136 0CAD     		add	r5, sp, #48
 6587 0138 ED18     		adds	r5, r5, r3
 6588 013a 160A     		lsrs	r6, r2, #8
 6589 013c 05F8286C 		strb	r6, [r5, #-40]
 6590 0140 0133     		adds	r3, r3, #1
 6591              	.LVL974:
 6592              	.L836:
3686:lib/ff/ff.c   **** 		} while (i < sl);
 6593              		.loc 1 3686 0
 6594 0142 0CAE     		add	r6, sp, #48
 6595 0144 F518     		adds	r5, r6, r3
 6596 0146 05F8282C 		strb	r2, [r5, #-40]
 6597 014a 0133     		adds	r3, r3, #1
 6598              	.LVL975:
3687:lib/ff/ff.c   **** 		while (j < 11) vn[j++] = ' ';
 6599              		.loc 1 3687 0
 6600 014c 8142     		cmp	r1, r0
 6601 014e 01D2     		bcs	.L852
 6602              	.L842:
 6603 0150 0D46     		mov	r5, r1
 6604 0152 7EE7     		b	.L827
 6605              	.LVL976:
 6606              	.L852:
3688:lib/ff/ff.c   **** 	}
 6607              		.loc 1 3688 0 discriminator 1
 6608 0154 0A2B     		cmp	r3, #10
 6609 0156 3FF670AF 		bhi	.L830
 6610              	.L829:
3688:lib/ff/ff.c   **** 	}
 6611              		.loc 1 3688 0 is_stmt 0 discriminator 2
 6612 015a 2021     		movs	r1, #32
 6613 015c 02AC     		add	r4, sp, #8
 6614 015e 1955     		strb	r1, [r3, r4]
 6615 0160 0133     		adds	r3, r3, #1
 6616              	.LVL977:
 6617 0162 F7E7     		b	.L852
 6618              	.LVL978:
 6619              	.L847:
3726:lib/ff/ff.c   **** 
 6620              		.loc 1 3726 0 is_stmt 1
 6621 0164 2046     		mov	r0, r4
 6622 0166 0DB0     		add	sp, sp, #52
 6623 0168 F0BD     		pop	{r4, r5, r6, r7, pc}
 6624              	.L860:
 6625 016a 00BF     		.align	2
 6626              	.L859:
 6627 016c FFFFFFFF 		.word	.LC1-1
 6628              		.cfi_endproc
 6629              	.LFE49:
 6631              		.section	.text.f_forward,"ax",%progbits
 6632              		.align	1
 6633              		.global	f_forward
 6634              		.thumb
 6635              		.thumb_func
 6637              	f_forward:
 6638              	.LFB50:
3744:lib/ff/ff.c   **** 	FRESULT res;
 6639              		.loc 1 3744 0
 6640              		.cfi_startproc
 6641              		@ args = 0, pretend = 0, frame = 0
 6642              		@ frame_needed = 0, uses_anonymous_args = 0
 6643              	.LVL979:
 6644 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
 6645              	.LCFI51:
 6646              		.cfi_def_cfa_offset 32
 6647              		.cfi_offset 4, -32
 6648              		.cfi_offset 5, -28
 6649              		.cfi_offset 6, -24
 6650              		.cfi_offset 7, -20
 6651              		.cfi_offset 8, -16
 6652              		.cfi_offset 9, -12
 6653              		.cfi_offset 10, -8
 6654              		.cfi_offset 14, -4
 6655 0004 0446     		mov	r4, r0
 6656 0006 8846     		mov	r8, r1
 6657 0008 9146     		mov	r9, r2
 6658 000a 1F46     		mov	r7, r3
3751:lib/ff/ff.c   **** 
 6659              		.loc 1 3751 0
 6660 000c 0023     		movs	r3, #0
 6661              	.LVL980:
 6662 000e 3B60     		str	r3, [r7, #0]
3753:lib/ff/ff.c   **** 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 6663              		.loc 1 3753 0
 6664 0010 FFF7FEFF 		bl	validate
 6665              	.LVL981:
3754:lib/ff/ff.c   **** 	if (fp->flag & FA__ERROR)						/* Check error flag */
 6666              		.loc 1 3754 0
 6667 0014 0546     		mov	r5, r0
 6668 0016 0028     		cmp	r0, #0
 6669 0018 5DD1     		bne	.L862
3755:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_INT_ERR);
 6670              		.loc 1 3755 0
 6671 001a A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
 6672              	.LVL982:
 6673 001c 0106     		lsls	r1, r0, #24
 6674 001e 57D4     		bmi	.L875
3757:lib/ff/ff.c   **** 		LEAVE_FF(fp->fs, FR_DENIED);
 6675              		.loc 1 3757 0
 6676 0020 C207     		lsls	r2, r0, #31
 6677 0022 57D5     		bpl	.L876
 6678              	.LVL983:
3760:lib/ff/ff.c   **** 	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
 6679              		.loc 1 3760 0
 6680 0024 E168     		ldr	r1, [r4, #12]
 6681 0026 A268     		ldr	r2, [r4, #8]
 6682 0028 8E1A     		subs	r6, r1, r2
 6683              	.LVL984:
 6684 002a B145     		cmp	r9, r6
 6685 002c 38BF     		it	cc
 6686 002e 4E46     		movcc	r6, r9
 6687              	.LVL985:
 6688              	.L863:
3763:lib/ff/ff.c   **** 		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
 6689              		.loc 1 3763 0 discriminator 1
 6690 0030 002E     		cmp	r6, #0
 6691 0032 50D0     		beq	.L862
3763:lib/ff/ff.c   **** 		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
 6692              		.loc 1 3763 0 is_stmt 0 discriminator 2
 6693 0034 0020     		movs	r0, #0
 6694 0036 0146     		mov	r1, r0
 6695 0038 C047     		blx	r8
 6696              	.LVL986:
 6697 003a 0028     		cmp	r0, #0
 6698 003c 4BD0     		beq	.L862
 6699              	.L873:
3765:lib/ff/ff.c   **** 		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 6700              		.loc 1 3765 0 is_stmt 1
 6701 003e A368     		ldr	r3, [r4, #8]
 6702 0040 2068     		ldr	r0, [r4, #0]
 6703 0042 90F80290 		ldrb	r9, [r0, #2]	@ zero_extendqisi2
 6704 0046 09F1FF31 		add	r1, r9, #-1
 6705 004a 01EA5322 		and	r2, r1, r3, lsr #9
 6706 004e 5FFA82F9 		uxtb	r9, r2
 6707              	.LVL987:
3766:lib/ff/ff.c   **** 			if (!csect) {							/* On the cluster boundary? */
 6708              		.loc 1 3766 0
 6709 0052 DA05     		lsls	r2, r3, #23
 6710              	.LVL988:
 6711 0054 0DD1     		bne	.L864
3767:lib/ff/ff.c   **** 				clst = (fp->fptr == 0) ?			/* On the top of the file? */
 6712              		.loc 1 3767 0
 6713 0056 B9F1000F 		cmp	r9, #0
 6714 005a 0AD1     		bne	.L864
3769:lib/ff/ff.c   **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
 6715              		.loc 1 3769 0
 6716 005c 0BB9     		cbnz	r3, .L865
3769:lib/ff/ff.c   **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
 6717              		.loc 1 3769 0 is_stmt 0 discriminator 1
 6718 005e 2069     		ldr	r0, [r4, #16]
 6719 0060 02E0     		b	.L866
 6720              	.L865:
3769:lib/ff/ff.c   **** 				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
 6721              		.loc 1 3769 0 discriminator 2
 6722 0062 6169     		ldr	r1, [r4, #20]
 6723 0064 FFF7FEFF 		bl	get_fat
 6724              	.LVL989:
 6725              	.L866:
3770:lib/ff/ff.c   **** 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 6726              		.loc 1 3770 0 is_stmt 1
 6727 0068 0128     		cmp	r0, #1
 6728 006a 24D9     		bls	.L878
 6729              	.L867:
3771:lib/ff/ff.c   **** 				fp->clust = clst;					/* Update current cluster */
 6730              		.loc 1 3771 0
 6731 006c 431C     		adds	r3, r0, #1
 6732 006e 0DD0     		beq	.L877
 6733              	.L868:
3772:lib/ff/ff.c   **** 			}
 6734              		.loc 1 3772 0
 6735 0070 6061     		str	r0, [r4, #20]
 6736              	.LVL990:
 6737              	.L864:
3775:lib/ff/ff.c   **** 		if (!sect) ABORT(fp->fs, FR_INT_ERR);
 6738              		.loc 1 3775 0
 6739 0072 D4F800A0 		ldr	sl, [r4, #0]
 6740 0076 5046     		mov	r0, sl
 6741 0078 6169     		ldr	r1, [r4, #20]
 6742 007a FFF7FEFF 		bl	clust2sect
 6743              	.LVL991:
3776:lib/ff/ff.c   **** 		sect += csect;
 6744              		.loc 1 3776 0
 6745 007e D0B1     		cbz	r0, .L878
 6746              	.L869:
3777:lib/ff/ff.c   **** 		if (move_window(fp->fs, sect))				/* Move sector window */
 6747              		.loc 1 3777 0
 6748 0080 8144     		add	r9, r0, r9
 6749              	.LVL992:
3778:lib/ff/ff.c   **** 			ABORT(fp->fs, FR_DISK_ERR);
 6750              		.loc 1 3778 0
 6751 0082 5046     		mov	r0, sl
 6752 0084 4946     		mov	r1, r9
 6753 0086 FFF7FEFF 		bl	move_window
 6754              	.LVL993:
 6755 008a 28B1     		cbz	r0, .L870
 6756              	.LVL994:
 6757              	.L877:
3779:lib/ff/ff.c   **** 		fp->dsect = sect;
 6758              		.loc 1 3779 0
 6759 008c A579     		ldrb	r5, [r4, #6]	@ zero_extendqisi2
 6760 008e 65F07F00 		orn	r0, r5, #127
 6761 0092 A071     		strb	r0, [r4, #6]
 6762 0094 0125     		movs	r5, #1
 6763 0096 1EE0     		b	.L862
 6764              	.LVL995:
 6765              	.L870:
3780:lib/ff/ff.c   **** 		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
 6766              		.loc 1 3780 0
 6767 0098 C4F81890 		str	r9, [r4, #24]
3781:lib/ff/ff.c   **** 		if (rcnt > btf) rcnt = btf;
 6768              		.loc 1 3781 0
 6769 009c A068     		ldr	r0, [r4, #8]
 6770 009e C305     		lsls	r3, r0, #23
 6771 00a0 DA0D     		lsrs	r2, r3, #23
 6772 00a2 C2F50071 		rsb	r1, r2, #512
 6773              	.LVL996:
3783:lib/ff/ff.c   **** 		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
 6774              		.loc 1 3783 0
 6775 00a6 3832     		adds	r2, r2, #56
 6776 00a8 2068     		ldr	r0, [r4, #0]
 6777 00aa 8018     		adds	r0, r0, r2
 6778 00ac 8E42     		cmp	r6, r1
 6779 00ae 38BF     		it	cc
 6780 00b0 3146     		movcc	r1, r6
 6781              	.LVL997:
 6782 00b2 C047     		blx	r8
 6783              	.LVL998:
3784:lib/ff/ff.c   **** 	}
 6784              		.loc 1 3784 0
 6785 00b4 20B9     		cbnz	r0, .L871
 6786              	.LVL999:
 6787              	.L878:
3784:lib/ff/ff.c   **** 	}
 6788              		.loc 1 3784 0 is_stmt 0 discriminator 1
 6789 00b6 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 6790 00b8 63F07F02 		orn	r2, r3, #127
 6791 00bc A271     		strb	r2, [r4, #6]
 6792 00be 07E0     		b	.L875
 6793              	.LVL1000:
 6794              	.L871:
3764:lib/ff/ff.c   **** 		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 6795              		.loc 1 3764 0 is_stmt 1
 6796 00c0 A168     		ldr	r1, [r4, #8]
 6797 00c2 0B18     		adds	r3, r1, r0
 6798 00c4 A360     		str	r3, [r4, #8]
 6799 00c6 3A68     		ldr	r2, [r7, #0]
 6800 00c8 1118     		adds	r1, r2, r0
 6801 00ca 3960     		str	r1, [r7, #0]
 6802 00cc 361A     		subs	r6, r6, r0
 6803              	.LVL1001:
 6804 00ce AFE7     		b	.L863
 6805              	.LVL1002:
 6806              	.L875:
3756:lib/ff/ff.c   **** 	if (!(fp->flag & FA_READ))						/* Check access mode */
 6807              		.loc 1 3756 0
 6808 00d0 0225     		movs	r5, #2
 6809 00d2 00E0     		b	.L862
 6810              	.LVL1003:
 6811              	.L876:
3758:lib/ff/ff.c   **** 
 6812              		.loc 1 3758 0
 6813 00d4 0725     		movs	r5, #7
 6814              	.LVL1004:
 6815              	.L862:
3788:lib/ff/ff.c   **** #endif /* _USE_FORWARD */
 6816              		.loc 1 3788 0
 6817 00d6 2846     		mov	r0, r5
 6818 00d8 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 6819              		.cfi_endproc
 6820              	.LFE50:
 6822              		.section	.text.f_mkfs,"ax",%progbits
 6823              		.align	1
 6824              		.global	f_mkfs
 6825              		.thumb
 6826              		.thumb_func
 6828              	f_mkfs:
 6829              	.LFB51:
3806:lib/ff/ff.c   **** 	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
 6830              		.loc 1 3806 0
 6831              		.cfi_startproc
 6832              		@ args = 0, pretend = 0, frame = 32
 6833              		@ frame_needed = 0, uses_anonymous_args = 0
 6834              	.LVL1005:
 6835 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 6836              	.LCFI52:
 6837              		.cfi_def_cfa_offset 36
 6838              		.cfi_offset 4, -36
 6839              		.cfi_offset 5, -32
 6840              		.cfi_offset 6, -28
 6841              		.cfi_offset 7, -24
 6842              		.cfi_offset 8, -20
 6843              		.cfi_offset 9, -16
 6844              		.cfi_offset 10, -12
 6845              		.cfi_offset 11, -8
 6846              		.cfi_offset 14, -4
 6847 0004 89B0     		sub	sp, sp, #36
 6848              	.LCFI53:
 6849              		.cfi_def_cfa_offset 72
 6850 0006 0E46     		mov	r6, r1
 6851 0008 1746     		mov	r7, r2
3819:lib/ff/ff.c   **** 	if (sfd > 1) return FR_INVALID_PARAMETER;
 6852              		.loc 1 3819 0
 6853 000a 0028     		cmp	r0, #0
 6854 000c 40F0FE81 		bne	.L919
3820:lib/ff/ff.c   **** 	if (au & (au - 1)) return FR_INVALID_PARAMETER;
 6855              		.loc 1 3820 0
 6856 0010 0129     		cmp	r1, #1
 6857 0012 00F2FD81 		bhi	.L921
3821:lib/ff/ff.c   **** 	fs = FatFs[vol];
 6858              		.loc 1 3821 0
 6859 0016 531E     		subs	r3, r2, #1
 6860 0018 13EA0201 		ands	r1, r3, r2
 6861              	.LVL1006:
 6862 001c 40F0F881 		bne	.L921
3822:lib/ff/ff.c   **** 	if (!fs) return FR_NOT_ENABLED;
 6863              		.loc 1 3822 0
 6864 0020 B14A     		ldr	r2, .L951
 6865              	.LVL1007:
 6866 0022 1468     		ldr	r4, [r2, #0]
 6867              	.LVL1008:
3823:lib/ff/ff.c   **** 	fs->fs_type = 0;
 6868              		.loc 1 3823 0
 6869 0024 002C     		cmp	r4, #0
 6870 0026 00F0F581 		beq	.L922
3824:lib/ff/ff.c   **** 	pdrv = LD2PD(vol);	/* Physical drive */
 6871              		.loc 1 3824 0
 6872 002a 2170     		strb	r1, [r4, #0]
 6873              	.LVL1009:
3829:lib/ff/ff.c   **** 	if (stat & STA_NOINIT) return FR_NOT_READY;
 6874              		.loc 1 3829 0
 6875 002c FFF7FEFF 		bl	disk_initialize
 6876              	.LVL1010:
3830:lib/ff/ff.c   **** 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 6877              		.loc 1 3830 0
 6878 0030 C307     		lsls	r3, r0, #31
 6879 0032 00F1F181 		bmi	.L923
3831:lib/ff/ff.c   **** #if _MAX_SS != 512					/* Get disk sector size */
 6880              		.loc 1 3831 0
 6881 0036 00F00400 		and	r0, r0, #4
 6882              	.LVL1011:
 6883 003a C0B2     		uxtb	r0, r0
 6884 003c 0028     		cmp	r0, #0
 6885 003e 40F0ED81 		bne	.L924
3846:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 6886              		.loc 1 3846 0
 6887 0042 0121     		movs	r1, #1
 6888 0044 05AA     		add	r2, sp, #20
 6889 0046 FFF7FEFF 		bl	disk_ioctl
 6890              	.LVL1012:
 6891 004a 08B1     		cbz	r0, .L881
 6892              	.LVL1013:
 6893              	.L882:
3847:lib/ff/ff.c   **** 		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
 6894              		.loc 1 3847 0
 6895 004c 0120     		movs	r0, #1
 6896 004e 00E2     		b	.L944
 6897              	.LVL1014:
 6898              	.L881:
3846:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 6899              		.loc 1 3846 0 discriminator 1
 6900 0050 059B     		ldr	r3, [sp, #20]
 6901 0052 7F2B     		cmp	r3, #127
 6902 0054 FAD9     		bls	.L882
3848:lib/ff/ff.c   **** 		n_vol -= b_vol;				/* Volume size */
 6903              		.loc 1 3848 0
 6904 0056 002E     		cmp	r6, #0
 6905 0058 0CBF     		ite	eq
 6906 005a 4FF03F08 		moveq	r8, #63
 6907 005e 4FF00008 		movne	r8, #0
 6908              	.LVL1015:
3849:lib/ff/ff.c   **** 	}
 6909              		.loc 1 3849 0
 6910 0062 C8EB0303 		rsb	r3, r8, r3
 6911              	.LVL1016:
 6912 0066 0593     		str	r3, [sp, #20]
 6913              	.LVL1017:
3852:lib/ff/ff.c   **** 		vs = n_vol / (2000 / (SS(fs) / 512));
 6914              		.loc 1 3852 0
 6915 0068 6FB9     		cbnz	r7, .L884
3853:lib/ff/ff.c   **** 		for (i = 0; vs < vst[i]; i++) ;
 6916              		.loc 1 3853 0
 6917 006a 4FF4FA65 		mov	r5, #2000
 6918 006e B3FBF5F5 		udiv	r5, r3, r5
 6919              	.LVL1018:
 6920              	.L885:
3854:lib/ff/ff.c   **** 		au = cst[i];
 6921              		.loc 1 3854 0 discriminator 1
 6922 0072 9E4A     		ldr	r2, .L951+4
 6923 0074 32F81700 		ldrh	r0, [r2, r7, lsl #1]
 6924 0078 8542     		cmp	r5, r0
 6925 007a 01D2     		bcs	.L948
 6926              	.L886:
3854:lib/ff/ff.c   **** 		au = cst[i];
 6927              		.loc 1 3854 0 is_stmt 0 discriminator 2
 6928 007c 0137     		adds	r7, r7, #1
 6929              	.LVL1019:
 6930 007e F8E7     		b	.L885
 6931              	.L948:
3855:lib/ff/ff.c   **** 	}
 6932              		.loc 1 3855 0 is_stmt 1
 6933 0080 9B49     		ldr	r1, .L951+8
 6934 0082 31F81770 		ldrh	r7, [r1, r7, lsl #1]
 6935              	.LVL1020:
 6936              	.L884:
3858:lib/ff/ff.c   **** 	if (au > 128) au = 128;
 6937              		.loc 1 3858 0
 6938 0086 7F0A     		lsrs	r7, r7, #9
 6939              	.LVL1021:
 6940 0088 04D0     		beq	.L926
3859:lib/ff/ff.c   **** 
 6941              		.loc 1 3859 0
 6942 008a 802F     		cmp	r7, #128
 6943 008c 28BF     		it	cs
 6944 008e 8027     		movcs	r7, #128
 6945              	.LVL1022:
 6946 0090 0197     		str	r7, [sp, #4]
 6947 0092 01E0     		b	.L888
 6948              	.LVL1023:
 6949              	.L926:
3858:lib/ff/ff.c   **** 	if (au > 128) au = 128;
 6950              		.loc 1 3858 0
 6951 0094 0125     		movs	r5, #1
 6952 0096 0195     		str	r5, [sp, #4]
 6953              	.LVL1024:
 6954              	.L888:
3862:lib/ff/ff.c   **** 	fmt = FS_FAT12;
 6955              		.loc 1 3862 0
 6956 0098 019A     		ldr	r2, [sp, #4]
 6957 009a B3FBF2F9 		udiv	r9, r3, r2
 6958              	.LVL1025:
3864:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
 6959              		.loc 1 3864 0
 6960 009e 40F6F570 		movw	r0, #4085
 6961 00a2 8145     		cmp	r9, r0
 6962 00a4 40F2BC81 		bls	.L889
 6963              	.LVL1026:
3865:lib/ff/ff.c   **** 
 6964              		.loc 1 3865 0
 6965 00a8 00F57040 		add	r0, r0, #61440
 6966 00ac 8145     		cmp	r9, r0
 6967 00ae 40F2CA81 		bls	.L949
 6968              	.L890:
 6969              	.LVL1027:
3869:lib/ff/ff.c   **** 		n_rsv = 32;
 6970              		.loc 1 3869 0
 6971 00b2 09F1820E 		add	lr, r9, #130
 6972 00b6 4FEA8E09 		lsl	r9, lr, #2
 6973              	.LVL1028:
 6974 00ba 09F1FF37 		add	r7, r9, #-1
 6975 00be 4FEA5729 		lsr	r9, r7, #9
 6976              	.LVL1029:
3865:lib/ff/ff.c   **** 
 6977              		.loc 1 3865 0
 6978 00c2 0325     		movs	r5, #3
3871:lib/ff/ff.c   **** 	} else {
 6979              		.loc 1 3871 0
 6980 00c4 0022     		movs	r2, #0
 6981 00c6 0292     		str	r2, [sp, #8]
3870:lib/ff/ff.c   **** 		n_dir = 0;
 6982              		.loc 1 3870 0
 6983 00c8 4FF0200B 		mov	fp, #32
 6984              	.LVL1030:
 6985              	.L917:
3878:lib/ff/ff.c   **** 	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
 6986              		.loc 1 3878 0
 6987 00cc 0BEB080A 		add	sl, fp, r8
 6988              	.LVL1031:
3879:lib/ff/ff.c   **** 	b_data = b_dir + n_dir;				/* Data area start sector */
 6989              		.loc 1 3879 0
 6990 00d0 0298     		ldr	r0, [sp, #8]
 6991 00d2 00EB0901 		add	r1, r0, r9
3880:lib/ff/ff.c   **** 	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
 6992              		.loc 1 3880 0
 6993 00d6 01EB0A07 		add	r7, r1, sl
 6994              	.LVL1032:
3881:lib/ff/ff.c   **** 
 6995              		.loc 1 3881 0
 6996 00da 019A     		ldr	r2, [sp, #4]
 6997 00dc C8EB0200 		rsb	r0, r8, r2
 6998 00e0 C119     		adds	r1, r0, r7
 6999 00e2 8B42     		cmp	r3, r1
 7000 00e4 01D2     		bcs	.L892
 7001              	.LVL1033:
 7002              	.L898:
 7003 00e6 0E20     		movs	r0, #14
 7004 00e8 B3E1     		b	.L944
 7005              	.LVL1034:
 7006              	.L892:
3884:lib/ff/ff.c   **** 	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
 7007              		.loc 1 3884 0
 7008 00ea 0020     		movs	r0, #0
 7009 00ec 0321     		movs	r1, #3
 7010 00ee 04AA     		add	r2, sp, #16
 7011 00f0 FFF7FEFF 		bl	disk_ioctl
 7012              	.LVL1035:
 7013 00f4 20B9     		cbnz	r0, .L893
 7014              	.LVL1036:
3884:lib/ff/ff.c   **** 	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
 7015              		.loc 1 3884 0 is_stmt 0 discriminator 2
 7016 00f6 049B     		ldr	r3, [sp, #16]
 7017 00f8 13B1     		cbz	r3, .L893
3884:lib/ff/ff.c   **** 	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
 7018              		.loc 1 3884 0 discriminator 1
 7019 00fa B3F5004F 		cmp	r3, #32768
 7020 00fe 01D9     		bls	.L894
 7021              	.L893:
 7022 0100 0122     		movs	r2, #1
 7023 0102 0492     		str	r2, [sp, #16]
 7024              	.L894:
3885:lib/ff/ff.c   **** 	n = (n - b_data) / N_FATS;
 7025              		.loc 1 3885 0 is_stmt 1
 7026 0104 0498     		ldr	r0, [sp, #16]
 7027 0106 411E     		subs	r1, r0, #1
 7028 0108 CA19     		adds	r2, r1, r7
 7029 010a 4342     		negs	r3, r0
 7030 010c 1340     		ands	r3, r3, r2
3886:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
 7031              		.loc 1 3886 0
 7032 010e DF1B     		subs	r7, r3, r7
 7033              	.LVL1037:
 7034 0110 0497     		str	r7, [sp, #16]
 7035              	.LVL1038:
3887:lib/ff/ff.c   **** 		n_rsv += n;
 7036              		.loc 1 3887 0
 7037 0112 032D     		cmp	r5, #3
3888:lib/ff/ff.c   **** 		b_fat += n;
 7038              		.loc 1 3888 0
 7039 0114 06BF     		itte	eq
 7040 0116 BB44     		addeq	fp, fp, r7
 7041              	.LVL1039:
3889:lib/ff/ff.c   **** 	} else {					/* FAT12/16: Expand FAT size */
 7042              		.loc 1 3889 0
 7043 0118 BA44     		addeq	sl, sl, r7
 7044              	.LVL1040:
3891:lib/ff/ff.c   **** 	}
 7045              		.loc 1 3891 0
 7046 011a B944     		addne	r9, r9, r7
 7047              	.LVL1041:
3895:lib/ff/ff.c   **** 	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
 7048              		.loc 1 3895 0
 7049 011c 059F     		ldr	r7, [sp, #20]
 7050              	.LVL1042:
 7051 011e CBEB0700 		rsb	r0, fp, r7
 7052 0122 C9EB0001 		rsb	r1, r9, r0
 7053 0126 029A     		ldr	r2, [sp, #8]
 7054 0128 8B1A     		subs	r3, r1, r2
 7055 012a 0198     		ldr	r0, [sp, #4]
 7056 012c B3FBF0F1 		udiv	r1, r3, r0
 7057 0130 0391     		str	r1, [sp, #12]
 7058              	.LVL1043:
3896:lib/ff/ff.c   **** 		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
 7059              		.loc 1 3896 0
 7060 0132 022D     		cmp	r5, #2
 7061 0134 05D1     		bne	.L897
3896:lib/ff/ff.c   **** 		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
 7062              		.loc 1 3896 0 is_stmt 0 discriminator 1
 7063 0136 40F6F570 		movw	r0, #4085
 7064 013a 0399     		ldr	r1, [sp, #12]
 7065 013c 8142     		cmp	r1, r0
 7066 013e D2D9     		bls	.L898
 7067 0140 0AE0     		b	.L899
 7068              	.L897:
3897:lib/ff/ff.c   **** 		return FR_MKFS_ABORTED;
 7069              		.loc 1 3897 0 is_stmt 1
 7070 0142 032D     		cmp	r5, #3
 7071 0144 06D1     		bne	.L900
3897:lib/ff/ff.c   **** 		return FR_MKFS_ABORTED;
 7072              		.loc 1 3897 0 is_stmt 0 discriminator 1
 7073 0146 4FF6F572 		movw	r2, #65525
 7074 014a 039B     		ldr	r3, [sp, #12]
 7075 014c 9342     		cmp	r3, r2
 7076 014e CAD9     		bls	.L898
3903:lib/ff/ff.c   **** 	}
 7077              		.loc 1 3903 0 is_stmt 1
 7078 0150 0C27     		movs	r7, #12
 7079 0152 08E0     		b	.L901
 7080              	.L900:
3900:lib/ff/ff.c   **** 	case FS_FAT12:	sys = 0x01; break;
 7081              		.loc 1 3900 0
 7082 0154 022D     		cmp	r5, #2
 7083 0156 05D1     		bne	.L946
 7084              	.L899:
3902:lib/ff/ff.c   **** 	default: 		sys = 0x0C;
 7085              		.loc 1 3902 0
 7086 0158 B7F5803F 		cmp	r7, #65536
 7087 015c 2CBF     		ite	cs
 7088 015e 0627     		movcs	r7, #6
 7089 0160 0427     		movcc	r7, #4
 7090 0162 00E0     		b	.L901
 7091              	.L946:
3901:lib/ff/ff.c   **** 	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
 7092              		.loc 1 3901 0
 7093 0164 0127     		movs	r7, #1
 7094              	.L901:
 7095              	.LVL1044:
3913:lib/ff/ff.c   **** 			md = 0xF0;
 7096              		.loc 1 3913 0
 7097 0166 002E     		cmp	r6, #0
 7098 0168 39D1     		bne	.L930
3916:lib/ff/ff.c   **** 			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
 7099              		.loc 1 3916 0
 7100 016a 04F1380C 		add	ip, r4, #56
 7101 016e 6046     		mov	r0, ip
 7102 0170 3146     		mov	r1, r6
 7103              	.LVL1045:
 7104 0172 4FF40072 		mov	r2, #512
 7105 0176 CDF800C0 		str	ip, [sp, #0]
 7106 017a FFF7FEFF 		bl	mem_set
 7107              	.LVL1046:
3918:lib/ff/ff.c   **** 			tbl[2] = 1;						/* Partition start sector */
 7108              		.loc 1 3918 0
 7109 017e 0123     		movs	r3, #1
 7110 0180 84F8F731 		strb	r3, [r4, #503]
3919:lib/ff/ff.c   **** 			tbl[3] = 0;						/* Partition start cylinder */
 7111              		.loc 1 3919 0
 7112 0184 84F8F831 		strb	r3, [r4, #504]
3920:lib/ff/ff.c   **** 			tbl[4] = sys;					/* System type */
 7113              		.loc 1 3920 0
 7114 0188 84F8F961 		strb	r6, [r4, #505]
3921:lib/ff/ff.c   **** 			tbl[5] = 254;					/* Partition end head */
 7115              		.loc 1 3921 0
 7116 018c 84F8FA71 		strb	r7, [r4, #506]
3922:lib/ff/ff.c   **** 			n = (b_vol + n_vol) / 63 / 255;
 7117              		.loc 1 3922 0
 7118 0190 FE22     		movs	r2, #254
 7119 0192 84F8FB21 		strb	r2, [r4, #507]
3923:lib/ff/ff.c   **** 			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partition end sector */
 7120              		.loc 1 3923 0
 7121 0196 0599     		ldr	r1, [sp, #20]
 7122 0198 08EB0100 		add	r0, r8, r1
 7123 019c 43F6C162 		movw	r2, #16065
 7124 01a0 B0FBF2F2 		udiv	r2, r0, r2
 7125              	.LVL1047:
 7126 01a4 0492     		str	r2, [sp, #16]
 7127              	.LVL1048:
3924:lib/ff/ff.c   **** 			tbl[7] = (BYTE)n;				/* End cylinder */
 7128              		.loc 1 3924 0
 7129 01a6 9008     		lsrs	r0, r2, #2
 7130 01a8 40F03F00 		orr	r0, r0, #63
 7131 01ac 84F8FC01 		strb	r0, [r4, #508]
3925:lib/ff/ff.c   **** 			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
 7132              		.loc 1 3925 0
 7133 01b0 84F8FD21 		strb	r2, [r4, #509]
3926:lib/ff/ff.c   **** 			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
 7134              		.loc 1 3926 0
 7135 01b4 3F22     		movs	r2, #63
 7136              	.LVL1049:
 7137 01b6 C4F8FE21 		str	r2, [r4, #510]
3927:lib/ff/ff.c   **** 			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
 7138              		.loc 1 3927 0
 7139 01ba C4F80212 		str	r1, [r4, #514]
3928:lib/ff/ff.c   **** 			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
 7140              		.loc 1 3928 0
 7141 01be 4AF65521 		movw	r1, #43605
 7142 01c2 A4F83612 		strh	r1, [r4, #566]	@ movhi
3929:lib/ff/ff.c   **** 				return FR_DISK_ERR;
 7143              		.loc 1 3929 0
 7144 01c6 3046     		mov	r0, r6
 7145 01c8 DDF800C0 		ldr	ip, [sp, #0]
 7146 01cc 6146     		mov	r1, ip
 7147 01ce 3246     		mov	r2, r6
 7148 01d0 FFF7FEFF 		bl	disk_write
 7149              	.LVL1050:
 7150 01d4 0028     		cmp	r0, #0
 7151 01d6 7FF439AF 		bne	.L882
3931:lib/ff/ff.c   **** 		}
 7152              		.loc 1 3931 0
 7153 01da F827     		movs	r7, #248
 7154              	.LVL1051:
 7155 01dc 00E0     		b	.L902
 7156              	.LVL1052:
 7157              	.L930:
3914:lib/ff/ff.c   **** 		} else {	/* Create partition table (FDISK) */
 7158              		.loc 1 3914 0
 7159 01de F027     		movs	r7, #240
 7160              	.LVL1053:
 7161              	.L902:
3936:lib/ff/ff.c   **** 	mem_set(tbl, 0, SS(fs));
 7162              		.loc 1 3936 0
 7163 01e0 04F13806 		add	r6, r4, #56
 7164              	.LVL1054:
3937:lib/ff/ff.c   **** 	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
 7165              		.loc 1 3937 0
 7166 01e4 3046     		mov	r0, r6
 7167 01e6 0021     		movs	r1, #0
 7168 01e8 4FF40072 		mov	r2, #512
 7169 01ec FFF7FEFF 		bl	mem_set
 7170              	.LVL1055:
3938:lib/ff/ff.c   **** 	i = SS(fs);								/* Sector size */
 7171              		.loc 1 3938 0
 7172 01f0 3046     		mov	r0, r6
 7173 01f2 4049     		ldr	r1, .L951+12
 7174 01f4 0B22     		movs	r2, #11
 7175 01f6 FFF7FEFF 		bl	mem_cpy
 7176              	.LVL1056:
3940:lib/ff/ff.c   **** 	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
 7177              		.loc 1 3940 0
 7178 01fa 4FF40073 		mov	r3, #512
 7179 01fe A4F84330 		strh	r3, [r4, #67]	@ movhi
3941:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
 7180              		.loc 1 3941 0
 7181 0202 0198     		ldr	r0, [sp, #4]
 7182 0204 84F84500 		strb	r0, [r4, #69]
3942:lib/ff/ff.c   **** 	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
 7183              		.loc 1 3942 0
 7184 0208 A4F846B0 		strh	fp, [r4, #70]	@ movhi
3943:lib/ff/ff.c   **** 	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
 7185              		.loc 1 3943 0
 7186 020c 0122     		movs	r2, #1
 7187 020e 84F84820 		strb	r2, [r4, #72]
3944:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_RootEntCnt, i);
 7188              		.loc 1 3944 0
 7189 0212 032D     		cmp	r5, #3
 7190 0214 14BF     		ite	ne
 7191 0216 4FF40071 		movne	r1, #512
 7192 021a 0021     		moveq	r1, #0
 7193              	.LVL1057:
3945:lib/ff/ff.c   **** 	if (n_vol < 0x10000) {					/* Number of total sectors */
 7194              		.loc 1 3945 0
 7195 021c A4F84910 		strh	r1, [r4, #73]	@ movhi
3946:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_TotSec16, n_vol);
 7196              		.loc 1 3946 0
 7197 0220 059B     		ldr	r3, [sp, #20]
 7198 0222 B3F5803F 		cmp	r3, #65536
3947:lib/ff/ff.c   **** 	} else {
 7199              		.loc 1 3947 0
 7200 0226 34BF     		ite	cc
 7201 0228 A4F84B30 		strhcc	r3, [r4, #75]	@ movhi
3949:lib/ff/ff.c   **** 	}
 7202              		.loc 1 3949 0
 7203 022c A365     		strcs	r3, [r4, #88]
3951:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
 7204              		.loc 1 3951 0
 7205 022e 84F84D70 		strb	r7, [r4, #77]
3952:lib/ff/ff.c   **** 	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
 7206              		.loc 1 3952 0
 7207 0232 3F20     		movs	r0, #63
 7208 0234 A4F85000 		strh	r0, [r4, #80]	@ movhi
3953:lib/ff/ff.c   **** 	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
 7209              		.loc 1 3953 0
 7210 0238 FF22     		movs	r2, #255
 7211 023a A4F85220 		strh	r2, [r4, #82]	@ movhi
3954:lib/ff/ff.c   **** 	n = get_fattime();						/* Use current time as VSN */
 7212              		.loc 1 3954 0
 7213 023e C4F85480 		str	r8, [r4, #84]
3955:lib/ff/ff.c   **** 	if (fmt == FS_FAT32) {
 7214              		.loc 1 3955 0
 7215 0242 FFF7FEFF 		bl	get_fattime
 7216              	.LVL1058:
 7217 0246 0490     		str	r0, [sp, #16]
3956:lib/ff/ff.c   **** 		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
 7218              		.loc 1 3956 0
 7219 0248 032D     		cmp	r5, #3
 7220 024a 15D1     		bne	.L906
3957:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
 7221              		.loc 1 3957 0
 7222 024c C4F87B00 		str	r0, [r4, #123]
3958:lib/ff/ff.c   **** 		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
 7223              		.loc 1 3958 0
 7224 0250 C4F85C90 		str	r9, [r4, #92]
3959:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
 7225              		.loc 1 3959 0
 7226 0254 0220     		movs	r0, #2
 7227              	.LVL1059:
 7228 0256 6066     		str	r0, [r4, #100]
3960:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
 7229              		.loc 1 3960 0
 7230 0258 0122     		movs	r2, #1
 7231 025a A4F86820 		strh	r2, [r4, #104]	@ movhi
3961:lib/ff/ff.c   **** 		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
 7232              		.loc 1 3961 0
 7233 025e 0621     		movs	r1, #6
 7234 0260 A4F86A10 		strh	r1, [r4, #106]	@ movhi
3962:lib/ff/ff.c   **** 		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
 7235              		.loc 1 3962 0
 7236 0264 8023     		movs	r3, #128
 7237 0266 84F87830 		strb	r3, [r4, #120]
3963:lib/ff/ff.c   **** 		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
 7238              		.loc 1 3963 0
 7239 026a 2920     		movs	r0, #41
 7240 026c 84F87A00 		strb	r0, [r4, #122]
3964:lib/ff/ff.c   **** 	} else {
 7241              		.loc 1 3964 0
 7242 0270 04F17F00 		add	r0, r4, #127
 7243 0274 2049     		ldr	r1, .L951+16
 7244 0276 0CE0     		b	.L947
 7245              	.L906:
3966:lib/ff/ff.c   **** 		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
 7246              		.loc 1 3966 0
 7247 0278 C4F85F00 		str	r0, [r4, #95]
3967:lib/ff/ff.c   **** 		tbl[BS_DrvNum] = 0x80;				/* Drive number */
 7248              		.loc 1 3967 0
 7249 027c A4F84E90 		strh	r9, [r4, #78]	@ movhi
3968:lib/ff/ff.c   **** 		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
 7250              		.loc 1 3968 0
 7251 0280 8021     		movs	r1, #128
 7252 0282 84F85C10 		strb	r1, [r4, #92]
3969:lib/ff/ff.c   **** 		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
 7253              		.loc 1 3969 0
 7254 0286 2923     		movs	r3, #41
 7255 0288 84F85E30 		strb	r3, [r4, #94]
3970:lib/ff/ff.c   **** 	}
 7256              		.loc 1 3970 0
 7257 028c 04F16300 		add	r0, r4, #99
 7258 0290 1A49     		ldr	r1, .L951+20
 7259              	.L947:
 7260 0292 1322     		movs	r2, #19
 7261 0294 FFF7FEFF 		bl	mem_cpy
 7262              	.LVL1060:
3972:lib/ff/ff.c   **** 	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
 7263              		.loc 1 3972 0
 7264 0298 4AF65522 		movw	r2, #43605
 7265 029c A4F83622 		strh	r2, [r4, #566]	@ movhi
3973:lib/ff/ff.c   **** 		return FR_DISK_ERR;
 7266              		.loc 1 3973 0
 7267 02a0 0020     		movs	r0, #0
 7268 02a2 3146     		mov	r1, r6
 7269 02a4 4246     		mov	r2, r8
 7270 02a6 0123     		movs	r3, #1
 7271 02a8 FFF7FEFF 		bl	disk_write
 7272              	.LVL1061:
 7273 02ac 0028     		cmp	r0, #0
 7274 02ae 7FF4CDAE 		bne	.L882
3975:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 6, 1);
 7275              		.loc 1 3975 0
 7276 02b2 032D     		cmp	r5, #3
 7277 02b4 05D1     		bne	.L908
3976:lib/ff/ff.c   **** 
 7278              		.loc 1 3976 0
 7279 02b6 3146     		mov	r1, r6
 7280 02b8 08F10602 		add	r2, r8, #6
 7281 02bc 0123     		movs	r3, #1
 7282 02be FFF7FEFF 		bl	disk_write
 7283              	.LVL1062:
 7284              	.L908:
3981:lib/ff/ff.c   **** 		n = md;								/* Media descriptor byte */
 7285              		.loc 1 3981 0 discriminator 1
 7286 02c2 3046     		mov	r0, r6
 7287 02c4 0021     		movs	r1, #0
 7288 02c6 4FF40072 		mov	r2, #512
 7289 02ca FFF7FEFF 		bl	mem_set
 7290              	.LVL1063:
3983:lib/ff/ff.c   **** 			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
 7291              		.loc 1 3983 0 discriminator 1
 7292 02ce 032D     		cmp	r5, #3
 7293 02d0 18D0     		beq	.L909
3984:lib/ff/ff.c   **** 			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
 7294              		.loc 1 3984 0
 7295 02d2 012D     		cmp	r5, #1
 7296 02d4 0A48     		ldr	r0, .L951+24
 7297 02d6 18BF     		it	ne
 7298 02d8 6FF0FF00 		mvnne	r0, #255
 7299 02dc 40EA0702 		orr	r2, r0, r7
 7300              	.LVL1064:
 7301 02e0 0492     		str	r2, [sp, #16]
 7302              	.LVL1065:
3985:lib/ff/ff.c   **** 		} else {
 7303              		.loc 1 3985 0
 7304 02e2 A263     		str	r2, [r4, #56]
 7305 02e4 18E0     		b	.L911
 7306              	.L952:
 7307 02e6 00BF     		.align	2
 7308              	.L951:
 7309 02e8 00000000 		.word	.LANCHOR1
 7310 02ec 00000000 		.word	.LANCHOR3
 7311 02f0 00000000 		.word	.LANCHOR4
 7312 02f4 1F000000 		.word	.LC2
 7313 02f8 2B000000 		.word	.LC3
 7314 02fc 3F000000 		.word	.LC4
 7315 0300 00FFFF00 		.word	16776960
 7316              	.LVL1066:
 7317              	.L909:
3987:lib/ff/ff.c   **** 			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
 7318              		.loc 1 3987 0
 7319 0304 67F0FF07 		orn	r7, r7, #255
 7320              	.LVL1067:
 7321 0308 0497     		str	r7, [sp, #16]
 7322              	.LVL1068:
3988:lib/ff/ff.c   **** 			ST_DWORD(tbl+4, 0xFFFFFFFF);
 7323              		.loc 1 3988 0
 7324 030a A763     		str	r7, [r4, #56]
3989:lib/ff/ff.c   **** 			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
 7325              		.loc 1 3989 0
 7326 030c 4FF0FF31 		mov	r1, #-1
 7327 0310 E163     		str	r1, [r4, #60]
3990:lib/ff/ff.c   **** 		}
 7328              		.loc 1 3990 0
 7329 0312 6FF07043 		mvn	r3, #-268435456
 7330 0316 2364     		str	r3, [r4, #64]
 7331              	.LVL1069:
 7332              	.L911:
3992:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 7333              		.loc 1 3992 0
 7334 0318 0AF10107 		add	r7, sl, #1
 7335              	.LVL1070:
 7336 031c 0020     		movs	r0, #0
 7337 031e 3146     		mov	r1, r6
 7338 0320 5246     		mov	r2, sl
 7339 0322 0123     		movs	r3, #1
 7340 0324 FFF7FEFF 		bl	disk_write
 7341              	.LVL1071:
 7342 0328 0146     		mov	r1, r0
 7343 032a 0028     		cmp	r0, #0
 7344 032c 7FF48EAE 		bne	.L882
3994:lib/ff/ff.c   **** 		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single se
 7345              		.loc 1 3994 0
 7346 0330 3046     		mov	r0, r6
 7347 0332 4FF40072 		mov	r2, #512
 7348 0336 FFF7FEFF 		bl	mem_set
 7349              	.LVL1072:
3995:lib/ff/ff.c   **** 			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 7350              		.loc 1 3995 0
 7351 033a 0121     		movs	r1, #1
 7352 033c 0491     		str	r1, [sp, #16]
 7353              	.LVL1073:
 7354              	.L912:
3995:lib/ff/ff.c   **** 			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 7355              		.loc 1 3995 0 is_stmt 0 discriminator 1
 7356 033e 049B     		ldr	r3, [sp, #16]
 7357 0340 4B45     		cmp	r3, r9
 7358 0342 0FD2     		bcs	.L950
 7359              	.L913:
3996:lib/ff/ff.c   **** 				return FR_DISK_ERR;
 7360              		.loc 1 3996 0 is_stmt 1
 7361 0344 07F1010A 		add	sl, r7, #1
 7362              	.LVL1074:
 7363 0348 0020     		movs	r0, #0
 7364 034a 3146     		mov	r1, r6
 7365 034c 3A46     		mov	r2, r7
 7366 034e 0123     		movs	r3, #1
 7367 0350 FFF7FEFF 		bl	disk_write
 7368              	.LVL1075:
 7369 0354 0028     		cmp	r0, #0
 7370 0356 7FF479AE 		bne	.L882
3995:lib/ff/ff.c   **** 			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 7371              		.loc 1 3995 0
 7372 035a 049F     		ldr	r7, [sp, #16]
 7373 035c 791C     		adds	r1, r7, #1
 7374 035e 0491     		str	r1, [sp, #16]
3996:lib/ff/ff.c   **** 				return FR_DISK_ERR;
 7375              		.loc 1 3996 0
 7376 0360 5746     		mov	r7, sl
 7377 0362 ECE7     		b	.L912
 7378              	.LVL1076:
 7379              	.L950:
3995:lib/ff/ff.c   **** 			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 7380              		.loc 1 3995 0
 7381 0364 BA46     		mov	sl, r7
 7382              	.LVL1077:
4002:lib/ff/ff.c   **** 	do {
 7383              		.loc 1 4002 0
 7384 0366 DDF808B0 		ldr	fp, [sp, #8]
 7385              	.LVL1078:
 7386 036a 0198     		ldr	r0, [sp, #4]
 7387 036c 032D     		cmp	r5, #3
 7388 036e 08BF     		it	eq
 7389 0370 8346     		moveq	fp, r0
 7390              	.LVL1079:
 7391              	.L915:
4004:lib/ff/ff.c   **** 			return FR_DISK_ERR;
 7392              		.loc 1 4004 0
 7393 0372 07F1010E 		add	lr, r7, #1
 7394              	.LVL1080:
 7395 0376 0020     		movs	r0, #0
 7396 0378 3146     		mov	r1, r6
 7397 037a 3A46     		mov	r2, r7
 7398 037c 0123     		movs	r3, #1
 7399 037e CDF800E0 		str	lr, [sp, #0]
 7400 0382 FFF7FEFF 		bl	disk_write
 7401              	.LVL1081:
 7402 0386 8146     		mov	r9, r0
 7403 0388 DDF800C0 		ldr	ip, [sp, #0]
 7404 038c 0028     		cmp	r0, #0
 7405 038e 7FF45DAE 		bne	.L882
 7406 0392 6746     		mov	r7, ip
 7407              	.LVL1082:
3801:lib/ff/ff.c   **** 	BYTE vol,		/* Logical drive number */
 7408              		.loc 1 3801 0
 7409 0394 0BEB0A02 		add	r2, fp, sl
4006:lib/ff/ff.c   **** 
 7410              		.loc 1 4006 0
 7411 0398 6245     		cmp	r2, ip
 7412 039a EAD1     		bne	.L915
 7413              	.LBB137:
4012:lib/ff/ff.c   **** 		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
 7414              		.loc 1 4012 0
 7415 039c CDF818C0 		str	ip, [sp, #24]
 7416 03a0 E91E     		subs	r1, r5, #3
 7417 03a2 4D42     		rsbs	r5, r1, #0
 7418 03a4 4D41     		adcs	r5, r5, r1
 7419 03a6 039B     		ldr	r3, [sp, #12]
 7420 03a8 591B     		subs	r1, r3, r5
 7421 03aa 019A     		ldr	r2, [sp, #4]
 7422 03ac 02FB01C7 		mla	r7, r2, r1, ip
 7423 03b0 013F     		subs	r7, r7, #1
 7424 03b2 0797     		str	r7, [sp, #28]
4013:lib/ff/ff.c   **** 	}
 7425              		.loc 1 4013 0
 7426 03b4 0421     		movs	r1, #4
 7427 03b6 06AA     		add	r2, sp, #24
 7428 03b8 FFF7FEFF 		bl	disk_ioctl
 7429              	.LVL1083:
 7430              	.LBE137:
4018:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
 7431              		.loc 1 4018 0
 7432 03bc EDB1     		cbz	r5, .L916
4019:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
 7433              		.loc 1 4019 0
 7434 03be 2648     		ldr	r0, .L953
 7435 03c0 A063     		str	r0, [r4, #56]
4020:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
 7436              		.loc 1 4020 0
 7437 03c2 264B     		ldr	r3, .L953+4
 7438 03c4 C4F81C32 		str	r3, [r4, #540]
4021:lib/ff/ff.c   **** 		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
 7439              		.loc 1 4021 0
 7440 03c8 0399     		ldr	r1, [sp, #12]
 7441 03ca 4A1E     		subs	r2, r1, #1
 7442 03cc C4F82022 		str	r2, [r4, #544]
4022:lib/ff/ff.c   **** 		ST_WORD(tbl+BS_55AA, 0xAA55);
 7443              		.loc 1 4022 0
 7444 03d0 0220     		movs	r0, #2
 7445 03d2 C4F82402 		str	r0, [r4, #548]
4023:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
 7446              		.loc 1 4023 0
 7447 03d6 4AF65523 		movw	r3, #43605
 7448 03da A4F83632 		strh	r3, [r4, #566]	@ movhi
4024:lib/ff/ff.c   **** 		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
 7449              		.loc 1 4024 0
 7450 03de 4846     		mov	r0, r9
 7451 03e0 3146     		mov	r1, r6
 7452 03e2 08F10102 		add	r2, r8, #1
 7453 03e6 0123     		movs	r3, #1
 7454 03e8 FFF7FEFF 		bl	disk_write
 7455              	.LVL1084:
4025:lib/ff/ff.c   **** 	}
 7456              		.loc 1 4025 0
 7457 03ec 4846     		mov	r0, r9
 7458 03ee 3146     		mov	r1, r6
 7459 03f0 08F10702 		add	r2, r8, #7
 7460 03f4 0123     		movs	r3, #1
 7461 03f6 FFF7FEFF 		bl	disk_write
 7462              	.LVL1085:
 7463              	.L916:
4028:lib/ff/ff.c   **** }
 7464              		.loc 1 4028 0
 7465 03fa 0020     		movs	r0, #0
 7466 03fc 0146     		mov	r1, r0
 7467 03fe 0246     		mov	r2, r0
 7468 0400 FFF7FEFF 		bl	disk_ioctl
 7469              	.LVL1086:
 7470 0404 0030     		adds	r0, r0, #0
 7471 0406 18BF     		it	ne
 7472 0408 0120     		movne	r0, #1
 7473 040a 22E0     		b	.L944
 7474              	.LVL1087:
 7475              	.L919:
3819:lib/ff/ff.c   **** 	if (sfd > 1) return FR_INVALID_PARAMETER;
 7476              		.loc 1 3819 0
 7477 040c 0B20     		movs	r0, #11
 7478              	.LVL1088:
 7479 040e 20E0     		b	.L944
 7480              	.LVL1089:
 7481              	.L921:
3820:lib/ff/ff.c   **** 	if (au & (au - 1)) return FR_INVALID_PARAMETER;
 7482              		.loc 1 3820 0
 7483 0410 1320     		movs	r0, #19
 7484              	.LVL1090:
 7485 0412 1EE0     		b	.L944
 7486              	.LVL1091:
 7487              	.L922:
3823:lib/ff/ff.c   **** 	fs->fs_type = 0;
 7488              		.loc 1 3823 0
 7489 0414 0C20     		movs	r0, #12
 7490              	.LVL1092:
 7491 0416 1CE0     		b	.L944
 7492              	.LVL1093:
 7493              	.L923:
3830:lib/ff/ff.c   **** 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 7494              		.loc 1 3830 0
 7495 0418 0320     		movs	r0, #3
 7496              	.LVL1094:
 7497 041a 1AE0     		b	.L944
 7498              	.L924:
3831:lib/ff/ff.c   **** #if _MAX_SS != 512					/* Get disk sector size */
 7499              		.loc 1 3831 0
 7500 041c 0A20     		movs	r0, #10
 7501 041e 18E0     		b	.L944
 7502              	.LVL1095:
 7503              	.L889:
3873:lib/ff/ff.c   **** 		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
 7504              		.loc 1 3873 0
 7505 0420 0321     		movs	r1, #3
 7506 0422 01FB09F7 		mul	r7, r1, r9
 7507 0426 07F10105 		add	r5, r7, #1
 7508 042a 4FEA5502 		lsr	r2, r5, #1
 7509 042e 02EB010B 		add	fp, r2, r1
3863:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
 7510              		.loc 1 3863 0
 7511 0432 0125     		movs	r5, #1
 7512              	.LVL1096:
 7513              	.L918:
3874:lib/ff/ff.c   **** 		n_rsv = 1;
 7514              		.loc 1 3874 0 discriminator 3
 7515 0434 0BF2FF1C 		addw	ip, fp, #511
 7516 0438 4FEA5C29 		lsr	r9, ip, #9
 7517              	.LVL1097:
3876:lib/ff/ff.c   **** 	}
 7518              		.loc 1 3876 0 discriminator 3
 7519 043c 2021     		movs	r1, #32
 7520 043e 0291     		str	r1, [sp, #8]
3875:lib/ff/ff.c   **** 		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
 7521              		.loc 1 3875 0 discriminator 3
 7522 0440 4FF0010B 		mov	fp, #1
 7523 0444 42E6     		b	.L917
 7524              	.LVL1098:
 7525              	.L949:
3873:lib/ff/ff.c   **** 		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
 7526              		.loc 1 3873 0
 7527 0446 09F1020A 		add	sl, r9, #2
 7528 044a 4FEA4A0B 		lsl	fp, sl, #1
3864:lib/ff/ff.c   **** 	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
 7529              		.loc 1 3864 0
 7530 044e 0225     		movs	r5, #2
 7531 0450 F0E7     		b	.L918
 7532              	.LVL1099:
 7533              	.L944:
4029:lib/ff/ff.c   **** 
 7534              		.loc 1 4029 0
 7535 0452 09B0     		add	sp, sp, #36
 7536 0454 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7537              	.L954:
 7538              		.align	2
 7539              	.L953:
 7540 0458 52526141 		.word	1096897106
 7541 045c 72724161 		.word	1631679090
 7542              		.cfi_endproc
 7543              	.LFE51:
 7545              		.section	.text.f_gets,"ax",%progbits
 7546              		.align	1
 7547              		.global	f_gets
 7548              		.thumb
 7549              		.thumb_func
 7551              	f_gets:
 7552              	.LFB52:
4115:lib/ff/ff.c   **** 	int n = 0;
 7553              		.loc 1 4115 0
 7554              		.cfi_startproc
 7555              		@ args = 0, pretend = 0, frame = 8
 7556              		@ frame_needed = 0, uses_anonymous_args = 0
 7557              	.LVL1100:
 7558 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 7559              	.LCFI54:
 7560              		.cfi_def_cfa_offset 32
 7561              		.cfi_offset 0, -32
 7562              		.cfi_offset 1, -28
 7563              		.cfi_offset 4, -24
 7564              		.cfi_offset 5, -20
 7565              		.cfi_offset 6, -16
 7566              		.cfi_offset 7, -12
 7567              		.cfi_offset 8, -8
 7568              		.cfi_offset 14, -4
 7569 0004 0646     		mov	r6, r0
 7570 0006 0F46     		mov	r7, r1
 7571 0008 9046     		mov	r8, r2
 7572              	.LVL1101:
 7573 000a 0546     		mov	r5, r0
4116:lib/ff/ff.c   **** 	TCHAR c, *p = buff;
 7574              		.loc 1 4116 0
 7575 000c 0024     		movs	r4, #0
 7576              	.LVL1102:
 7577              	.L956:
4122:lib/ff/ff.c   **** 		f_read(fp, s, 1, &rc);
 7578              		.loc 1 4122 0 discriminator 1
 7579 000e 7B1E     		subs	r3, r7, #1
 7580 0010 9C42     		cmp	r4, r3
 7581 0012 0FDA     		bge	.L957
 7582              	.L958:
4123:lib/ff/ff.c   **** 		if (rc != 1) break;			/* Break on EOF or error */
 7583              		.loc 1 4123 0
 7584 0014 4046     		mov	r0, r8
 7585 0016 6946     		mov	r1, sp
 7586 0018 0122     		movs	r2, #1
 7587 001a 01AB     		add	r3, sp, #4
 7588 001c FFF7FEFF 		bl	f_read
 7589              	.LVL1103:
4124:lib/ff/ff.c   **** 		c = s[0];
 7590              		.loc 1 4124 0
 7591 0020 0198     		ldr	r0, [sp, #4]
 7592              	.LVL1104:
 7593 0022 0128     		cmp	r0, #1
 7594 0024 06D1     		bne	.L957
4125:lib/ff/ff.c   **** #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
 7595              		.loc 1 4125 0
 7596 0026 9DF80010 		ldrb	r1, [sp, #0]	@ zero_extendqisi2
 7597              	.LVL1105:
4149:lib/ff/ff.c   **** 		n++;
 7598              		.loc 1 4149 0
 7599 002a 05F8011B 		strb	r1, [r5], #1
 7600              	.LVL1106:
4150:lib/ff/ff.c   **** 		if (c == '\n') break;		/* Break on EOL */
 7601              		.loc 1 4150 0
 7602 002e 0134     		adds	r4, r4, #1
 7603              	.LVL1107:
4151:lib/ff/ff.c   **** 	}
 7604              		.loc 1 4151 0
 7605 0030 0A29     		cmp	r1, #10
 7606 0032 ECD1     		bne	.L956
 7607              	.LVL1108:
 7608              	.L957:
4153:lib/ff/ff.c   **** 	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
 7609              		.loc 1 4153 0
 7610 0034 0022     		movs	r2, #0
 7611 0036 2A70     		strb	r2, [r5, #0]
4155:lib/ff/ff.c   **** 
 7612              		.loc 1 4155 0
 7613 0038 9442     		cmp	r4, r2
 7614 003a 14BF     		ite	ne
 7615 003c 3046     		movne	r0, r6
 7616 003e 1046     		moveq	r0, r2
 7617 0040 BDE8FC81 		pop	{r2, r3, r4, r5, r6, r7, r8, pc}
 7618              		.cfi_endproc
 7619              	.LFE52:
 7621              		.section	.text.f_putc,"ax",%progbits
 7622              		.align	1
 7623              		.global	f_putc
 7624              		.thumb
 7625              		.thumb_func
 7627              	f_putc:
 7628              	.LFB53:
4169:lib/ff/ff.c   **** 	UINT bw, btw;
 7629              		.loc 1 4169 0
 7630              		.cfi_startproc
 7631              		@ args = 0, pretend = 0, frame = 8
 7632              		@ frame_needed = 0, uses_anonymous_args = 0
 7633              	.LVL1109:
 7634 0000 07B5     		push	{r0, r1, r2, lr}
 7635              	.LCFI55:
 7636              		.cfi_def_cfa_offset 16
 7637              		.cfi_offset 0, -16
 7638              		.cfi_offset 1, -12
 7639              		.cfi_offset 2, -8
 7640              		.cfi_offset 14, -4
4195:lib/ff/ff.c   **** 	btw = 1;
 7641              		.loc 1 4195 0
 7642 0002 02AB     		add	r3, sp, #8
 7643 0004 03F8080D 		strb	r0, [r3, #-8]!
 7644              	.LVL1110:
4198:lib/ff/ff.c   **** 	return (bw == btw) ? 1 : EOF;	/* Return the result */
 7645              		.loc 1 4198 0
 7646 0008 0846     		mov	r0, r1
 7647              	.LVL1111:
 7648 000a 6946     		mov	r1, sp
 7649              	.LVL1112:
 7650 000c 0122     		movs	r2, #1
 7651 000e 01AB     		add	r3, sp, #4
 7652              	.LVL1113:
 7653 0010 FFF7FEFF 		bl	f_write
 7654              	.LVL1114:
4200:lib/ff/ff.c   **** 
 7655              		.loc 1 4200 0
 7656 0014 0198     		ldr	r0, [sp, #4]
 7657 0016 0128     		cmp	r0, #1
 7658 0018 14BF     		ite	ne
 7659 001a 4FF0FF30 		movne	r0, #-1
 7660 001e 0120     		moveq	r0, #1
 7661 0020 0EBD     		pop	{r1, r2, r3, pc}
 7662              		.cfi_endproc
 7663              	.LFE53:
 7665              		.section	.text.f_puts,"ax",%progbits
 7666              		.align	1
 7667              		.global	f_puts
 7668              		.thumb
 7669              		.thumb_func
 7671              	f_puts:
 7672              	.LFB54:
4213:lib/ff/ff.c   **** 	int n;
 7673              		.loc 1 4213 0
 7674              		.cfi_startproc
 7675              		@ args = 0, pretend = 0, frame = 0
 7676              		@ frame_needed = 0, uses_anonymous_args = 0
 7677              	.LVL1115:
 7678 0000 70B5     		push	{r4, r5, r6, lr}
 7679              	.LCFI56:
 7680              		.cfi_def_cfa_offset 16
 7681              		.cfi_offset 4, -16
 7682              		.cfi_offset 5, -12
 7683              		.cfi_offset 6, -8
 7684              		.cfi_offset 14, -4
 7685 0002 0546     		mov	r5, r0
 7686 0004 0E46     		mov	r6, r1
 7687              	.LVL1116:
4217:lib/ff/ff.c   **** 		if (f_putc(*str, fp) == EOF) return EOF;
 7688              		.loc 1 4217 0
 7689 0006 0024     		movs	r4, #0
 7690              	.LVL1117:
 7691              	.L967:
4217:lib/ff/ff.c   **** 		if (f_putc(*str, fp) == EOF) return EOF;
 7692              		.loc 1 4217 0 is_stmt 0 discriminator 1
 7693 0008 285D     		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 7694 000a 40B1     		cbz	r0, .L968
 7695              	.L969:
4218:lib/ff/ff.c   **** 	}
 7696              		.loc 1 4218 0 is_stmt 1
 7697 000c 40B2     		sxtb	r0, r0
 7698 000e 3146     		mov	r1, r6
 7699 0010 FFF7FEFF 		bl	f_putc
 7700              	.LVL1118:
 7701 0014 421C     		adds	r2, r0, #1
 7702 0016 01D0     		beq	.L970
4217:lib/ff/ff.c   **** 		if (f_putc(*str, fp) == EOF) return EOF;
 7703              		.loc 1 4217 0
 7704 0018 0134     		adds	r4, r4, #1
 7705              	.LVL1119:
 7706 001a F5E7     		b	.L967
 7707              	.L970:
4218:lib/ff/ff.c   **** 	}
 7708              		.loc 1 4218 0
 7709 001c 0446     		mov	r4, r0
 7710              	.LVL1120:
 7711              	.L968:
4221:lib/ff/ff.c   **** 
 7712              		.loc 1 4221 0
 7713 001e 2046     		mov	r0, r4
 7714 0020 70BD     		pop	{r4, r5, r6, pc}
 7715              		.cfi_endproc
 7716              	.LFE54:
 7718              		.section	.text.f_printf,"ax",%progbits
 7719              		.align	1
 7720              		.global	f_printf
 7721              		.thumb
 7722              		.thumb_func
 7724              	f_printf:
 7725              	.LFB55:
4235:lib/ff/ff.c   **** 	va_list arp;
 7726              		.loc 1 4235 0
 7727              		.cfi_startproc
 7728              		@ args = 4, pretend = 12, frame = 32
 7729              		@ frame_needed = 0, uses_anonymous_args = 1
 7730              	.LVL1121:
 7731 0000 0EB4     		push	{r1, r2, r3}
 7732              	.LCFI57:
 7733              		.cfi_def_cfa_offset 12
 7734              		.cfi_offset 1, -12
 7735              		.cfi_offset 2, -8
 7736              		.cfi_offset 3, -4
 7737 0002 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7738              	.LCFI58:
 7739              		.cfi_def_cfa_offset 48
 7740              		.cfi_offset 4, -48
 7741              		.cfi_offset 5, -44
 7742              		.cfi_offset 6, -40
 7743              		.cfi_offset 7, -36
 7744              		.cfi_offset 8, -32
 7745              		.cfi_offset 9, -28
 7746              		.cfi_offset 10, -24
 7747              		.cfi_offset 11, -20
 7748              		.cfi_offset 14, -16
 7749 0006 88B0     		sub	sp, sp, #32
 7750              	.LCFI59:
 7751              		.cfi_def_cfa_offset 80
 7752 0008 0746     		mov	r7, r0
 7753 000a 11AB     		add	r3, sp, #68
 7754 000c 53F8042B 		ldr	r2, [r3], #4
4244:lib/ff/ff.c   **** 
 7755              		.loc 1 4244 0
 7756 0010 0393     		str	r3, [sp, #12]
 7757              	.LVL1122:
4246:lib/ff/ff.c   **** 		c = *str++;
 7758              		.loc 1 4246 0
 7759 0012 0020     		movs	r0, #0
 7760              	.LVL1123:
 7761 0014 8146     		mov	r9, r0
 7762              	.LVL1124:
 7763              	.L1014:
4247:lib/ff/ff.c   **** 		if (c == 0) break;			/* End of string */
 7764              		.loc 1 4247 0
 7765 0016 1546     		mov	r5, r2
 7766 0018 15F8011B 		ldrb	r1, [r5], #1	@ zero_extendqisi2
 7767              	.LVL1125:
4248:lib/ff/ff.c   **** 		if (c != '%') {				/* Non escape character */
 7768              		.loc 1 4248 0
 7769 001c 0029     		cmp	r1, #0
 7770 001e 00F01481 		beq	.L972
4249:lib/ff/ff.c   **** 			cc = f_putc(c, fp);
 7771              		.loc 1 4249 0
 7772 0022 4BB2     		sxtb	r3, r1
 7773 0024 252B     		cmp	r3, #37
 7774 0026 0AD0     		beq	.L973
4250:lib/ff/ff.c   **** 			if (cc != EOF) cc = 1;
 7775              		.loc 1 4250 0
 7776 0028 1846     		mov	r0, r3
 7777 002a 3946     		mov	r1, r7
 7778 002c FFF7FEFF 		bl	f_putc
 7779              	.LVL1126:
4251:lib/ff/ff.c   **** 			continue;
 7780              		.loc 1 4251 0
 7781 0030 B0F1FF3F 		cmp	r0, #-1
 7782 0034 0CBF     		ite	eq
 7783 0036 4FF0FF30 		moveq	r0, #-1
 7784 003a 0120     		movne	r0, #1
 7785 003c 00E1     		b	.L974
 7786              	.LVL1127:
 7787              	.L973:
4255:lib/ff/ff.c   **** 		if (c == '0') {				/* Flag: '0' padding */
 7788              		.loc 1 4255 0
 7789 003e 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 7790              	.LVL1128:
4256:lib/ff/ff.c   **** 			f = 1; c = *str++;
 7791              		.loc 1 4256 0
 7792 0040 5CB2     		sxtb	r4, r3
 7793 0042 302C     		cmp	r4, #48
 7794 0044 03D1     		bne	.L975
 7795              	.LVL1129:
4257:lib/ff/ff.c   **** 		} else {
 7796              		.loc 1 4257 0
 7797 0046 9378     		ldrb	r3, [r2, #2]	@ zero_extendqisi2
 7798              	.LVL1130:
 7799 0048 D51C     		adds	r5, r2, #3
 7800              	.LVL1131:
 7801 004a 0124     		movs	r4, #1
 7802 004c 07E0     		b	.L976
 7803              	.LVL1132:
 7804              	.L975:
4259:lib/ff/ff.c   **** 				f = 2; c = *str++;
 7805              		.loc 1 4259 0
 7806 004e 2D2C     		cmp	r4, #45
 7807 0050 02D0     		beq	.L977
4255:lib/ff/ff.c   **** 		if (c == '0') {				/* Flag: '0' padding */
 7808              		.loc 1 4255 0
 7809 0052 951C     		adds	r5, r2, #2
4254:lib/ff/ff.c   **** 		c = *str++;
 7810              		.loc 1 4254 0
 7811 0054 0024     		movs	r4, #0
 7812 0056 02E0     		b	.L976
 7813              	.L977:
 7814              	.LVL1133:
4260:lib/ff/ff.c   **** 			}
 7815              		.loc 1 4260 0
 7816 0058 9378     		ldrb	r3, [r2, #2]	@ zero_extendqisi2
 7817              	.LVL1134:
 7818 005a D51C     		adds	r5, r2, #3
 7819              	.LVL1135:
 7820 005c 0224     		movs	r4, #2
 7821              	.LVL1136:
 7822              	.L976:
4257:lib/ff/ff.c   **** 		} else {
 7823              		.loc 1 4257 0 discriminator 1
 7824 005e 4FF00008 		mov	r8, #0
 7825              	.LVL1137:
 7826              	.L978:
4263:lib/ff/ff.c   **** 			w = w * 10 + c - '0';
 7827              		.loc 1 4263 0 discriminator 1
 7828 0062 A3F13002 		sub	r2, r3, #48
 7829 0066 092A     		cmp	r2, #9
 7830 0068 59B2     		sxtb	r1, r3
 7831 006a 07D8     		bhi	.L1061
 7832              	.L979:
4264:lib/ff/ff.c   **** 			c = *str++;
 7833              		.loc 1 4264 0
 7834 006c 0A22     		movs	r2, #10
 7835 006e 02FB0818 		mla	r8, r2, r8, r1
 7836              	.LVL1138:
 7837 0072 A8F13008 		sub	r8, r8, #48
 7838              	.LVL1139:
4265:lib/ff/ff.c   **** 		}
 7839              		.loc 1 4265 0
 7840 0076 15F8013B 		ldrb	r3, [r5], #1	@ zero_extendqisi2
 7841              	.LVL1140:
 7842 007a F2E7     		b	.L978
 7843              	.LVL1141:
 7844              	.L1061:
4267:lib/ff/ff.c   **** 			f |= 4; c = *str++;
 7845              		.loc 1 4267 0
 7846 007c 6C29     		cmp	r1, #108
 7847 007e 01D0     		beq	.L980
4267:lib/ff/ff.c   **** 			f |= 4; c = *str++;
 7848              		.loc 1 4267 0 is_stmt 0 discriminator 1
 7849 0080 4C29     		cmp	r1, #76
 7850 0082 03D1     		bne	.L981
 7851              	.L980:
4268:lib/ff/ff.c   **** 		}
 7852              		.loc 1 4268 0 is_stmt 1
 7853 0084 44F00404 		orr	r4, r4, #4
 7854              	.LVL1142:
 7855 0088 15F8013B 		ldrb	r3, [r5], #1	@ zero_extendqisi2
 7856              	.LVL1143:
 7857              	.L981:
4270:lib/ff/ff.c   **** 		d = c;
 7858              		.loc 1 4270 0
 7859 008c 002B     		cmp	r3, #0
 7860 008e 00F0DC80 		beq	.L972
 7861              	.LVL1144:
4272:lib/ff/ff.c   **** 		switch (d) {				/* Type is... */
 7862              		.loc 1 4272 0
 7863 0092 D8B2     		uxtb	r0, r3
 7864 0094 A0F16102 		sub	r2, r0, #97
 7865 0098 192A     		cmp	r2, #25
 7866 009a 02D8     		bhi	.L1016
4272:lib/ff/ff.c   **** 		switch (d) {				/* Type is... */
 7867              		.loc 1 4272 0 is_stmt 0 discriminator 1
 7868 009c 2038     		subs	r0, r0, #32
 7869 009e C1B2     		uxtb	r1, r0
 7870              	.LVL1145:
 7871 00a0 00E0     		b	.L982
 7872              	.LVL1146:
 7873              	.L1016:
4272:lib/ff/ff.c   **** 		switch (d) {				/* Type is... */
 7874              		.loc 1 4272 0
 7875 00a2 1946     		mov	r1, r3
 7876              	.LVL1147:
 7877              	.L982:
4273:lib/ff/ff.c   **** 		case 'S' :					/* String */
 7878              		.loc 1 4273 0 is_stmt 1
 7879 00a4 48B2     		sxtb	r0, r1
 7880 00a6 4F28     		cmp	r0, #79
 7881 00a8 51D0     		beq	.L1017
 7882 00aa 06DC     		bgt	.L990
 7883 00ac 4328     		cmp	r0, #67
 7884 00ae 3FD0     		beq	.L985
 7885 00b0 4428     		cmp	r0, #68
 7886 00b2 0FD0     		beq	.L986
 7887 00b4 4228     		cmp	r0, #66
 7888 00b6 43D1     		bne	.L983
 7889 00b8 47E0     		b	.L1062
 7890              	.L990:
 7891 00ba 5528     		cmp	r0, #85
 7892 00bc 0AD0     		beq	.L986
 7893 00be 5828     		cmp	r0, #88
 7894 00c0 3CD0     		beq	.L989
 7895 00c2 5328     		cmp	r0, #83
 7896 00c4 3CD1     		bne	.L983
4275:lib/ff/ff.c   **** 			for (j = 0; p[j]; j++) ;
 7897              		.loc 1 4275 0
 7898 00c6 039E     		ldr	r6, [sp, #12]
 7899 00c8 311D     		adds	r1, r6, #4
 7900              	.LVL1148:
 7901 00ca 0391     		str	r1, [sp, #12]
 7902 00cc D6F800A0 		ldr	sl, [r6, #0]
 7903              	.LVL1149:
4276:lib/ff/ff.c   **** 			chc = 0;
 7904              		.loc 1 4276 0
 7905 00d0 0026     		movs	r6, #0
 7906 00d2 01E0     		b	.L991
 7907              	.LVL1150:
 7908              	.L986:
4293:lib/ff/ff.c   **** 		case 'X' :					/* Hexdecimal */
 7909              		.loc 1 4293 0
 7910 00d4 0A20     		movs	r0, #10
 7911 00d6 3BE0     		b	.L987
 7912              	.LVL1151:
 7913              	.L991:
4276:lib/ff/ff.c   **** 			chc = 0;
 7914              		.loc 1 4276 0 discriminator 1
 7915 00d8 1AF90600 		ldrsb	r0, [sl, r6]
 7916 00dc 08B1     		cbz	r0, .L1063
 7917              	.L992:
4276:lib/ff/ff.c   **** 			chc = 0;
 7918              		.loc 1 4276 0 is_stmt 0 discriminator 2
 7919 00de 0136     		adds	r6, r6, #1
 7920              	.LVL1152:
 7921 00e0 FAE7     		b	.L991
 7922              	.L1063:
 7923              	.LVL1153:
4278:lib/ff/ff.c   **** 				while (j++ < w) chc += (cc = f_putc(' ', fp));
 7924              		.loc 1 4278 0 is_stmt 1
 7925 00e2 04F00204 		and	r4, r4, #2
 7926              	.LVL1154:
 7927 00e6 E4B2     		uxtb	r4, r4
 7928 00e8 0CB1     		cbz	r4, .L993
4277:lib/ff/ff.c   **** 			if (!(f & 2)) {
 7929              		.loc 1 4277 0
 7930 00ea 0446     		mov	r4, r0
 7931 00ec 0BE0     		b	.L994
 7932              	.LVL1155:
 7933              	.L993:
4279:lib/ff/ff.c   **** 			}
 7934              		.loc 1 4279 0 discriminator 1
 7935 00ee 06F1010B 		add	fp, r6, #1
 7936              	.LVL1156:
 7937 00f2 4645     		cmp	r6, r8
 7938 00f4 06D2     		bcs	.L1064
 7939              	.L995:
4279:lib/ff/ff.c   **** 			}
 7940              		.loc 1 4279 0 is_stmt 0 discriminator 2
 7941 00f6 2020     		movs	r0, #32
 7942 00f8 3946     		mov	r1, r7
 7943 00fa FFF7FEFF 		bl	f_putc
 7944              	.LVL1157:
 7945 00fe 2418     		adds	r4, r4, r0
 7946              	.LVL1158:
 7947 0100 5E46     		mov	r6, fp
 7948 0102 F4E7     		b	.L993
 7949              	.LVL1159:
 7950              	.L1064:
4279:lib/ff/ff.c   **** 			}
 7951              		.loc 1 4279 0
 7952 0104 5E46     		mov	r6, fp
 7953              	.LVL1160:
 7954              	.L994:
4281:lib/ff/ff.c   **** 			while (j++ < w) chc += (cc = f_putc(' ', fp));
 7955              		.loc 1 4281 0 is_stmt 1
 7956 0106 5046     		mov	r0, sl
 7957 0108 3946     		mov	r1, r7
 7958 010a FFF7FEFF 		bl	f_puts
 7959              	.LVL1161:
 7960 010e 2418     		adds	r4, r4, r0
 7961              	.LVL1162:
 7962              	.L996:
4282:lib/ff/ff.c   **** 			if (cc != EOF) cc = chc;
 7963              		.loc 1 4282 0 discriminator 1
 7964 0110 4645     		cmp	r6, r8
 7965 0112 06D2     		bcs	.L1065
 7966              	.L997:
4282:lib/ff/ff.c   **** 			if (cc != EOF) cc = chc;
 7967              		.loc 1 4282 0 is_stmt 0 discriminator 2
 7968 0114 2020     		movs	r0, #32
 7969 0116 3946     		mov	r1, r7
 7970 0118 FFF7FEFF 		bl	f_putc
 7971              	.LVL1163:
 7972 011c 2418     		adds	r4, r4, r0
 7973              	.LVL1164:
 7974 011e 0136     		adds	r6, r6, #1
 7975 0120 F6E7     		b	.L996
 7976              	.L1065:
4283:lib/ff/ff.c   **** 			continue;
 7977              		.loc 1 4283 0 is_stmt 1
 7978 0122 B0F1FF3F 		cmp	r0, #-1
 7979 0126 14BF     		ite	ne
 7980 0128 2046     		movne	r0, r4
 7981 012a 4FF0FF30 		moveq	r0, #-1
 7982 012e 87E0     		b	.L974
 7983              	.LVL1165:
 7984              	.L985:
4286:lib/ff/ff.c   **** 		case 'B' :					/* Binary */
 7985              		.loc 1 4286 0
 7986 0130 039B     		ldr	r3, [sp, #12]
 7987              	.LVL1166:
 7988 0132 1A1D     		adds	r2, r3, #4
 7989 0134 0392     		str	r2, [sp, #12]
 7990 0136 93F90000 		ldrsb	r0, [r3, #0]
 7991 013a 02E0     		b	.L1058
 7992              	.LVL1167:
 7993              	.L989:
4295:lib/ff/ff.c   **** 		default:					/* Unknown type (pass-through) */
 7994              		.loc 1 4295 0
 7995 013c 1020     		movs	r0, #16
 7996 013e 07E0     		b	.L987
 7997              	.LVL1168:
 7998              	.L983:
4297:lib/ff/ff.c   **** 		}
 7999              		.loc 1 4297 0
 8000 0140 58B2     		sxtb	r0, r3
 8001              	.LVL1169:
 8002              	.L1058:
 8003 0142 3946     		mov	r1, r7
 8004              	.LVL1170:
 8005 0144 FFF7FEFF 		bl	f_putc
 8006              	.LVL1171:
 8007 0148 7AE0     		b	.L974
 8008              	.LVL1172:
 8009              	.L1062:
4288:lib/ff/ff.c   **** 		case 'O' :					/* Octal */
 8010              		.loc 1 4288 0
 8011 014a 0220     		movs	r0, #2
 8012 014c 00E0     		b	.L987
 8013              	.L1017:
4290:lib/ff/ff.c   **** 		case 'D' :					/* Signed decimal */
 8014              		.loc 1 4290 0
 8015 014e 0820     		movs	r0, #8
 8016              	.L987:
 8017              	.LVL1173:
4301:lib/ff/ff.c   **** 		if (d == 'D' && (v & 0x80000000)) {
 8018              		.loc 1 4301 0
 8019 0150 04F00402 		and	r2, r4, #4
 8020 0154 D6B2     		uxtb	r6, r2
 8021 0156 039A     		ldr	r2, [sp, #12]
 8022 0158 2EB1     		cbz	r6, .L998
4301:lib/ff/ff.c   **** 		if (d == 'D' && (v & 0x80000000)) {
 8023              		.loc 1 4301 0 is_stmt 0 discriminator 1
 8024 015a 161D     		adds	r6, r2, #4
 8025 015c 0396     		str	r6, [sp, #12]
 8026 015e 1268     		ldr	r2, [r2, #0]
 8027              	.LVL1174:
4302:lib/ff/ff.c   **** 			v = 0 - v;
 8028              		.loc 1 4302 0 is_stmt 1 discriminator 1
 8029 0160 49B2     		sxtb	r1, r1
 8030              	.LVL1175:
 8031 0162 4429     		cmp	r1, #68
 8032 0164 05E0     		b	.L1060
 8033              	.LVL1176:
 8034              	.L998:
4301:lib/ff/ff.c   **** 		if (d == 'D' && (v & 0x80000000)) {
 8035              		.loc 1 4301 0 discriminator 2
 8036 0166 49B2     		sxtb	r1, r1
 8037              	.LVL1177:
 8038 0168 4429     		cmp	r1, #68
 8039 016a 02F10406 		add	r6, r2, #4
 8040 016e 0396     		str	r6, [sp, #12]
 8041 0170 1268     		ldr	r2, [r2, #0]
 8042              	.L1060:
 8043 0172 04D1     		bne	.L1000
4302:lib/ff/ff.c   **** 			v = 0 - v;
 8044              		.loc 1 4302 0 discriminator 1
 8045 0174 002A     		cmp	r2, #0
 8046 0176 02DA     		bge	.L1000
4303:lib/ff/ff.c   **** 			f |= 8;
 8047              		.loc 1 4303 0
 8048 0178 5242     		negs	r2, r2
 8049              	.LVL1178:
4304:lib/ff/ff.c   **** 		}
 8050              		.loc 1 4304 0
 8051 017a 44F00804 		orr	r4, r4, #8
 8052              	.LVL1179:
 8053              	.L1000:
4306:lib/ff/ff.c   **** 		do {
 8054              		.loc 1 4306 0
 8055 017e 0021     		movs	r1, #0
 8056              	.LVL1180:
 8057              	.L1005:
4308:lib/ff/ff.c   **** 			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 8058              		.loc 1 4308 0
 8059 0180 B2FBF0FE 		udiv	lr, r2, r0
 8060 0184 00FB1E22 		mls	r2, r0, lr, r2
 8061              	.LVL1181:
 8062 0188 D6B2     		uxtb	r6, r2
 8063              	.LVL1182:
 8064 018a 7246     		mov	r2, lr
 8065              	.LVL1183:
4309:lib/ff/ff.c   **** 			s[i++] = d + '0';
 8066              		.loc 1 4309 0
 8067 018c 4FFA86FC 		sxtb	ip, r6
 8068 0190 BCF1090F 		cmp	ip, #9
 8069 0194 07DD     		ble	.L1002
4309:lib/ff/ff.c   **** 			s[i++] = d + '0';
 8070              		.loc 1 4309 0 is_stmt 0 discriminator 1
 8071 0196 782B     		cmp	r3, #120
 8072 0198 14BF     		ite	ne
 8073 019a 4FF0070A 		movne	sl, #7
 8074 019e 4FF0270A 		moveq	sl, #39
 8075 01a2 5644     		add	r6, sl, r6
 8076              	.LVL1184:
 8077 01a4 F6B2     		uxtb	r6, r6
 8078              	.LVL1185:
 8079              	.L1002:
4310:lib/ff/ff.c   **** 		} while (v && i < sizeof s / sizeof s[0]);
 8080              		.loc 1 4310 0 is_stmt 1
 8081 01a6 3036     		adds	r6, r6, #48
 8082              	.LVL1186:
 8083 01a8 0DF1100B 		add	fp, sp, #16
 8084 01ac 01F80B60 		strb	r6, [r1, fp]
 8085 01b0 4E1C     		adds	r6, r1, #1
 8086              	.LVL1187:
4311:lib/ff/ff.c   **** 		if (f & 8) s[i++] = '-';
 8087              		.loc 1 4311 0
 8088 01b2 BEF1000F 		cmp	lr, #0
 8089 01b6 04D0     		beq	.L1004
4311:lib/ff/ff.c   **** 		if (f & 8) s[i++] = '-';
 8090              		.loc 1 4311 0 is_stmt 0 discriminator 1
 8091 01b8 102E     		cmp	r6, #16
 8092 01ba 01D0     		beq	.L1066
 8093              	.L1020:
4310:lib/ff/ff.c   **** 		} while (v && i < sizeof s / sizeof s[0]);
 8094              		.loc 1 4310 0 is_stmt 1
 8095 01bc 3146     		mov	r1, r6
 8096 01be DFE7     		b	.L1005
 8097              	.L1066:
4311:lib/ff/ff.c   **** 		if (f & 8) s[i++] = '-';
 8098              		.loc 1 4311 0
 8099 01c0 0F21     		movs	r1, #15
 8100              	.L1004:
4312:lib/ff/ff.c   **** 		j = i; d = (f & 1) ? '0' : ' ';
 8101              		.loc 1 4312 0
 8102 01c2 04F00803 		and	r3, r4, #8
 8103              	.LVL1188:
 8104 01c6 D8B2     		uxtb	r0, r3
 8105              	.LVL1189:
 8106 01c8 28B1     		cbz	r0, .L1006
4312:lib/ff/ff.c   **** 		j = i; d = (f & 1) ? '0' : ' ';
 8107              		.loc 1 4312 0 is_stmt 0 discriminator 1
 8108 01ca 08AA     		add	r2, sp, #32
 8109              	.LVL1190:
 8110 01cc 9619     		adds	r6, r2, r6
 8111              	.LVL1191:
 8112 01ce 2D23     		movs	r3, #45
 8113 01d0 06F8103C 		strb	r3, [r6, #-16]
 8114 01d4 8E1C     		adds	r6, r1, #2
 8115              	.LVL1192:
 8116              	.L1006:
4313:lib/ff/ff.c   **** 		chc = 0;
 8117              		.loc 1 4313 0 is_stmt 1
 8118 01d6 14F0010F 		tst	r4, #1
 8119 01da 0CBF     		ite	eq
 8120 01dc 2022     		moveq	r2, #32
 8121 01de 3022     		movne	r2, #48
 8122              	.LVL1193:
 8123 01e0 B346     		mov	fp, r6
4314:lib/ff/ff.c   **** 		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, fp));
 8124              		.loc 1 4314 0
 8125 01e2 4FF0000A 		mov	sl, #0
 8126              	.LVL1194:
 8127              	.L1008:
4315:lib/ff/ff.c   **** 		do chc += (cc = f_putc(s[--i], fp)); while(i);
 8128              		.loc 1 4315 0 discriminator 1
 8129 01e6 04F00201 		and	r1, r4, #2
 8130 01ea C8B2     		uxtb	r0, r1
 8131 01ec 78B9     		cbnz	r0, .L1047
4315:lib/ff/ff.c   **** 		do chc += (cc = f_putc(s[--i], fp)); while(i);
 8132              		.loc 1 4315 0 is_stmt 0 discriminator 2
 8133 01ee 0BF10103 		add	r3, fp, #1
 8134              	.LVL1195:
 8135 01f2 C345     		cmp	fp, r8
 8136 01f4 0AD2     		bcs	.L1067
 8137              	.L1010:
4315:lib/ff/ff.c   **** 		do chc += (cc = f_putc(s[--i], fp)); while(i);
 8138              		.loc 1 4315 0 discriminator 1
 8139 01f6 1046     		mov	r0, r2
 8140 01f8 3946     		mov	r1, r7
 8141 01fa 0192     		str	r2, [sp, #4]
 8142 01fc 0093     		str	r3, [sp, #0]
 8143 01fe FFF7FEFF 		bl	f_putc
 8144              	.LVL1196:
 8145 0202 8244     		add	sl, sl, r0
 8146              	.LVL1197:
 8147 0204 0099     		ldr	r1, [sp, #0]
 8148 0206 8B46     		mov	fp, r1
 8149              	.LVL1198:
 8150 0208 019A     		ldr	r2, [sp, #4]
 8151 020a ECE7     		b	.L1008
 8152              	.LVL1199:
 8153              	.L1067:
4315:lib/ff/ff.c   **** 		do chc += (cc = f_putc(s[--i], fp)); while(i);
 8154              		.loc 1 4315 0
 8155 020c 9B46     		mov	fp, r3
 8156              	.LVL1200:
 8157              	.L1047:
4316:lib/ff/ff.c   **** 		while (j++ < w) chc += (cc = f_putc(' ', fp));
 8158              		.loc 1 4316 0 is_stmt 1 discriminator 1
 8159 020e 013E     		subs	r6, r6, #1
 8160              	.LVL1201:
 8161 0210 04AA     		add	r2, sp, #16
 8162 0212 9057     		ldrsb	r0, [r2, r6]
 8163 0214 3946     		mov	r1, r7
 8164 0216 FFF7FEFF 		bl	f_putc
 8165              	.LVL1202:
 8166 021a 8244     		add	sl, sl, r0
 8167              	.LVL1203:
 8168 021c 002E     		cmp	r6, #0
 8169 021e F6D1     		bne	.L1047
 8170              	.L1057:
4317:lib/ff/ff.c   **** 		if (cc != EOF) cc = chc;
 8171              		.loc 1 4317 0 discriminator 1
 8172 0220 C345     		cmp	fp, r8
 8173 0222 07D2     		bcs	.L1068
 8174              	.L1013:
4317:lib/ff/ff.c   **** 		if (cc != EOF) cc = chc;
 8175              		.loc 1 4317 0 is_stmt 0 discriminator 2
 8176 0224 2020     		movs	r0, #32
 8177 0226 3946     		mov	r1, r7
 8178 0228 FFF7FEFF 		bl	f_putc
 8179              	.LVL1204:
 8180 022c 8244     		add	sl, sl, r0
 8181              	.LVL1205:
 8182 022e 0BF1010B 		add	fp, fp, #1
 8183 0232 F5E7     		b	.L1057
 8184              	.L1068:
4318:lib/ff/ff.c   **** 	}
 8185              		.loc 1 4318 0 is_stmt 1
 8186 0234 B0F1FF3F 		cmp	r0, #-1
 8187 0238 14BF     		ite	ne
 8188 023a 5046     		movne	r0, sl
 8189 023c 4FF0FF30 		moveq	r0, #-1
 8190              	.LVL1206:
 8191              	.L974:
4246:lib/ff/ff.c   **** 		c = *str++;
 8192              		.loc 1 4246 0
 8193 0240 8144     		add	r9, r9, r0
 8194              	.LVL1207:
 8195 0242 411C     		adds	r1, r0, #1
 8196 0244 07D0     		beq	.L1015
 8197              	.L1022:
 8198 0246 2A46     		mov	r2, r5
 8199 0248 E5E6     		b	.L1014
 8200              	.LVL1208:
 8201              	.L972:
4322:lib/ff/ff.c   **** }
 8202              		.loc 1 4322 0
 8203 024a B0F1FF3F 		cmp	r0, #-1
 8204 024e 14BF     		ite	ne
 8205 0250 4846     		movne	r0, r9
 8206 0252 4FF0FF30 		moveq	r0, #-1
 8207              	.L1015:
 8208              		.loc 1 4323 0 discriminator 3
 8209 0256 08B0     		add	sp, sp, #32
 8210 0258 BDE8F04F 		pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8211 025c 03B0     		add	sp, sp, #12
 8212 025e 7047     		bx	lr
 8213              		.cfi_endproc
 8214              	.LFE55:
 8216              		.section	.rodata.cst.4341,"a",%progbits
 8217              		.align	1
 8218              		.set	.LANCHOR4,. + 0
 8221              	cst.4341:
 8222 0000 0080     		.short	-32768
 8223 0002 0040     		.short	16384
 8224 0004 0020     		.short	8192
 8225 0006 0010     		.short	4096
 8226 0008 0008     		.short	2048
 8227 000a 0040     		.short	16384
 8228 000c 0020     		.short	8192
 8229 000e 0010     		.short	4096
 8230 0010 0008     		.short	2048
 8231 0012 0004     		.short	1024
 8232 0014 0002     		.short	512
 8233              		.section	.bss.CurrVol,"aw",%nobits
 8234              		.set	.LANCHOR0,. + 0
 8237              	CurrVol:
 8238 0000 00       		.space	1
 8239              		.section	.rodata.str1.1,"aMS",%progbits,1
 8240              	.LC0:
 8241 0000 222A2B2C 		.ascii	"\"*+,:;<=>?[]|\177\000"
 8241      3A3B3C3D 
 8241      3E3F5B5D 
 8241      7C7F00
 8242              	.LC1:
 8243 000f 222A2B2C 		.ascii	"\"*+,.:;<=>?[]|\177\000"
 8243      2E3A3B3C 
 8243      3D3E3F5B 
 8243      5D7C7F00 
 8244              	.LC2:
 8245 001f EBFE904D 		.ascii	"\353\376\220MSDOS5.0\000"
 8245      53444F53 
 8245      352E3000 
 8246              	.LC3:
 8247 002b 4E4F204E 		.ascii	"NO NAME    FAT32   \000"
 8247      414D4520 
 8247      20202046 
 8247      41543332 
 8247      20202000 
 8248              	.LC4:
 8249 003f 4E4F204E 		.ascii	"NO NAME    FAT     \000"
 8249      414D4520 
 8249      20202046 
 8249      41542020 
 8249      20202000 
 8250              		.section	.bss.Fsid,"aw",%nobits
 8251              		.align	1
 8252              		.set	.LANCHOR2,. + 0
 8255              	Fsid:
 8256 0000 0000     		.space	2
 8257              		.section	.rodata.vst.4340,"a",%progbits
 8258              		.align	1
 8259              		.set	.LANCHOR3,. + 0
 8262              	vst.4340:
 8263 0000 0004     		.short	1024
 8264 0002 0002     		.short	512
 8265 0004 0001     		.short	256
 8266 0006 8000     		.short	128
 8267 0008 4000     		.short	64
 8268 000a 2000     		.short	32
 8269 000c 1000     		.short	16
 8270 000e 0800     		.short	8
 8271 0010 0400     		.short	4
 8272 0012 0200     		.short	2
 8273 0014 0000     		.short	0
 8274              		.section	.bss.FatFs,"aw",%nobits
 8275              		.align	2
 8276              		.set	.LANCHOR1,. + 0
 8279              	FatFs:
 8280 0000 00000000 		.space	4
 8281              		.text
 8282              	.Letext0:
 8283              		.file 2 "lib/ff/integer.h"
 8284              		.file 3 "lib/ff/ff.h"
 8285              		.file 4 "lib/ff/diskio.h"
 8286              		.file 5 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/include/stdarg.h"
 8287              		.file 6 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ff.c
  R:\TEMP\cchDn2wG.s:19     .text.mem_cpy:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:23     .text.mem_cpy:0000000000000000 mem_cpy
  R:\TEMP\cchDn2wG.s:77     .text.mem_set:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:81     .text.mem_set:0000000000000000 mem_set
  R:\TEMP\cchDn2wG.s:109    .text.clmt_clust:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:113    .text.clmt_clust:0000000000000000 clmt_clust
  R:\TEMP\cchDn2wG.s:164    .text.get_fileinfo:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:168    .text.get_fileinfo:0000000000000000 get_fileinfo
  R:\TEMP\cchDn2wG.s:275    .text.validate:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:279    .text.validate:0000000000000000 validate
  R:\TEMP\cchDn2wG.s:323    .text.sync_window:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:327    .text.sync_window:0000000000000000 sync_window
  R:\TEMP\cchDn2wG.s:415    .text.sync_fs:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:419    .text.sync_fs:0000000000000000 sync_fs
  R:\TEMP\cchDn2wG.s:499    .text.sync_fs:0000000000000068 $d
  R:\TEMP\cchDn2wG.s:505    .text.move_window:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:509    .text.move_window:0000000000000000 move_window
  R:\TEMP\cchDn2wG.s:565    .text.check_fs:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:569    .text.check_fs:0000000000000000 check_fs
  R:\TEMP\cchDn2wG.s:630    .text.check_fs:0000000000000048 $d
  R:\TEMP\cchDn2wG.s:635    .text.chk_mounted:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:639    .text.chk_mounted:0000000000000000 chk_mounted
  R:\TEMP\cchDn2wG.s:1035   .text.chk_mounted:0000000000000204 $d
  R:\TEMP\cchDn2wG.s:1044   .text.clust2sect:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:1049   .text.clust2sect:0000000000000000 clust2sect
  R:\TEMP\cchDn2wG.s:1082   .text.get_fat:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:1087   .text.get_fat:0000000000000000 get_fat
  R:\TEMP\cchDn2wG.s:1223   .text.dir_sdi:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:1227   .text.dir_sdi:0000000000000000 dir_sdi
  R:\TEMP\cchDn2wG.s:1356   .text.dir_remove:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:1360   .text.dir_remove:0000000000000000 dir_remove
  R:\TEMP\cchDn2wG.s:1408   .text.put_fat:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:1413   .text.put_fat:0000000000000000 put_fat
  R:\TEMP\cchDn2wG.s:1588   .text.create_chain:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:1592   .text.create_chain:0000000000000000 create_chain
  R:\TEMP\cchDn2wG.s:1755   .text.dir_next:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:1759   .text.dir_next:0000000000000000 dir_next
  R:\TEMP\cchDn2wG.s:1963   .text.dir_read:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:1967   .text.dir_read:0000000000000000 dir_read
  R:\TEMP\cchDn2wG.s:2067   .text.follow_path:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:2071   .text.follow_path:0000000000000000 follow_path
  R:\TEMP\cchDn2wG.s:2566   .text.follow_path:0000000000000254 $d
  R:\TEMP\cchDn2wG.s:2571   .text.dir_alloc.constprop.9:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:2575   .text.dir_alloc.constprop.9:0000000000000000 dir_alloc.constprop.9
  R:\TEMP\cchDn2wG.s:2632   .text.dir_register:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:2636   .text.dir_register:0000000000000000 dir_register
  R:\TEMP\cchDn2wG.s:2697   .text.remove_chain:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:2701   .text.remove_chain:0000000000000000 remove_chain
  R:\TEMP\cchDn2wG.s:2834   .text.f_mount:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:2839   .text.f_mount:0000000000000000 f_mount
  R:\TEMP\cchDn2wG.s:2880   .text.f_mount:000000000000001c $d
  R:\TEMP\cchDn2wG.s:2885   .text.f_open:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:2890   .text.f_open:0000000000000000 f_open
  R:\TEMP\cchDn2wG.s:3170   .text.f_read:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:3175   .text.f_read:0000000000000000 f_read
  R:\TEMP\cchDn2wG.s:3422   .text.f_write:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:3427   .text.f_write:0000000000000000 f_write
  R:\TEMP\cchDn2wG.s:3736   .text.f_sync:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:3741   .text.f_sync:0000000000000000 f_sync
  R:\TEMP\cchDn2wG.s:3831   .text.f_close:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:3836   .text.f_close:0000000000000000 f_close
  R:\TEMP\cchDn2wG.s:3863   .text.f_chdrive:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:3868   .text.f_chdrive:0000000000000000 f_chdrive
  R:\TEMP\cchDn2wG.s:3892   .text.f_chdrive:000000000000000c $d
  R:\TEMP\cchDn2wG.s:3897   .text.f_chdir:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:3902   .text.f_chdir:0000000000000000 f_chdir
  R:\TEMP\cchDn2wG.s:3997   .text.f_getcwd:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:4002   .text.f_getcwd:0000000000000000 f_getcwd
  R:\TEMP\cchDn2wG.s:4282   .text.f_getcwd:0000000000000124 $d
  R:\TEMP\cchDn2wG.s:4287   .text.f_lseek:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:4292   .text.f_lseek:0000000000000000 f_lseek
  R:\TEMP\cchDn2wG.s:4687   .text.f_opendir:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:4692   .text.f_opendir:0000000000000000 f_opendir
  R:\TEMP\cchDn2wG.s:4802   .text.f_readdir:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:4807   .text.f_readdir:0000000000000000 f_readdir
  R:\TEMP\cchDn2wG.s:4899   .text.f_stat:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:4904   .text.f_stat:0000000000000000 f_stat
  R:\TEMP\cchDn2wG.s:4971   .text.f_getfree:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:4976   .text.f_getfree:0000000000000000 f_getfree
  R:\TEMP\cchDn2wG.s:5163   .text.f_truncate:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:5168   .text.f_truncate:0000000000000000 f_truncate
  R:\TEMP\cchDn2wG.s:5300   .text.f_unlink:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:5305   .text.f_unlink:0000000000000000 f_unlink
  R:\TEMP\cchDn2wG.s:5498   .text.f_mkdir:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:5503   .text.f_mkdir:0000000000000000 f_mkdir
  R:\TEMP\cchDn2wG.s:5779   .text.f_chmod:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:5784   .text.f_chmod:0000000000000000 f_chmod
  R:\TEMP\cchDn2wG.s:5872   .text.f_utime:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:5877   .text.f_utime:0000000000000000 f_utime
  R:\TEMP\cchDn2wG.s:5959   .text.f_rename:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:5964   .text.f_rename:0000000000000000 f_rename
  R:\TEMP\cchDn2wG.s:6192   .text.f_getlabel:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:6197   .text.f_getlabel:0000000000000000 f_getlabel
  R:\TEMP\cchDn2wG.s:6319   .text.f_setlabel:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:6324   .text.f_setlabel:0000000000000000 f_setlabel
  R:\TEMP\cchDn2wG.s:6627   .text.f_setlabel:000000000000016c $d
  R:\TEMP\cchDn2wG.s:6632   .text.f_forward:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:6637   .text.f_forward:0000000000000000 f_forward
  R:\TEMP\cchDn2wG.s:6823   .text.f_mkfs:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:6828   .text.f_mkfs:0000000000000000 f_mkfs
  R:\TEMP\cchDn2wG.s:7309   .text.f_mkfs:00000000000002e8 $d
  R:\TEMP\cchDn2wG.s:7319   .text.f_mkfs:0000000000000304 $t
  R:\TEMP\cchDn2wG.s:7540   .text.f_mkfs:0000000000000458 $d
  R:\TEMP\cchDn2wG.s:7546   .text.f_gets:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:7551   .text.f_gets:0000000000000000 f_gets
  R:\TEMP\cchDn2wG.s:7622   .text.f_putc:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:7627   .text.f_putc:0000000000000000 f_putc
  R:\TEMP\cchDn2wG.s:7666   .text.f_puts:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:7671   .text.f_puts:0000000000000000 f_puts
  R:\TEMP\cchDn2wG.s:7719   .text.f_printf:0000000000000000 $t
  R:\TEMP\cchDn2wG.s:7724   .text.f_printf:0000000000000000 f_printf
  R:\TEMP\cchDn2wG.s:8217   .rodata.cst.4341:0000000000000000 $d
  R:\TEMP\cchDn2wG.s:8221   .rodata.cst.4341:0000000000000000 cst.4341
  R:\TEMP\cchDn2wG.s:8237   .bss.CurrVol:0000000000000000 CurrVol
  R:\TEMP\cchDn2wG.s:8238   .bss.CurrVol:0000000000000000 $d
  R:\TEMP\cchDn2wG.s:8240   .rodata.str1.1:0000000000000000 .LC0
  R:\TEMP\cchDn2wG.s:8242   .rodata.str1.1:000000000000000f .LC1
  R:\TEMP\cchDn2wG.s:8251   .bss.Fsid:0000000000000000 $d
  R:\TEMP\cchDn2wG.s:8255   .bss.Fsid:0000000000000000 Fsid
  R:\TEMP\cchDn2wG.s:8258   .rodata.vst.4340:0000000000000000 $d
  R:\TEMP\cchDn2wG.s:8262   .rodata.vst.4340:0000000000000000 vst.4340
  R:\TEMP\cchDn2wG.s:8275   .bss.FatFs:0000000000000000 $d
  R:\TEMP\cchDn2wG.s:8279   .bss.FatFs:0000000000000000 FatFs
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
disk_status
disk_write
disk_ioctl
disk_read
disk_initialize
get_fattime
