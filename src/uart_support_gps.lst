   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"uart_support_gps.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.conio_init,"ax",%progbits
  19              		.align	1
  20              		.global	conio_init
  21              		.thumb
  22              		.thumb_func
  24              	conio_init:
  25              	.LFB56:
  26              		.file 1 "src/uart_support_gps.c"
   1:src/uart_support_gps.c **** /********************************************************************************/
   2:src/uart_support_gps.c **** /*!
   3:src/uart_support_gps.c **** 	@file			uart_support_gps.c
   4:src/uart_support_gps.c **** 	@author         Nemui Trinomius (http://nemuisan.blog.bai.ne.jp)
   5:src/uart_support_gps.c ****     @version        2.00
   6:src/uart_support_gps.c ****     @date           2013.02.20
   7:src/uart_support_gps.c **** 	@brief          For STM32 Primer2(USART2).
   8:src/uart_support_gps.c **** 
   9:src/uart_support_gps.c ****     @section HISTORY
  10:src/uart_support_gps.c **** 		2012.01.31	V1.00	Start Here.
  11:src/uart_support_gps.c **** 		2013.02.20	V2.00	Added RX/TX Buffer Consideration.
  12:src/uart_support_gps.c **** 
  13:src/uart_support_gps.c ****     @section LICENSE
  14:src/uart_support_gps.c **** 		BSD License. See Copyright.txt
  15:src/uart_support_gps.c **** */
  16:src/uart_support_gps.c **** /********************************************************************************/
  17:src/uart_support_gps.c **** 
  18:src/uart_support_gps.c **** /* Includes ------------------------------------------------------------------*/
  19:src/uart_support_gps.c **** #include "uart_support_gps.h"
  20:src/uart_support_gps.c **** 
  21:src/uart_support_gps.c **** /* Defines -------------------------------------------------------------------*/
  22:src/uart_support_gps.c **** 
  23:src/uart_support_gps.c **** /* Variables -----------------------------------------------------------------*/
  24:src/uart_support_gps.c **** USART_InitTypeDef USART_InitStructure;
  25:src/uart_support_gps.c **** static USART_TypeDef* UART;
  26:src/uart_support_gps.c **** static USART_Buffer_t* pUSART_Buf;
  27:src/uart_support_gps.c **** USART_Buffer_t USART2_Buf;
  28:src/uart_support_gps.c **** 
  29:src/uart_support_gps.c **** /* Constants -----------------------------------------------------------------*/
  30:src/uart_support_gps.c **** 
  31:src/uart_support_gps.c **** /* Function prototypes -------------------------------------------------------*/
  32:src/uart_support_gps.c **** void (*xUART_IRQ)(void);
  33:src/uart_support_gps.c **** 
  34:src/uart_support_gps.c **** /* Functions -----------------------------------------------------------------*/
  35:src/uart_support_gps.c **** 
  36:src/uart_support_gps.c **** /**************************************************************************/
  37:src/uart_support_gps.c **** /*! 
  38:src/uart_support_gps.c ****     Initialize UART.
  39:src/uart_support_gps.c **** */
  40:src/uart_support_gps.c **** /**************************************************************************/
  41:src/uart_support_gps.c **** /* Initialize serial console */
  42:src/uart_support_gps.c **** void conio_init(uint32_t port, uint32_t baudrate)
  43:src/uart_support_gps.c **** {
  27              		.loc 1 43 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 32
  35              		.cfi_offset 0, -32
  36              		.cfi_offset 1, -28
  37              		.cfi_offset 4, -24
  38              		.cfi_offset 5, -20
  39              		.cfi_offset 6, -16
  40              		.cfi_offset 7, -12
  41              		.cfi_offset 8, -8
  42              		.cfi_offset 14, -4
  43 0004 0446     		mov	r4, r0
  44 0006 8846     		mov	r8, r1
  44:src/uart_support_gps.c **** 	GPIO_InitTypeDef GPIO_InitStructure;
  45:src/uart_support_gps.c **** 	NVIC_InitTypeDef NVIC_InitStructure;
  46:src/uart_support_gps.c ****   
  47:src/uart_support_gps.c **** 	/* Turn on USART*/
  48:src/uart_support_gps.c **** 	switch (port)
  45              		.loc 1 48 0
  46 0008 0228     		cmp	r0, #2
  47 000a 55D1     		bne	.L1
  49:src/uart_support_gps.c **** 	{
  50:src/uart_support_gps.c **** 		case 1 :
  51:src/uart_support_gps.c **** 		break;
  52:src/uart_support_gps.c ****  
  53:src/uart_support_gps.c **** 		case 2 :
  54:src/uart_support_gps.c **** 			UART = (USART_TypeDef *) USART2_BASE;
  48              		.loc 1 54 0
  49 000c 2B4D     		ldr	r5, .L5
  50 000e 2C4B     		ldr	r3, .L5+4
  51 0010 2B60     		str	r3, [r5, #0]
  55:src/uart_support_gps.c **** 
  56:src/uart_support_gps.c **** #if defined (USE_STM3210B_EVAL) || defined (USE_STM3210C_EVAL) || \
  57:src/uart_support_gps.c **** 	defined (USE_GOLDBULL)      || defined (USE_CQ_STARM_COMP) || defined (USE_ETHERPOD)
  58:src/uart_support_gps.c **** 			/* Turn on peripheral clocks */
  59:src/uart_support_gps.c **** 			RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD|RCC_APB2Periph_AFIO, ENABLE);
  60:src/uart_support_gps.c **** 			RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
  61:src/uart_support_gps.c **** 
  62:src/uart_support_gps.c **** 			/* Enable the USART2 Pins Software Remapping */
  63:src/uart_support_gps.c **** 			GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);
  64:src/uart_support_gps.c **** 	
  65:src/uart_support_gps.c **** 			/* Configure USART2 TX as alternate function push-pull */
  66:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_5;
  67:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_50MHz;
  68:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_AF_PP;
  69:src/uart_support_gps.c **** 			GPIO_Init(GPIOD, &GPIO_InitStructure);
  70:src/uart_support_gps.c **** 
  71:src/uart_support_gps.c **** 			/* Configure USART2 RX as input floating */
  72:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_6;
  73:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_50MHz;
  74:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_IN_FLOATING;
  75:src/uart_support_gps.c **** 			GPIO_Init(GPIOD, &GPIO_InitStructure);
  76:src/uart_support_gps.c **** 
  77:src/uart_support_gps.c **** #else	/* defined (USE_STM32PRIMER2) */
  78:src/uart_support_gps.c **** 
  79:src/uart_support_gps.c **** 			/* Turn on peripheral clocks */
  80:src/uart_support_gps.c **** 			RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO, ENABLE);
  52              		.loc 1 80 0
  53 0012 0520     		movs	r0, #5
  54              	.LVL1:
  55 0014 0121     		movs	r1, #1
  56              	.LVL2:
  57 0016 FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
  58              	.LVL3:
  81:src/uart_support_gps.c **** 			RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
  59              		.loc 1 81 0
  60 001a 4FF40030 		mov	r0, #131072
  61 001e 0121     		movs	r1, #1
  62 0020 FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
  63              	.LVL4:
  82:src/uart_support_gps.c **** 
  83:src/uart_support_gps.c **** 			/* Configure USART2 TX as alternate function push-pull */
  84:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_2;
  64              		.loc 1 84 0
  65 0024 0420     		movs	r0, #4
  66 0026 0746     		mov	r7, r0	@ movhi
  67 0028 ADF80000 		strh	r0, [sp, #0]	@ movhi
  85:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_50MHz;
  68              		.loc 1 85 0
  69 002c 0326     		movs	r6, #3
  70 002e 8DF80260 		strb	r6, [sp, #2]
  86:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_AF_PP;
  71              		.loc 1 86 0
  72 0032 1821     		movs	r1, #24
  73 0034 8DF80310 		strb	r1, [sp, #3]
  87:src/uart_support_gps.c **** 			GPIO_Init(GPIOA, &GPIO_InitStructure);
  74              		.loc 1 87 0
  75 0038 2248     		ldr	r0, .L5+8
  76 003a 6946     		mov	r1, sp
  77 003c FFF7FEFF 		bl	GPIO_Init
  78              	.LVL5:
  88:src/uart_support_gps.c **** 
  89:src/uart_support_gps.c **** 			/* Configure USART2 RX as input floating */
  90:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_3;
  79              		.loc 1 90 0
  80 0040 0822     		movs	r2, #8
  81 0042 ADF80020 		strh	r2, [sp, #0]	@ movhi
  91:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_50MHz;
  82              		.loc 1 91 0
  83 0046 8DF80260 		strb	r6, [sp, #2]
  92:src/uart_support_gps.c **** 			GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_IN_FLOATING;
  84              		.loc 1 92 0
  85 004a 8DF80370 		strb	r7, [sp, #3]
  93:src/uart_support_gps.c **** 			GPIO_Init(GPIOA, &GPIO_InitStructure);
  86              		.loc 1 93 0
  87 004e 1D48     		ldr	r0, .L5+8
  88 0050 6946     		mov	r1, sp
  89 0052 FFF7FEFF 		bl	GPIO_Init
  90              	.LVL6:
  94:src/uart_support_gps.c **** #endif
  95:src/uart_support_gps.c **** 
  96:src/uart_support_gps.c **** #if (UART_HANDLING == UART_INTERRUPT_MODE)
  97:src/uart_support_gps.c **** 			/* Configure one bit for preemption priority */
  98:src/uart_support_gps.c **** 			NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
  91              		.loc 1 98 0
  92 0056 4FF4C060 		mov	r0, #1536
  93 005a FFF7FEFF 		bl	NVIC_PriorityGroupConfig
  94              	.LVL7:
  99:src/uart_support_gps.c **** 
 100:src/uart_support_gps.c **** 			/* Enable the USART2 Interrupt */
 101:src/uart_support_gps.c **** 			NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
  95              		.loc 1 101 0
  96 005e 2623     		movs	r3, #38
  97 0060 8DF80430 		strb	r3, [sp, #4]
 102:src/uart_support_gps.c **** 			NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
  98              		.loc 1 102 0
  99 0064 8DF80540 		strb	r4, [sp, #5]
 103:src/uart_support_gps.c **** 			NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 100              		.loc 1 103 0
 101 0068 0024     		movs	r4, #0
 102              	.LVL8:
 103 006a 8DF80640 		strb	r4, [sp, #6]
 104:src/uart_support_gps.c **** 			NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 104              		.loc 1 104 0
 105 006e 0126     		movs	r6, #1
 106 0070 8DF80760 		strb	r6, [sp, #7]
 105:src/uart_support_gps.c **** 			NVIC_Init(&NVIC_InitStructure);
 107              		.loc 1 105 0
 108 0074 01A8     		add	r0, sp, #4
 109 0076 FFF7FEFF 		bl	NVIC_Init
 110              	.LVL9:
 106:src/uart_support_gps.c **** 
 107:src/uart_support_gps.c **** 			USART_StructInit(&USART_InitStructure);
 111              		.loc 1 107 0
 112 007a 134F     		ldr	r7, .L5+12
 113 007c 3846     		mov	r0, r7
 114 007e FFF7FEFF 		bl	USART_StructInit
 115              	.LVL10:
 108:src/uart_support_gps.c **** 			USART_InitStructure.USART_BaudRate = baudrate;
 116              		.loc 1 108 0
 117 0082 C7F80080 		str	r8, [r7, #0]
 109:src/uart_support_gps.c **** 			USART_Init(UART, &USART_InitStructure);
 118              		.loc 1 109 0
 119 0086 2868     		ldr	r0, [r5, #0]
 120 0088 3946     		mov	r1, r7
 121 008a FFF7FEFF 		bl	USART_Init
 122              	.LVL11:
 110:src/uart_support_gps.c **** 
 111:src/uart_support_gps.c **** 			/* Init Ring Buffer */
 112:src/uart_support_gps.c **** 			pUSART_Buf = &USART2_Buf;
 123              		.loc 1 112 0
 124 008e 0F48     		ldr	r0, .L5+16
 125 0090 0F49     		ldr	r1, .L5+20
 126 0092 0860     		str	r0, [r1, #0]
 113:src/uart_support_gps.c **** 			USART2_Buf.RX_Tail = 0;
 127              		.loc 1 113 0
 128 0094 A0F80242 		strh	r4, [r0, #514]	@ movhi
 114:src/uart_support_gps.c **** 			USART2_Buf.RX_Head = 0;
 129              		.loc 1 114 0
 130 0098 A0F80042 		strh	r4, [r0, #512]	@ movhi
 115:src/uart_support_gps.c **** 			USART2_Buf.TX_Tail = 0;
 131              		.loc 1 115 0
 132 009c A0F80642 		strh	r4, [r0, #518]	@ movhi
 116:src/uart_support_gps.c **** 			USART2_Buf.TX_Head = 0;
 133              		.loc 1 116 0
 134 00a0 A0F80442 		strh	r4, [r0, #516]	@ movhi
 117:src/uart_support_gps.c **** 
 118:src/uart_support_gps.c **** 			/* Enable USART2 Receive interrupts */
 119:src/uart_support_gps.c **** 			USART_ITConfig(UART, USART_IT_RXNE, ENABLE);
 135              		.loc 1 119 0
 136 00a4 2868     		ldr	r0, [r5, #0]
 137 00a6 40F22551 		movw	r1, #1317
 138 00aa 3246     		mov	r2, r6
 139 00ac FFF7FEFF 		bl	USART_ITConfig
 140              	.LVL12:
 120:src/uart_support_gps.c **** #endif
 121:src/uart_support_gps.c **** 			/* Enable UART */
 122:src/uart_support_gps.c **** 			USART_Cmd(UART, ENABLE);
 141              		.loc 1 122 0
 142 00b0 2868     		ldr	r0, [r5, #0]
 143 00b2 3146     		mov	r1, r6
 144 00b4 FFF7FEFF 		bl	USART_Cmd
 145              	.LVL13:
 146              	.L1:
 123:src/uart_support_gps.c **** 		break;
 124:src/uart_support_gps.c ****  
 125:src/uart_support_gps.c **** 		case 3 : /* NOT Supported yet */
 126:src/uart_support_gps.c **** 		break;
 127:src/uart_support_gps.c **** 
 128:src/uart_support_gps.c **** 	}
 129:src/uart_support_gps.c **** 
 130:src/uart_support_gps.c **** }
 147              		.loc 1 130 0
 148 00b8 BDE8FC81 		pop	{r2, r3, r4, r5, r6, r7, r8, pc}
 149              	.L6:
 150              		.align	2
 151              	.L5:
 152 00bc 00000000 		.word	.LANCHOR0
 153 00c0 00440040 		.word	1073759232
 154 00c4 00080140 		.word	1073809408
 155 00c8 00000000 		.word	.LANCHOR1
 156 00cc 00000000 		.word	.LANCHOR3
 157 00d0 00000000 		.word	.LANCHOR2
 158              		.cfi_endproc
 159              	.LFE56:
 161              		.section	.text.USART_TXBuffer_FreeSpace,"ax",%progbits
 162              		.align	1
 163              		.global	USART_TXBuffer_FreeSpace
 164              		.thumb
 165              		.thumb_func
 167              	USART_TXBuffer_FreeSpace:
 168              	.LFB57:
 131:src/uart_support_gps.c **** 
 132:src/uart_support_gps.c **** /**************************************************************************/
 133:src/uart_support_gps.c **** /*! 
 134:src/uart_support_gps.c ****     Check UART TX Buffer Empty.
 135:src/uart_support_gps.c **** */
 136:src/uart_support_gps.c **** /**************************************************************************/
 137:src/uart_support_gps.c **** bool USART_TXBuffer_FreeSpace(USART_Buffer_t* USART_buf)
 138:src/uart_support_gps.c **** {
 169              		.loc 1 138 0
 170              		.cfi_startproc
 171              		@ args = 0, pretend = 0, frame = 0
 172              		@ frame_needed = 0, uses_anonymous_args = 0
 173              		@ link register save eliminated.
 174              	.LVL14:
 139:src/uart_support_gps.c **** 	/* Make copies to make sure that volatile access is specified. */
 140:src/uart_support_gps.c **** 	uint8_t tempHead = (USART_buf->TX_Head + 1) & (UART_BUFSIZE-1);
 175              		.loc 1 140 0
 176 0000 B0F80422 		ldrh	r2, [r0, #516]
 177              	.LVL15:
 141:src/uart_support_gps.c **** 	uint8_t tempTail = USART_buf->TX_Tail;
 178              		.loc 1 141 0
 179 0004 B0F80632 		ldrh	r3, [r0, #518]
 180              	.LVL16:
 140:src/uart_support_gps.c **** 	uint8_t tempTail = USART_buf->TX_Tail;
 181              		.loc 1 140 0
 182 0008 501C     		adds	r0, r2, #1
 183              	.LVL17:
 142:src/uart_support_gps.c **** 
 143:src/uart_support_gps.c **** 	/* There are data left in the buffer unless Head and Tail are equal. */
 144:src/uart_support_gps.c **** 	return (tempHead != tempTail);
 184              		.loc 1 144 0
 185 000a 00F0FF01 		and	r1, r0, #255
 186 000e DAB2     		uxtb	r2, r3
 187              	.LVL18:
 145:src/uart_support_gps.c **** }
 188              		.loc 1 145 0
 189 0010 881A     		subs	r0, r1, r2
 190 0012 18BF     		it	ne
 191 0014 0120     		movne	r0, #1
 192 0016 7047     		bx	lr
 193              		.cfi_endproc
 194              	.LFE57:
 196              		.section	.text.USART_TXBuffer_PutByte,"ax",%progbits
 197              		.align	1
 198              		.global	USART_TXBuffer_PutByte
 199              		.thumb
 200              		.thumb_func
 202              	USART_TXBuffer_PutByte:
 203              	.LFB58:
 146:src/uart_support_gps.c **** 
 147:src/uart_support_gps.c **** /**************************************************************************/
 148:src/uart_support_gps.c **** /*! 
 149:src/uart_support_gps.c ****     Put Bytedata with Buffering.
 150:src/uart_support_gps.c **** */
 151:src/uart_support_gps.c **** /**************************************************************************/
 152:src/uart_support_gps.c **** bool USART_TXBuffer_PutByte(USART_Buffer_t* USART_buf, uint8_t data)
 153:src/uart_support_gps.c **** {
 204              		.loc 1 153 0
 205              		.cfi_startproc
 206              		@ args = 0, pretend = 0, frame = 0
 207              		@ frame_needed = 0, uses_anonymous_args = 0
 208              	.LVL19:
 209 0000 10B5     		push	{r4, lr}
 210              	.LCFI1:
 211              		.cfi_def_cfa_offset 8
 212              		.cfi_offset 4, -8
 213              		.cfi_offset 14, -4
 214 0002 0346     		mov	r3, r0
 215              	.LVL20:
 216              	.LBB18:
 217              	.LBB19:
 140:src/uart_support_gps.c **** 	uint8_t tempTail = USART_buf->TX_Tail;
 218              		.loc 1 140 0
 219 0004 B0F80442 		ldrh	r4, [r0, #516]
 220              	.LVL21:
 141:src/uart_support_gps.c **** 
 221              		.loc 1 141 0
 222 0008 B0F80622 		ldrh	r2, [r0, #518]
 223              	.LVL22:
 140:src/uart_support_gps.c **** 	uint8_t tempTail = USART_buf->TX_Tail;
 224              		.loc 1 140 0
 225 000c 601C     		adds	r0, r4, #1
 226              	.LVL23:
 144:src/uart_support_gps.c **** }
 227              		.loc 1 144 0
 228 000e 00F0FF04 		and	r4, r0, #255
 229              	.LVL24:
 230 0012 D2B2     		uxtb	r2, r2
 231              	.LVL25:
 232 0014 A41A     		subs	r4, r4, r2
 233 0016 18BF     		it	ne
 234 0018 0124     		movne	r4, #1
 235              	.LBE19:
 236              	.LBE18:
 154:src/uart_support_gps.c **** 
 155:src/uart_support_gps.c **** 	uint8_t tempTX_Head;
 156:src/uart_support_gps.c **** 	bool TXBuffer_FreeSpace;
 157:src/uart_support_gps.c **** 
 158:src/uart_support_gps.c **** 	TXBuffer_FreeSpace = USART_TXBuffer_FreeSpace(USART_buf);
 159:src/uart_support_gps.c **** 
 160:src/uart_support_gps.c **** 
 161:src/uart_support_gps.c **** 	if(TXBuffer_FreeSpace)
 237              		.loc 1 161 0
 238 001a 9CB1     		cbz	r4, .L9
 162:src/uart_support_gps.c **** 	{
 163:src/uart_support_gps.c **** 	  	tempTX_Head = USART_buf->TX_Head;
 239              		.loc 1 163 0
 240 001c B3F80402 		ldrh	r0, [r3, #516]
 241 0020 82B2     		uxth	r2, r0
 242              	.LVL26:
 243              	.LBB20:
 244              	.LBB21:
 245              		.file 2 "./lib/CMSIS/Include/core_cmFunc.h"
   1:./lib/CMSIS/Include/core_cmFunc.h **** /**************************************************************************//**
   2:./lib/CMSIS/Include/core_cmFunc.h ****  * @file     core_cmFunc.h
   3:./lib/CMSIS/Include/core_cmFunc.h ****  * @brief    CMSIS Cortex-M Core Function Access Header File
   4:./lib/CMSIS/Include/core_cmFunc.h ****  * @version  V3.20
   5:./lib/CMSIS/Include/core_cmFunc.h ****  * @date     25. February 2013
   6:./lib/CMSIS/Include/core_cmFunc.h ****  *
   7:./lib/CMSIS/Include/core_cmFunc.h ****  * @note
   8:./lib/CMSIS/Include/core_cmFunc.h ****  *
   9:./lib/CMSIS/Include/core_cmFunc.h ****  ******************************************************************************/
  10:./lib/CMSIS/Include/core_cmFunc.h **** /* Copyright (c) 2009 - 2013 ARM LIMITED
  11:./lib/CMSIS/Include/core_cmFunc.h **** 
  12:./lib/CMSIS/Include/core_cmFunc.h ****    All rights reserved.
  13:./lib/CMSIS/Include/core_cmFunc.h ****    Redistribution and use in source and binary forms, with or without
  14:./lib/CMSIS/Include/core_cmFunc.h ****    modification, are permitted provided that the following conditions are met:
  15:./lib/CMSIS/Include/core_cmFunc.h ****    - Redistributions of source code must retain the above copyright
  16:./lib/CMSIS/Include/core_cmFunc.h ****      notice, this list of conditions and the following disclaimer.
  17:./lib/CMSIS/Include/core_cmFunc.h ****    - Redistributions in binary form must reproduce the above copyright
  18:./lib/CMSIS/Include/core_cmFunc.h ****      notice, this list of conditions and the following disclaimer in the
  19:./lib/CMSIS/Include/core_cmFunc.h ****      documentation and/or other materials provided with the distribution.
  20:./lib/CMSIS/Include/core_cmFunc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:./lib/CMSIS/Include/core_cmFunc.h ****      to endorse or promote products derived from this software without
  22:./lib/CMSIS/Include/core_cmFunc.h ****      specific prior written permission.
  23:./lib/CMSIS/Include/core_cmFunc.h ****    *
  24:./lib/CMSIS/Include/core_cmFunc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:./lib/CMSIS/Include/core_cmFunc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:./lib/CMSIS/Include/core_cmFunc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:./lib/CMSIS/Include/core_cmFunc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:./lib/CMSIS/Include/core_cmFunc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:./lib/CMSIS/Include/core_cmFunc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:./lib/CMSIS/Include/core_cmFunc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:./lib/CMSIS/Include/core_cmFunc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:./lib/CMSIS/Include/core_cmFunc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:./lib/CMSIS/Include/core_cmFunc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:./lib/CMSIS/Include/core_cmFunc.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:./lib/CMSIS/Include/core_cmFunc.h ****    ---------------------------------------------------------------------------*/
  36:./lib/CMSIS/Include/core_cmFunc.h **** 
  37:./lib/CMSIS/Include/core_cmFunc.h **** 
  38:./lib/CMSIS/Include/core_cmFunc.h **** #ifndef __CORE_CMFUNC_H
  39:./lib/CMSIS/Include/core_cmFunc.h **** #define __CORE_CMFUNC_H
  40:./lib/CMSIS/Include/core_cmFunc.h **** 
  41:./lib/CMSIS/Include/core_cmFunc.h **** 
  42:./lib/CMSIS/Include/core_cmFunc.h **** /* ###########################  Core Function Access  ########################### */
  43:./lib/CMSIS/Include/core_cmFunc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  44:./lib/CMSIS/Include/core_cmFunc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  45:./lib/CMSIS/Include/core_cmFunc.h ****   @{
  46:./lib/CMSIS/Include/core_cmFunc.h ****  */
  47:./lib/CMSIS/Include/core_cmFunc.h **** 
  48:./lib/CMSIS/Include/core_cmFunc.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  49:./lib/CMSIS/Include/core_cmFunc.h **** /* ARM armcc specific functions */
  50:./lib/CMSIS/Include/core_cmFunc.h **** 
  51:./lib/CMSIS/Include/core_cmFunc.h **** #if (__ARMCC_VERSION < 400677)
  52:./lib/CMSIS/Include/core_cmFunc.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  53:./lib/CMSIS/Include/core_cmFunc.h **** #endif
  54:./lib/CMSIS/Include/core_cmFunc.h **** 
  55:./lib/CMSIS/Include/core_cmFunc.h **** /* intrinsic void __enable_irq();     */
  56:./lib/CMSIS/Include/core_cmFunc.h **** /* intrinsic void __disable_irq();    */
  57:./lib/CMSIS/Include/core_cmFunc.h **** 
  58:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Control Register
  59:./lib/CMSIS/Include/core_cmFunc.h **** 
  60:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the Control Register.
  61:./lib/CMSIS/Include/core_cmFunc.h **** 
  62:./lib/CMSIS/Include/core_cmFunc.h ****     \return               Control Register value
  63:./lib/CMSIS/Include/core_cmFunc.h ****  */
  64:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_CONTROL(void)
  65:./lib/CMSIS/Include/core_cmFunc.h **** {
  66:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  67:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regControl);
  68:./lib/CMSIS/Include/core_cmFunc.h **** }
  69:./lib/CMSIS/Include/core_cmFunc.h **** 
  70:./lib/CMSIS/Include/core_cmFunc.h **** 
  71:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Control Register
  72:./lib/CMSIS/Include/core_cmFunc.h **** 
  73:./lib/CMSIS/Include/core_cmFunc.h ****     This function writes the given value to the Control Register.
  74:./lib/CMSIS/Include/core_cmFunc.h **** 
  75:./lib/CMSIS/Include/core_cmFunc.h ****     \param [in]    control  Control Register value to set
  76:./lib/CMSIS/Include/core_cmFunc.h ****  */
  77:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_CONTROL(uint32_t control)
  78:./lib/CMSIS/Include/core_cmFunc.h **** {
  79:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  80:./lib/CMSIS/Include/core_cmFunc.h ****   __regControl = control;
  81:./lib/CMSIS/Include/core_cmFunc.h **** }
  82:./lib/CMSIS/Include/core_cmFunc.h **** 
  83:./lib/CMSIS/Include/core_cmFunc.h **** 
  84:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get IPSR Register
  85:./lib/CMSIS/Include/core_cmFunc.h **** 
  86:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the IPSR Register.
  87:./lib/CMSIS/Include/core_cmFunc.h **** 
  88:./lib/CMSIS/Include/core_cmFunc.h ****     \return               IPSR Register value
  89:./lib/CMSIS/Include/core_cmFunc.h ****  */
  90:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_IPSR(void)
  91:./lib/CMSIS/Include/core_cmFunc.h **** {
  92:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regIPSR          __ASM("ipsr");
  93:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regIPSR);
  94:./lib/CMSIS/Include/core_cmFunc.h **** }
  95:./lib/CMSIS/Include/core_cmFunc.h **** 
  96:./lib/CMSIS/Include/core_cmFunc.h **** 
  97:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get APSR Register
  98:./lib/CMSIS/Include/core_cmFunc.h **** 
  99:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the APSR Register.
 100:./lib/CMSIS/Include/core_cmFunc.h **** 
 101:./lib/CMSIS/Include/core_cmFunc.h ****     \return               APSR Register value
 102:./lib/CMSIS/Include/core_cmFunc.h ****  */
 103:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_APSR(void)
 104:./lib/CMSIS/Include/core_cmFunc.h **** {
 105:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regAPSR          __ASM("apsr");
 106:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regAPSR);
 107:./lib/CMSIS/Include/core_cmFunc.h **** }
 108:./lib/CMSIS/Include/core_cmFunc.h **** 
 109:./lib/CMSIS/Include/core_cmFunc.h **** 
 110:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get xPSR Register
 111:./lib/CMSIS/Include/core_cmFunc.h **** 
 112:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the xPSR Register.
 113:./lib/CMSIS/Include/core_cmFunc.h **** 
 114:./lib/CMSIS/Include/core_cmFunc.h ****     \return               xPSR Register value
 115:./lib/CMSIS/Include/core_cmFunc.h ****  */
 116:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_xPSR(void)
 117:./lib/CMSIS/Include/core_cmFunc.h **** {
 118:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regXPSR          __ASM("xpsr");
 119:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regXPSR);
 120:./lib/CMSIS/Include/core_cmFunc.h **** }
 121:./lib/CMSIS/Include/core_cmFunc.h **** 
 122:./lib/CMSIS/Include/core_cmFunc.h **** 
 123:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Process Stack Pointer
 124:./lib/CMSIS/Include/core_cmFunc.h **** 
 125:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Process Stack Pointer (PSP).
 126:./lib/CMSIS/Include/core_cmFunc.h **** 
 127:./lib/CMSIS/Include/core_cmFunc.h ****     \return               PSP Register value
 128:./lib/CMSIS/Include/core_cmFunc.h ****  */
 129:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_PSP(void)
 130:./lib/CMSIS/Include/core_cmFunc.h **** {
 131:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 132:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regProcessStackPointer);
 133:./lib/CMSIS/Include/core_cmFunc.h **** }
 134:./lib/CMSIS/Include/core_cmFunc.h **** 
 135:./lib/CMSIS/Include/core_cmFunc.h **** 
 136:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Process Stack Pointer
 137:./lib/CMSIS/Include/core_cmFunc.h **** 
 138:./lib/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Process Stack Pointer (PSP).
 139:./lib/CMSIS/Include/core_cmFunc.h **** 
 140:./lib/CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfProcStack  Process Stack Pointer value to set
 141:./lib/CMSIS/Include/core_cmFunc.h ****  */
 142:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 143:./lib/CMSIS/Include/core_cmFunc.h **** {
 144:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 145:./lib/CMSIS/Include/core_cmFunc.h ****   __regProcessStackPointer = topOfProcStack;
 146:./lib/CMSIS/Include/core_cmFunc.h **** }
 147:./lib/CMSIS/Include/core_cmFunc.h **** 
 148:./lib/CMSIS/Include/core_cmFunc.h **** 
 149:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Main Stack Pointer
 150:./lib/CMSIS/Include/core_cmFunc.h **** 
 151:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Main Stack Pointer (MSP).
 152:./lib/CMSIS/Include/core_cmFunc.h **** 
 153:./lib/CMSIS/Include/core_cmFunc.h ****     \return               MSP Register value
 154:./lib/CMSIS/Include/core_cmFunc.h ****  */
 155:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_MSP(void)
 156:./lib/CMSIS/Include/core_cmFunc.h **** {
 157:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 158:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regMainStackPointer);
 159:./lib/CMSIS/Include/core_cmFunc.h **** }
 160:./lib/CMSIS/Include/core_cmFunc.h **** 
 161:./lib/CMSIS/Include/core_cmFunc.h **** 
 162:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Main Stack Pointer
 163:./lib/CMSIS/Include/core_cmFunc.h **** 
 164:./lib/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Main Stack Pointer (MSP).
 165:./lib/CMSIS/Include/core_cmFunc.h **** 
 166:./lib/CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 167:./lib/CMSIS/Include/core_cmFunc.h ****  */
 168:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 169:./lib/CMSIS/Include/core_cmFunc.h **** {
 170:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 171:./lib/CMSIS/Include/core_cmFunc.h ****   __regMainStackPointer = topOfMainStack;
 172:./lib/CMSIS/Include/core_cmFunc.h **** }
 173:./lib/CMSIS/Include/core_cmFunc.h **** 
 174:./lib/CMSIS/Include/core_cmFunc.h **** 
 175:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Priority Mask
 176:./lib/CMSIS/Include/core_cmFunc.h **** 
 177:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the current state of the priority mask bit from the Priority Mask Registe
 178:./lib/CMSIS/Include/core_cmFunc.h **** 
 179:./lib/CMSIS/Include/core_cmFunc.h ****     \return               Priority Mask value
 180:./lib/CMSIS/Include/core_cmFunc.h ****  */
 181:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_PRIMASK(void)
 182:./lib/CMSIS/Include/core_cmFunc.h **** {
 183:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 184:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regPriMask);
 185:./lib/CMSIS/Include/core_cmFunc.h **** }
 186:./lib/CMSIS/Include/core_cmFunc.h **** 
 187:./lib/CMSIS/Include/core_cmFunc.h **** 
 188:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Priority Mask
 189:./lib/CMSIS/Include/core_cmFunc.h **** 
 190:./lib/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Priority Mask Register.
 191:./lib/CMSIS/Include/core_cmFunc.h **** 
 192:./lib/CMSIS/Include/core_cmFunc.h ****     \param [in]    priMask  Priority Mask
 193:./lib/CMSIS/Include/core_cmFunc.h ****  */
 194:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 195:./lib/CMSIS/Include/core_cmFunc.h **** {
 196:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 197:./lib/CMSIS/Include/core_cmFunc.h ****   __regPriMask = (priMask);
 198:./lib/CMSIS/Include/core_cmFunc.h **** }
 199:./lib/CMSIS/Include/core_cmFunc.h **** 
 200:./lib/CMSIS/Include/core_cmFunc.h **** 
 201:./lib/CMSIS/Include/core_cmFunc.h **** #if       (__CORTEX_M >= 0x03)
 202:./lib/CMSIS/Include/core_cmFunc.h **** 
 203:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Enable FIQ
 204:./lib/CMSIS/Include/core_cmFunc.h **** 
 205:./lib/CMSIS/Include/core_cmFunc.h ****     This function enables FIQ interrupts by clearing the F-bit in the CPSR.
 206:./lib/CMSIS/Include/core_cmFunc.h ****     Can only be executed in Privileged modes.
 207:./lib/CMSIS/Include/core_cmFunc.h ****  */
 208:./lib/CMSIS/Include/core_cmFunc.h **** #define __enable_fault_irq                __enable_fiq
 209:./lib/CMSIS/Include/core_cmFunc.h **** 
 210:./lib/CMSIS/Include/core_cmFunc.h **** 
 211:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Disable FIQ
 212:./lib/CMSIS/Include/core_cmFunc.h **** 
 213:./lib/CMSIS/Include/core_cmFunc.h ****     This function disables FIQ interrupts by setting the F-bit in the CPSR.
 214:./lib/CMSIS/Include/core_cmFunc.h ****     Can only be executed in Privileged modes.
 215:./lib/CMSIS/Include/core_cmFunc.h ****  */
 216:./lib/CMSIS/Include/core_cmFunc.h **** #define __disable_fault_irq               __disable_fiq
 217:./lib/CMSIS/Include/core_cmFunc.h **** 
 218:./lib/CMSIS/Include/core_cmFunc.h **** 
 219:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Base Priority
 220:./lib/CMSIS/Include/core_cmFunc.h **** 
 221:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Base Priority register.
 222:./lib/CMSIS/Include/core_cmFunc.h **** 
 223:./lib/CMSIS/Include/core_cmFunc.h ****     \return               Base Priority register value
 224:./lib/CMSIS/Include/core_cmFunc.h ****  */
 225:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t  __get_BASEPRI(void)
 226:./lib/CMSIS/Include/core_cmFunc.h **** {
 227:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 228:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regBasePri);
 229:./lib/CMSIS/Include/core_cmFunc.h **** }
 230:./lib/CMSIS/Include/core_cmFunc.h **** 
 231:./lib/CMSIS/Include/core_cmFunc.h **** 
 232:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Base Priority
 233:./lib/CMSIS/Include/core_cmFunc.h **** 
 234:./lib/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Base Priority register.
 235:./lib/CMSIS/Include/core_cmFunc.h **** 
 236:./lib/CMSIS/Include/core_cmFunc.h ****     \param [in]    basePri  Base Priority value to set
 237:./lib/CMSIS/Include/core_cmFunc.h ****  */
 238:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 239:./lib/CMSIS/Include/core_cmFunc.h **** {
 240:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 241:./lib/CMSIS/Include/core_cmFunc.h ****   __regBasePri = (basePri & 0xff);
 242:./lib/CMSIS/Include/core_cmFunc.h **** }
 243:./lib/CMSIS/Include/core_cmFunc.h **** 
 244:./lib/CMSIS/Include/core_cmFunc.h **** 
 245:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Fault Mask
 246:./lib/CMSIS/Include/core_cmFunc.h **** 
 247:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Fault Mask register.
 248:./lib/CMSIS/Include/core_cmFunc.h **** 
 249:./lib/CMSIS/Include/core_cmFunc.h ****     \return               Fault Mask register value
 250:./lib/CMSIS/Include/core_cmFunc.h ****  */
 251:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 252:./lib/CMSIS/Include/core_cmFunc.h **** {
 253:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 254:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regFaultMask);
 255:./lib/CMSIS/Include/core_cmFunc.h **** }
 256:./lib/CMSIS/Include/core_cmFunc.h **** 
 257:./lib/CMSIS/Include/core_cmFunc.h **** 
 258:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Fault Mask
 259:./lib/CMSIS/Include/core_cmFunc.h **** 
 260:./lib/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Fault Mask register.
 261:./lib/CMSIS/Include/core_cmFunc.h **** 
 262:./lib/CMSIS/Include/core_cmFunc.h ****     \param [in]    faultMask  Fault Mask value to set
 263:./lib/CMSIS/Include/core_cmFunc.h ****  */
 264:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 265:./lib/CMSIS/Include/core_cmFunc.h **** {
 266:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 267:./lib/CMSIS/Include/core_cmFunc.h ****   __regFaultMask = (faultMask & (uint32_t)1);
 268:./lib/CMSIS/Include/core_cmFunc.h **** }
 269:./lib/CMSIS/Include/core_cmFunc.h **** 
 270:./lib/CMSIS/Include/core_cmFunc.h **** #endif /* (__CORTEX_M >= 0x03) */
 271:./lib/CMSIS/Include/core_cmFunc.h **** 
 272:./lib/CMSIS/Include/core_cmFunc.h **** 
 273:./lib/CMSIS/Include/core_cmFunc.h **** #if       (__CORTEX_M == 0x04)
 274:./lib/CMSIS/Include/core_cmFunc.h **** 
 275:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Get FPSCR
 276:./lib/CMSIS/Include/core_cmFunc.h **** 
 277:./lib/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Floating Point Status/Control register.
 278:./lib/CMSIS/Include/core_cmFunc.h **** 
 279:./lib/CMSIS/Include/core_cmFunc.h ****     \return               Floating Point Status/Control register value
 280:./lib/CMSIS/Include/core_cmFunc.h ****  */
 281:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_FPSCR(void)
 282:./lib/CMSIS/Include/core_cmFunc.h **** {
 283:./lib/CMSIS/Include/core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 284:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 285:./lib/CMSIS/Include/core_cmFunc.h ****   return(__regfpscr);
 286:./lib/CMSIS/Include/core_cmFunc.h **** #else
 287:./lib/CMSIS/Include/core_cmFunc.h ****    return(0);
 288:./lib/CMSIS/Include/core_cmFunc.h **** #endif
 289:./lib/CMSIS/Include/core_cmFunc.h **** }
 290:./lib/CMSIS/Include/core_cmFunc.h **** 
 291:./lib/CMSIS/Include/core_cmFunc.h **** 
 292:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Set FPSCR
 293:./lib/CMSIS/Include/core_cmFunc.h **** 
 294:./lib/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Floating Point Status/Control register.
 295:./lib/CMSIS/Include/core_cmFunc.h **** 
 296:./lib/CMSIS/Include/core_cmFunc.h ****     \param [in]    fpscr  Floating Point Status/Control value to set
 297:./lib/CMSIS/Include/core_cmFunc.h ****  */
 298:./lib/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 299:./lib/CMSIS/Include/core_cmFunc.h **** {
 300:./lib/CMSIS/Include/core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 301:./lib/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 302:./lib/CMSIS/Include/core_cmFunc.h ****   __regfpscr = (fpscr);
 303:./lib/CMSIS/Include/core_cmFunc.h **** #endif
 304:./lib/CMSIS/Include/core_cmFunc.h **** }
 305:./lib/CMSIS/Include/core_cmFunc.h **** 
 306:./lib/CMSIS/Include/core_cmFunc.h **** #endif /* (__CORTEX_M == 0x04) */
 307:./lib/CMSIS/Include/core_cmFunc.h **** 
 308:./lib/CMSIS/Include/core_cmFunc.h **** 
 309:./lib/CMSIS/Include/core_cmFunc.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 310:./lib/CMSIS/Include/core_cmFunc.h **** /* IAR iccarm specific functions */
 311:./lib/CMSIS/Include/core_cmFunc.h **** 
 312:./lib/CMSIS/Include/core_cmFunc.h **** #include <cmsis_iar.h>
 313:./lib/CMSIS/Include/core_cmFunc.h **** 
 314:./lib/CMSIS/Include/core_cmFunc.h **** 
 315:./lib/CMSIS/Include/core_cmFunc.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 316:./lib/CMSIS/Include/core_cmFunc.h **** /* TI CCS specific functions */
 317:./lib/CMSIS/Include/core_cmFunc.h **** 
 318:./lib/CMSIS/Include/core_cmFunc.h **** #include <cmsis_ccs.h>
 319:./lib/CMSIS/Include/core_cmFunc.h **** 
 320:./lib/CMSIS/Include/core_cmFunc.h **** 
 321:./lib/CMSIS/Include/core_cmFunc.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 322:./lib/CMSIS/Include/core_cmFunc.h **** /* GNU gcc specific functions */
 323:./lib/CMSIS/Include/core_cmFunc.h **** 
 324:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Enable IRQ Interrupts
 325:./lib/CMSIS/Include/core_cmFunc.h **** 
 326:./lib/CMSIS/Include/core_cmFunc.h ****   This function enables IRQ interrupts by clearing the I-bit in the CPSR.
 327:./lib/CMSIS/Include/core_cmFunc.h ****   Can only be executed in Privileged modes.
 328:./lib/CMSIS/Include/core_cmFunc.h ****  */
 329:./lib/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
 330:./lib/CMSIS/Include/core_cmFunc.h **** {
 331:./lib/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 332:./lib/CMSIS/Include/core_cmFunc.h **** }
 333:./lib/CMSIS/Include/core_cmFunc.h **** 
 334:./lib/CMSIS/Include/core_cmFunc.h **** 
 335:./lib/CMSIS/Include/core_cmFunc.h **** /** \brief  Disable IRQ Interrupts
 336:./lib/CMSIS/Include/core_cmFunc.h **** 
 337:./lib/CMSIS/Include/core_cmFunc.h ****   This function disables IRQ interrupts by setting the I-bit in the CPSR.
 338:./lib/CMSIS/Include/core_cmFunc.h ****   Can only be executed in Privileged modes.
 339:./lib/CMSIS/Include/core_cmFunc.h ****  */
 340:./lib/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
 341:./lib/CMSIS/Include/core_cmFunc.h **** {
 342:./lib/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 246              		.loc 2 342 0
 247              	@ 342 "./lib/CMSIS/Include/core_cmFunc.h" 1
 248 0022 72B6     		cpsid i
 249              	@ 0 "" 2
 250              		.thumb
 251              	.LBE21:
 252              	.LBE20:
 164:src/uart_support_gps.c **** 		
 165:src/uart_support_gps.c **** 		__disable_irq();
 166:src/uart_support_gps.c **** 	  	USART_buf->TX[tempTX_Head]= data;
 253              		.loc 1 166 0
 254 0024 D2B2     		uxtb	r2, r2
 255              	.LVL27:
 256 0026 9818     		adds	r0, r3, r2
 257              	.LVL28:
 258 0028 80F80011 		strb	r1, [r0, #256]
 167:src/uart_support_gps.c **** 		/* Advance buffer head. */
 168:src/uart_support_gps.c **** 		USART_buf->TX_Head = (tempTX_Head + 1) & (UART_BUFSIZE-1);
 259              		.loc 1 168 0
 260 002c 511C     		adds	r1, r2, #1
 261              	.LVL29:
 262 002e CAB2     		uxtb	r2, r1
 263 0030 A3F80422 		strh	r2, [r3, #516]	@ movhi
 264              	.LBB22:
 265              	.LBB23:
 331:./lib/CMSIS/Include/core_cmFunc.h **** }
 266              		.loc 2 331 0
 267              	@ 331 "./lib/CMSIS/Include/core_cmFunc.h" 1
 268 0034 62B6     		cpsie i
 269              	@ 0 "" 2
 270              		.thumb
 271              	.LBE23:
 272              	.LBE22:
 169:src/uart_support_gps.c **** 		__enable_irq();
 170:src/uart_support_gps.c **** 
 171:src/uart_support_gps.c **** 		/* Enable TXE interrupt. */
 172:src/uart_support_gps.c **** 		USART_ITConfig(UART, USART_IT_TXE, ENABLE);
 273              		.loc 1 172 0
 274 0036 044B     		ldr	r3, .L13
 275              	.LVL30:
 276 0038 1868     		ldr	r0, [r3, #0]
 277              	.LVL31:
 278 003a 40F22771 		movw	r1, #1831
 279              	.LVL32:
 280 003e 0122     		movs	r2, #1
 281 0040 FFF7FEFF 		bl	USART_ITConfig
 282              	.LVL33:
 283              	.L9:
 173:src/uart_support_gps.c **** 	}
 174:src/uart_support_gps.c **** 	return TXBuffer_FreeSpace;
 175:src/uart_support_gps.c **** }
 284              		.loc 1 175 0
 285 0044 2046     		mov	r0, r4
 286 0046 10BD     		pop	{r4, pc}
 287              	.L14:
 288              		.align	2
 289              	.L13:
 290 0048 00000000 		.word	.LANCHOR0
 291              		.cfi_endproc
 292              	.LFE58:
 294              		.section	.text.USART_RXBufferData_Available,"ax",%progbits
 295              		.align	1
 296              		.global	USART_RXBufferData_Available
 297              		.thumb
 298              		.thumb_func
 300              	USART_RXBufferData_Available:
 301              	.LFB59:
 176:src/uart_support_gps.c **** 
 177:src/uart_support_gps.c **** /**************************************************************************/
 178:src/uart_support_gps.c **** /*! 
 179:src/uart_support_gps.c ****     Check UART RX Buffer Empty.
 180:src/uart_support_gps.c **** */
 181:src/uart_support_gps.c **** /**************************************************************************/
 182:src/uart_support_gps.c **** bool USART_RXBufferData_Available(USART_Buffer_t* USART_buf)
 183:src/uart_support_gps.c **** {
 302              		.loc 1 183 0
 303              		.cfi_startproc
 304              		@ args = 0, pretend = 0, frame = 0
 305              		@ frame_needed = 0, uses_anonymous_args = 0
 306              		@ link register save eliminated.
 307              	.LVL34:
 184:src/uart_support_gps.c **** 	/* Make copies to make sure that volatile access is specified. */
 185:src/uart_support_gps.c **** 	uint8_t tempHead = USART_buf->RX_Head;
 308              		.loc 1 185 0
 309 0000 B0F80022 		ldrh	r2, [r0, #512]
 310              	.LVL35:
 186:src/uart_support_gps.c **** 	uint8_t tempTail = USART_buf->RX_Tail;
 311              		.loc 1 186 0
 312 0004 B0F80232 		ldrh	r3, [r0, #514]
 313              	.LVL36:
 187:src/uart_support_gps.c **** 
 188:src/uart_support_gps.c **** 	/* There are data left in the buffer unless Head and Tail are equal. */
 189:src/uart_support_gps.c **** 	return (tempHead != tempTail);
 314              		.loc 1 189 0
 315 0008 D0B2     		uxtb	r0, r2
 316              	.LVL37:
 317 000a D9B2     		uxtb	r1, r3
 190:src/uart_support_gps.c **** }
 318              		.loc 1 190 0
 319 000c 401A     		subs	r0, r0, r1
 320 000e 18BF     		it	ne
 321 0010 0120     		movne	r0, #1
 322 0012 7047     		bx	lr
 323              		.cfi_endproc
 324              	.LFE59:
 326              		.section	.text.USART_RXBuffer_GetByte,"ax",%progbits
 327              		.align	1
 328              		.global	USART_RXBuffer_GetByte
 329              		.thumb
 330              		.thumb_func
 332              	USART_RXBuffer_GetByte:
 333              	.LFB60:
 191:src/uart_support_gps.c **** 
 192:src/uart_support_gps.c **** /**************************************************************************/
 193:src/uart_support_gps.c **** /*! 
 194:src/uart_support_gps.c ****     Get Bytedata with Buffering.
 195:src/uart_support_gps.c **** */
 196:src/uart_support_gps.c **** /**************************************************************************/
 197:src/uart_support_gps.c **** uint8_t USART_RXBuffer_GetByte(USART_Buffer_t* USART_buf)
 198:src/uart_support_gps.c **** {
 334              		.loc 1 198 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 0
 337              		@ frame_needed = 0, uses_anonymous_args = 0
 338              		@ link register save eliminated.
 339              	.LVL38:
 340 0000 0346     		mov	r3, r0
 341              	.LBB24:
 342              	.LBB25:
 343              		.loc 2 342 0
 344              	@ 342 "./lib/CMSIS/Include/core_cmFunc.h" 1
 345 0002 72B6     		cpsid i
 346              	@ 0 "" 2
 347              		.thumb
 348              	.LBE25:
 349              	.LBE24:
 199:src/uart_support_gps.c **** 	uint8_t ans;
 200:src/uart_support_gps.c **** 
 201:src/uart_support_gps.c **** 	__disable_irq();
 202:src/uart_support_gps.c **** 	ans = (USART_buf->RX[USART_buf->RX_Tail]);
 350              		.loc 1 202 0
 351 0004 B0F80222 		ldrh	r2, [r0, #514]
 352 0008 90B2     		uxth	r0, r2
 353              	.LVL39:
 354 000a 185C     		ldrb	r0, [r3, r0]	@ zero_extendqisi2
 355              	.LVL40:
 203:src/uart_support_gps.c **** 
 204:src/uart_support_gps.c **** 	/* Advance buffer tail. */
 205:src/uart_support_gps.c **** 	USART_buf->RX_Tail = (USART_buf->RX_Tail + 1) & (UART_BUFSIZE-1);
 356              		.loc 1 205 0
 357 000c B3F80212 		ldrh	r1, [r3, #514]
 358 0010 4A1C     		adds	r2, r1, #1
 359 0012 D1B2     		uxtb	r1, r2
 360 0014 A3F80212 		strh	r1, [r3, #514]	@ movhi
 361              	.LBB26:
 362              	.LBB27:
 331:./lib/CMSIS/Include/core_cmFunc.h **** }
 363              		.loc 2 331 0
 364              	@ 331 "./lib/CMSIS/Include/core_cmFunc.h" 1
 365 0018 62B6     		cpsie i
 366              	@ 0 "" 2
 367              		.thumb
 368              	.LBE27:
 369              	.LBE26:
 206:src/uart_support_gps.c **** 	
 207:src/uart_support_gps.c **** 	__enable_irq();
 208:src/uart_support_gps.c **** 
 209:src/uart_support_gps.c **** 	return ans;
 210:src/uart_support_gps.c **** }
 370              		.loc 1 210 0
 371 001a 7047     		bx	lr
 372              		.cfi_endproc
 373              	.LFE60:
 375              		.section	.text.putch,"ax",%progbits
 376              		.align	1
 377              		.global	putch
 378              		.thumb
 379              		.thumb_func
 381              	putch:
 382              	.LFB61:
 211:src/uart_support_gps.c **** 
 212:src/uart_support_gps.c **** /**************************************************************************/
 213:src/uart_support_gps.c **** /*! 
 214:src/uart_support_gps.c ****     High Level function.
 215:src/uart_support_gps.c **** */
 216:src/uart_support_gps.c **** /**************************************************************************/
 217:src/uart_support_gps.c **** /* Send 1 character */
 218:src/uart_support_gps.c **** inline void putch(uint8_t data)
 219:src/uart_support_gps.c **** {
 383              		.loc 1 219 0
 384              		.cfi_startproc
 385              		@ args = 0, pretend = 0, frame = 0
 386              		@ frame_needed = 0, uses_anonymous_args = 0
 387              		@ link register save eliminated.
 388              	.LVL41:
 389 0000 0146     		mov	r1, r0
 220:src/uart_support_gps.c **** #if (UART_HANDLING == UART_INTERRUPT_MODE)
 221:src/uart_support_gps.c **** 	/* Interrupt Version */
 222:src/uart_support_gps.c **** 	while(!USART_TXBuffer_FreeSpace(pUSART_Buf));
 390              		.loc 1 222 0
 391 0002 074B     		ldr	r3, .L20
 392 0004 1B68     		ldr	r3, [r3, #0]
 393              	.LVL42:
 394              	.L18:
 395              	.LBB28:
 396              	.LBB29:
 140:src/uart_support_gps.c **** 	uint8_t tempTail = USART_buf->TX_Tail;
 397              		.loc 1 140 0 discriminator 1
 398 0006 B3F80402 		ldrh	r0, [r3, #516]
 399              	.LVL43:
 141:src/uart_support_gps.c **** 
 400              		.loc 1 141 0 discriminator 1
 401 000a B3F80622 		ldrh	r2, [r3, #518]
 402              	.LVL44:
 140:src/uart_support_gps.c **** 	uint8_t tempTail = USART_buf->TX_Tail;
 403              		.loc 1 140 0 discriminator 1
 404 000e 0130     		adds	r0, r0, #1
 405              	.LVL45:
 406              	.LBE29:
 407              	.LBE28:
 408              		.loc 1 222 0 discriminator 1
 409 0010 00F0FF00 		and	r0, r0, #255
 410 0014 D2B2     		uxtb	r2, r2
 411              	.LVL46:
 412 0016 9042     		cmp	r0, r2
 413 0018 F5D0     		beq	.L18
 223:src/uart_support_gps.c **** 	USART_TXBuffer_PutByte(pUSART_Buf,data);
 414              		.loc 1 223 0
 415 001a 1846     		mov	r0, r3
 224:src/uart_support_gps.c **** #else 
 225:src/uart_support_gps.c **** 	/* Polling version */
 226:src/uart_support_gps.c **** 	while (!(UART->SR & USART_FLAG_TXE));
 227:src/uart_support_gps.c **** 	UART->DR = data;
 228:src/uart_support_gps.c **** #endif
 229:src/uart_support_gps.c **** }
 416              		.loc 1 229 0
 223:src/uart_support_gps.c **** 	USART_TXBuffer_PutByte(pUSART_Buf,data);
 417              		.loc 1 223 0
 418 001c FFF7FEBF 		b	USART_TXBuffer_PutByte
 419              	.LVL47:
 420              	.L21:
 421              		.align	2
 422              	.L20:
 423 0020 00000000 		.word	.LANCHOR2
 424              		.cfi_endproc
 425              	.LFE61:
 427              		.section	.text.getch,"ax",%progbits
 428              		.align	1
 429              		.global	getch
 430              		.thumb
 431              		.thumb_func
 433              	getch:
 434              	.LFB62:
 230:src/uart_support_gps.c **** 
 231:src/uart_support_gps.c **** /**************************************************************************/
 232:src/uart_support_gps.c **** /*! 
 233:src/uart_support_gps.c ****     High Level function.
 234:src/uart_support_gps.c **** */
 235:src/uart_support_gps.c **** /**************************************************************************/
 236:src/uart_support_gps.c **** /* Receive 1 character */
 237:src/uart_support_gps.c **** uint8_t getch(void)
 238:src/uart_support_gps.c **** {
 435              		.loc 1 238 0
 436              		.cfi_startproc
 437              		@ args = 0, pretend = 0, frame = 0
 438              		@ frame_needed = 0, uses_anonymous_args = 0
 439              		@ link register save eliminated.
 239:src/uart_support_gps.c **** #if (UART_HANDLING == UART_INTERRUPT_MODE)
 240:src/uart_support_gps.c **** 	if (USART_RXBufferData_Available(pUSART_Buf))  return USART_RXBuffer_GetByte(pUSART_Buf);
 440              		.loc 1 240 0
 441 0000 064B     		ldr	r3, .L24
 442 0002 1868     		ldr	r0, [r3, #0]
 443              	.LVL48:
 444              	.LBB30:
 445              	.LBB31:
 185:src/uart_support_gps.c **** 	uint8_t tempTail = USART_buf->RX_Tail;
 446              		.loc 1 185 0
 447 0004 B0F80022 		ldrh	r2, [r0, #512]
 448              	.LVL49:
 186:src/uart_support_gps.c **** 
 449              		.loc 1 186 0
 450 0008 B0F80212 		ldrh	r1, [r0, #514]
 451              	.LVL50:
 452              	.LBE31:
 453              	.LBE30:
 454              		.loc 1 240 0
 455 000c D2B2     		uxtb	r2, r2
 456              	.LVL51:
 457 000e CBB2     		uxtb	r3, r1
 458 0010 9A42     		cmp	r2, r3
 459 0012 01D0     		beq	.L23
 241:src/uart_support_gps.c **** 	else										   return false;
 242:src/uart_support_gps.c **** #else
 243:src/uart_support_gps.c **** 	/* Polling version */
 244:src/uart_support_gps.c **** 	while (!(UART->SR & USART_FLAG_RXNE));
 245:src/uart_support_gps.c **** 	return (uint8_t)(USART->DR);
 246:src/uart_support_gps.c **** #endif
 247:src/uart_support_gps.c **** }
 460              		.loc 1 247 0 discriminator 1
 240:src/uart_support_gps.c **** 	else										   return false;
 461              		.loc 1 240 0 discriminator 1
 462 0014 FFF7FEBF 		b	USART_RXBuffer_GetByte
 463              	.LVL52:
 464              	.L23:
 465              		.loc 1 247 0
 466 0018 0020     		movs	r0, #0
 467              	.LVL53:
 468 001a 7047     		bx	lr
 469              	.L25:
 470              		.align	2
 471              	.L24:
 472 001c 00000000 		.word	.LANCHOR2
 473              		.cfi_endproc
 474              	.LFE62:
 476              		.section	.text.keypressed,"ax",%progbits
 477              		.align	1
 478              		.global	keypressed
 479              		.thumb
 480              		.thumb_func
 482              	keypressed:
 483              	.LFB63:
 248:src/uart_support_gps.c **** 
 249:src/uart_support_gps.c **** /**************************************************************************/
 250:src/uart_support_gps.c **** /*! 
 251:src/uart_support_gps.c ****     High Level function.
 252:src/uart_support_gps.c **** */
 253:src/uart_support_gps.c **** /**************************************************************************/
 254:src/uart_support_gps.c **** /* Return 1 if key pressed */
 255:src/uart_support_gps.c **** uint8_t keypressed(void)
 256:src/uart_support_gps.c **** {
 484              		.loc 1 256 0
 485              		.cfi_startproc
 486              		@ args = 0, pretend = 0, frame = 0
 487              		@ frame_needed = 0, uses_anonymous_args = 0
 488              		@ link register save eliminated.
 257:src/uart_support_gps.c **** #if (UART_HANDLING == UART_INTERRUPT_MODE)
 258:src/uart_support_gps.c ****   return (USART_RXBufferData_Available(pUSART_Buf));
 489              		.loc 1 258 0
 490 0000 054B     		ldr	r3, .L27
 491 0002 1968     		ldr	r1, [r3, #0]
 492              	.LVL54:
 493              	.LBB32:
 494              	.LBB33:
 185:src/uart_support_gps.c **** 	uint8_t tempTail = USART_buf->RX_Tail;
 495              		.loc 1 185 0
 496 0004 B1F80002 		ldrh	r0, [r1, #512]
 497              	.LVL55:
 186:src/uart_support_gps.c **** 
 498              		.loc 1 186 0
 499 0008 B1F80222 		ldrh	r2, [r1, #514]
 500              	.LVL56:
 189:src/uart_support_gps.c **** }
 501              		.loc 1 189 0
 502 000c C1B2     		uxtb	r1, r0
 503              	.LVL57:
 504 000e D3B2     		uxtb	r3, r2
 505              	.LBE33:
 506              	.LBE32:
 259:src/uart_support_gps.c **** #else
 260:src/uart_support_gps.c ****   return (UART->SR & USART_FLAG_RXNE);
 261:src/uart_support_gps.c **** #endif
 262:src/uart_support_gps.c **** }
 507              		.loc 1 262 0
 508 0010 C81A     		subs	r0, r1, r3
 509              	.LVL58:
 510 0012 18BF     		it	ne
 511 0014 0120     		movne	r0, #1
 512 0016 7047     		bx	lr
 513              	.L28:
 514              		.align	2
 515              	.L27:
 516 0018 00000000 		.word	.LANCHOR2
 517              		.cfi_endproc
 518              	.LFE63:
 520              		.section	.text.cputs,"ax",%progbits
 521              		.align	1
 522              		.global	cputs
 523              		.thumb
 524              		.thumb_func
 526              	cputs:
 527              	.LFB64:
 263:src/uart_support_gps.c **** 
 264:src/uart_support_gps.c **** /**************************************************************************/
 265:src/uart_support_gps.c **** /*! 
 266:src/uart_support_gps.c ****     High Level function.
 267:src/uart_support_gps.c **** */
 268:src/uart_support_gps.c **** /**************************************************************************/
 269:src/uart_support_gps.c **** /* Send a string */
 270:src/uart_support_gps.c **** void cputs(char *s)
 271:src/uart_support_gps.c **** {
 528              		.loc 1 271 0
 529              		.cfi_startproc
 530              		@ args = 0, pretend = 0, frame = 0
 531              		@ frame_needed = 0, uses_anonymous_args = 0
 532              	.LVL59:
 533 0000 10B5     		push	{r4, lr}
 534              	.LCFI2:
 535              		.cfi_def_cfa_offset 8
 536              		.cfi_offset 4, -8
 537              		.cfi_offset 14, -4
 270:src/uart_support_gps.c **** {
 538              		.loc 1 270 0
 539 0002 441E     		subs	r4, r0, #1
 540              	.LVL60:
 541              	.L30:
 272:src/uart_support_gps.c ****   while (*s)
 542              		.loc 1 272 0 discriminator 1
 543 0004 14F8010F 		ldrb	r0, [r4, #1]!	@ zero_extendqisi2
 544 0008 10B1     		cbz	r0, .L32
 545              	.L31:
 273:src/uart_support_gps.c ****     putch(*s++);
 546              		.loc 1 273 0
 547 000a FFF7FEFF 		bl	putch
 548              	.LVL61:
 549 000e F9E7     		b	.L30
 550              	.L32:
 274:src/uart_support_gps.c **** }
 551              		.loc 1 274 0
 552 0010 10BD     		pop	{r4, pc}
 553              		.cfi_endproc
 554              	.LFE64:
 556              		.section	.text.cgets,"ax",%progbits
 557              		.align	1
 558              		.global	cgets
 559              		.thumb
 560              		.thumb_func
 562              	cgets:
 563              	.LFB65:
 275:src/uart_support_gps.c **** 
 276:src/uart_support_gps.c **** /**************************************************************************/
 277:src/uart_support_gps.c **** /*! 
 278:src/uart_support_gps.c ****     High Level function.
 279:src/uart_support_gps.c **** */
 280:src/uart_support_gps.c **** /**************************************************************************/
 281:src/uart_support_gps.c **** /* Receive a string, with rudimentary line editing */
 282:src/uart_support_gps.c **** void cgets(char *s, int bufsize)
 283:src/uart_support_gps.c **** {
 564              		.loc 1 283 0
 565              		.cfi_startproc
 566              		@ args = 0, pretend = 0, frame = 0
 567              		@ frame_needed = 0, uses_anonymous_args = 0
 568              	.LVL62:
 569 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 570              	.LCFI3:
 571              		.cfi_def_cfa_offset 24
 572              		.cfi_offset 3, -24
 573              		.cfi_offset 4, -20
 574              		.cfi_offset 5, -16
 575              		.cfi_offset 6, -12
 576              		.cfi_offset 7, -8
 577              		.cfi_offset 14, -4
 578 0002 0646     		mov	r6, r0
 579 0004 0F46     		mov	r7, r1
 284:src/uart_support_gps.c ****   char *p;
 285:src/uart_support_gps.c ****   int c;
 286:src/uart_support_gps.c **** 
 287:src/uart_support_gps.c ****   memset(s, 0, bufsize);
 580              		.loc 1 287 0
 581 0006 0021     		movs	r1, #0
 582              	.LVL63:
 583 0008 3A46     		mov	r2, r7
 584 000a FFF7FEFF 		bl	memset
 585              	.LVL64:
 288:src/uart_support_gps.c **** 
 289:src/uart_support_gps.c ****   p = s;
 290:src/uart_support_gps.c **** 
 291:src/uart_support_gps.c ****   for (p = s; p < s + bufsize-1;)
 586              		.loc 1 291 0
 587 000e 3446     		mov	r4, r6
 588              	.LVL65:
 589              	.L54:
 590              		.loc 1 291 0 is_stmt 0 discriminator 1
 591 0010 7B1E     		subs	r3, r7, #1
 592 0012 F018     		adds	r0, r6, r3
 593 0014 8442     		cmp	r4, r0
 594 0016 27D2     		bcs	.L56
 595              	.L48:
 292:src/uart_support_gps.c ****   {
 293:src/uart_support_gps.c ****     /* 20090521Nemui */
 294:src/uart_support_gps.c **** 	do{		
 295:src/uart_support_gps.c **** 		c = getch();
 596              		.loc 1 295 0 is_stmt 1
 597 0018 FFF7FEFF 		bl	getch
 598              	.LVL66:
 296:src/uart_support_gps.c **** 	}while(c == false);
 599              		.loc 1 296 0
 600 001c 0546     		mov	r5, r0
 601 001e 0028     		cmp	r0, #0
 602 0020 FAD0     		beq	.L48
 297:src/uart_support_gps.c **** 	/* 20090521Nemui */
 298:src/uart_support_gps.c ****     switch (c)
 603              		.loc 1 298 0
 604 0022 0A28     		cmp	r0, #10
 605 0024 04D0     		beq	.L38
 606 0026 0D28     		cmp	r0, #13
 607 0028 02D0     		beq	.L38
 608 002a 0828     		cmp	r0, #8
 609 002c 17D1     		bne	.L55
 610 002e 08E0     		b	.L57
 611              	.L38:
 299:src/uart_support_gps.c ****     {
 300:src/uart_support_gps.c ****       case '\r' :
 301:src/uart_support_gps.c ****       case '\n' :
 302:src/uart_support_gps.c ****         putch('\r');
 612              		.loc 1 302 0
 613 0030 0D20     		movs	r0, #13
 614              	.LVL67:
 615 0032 FFF7FEFF 		bl	putch
 616              	.LVL68:
 303:src/uart_support_gps.c ****         putch('\n');
 617              		.loc 1 303 0
 618 0036 0A20     		movs	r0, #10
 619 0038 FFF7FEFF 		bl	putch
 620              	.LVL69:
 304:src/uart_support_gps.c ****         *p = '\n';
 621              		.loc 1 304 0
 622 003c 0A22     		movs	r2, #10
 623 003e 2270     		strb	r2, [r4, #0]
 305:src/uart_support_gps.c ****         return;
 624              		.loc 1 305 0
 625 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 626              	.LVL70:
 627              	.L57:
 306:src/uart_support_gps.c **** 
 307:src/uart_support_gps.c ****       case '\b' :
 308:src/uart_support_gps.c ****         if (p > s)
 628              		.loc 1 308 0
 629 0042 B442     		cmp	r4, r6
 630 0044 E4D9     		bls	.L54
 309:src/uart_support_gps.c ****         {
 310:src/uart_support_gps.c ****           *p-- = 0;
 631              		.loc 1 310 0
 632 0046 0021     		movs	r1, #0
 633 0048 04F80119 		strb	r1, [r4], #-1
 634              	.LVL71:
 311:src/uart_support_gps.c ****           putch('\b');
 635              		.loc 1 311 0
 636 004c FFF7FEFF 		bl	putch
 637              	.LVL72:
 312:src/uart_support_gps.c ****           putch(' ');
 638              		.loc 1 312 0
 639 0050 2020     		movs	r0, #32
 640 0052 FFF7FEFF 		bl	putch
 641              	.LVL73:
 313:src/uart_support_gps.c ****           putch('\b');
 642              		.loc 1 313 0
 643 0056 2846     		mov	r0, r5
 644 0058 FFF7FEFF 		bl	putch
 645              	.LVL74:
 646 005c D8E7     		b	.L54
 647              	.LVL75:
 648              	.L55:
 314:src/uart_support_gps.c ****         }
 315:src/uart_support_gps.c ****         break;
 316:src/uart_support_gps.c **** 
 317:src/uart_support_gps.c ****       default :
 318:src/uart_support_gps.c ****         putch(c);
 649              		.loc 1 318 0
 650 005e FFF7FEFF 		bl	putch
 651              	.LVL76:
 319:src/uart_support_gps.c ****         *p++ = c;
 652              		.loc 1 319 0
 653 0062 04F8015B 		strb	r5, [r4], #1
 654              	.LVL77:
 320:src/uart_support_gps.c ****         break;
 655              		.loc 1 320 0
 656 0066 D3E7     		b	.L54
 657              	.L56:
 658 0068 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 659              		.cfi_endproc
 660              	.LFE65:
 662              		.section	.text.conio_IRQ,"ax",%progbits
 663              		.align	1
 664              		.global	conio_IRQ
 665              		.thumb
 666              		.thumb_func
 668              	conio_IRQ:
 669              	.LFB66:
 321:src/uart_support_gps.c ****     }
 322:src/uart_support_gps.c ****   }
 323:src/uart_support_gps.c **** 
 324:src/uart_support_gps.c ****   return;
 325:src/uart_support_gps.c **** }
 326:src/uart_support_gps.c **** 
 327:src/uart_support_gps.c **** 
 328:src/uart_support_gps.c **** /**************************************************************************/
 329:src/uart_support_gps.c **** /*! 
 330:src/uart_support_gps.c ****     Interrupt handlers.
 331:src/uart_support_gps.c **** */
 332:src/uart_support_gps.c **** /**************************************************************************/
 333:src/uart_support_gps.c **** void conio_IRQ(void)
 334:src/uart_support_gps.c **** {
 670              		.loc 1 334 0
 671              		.cfi_startproc
 672              		@ args = 0, pretend = 0, frame = 0
 673              		@ frame_needed = 0, uses_anonymous_args = 0
 674 0000 70B5     		push	{r4, r5, r6, lr}
 675              	.LCFI4:
 676              		.cfi_def_cfa_offset 16
 677              		.cfi_offset 4, -16
 678              		.cfi_offset 5, -12
 679              		.cfi_offset 6, -8
 680              		.cfi_offset 14, -4
 335:src/uart_support_gps.c **** 	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
 681              		.loc 1 335 0
 682 0002 2348     		ldr	r0, .L69
 683 0004 40F22551 		movw	r1, #1317
 684 0008 FFF7FEFF 		bl	USART_GetITStatus
 685              	.LVL78:
 686 000c D0B1     		cbz	r0, .L59
 687              	.LBB34:
 336:src/uart_support_gps.c **** 	{
 337:src/uart_support_gps.c **** 		/* Advance buffer head. */
 338:src/uart_support_gps.c **** 		uint16_t tempRX_Head = ((&USART2_Buf)->RX_Head + 1) & (UART_BUFSIZE-1);
 688              		.loc 1 338 0
 689 000e 214C     		ldr	r4, .L69+4
 690 0010 B4F80052 		ldrh	r5, [r4, #512]
 691 0014 681C     		adds	r0, r5, #1
 692 0016 C5B2     		uxtb	r5, r0
 693              	.LVL79:
 339:src/uart_support_gps.c **** 
 340:src/uart_support_gps.c **** 		/* Check for overflow. */
 341:src/uart_support_gps.c **** 		uint16_t tempRX_Tail = (&USART2_Buf)->RX_Tail;
 694              		.loc 1 341 0
 695 0018 B4F80262 		ldrh	r6, [r4, #514]
 696 001c B6B2     		uxth	r6, r6
 697              	.LVL80:
 342:src/uart_support_gps.c **** 		uint8_t data =  USART_ReceiveData(USART2);
 698              		.loc 1 342 0
 699 001e 1C48     		ldr	r0, .L69
 700 0020 FFF7FEFF 		bl	USART_ReceiveData
 701              	.LVL81:
 702 0024 C1B2     		uxtb	r1, r0
 703              	.LVL82:
 343:src/uart_support_gps.c **** 
 344:src/uart_support_gps.c **** 		if (tempRX_Head == tempRX_Tail) {
 704              		.loc 1 344 0
 705 0026 B542     		cmp	r5, r6
 706 0028 06D1     		bne	.L60
 345:src/uart_support_gps.c **** 			/* Disable the USART2 Receive interrupt */
 346:src/uart_support_gps.c **** 			USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);
 707              		.loc 1 346 0
 708 002a 1948     		ldr	r0, .L69
 709              	.LVL83:
 710 002c 40F22551 		movw	r1, #1317
 711              	.LVL84:
 712 0030 0022     		movs	r2, #0
 713 0032 FFF7FEFF 		bl	USART_ITConfig
 714              	.LVL85:
 715 0036 05E0     		b	.L59
 716              	.LVL86:
 717              	.L60:
 347:src/uart_support_gps.c **** 		}else{
 348:src/uart_support_gps.c **** 			(&USART2_Buf)->RX[(&USART2_Buf)->RX_Head] = data;
 718              		.loc 1 348 0
 719 0038 B4F80032 		ldrh	r3, [r4, #512]
 720 003c 9AB2     		uxth	r2, r3
 721 003e A154     		strb	r1, [r4, r2]
 349:src/uart_support_gps.c **** 			(&USART2_Buf)->RX_Head = tempRX_Head;
 722              		.loc 1 349 0
 723 0040 A4F80052 		strh	r5, [r4, #512]	@ movhi
 724              	.LVL87:
 725              	.L59:
 726              	.LBE34:
 350:src/uart_support_gps.c **** 		}
 351:src/uart_support_gps.c **** 	}
 352:src/uart_support_gps.c **** 
 353:src/uart_support_gps.c **** 	if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)
 727              		.loc 1 353 0
 728 0044 124C     		ldr	r4, .L69
 729 0046 2046     		mov	r0, r4
 730 0048 40F22771 		movw	r1, #1831
 731 004c FFF7FEFF 		bl	USART_GetITStatus
 732              	.LVL88:
 733 0050 E8B1     		cbz	r0, .L58
 734              	.LBB35:
 354:src/uart_support_gps.c **** 	{   
 355:src/uart_support_gps.c **** 
 356:src/uart_support_gps.c **** 		/* Check if all data is transmitted. */
 357:src/uart_support_gps.c **** 		uint16_t tempTX_Tail = (&USART2_Buf)->TX_Tail;
 735              		.loc 1 357 0
 736 0052 1048     		ldr	r0, .L69+4
 737 0054 B0F80612 		ldrh	r1, [r0, #518]
 738 0058 8BB2     		uxth	r3, r1
 739              	.LVL89:
 358:src/uart_support_gps.c **** 		if ((&USART2_Buf)->TX_Head == tempTX_Tail){
 740              		.loc 1 358 0
 741 005a B0F80422 		ldrh	r2, [r0, #516]
 742 005e 91B2     		uxth	r1, r2
 743              	.LVL90:
 744 0060 9942     		cmp	r1, r3
 745 0062 07D1     		bne	.L62
 359:src/uart_support_gps.c **** 			/* Overflow MAX size Situation */
 360:src/uart_support_gps.c **** 			/* Disable the USART2 Transmit interrupt */
 361:src/uart_support_gps.c **** 			USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
 746              		.loc 1 361 0
 747 0064 2046     		mov	r0, r4
 748 0066 40F22771 		movw	r1, #1831
 749 006a 0022     		movs	r2, #0
 750              	.LBE35:
 362:src/uart_support_gps.c **** 		}else{
 363:src/uart_support_gps.c **** 			/* Start transmitting. */
 364:src/uart_support_gps.c **** 			uint8_t data = (&USART2_Buf)->TX[(&USART2_Buf)->TX_Tail];
 365:src/uart_support_gps.c **** 			USART2->DR = data;
 366:src/uart_support_gps.c **** 
 367:src/uart_support_gps.c **** 			/* Advance buffer tail. */
 368:src/uart_support_gps.c **** 			(&USART2_Buf)->TX_Tail = ((&USART2_Buf)->TX_Tail + 1) & (UART_BUFSIZE-1);
 369:src/uart_support_gps.c **** 		}
 370:src/uart_support_gps.c **** 
 371:src/uart_support_gps.c **** 	}
 372:src/uart_support_gps.c **** }
 751              		.loc 1 372 0
 752 006c BDE87040 		pop	{r4, r5, r6, lr}
 753              	.LBB37:
 361:src/uart_support_gps.c **** 		}else{
 754              		.loc 1 361 0
 755 0070 FFF7FEBF 		b	USART_ITConfig
 756              	.LVL91:
 757              	.L62:
 758              	.LBB36:
 364:src/uart_support_gps.c **** 			USART2->DR = data;
 759              		.loc 1 364 0
 760 0074 B0F80632 		ldrh	r3, [r0, #518]
 761              	.LVL92:
 762 0078 9AB2     		uxth	r2, r3
 763 007a 8118     		adds	r1, r0, r2
 764 007c 91F80031 		ldrb	r3, [r1, #256]	@ zero_extendqisi2
 765              	.LVL93:
 365:src/uart_support_gps.c **** 
 766              		.loc 1 365 0
 767 0080 A380     		strh	r3, [r4, #4]	@ movhi
 368:src/uart_support_gps.c **** 		}
 768              		.loc 1 368 0
 769 0082 B0F80622 		ldrh	r2, [r0, #518]
 770 0086 511C     		adds	r1, r2, #1
 771 0088 CBB2     		uxtb	r3, r1
 772              	.LVL94:
 773 008a A0F80632 		strh	r3, [r0, #518]	@ movhi
 774              	.LVL95:
 775              	.L58:
 776 008e 70BD     		pop	{r4, r5, r6, pc}
 777              	.L70:
 778              		.align	2
 779              	.L69:
 780 0090 00440040 		.word	1073759232
 781 0094 00000000 		.word	.LANCHOR3
 782              	.LBE36:
 783              	.LBE37:
 784              		.cfi_endproc
 785              	.LFE66:
 787              		.section	.text.USART2_IRQHandler,"ax",%progbits
 788              		.align	1
 789              		.global	USART2_IRQHandler
 790              		.thumb
 791              		.thumb_func
 793              	USART2_IRQHandler:
 794              	.LFB67:
 373:src/uart_support_gps.c **** 
 374:src/uart_support_gps.c **** 
 375:src/uart_support_gps.c **** /**************************************************************************/
 376:src/uart_support_gps.c **** /*! 
 377:src/uart_support_gps.c ****     @brief	Handles USART2 global interrupt wrapper.
 378:src/uart_support_gps.c **** 	@param	None.
 379:src/uart_support_gps.c ****     @retval	None.
 380:src/uart_support_gps.c **** */
 381:src/uart_support_gps.c **** /**************************************************************************/
 382:src/uart_support_gps.c **** void USART2_IRQHandler(void)
 383:src/uart_support_gps.c **** {
 795              		.loc 1 383 0
 796              		.cfi_startproc
 797              		@ args = 0, pretend = 0, frame = 0
 798              		@ frame_needed = 0, uses_anonymous_args = 0
 799 0000 08B5     		push	{r3, lr}
 800              	.LCFI5:
 801              		.cfi_def_cfa_offset 8
 802              		.cfi_offset 3, -8
 803              		.cfi_offset 14, -4
 384:src/uart_support_gps.c **** 	xUART_IRQ();
 804              		.loc 1 384 0
 805 0002 024B     		ldr	r3, .L72
 806 0004 1868     		ldr	r0, [r3, #0]
 807 0006 8047     		blx	r0
 808              	.LVL96:
 809 0008 08BD     		pop	{r3, pc}
 810              	.L73:
 811 000a 00BF     		.align	2
 812              	.L72:
 813 000c 00000000 		.word	.LANCHOR4
 814              		.cfi_endproc
 815              	.LFE67:
 817              		.section	.text.Flush_RXBuffer,"ax",%progbits
 818              		.align	1
 819              		.global	Flush_RXBuffer
 820              		.thumb
 821              		.thumb_func
 823              	Flush_RXBuffer:
 824              	.LFB68:
 385:src/uart_support_gps.c **** }
 386:src/uart_support_gps.c **** 
 387:src/uart_support_gps.c **** /**************************************************************************/
 388:src/uart_support_gps.c **** /*! 
 389:src/uart_support_gps.c ****     @brief	Flush USART RX Buffers.
 390:src/uart_support_gps.c **** 	@param	None.
 391:src/uart_support_gps.c ****     @retval	None.
 392:src/uart_support_gps.c **** */
 393:src/uart_support_gps.c **** /**************************************************************************/
 394:src/uart_support_gps.c **** void Flush_RXBuffer(void)
 395:src/uart_support_gps.c **** {
 825              		.loc 1 395 0
 826              		.cfi_startproc
 827              		@ args = 0, pretend = 0, frame = 0
 828              		@ frame_needed = 0, uses_anonymous_args = 0
 829              		@ link register save eliminated.
 396:src/uart_support_gps.c **** 	/* Init Ring Buffer */
 397:src/uart_support_gps.c **** 	pUSART_Buf->RX_Tail = 0;
 830              		.loc 1 397 0
 831 0000 064B     		ldr	r3, .L75
 832 0002 1868     		ldr	r0, [r3, #0]
 833 0004 0022     		movs	r2, #0
 834 0006 A0F80222 		strh	r2, [r0, #514]	@ movhi
 398:src/uart_support_gps.c **** 	pUSART_Buf->RX_Head = 0;
 835              		.loc 1 398 0
 836 000a A0F80022 		strh	r2, [r0, #512]	@ movhi
 399:src/uart_support_gps.c **** 
 400:src/uart_support_gps.c **** 	/* Re-Enable USART2 Receive interrupts */
 401:src/uart_support_gps.c **** 	USART_ITConfig(UART, USART_IT_RXNE, ENABLE);
 837              		.loc 1 401 0
 838 000e 0449     		ldr	r1, .L75+4
 839 0010 0868     		ldr	r0, [r1, #0]
 840 0012 40F22551 		movw	r1, #1317
 841 0016 0122     		movs	r2, #1
 402:src/uart_support_gps.c **** }
 842              		.loc 1 402 0
 401:src/uart_support_gps.c **** }
 843              		.loc 1 401 0
 844 0018 FFF7FEBF 		b	USART_ITConfig
 845              	.LVL97:
 846              	.L76:
 847              		.align	2
 848              	.L75:
 849 001c 00000000 		.word	.LANCHOR2
 850 0020 00000000 		.word	.LANCHOR0
 851              		.cfi_endproc
 852              	.LFE68:
 854              		.section	.text.WaitTxBuffer,"ax",%progbits
 855              		.align	1
 856              		.global	WaitTxBuffer
 857              		.thumb
 858              		.thumb_func
 860              	WaitTxBuffer:
 861              	.LFB69:
 403:src/uart_support_gps.c **** 
 404:src/uart_support_gps.c **** /**************************************************************************/
 405:src/uart_support_gps.c **** /*! 
 406:src/uart_support_gps.c ****     @brief	Wait to Empty USART TX Buffers.
 407:src/uart_support_gps.c **** 	@param	None.
 408:src/uart_support_gps.c ****     @retval	None.
 409:src/uart_support_gps.c **** */
 410:src/uart_support_gps.c **** /**************************************************************************/
 411:src/uart_support_gps.c **** uint8_t WaitTxBuffer(void)
 412:src/uart_support_gps.c **** {
 862              		.loc 1 412 0
 863              		.cfi_startproc
 864              		@ args = 0, pretend = 0, frame = 0
 865              		@ frame_needed = 0, uses_anonymous_args = 0
 866              		@ link register save eliminated.
 413:src/uart_support_gps.c **** 	/* Return 1 If All Character send */
 414:src/uart_support_gps.c **** 	uint16_t tempTX_Tail = pUSART_Buf->TX_Tail;
 867              		.loc 1 414 0
 868 0000 064B     		ldr	r3, .L78
 869 0002 1868     		ldr	r0, [r3, #0]
 870 0004 B0F80622 		ldrh	r2, [r0, #518]
 871 0008 91B2     		uxth	r1, r2
 872              	.LVL98:
 415:src/uart_support_gps.c **** 	return (pUSART_Buf->TX_Head == tempTX_Tail);
 873              		.loc 1 415 0
 874 000a B0F80432 		ldrh	r3, [r0, #516]
 875 000e 98B2     		uxth	r0, r3
 416:src/uart_support_gps.c **** }
 876              		.loc 1 416 0
 877 0010 421A     		subs	r2, r0, r1
 878              	.LVL99:
 879 0012 5142     		rsbs	r1, r2, #0
 880              	.LVL100:
 881 0014 51EB0200 		adcs	r0, r1, r2
 882 0018 7047     		bx	lr
 883              	.L79:
 884 001a 00BF     		.align	2
 885              	.L78:
 886 001c 00000000 		.word	.LANCHOR2
 887              		.cfi_endproc
 888              	.LFE69:
 890              		.global	xUART_IRQ
 891              		.global	USART2_Buf
 892              		.global	USART_InitStructure
 893              		.section	.bss.pUSART_Buf,"aw",%nobits
 894              		.align	2
 895              		.set	.LANCHOR2,. + 0
 898              	pUSART_Buf:
 899 0000 00000000 		.space	4
 900              		.section	.bss.UART,"aw",%nobits
 901              		.align	2
 902              		.set	.LANCHOR0,. + 0
 905              	UART:
 906 0000 00000000 		.space	4
 907              		.section	.bss.xUART_IRQ,"aw",%nobits
 908              		.align	2
 909              		.set	.LANCHOR4,. + 0
 912              	xUART_IRQ:
 913 0000 00000000 		.space	4
 914              		.section	.bss.USART2_Buf,"aw",%nobits
 915              		.align	1
 916              		.set	.LANCHOR3,. + 0
 919              	USART2_Buf:
 920 0000 00000000 		.space	520
 920      00000000 
 920      00000000 
 920      00000000 
 920      00000000 
 921              		.section	.bss.USART_InitStructure,"aw",%nobits
 922              		.align	2
 923              		.set	.LANCHOR1,. + 0
 926              	USART_InitStructure:
 927 0000 00000000 		.space	16
 927      00000000 
 927      00000000 
 927      00000000 
 928              		.text
 929              	.Letext0:
 930              		.file 3 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/include/stddef.h"
 931              		.file 4 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/include/stdint-gcc.h"
 932              		.file 5 "./lib/CMSIS/Device/ST/STM32F10x/Include/stm32f10x.h"
 933              		.file 6 "./lib/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h"
 934              		.file 7 "./lib/STM32F10x_StdPeriph_Driver/inc/stm32f10x_usart.h"
 935              		.file 8 "./lib/STM32F10x_StdPeriph_Driver/inc/misc.h"
 936              		.file 9 "./inc/uart_support_gps.h"
 937              		.file 10 "./lib/CMSIS/Include/core_cm3.h"
 938              		.file 11 "./lib/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h"
 939              		.file 12 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-e
DEFINED SYMBOLS
                            *ABS*:00000000 uart_support_gps.c
  R:\TEMP\ccXjxqnc.s:19     .text.conio_init:00000000 $t
  R:\TEMP\ccXjxqnc.s:24     .text.conio_init:00000000 conio_init
  R:\TEMP\ccXjxqnc.s:152    .text.conio_init:000000bc $d
  R:\TEMP\ccXjxqnc.s:162    .text.USART_TXBuffer_FreeSpace:00000000 $t
  R:\TEMP\ccXjxqnc.s:167    .text.USART_TXBuffer_FreeSpace:00000000 USART_TXBuffer_FreeSpace
  R:\TEMP\ccXjxqnc.s:197    .text.USART_TXBuffer_PutByte:00000000 $t
  R:\TEMP\ccXjxqnc.s:202    .text.USART_TXBuffer_PutByte:00000000 USART_TXBuffer_PutByte
  R:\TEMP\ccXjxqnc.s:290    .text.USART_TXBuffer_PutByte:00000048 $d
  R:\TEMP\ccXjxqnc.s:295    .text.USART_RXBufferData_Available:00000000 $t
  R:\TEMP\ccXjxqnc.s:300    .text.USART_RXBufferData_Available:00000000 USART_RXBufferData_Available
  R:\TEMP\ccXjxqnc.s:327    .text.USART_RXBuffer_GetByte:00000000 $t
  R:\TEMP\ccXjxqnc.s:332    .text.USART_RXBuffer_GetByte:00000000 USART_RXBuffer_GetByte
  R:\TEMP\ccXjxqnc.s:376    .text.putch:00000000 $t
  R:\TEMP\ccXjxqnc.s:381    .text.putch:00000000 putch
  R:\TEMP\ccXjxqnc.s:423    .text.putch:00000020 $d
  R:\TEMP\ccXjxqnc.s:428    .text.getch:00000000 $t
  R:\TEMP\ccXjxqnc.s:433    .text.getch:00000000 getch
  R:\TEMP\ccXjxqnc.s:472    .text.getch:0000001c $d
  R:\TEMP\ccXjxqnc.s:477    .text.keypressed:00000000 $t
  R:\TEMP\ccXjxqnc.s:482    .text.keypressed:00000000 keypressed
  R:\TEMP\ccXjxqnc.s:516    .text.keypressed:00000018 $d
  R:\TEMP\ccXjxqnc.s:521    .text.cputs:00000000 $t
  R:\TEMP\ccXjxqnc.s:526    .text.cputs:00000000 cputs
  R:\TEMP\ccXjxqnc.s:557    .text.cgets:00000000 $t
  R:\TEMP\ccXjxqnc.s:562    .text.cgets:00000000 cgets
  R:\TEMP\ccXjxqnc.s:663    .text.conio_IRQ:00000000 $t
  R:\TEMP\ccXjxqnc.s:668    .text.conio_IRQ:00000000 conio_IRQ
  R:\TEMP\ccXjxqnc.s:780    .text.conio_IRQ:00000090 $d
  R:\TEMP\ccXjxqnc.s:788    .text.USART2_IRQHandler:00000000 $t
  R:\TEMP\ccXjxqnc.s:793    .text.USART2_IRQHandler:00000000 USART2_IRQHandler
  R:\TEMP\ccXjxqnc.s:813    .text.USART2_IRQHandler:0000000c $d
  R:\TEMP\ccXjxqnc.s:818    .text.Flush_RXBuffer:00000000 $t
  R:\TEMP\ccXjxqnc.s:823    .text.Flush_RXBuffer:00000000 Flush_RXBuffer
  R:\TEMP\ccXjxqnc.s:849    .text.Flush_RXBuffer:0000001c $d
  R:\TEMP\ccXjxqnc.s:855    .text.WaitTxBuffer:00000000 $t
  R:\TEMP\ccXjxqnc.s:860    .text.WaitTxBuffer:00000000 WaitTxBuffer
  R:\TEMP\ccXjxqnc.s:886    .text.WaitTxBuffer:0000001c $d
  R:\TEMP\ccXjxqnc.s:912    .bss.xUART_IRQ:00000000 xUART_IRQ
  R:\TEMP\ccXjxqnc.s:919    .bss.USART2_Buf:00000000 USART2_Buf
  R:\TEMP\ccXjxqnc.s:926    .bss.USART_InitStructure:00000000 USART_InitStructure
  R:\TEMP\ccXjxqnc.s:894    .bss.pUSART_Buf:00000000 $d
  R:\TEMP\ccXjxqnc.s:898    .bss.pUSART_Buf:00000000 pUSART_Buf
  R:\TEMP\ccXjxqnc.s:901    .bss.UART:00000000 $d
  R:\TEMP\ccXjxqnc.s:905    .bss.UART:00000000 UART
  R:\TEMP\ccXjxqnc.s:908    .bss.xUART_IRQ:00000000 $d
  R:\TEMP\ccXjxqnc.s:915    .bss.USART2_Buf:00000000 $d
  R:\TEMP\ccXjxqnc.s:922    .bss.USART_InitStructure:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB2PeriphClockCmd
RCC_APB1PeriphClockCmd
GPIO_Init
NVIC_PriorityGroupConfig
NVIC_Init
USART_StructInit
USART_Init
USART_ITConfig
USART_Cmd
memset
USART_GetITStatus
USART_ReceiveData
