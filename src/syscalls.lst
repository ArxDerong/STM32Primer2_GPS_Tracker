   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"syscalls.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text._read_r,"ax",%progbits
  19              		.align	1
  20              		.global	_read_r
  21              		.thumb
  22              		.thumb_func
  24              	_read_r:
  25              	.LFB57:
  26              		.file 1 "src/syscalls.c"
   1:src/syscalls.c **** /********************************************************************************/
   2:src/syscalls.c **** /*!
   3:src/syscalls.c **** 	@file			syscalls.c
   4:src/syscalls.c **** 	@author         Nemui Trinomius (http://nemuisan.blog.bai.ne.jp)
   5:src/syscalls.c ****     @version        3.00
   6:src/syscalls.c ****     @date           2013.07.10
   7:src/syscalls.c **** 	@brief          Syscall support functions for newlib console I/O with stdio.
   8:src/syscalls.c **** 					Based on Red Hat newlib C library examples thanks!
   9:src/syscalls.c **** 					Based on under URL thanks!
  10:src/syscalls.c **** 					 http://sourceware.org/newlib/libc.html#Syscalls
  11:src/syscalls.c **** 
  12:src/syscalls.c ****     @section HISTORY
  13:src/syscalls.c **** 		2012.08.27	V1.00	Start Here.
  14:src/syscalls.c **** 		2013.01.07	V2.00	Adopted "--specs=nano.specs" option.
  15:src/syscalls.c **** 		2013.07.10	V3.00	Adopted semihosting function on nanolib.
  16:src/syscalls.c **** 
  17:src/syscalls.c ****     @section LICENSE
  18:src/syscalls.c **** 		BSD License. See Copyright.txt
  19:src/syscalls.c **** */
  20:src/syscalls.c **** /********************************************************************************/
  21:src/syscalls.c **** 
  22:src/syscalls.c **** /* Includes ------------------------------------------------------------------*/
  23:src/syscalls.c **** #include <stdlib.h>
  24:src/syscalls.c **** #include <string.h>
  25:src/syscalls.c **** #include <stdbool.h>
  26:src/syscalls.c **** #include <reent.h>
  27:src/syscalls.c **** #include <errno.h>
  28:src/syscalls.c **** #include <sys/stat.h>
  29:src/syscalls.c **** #include <sys/types.h>
  30:src/syscalls.c **** 
  31:src/syscalls.c **** /* This is platform dependent includion */
  32:src/syscalls.c **** #include "syscalls_if.h"
  33:src/syscalls.c **** 
  34:src/syscalls.c **** /* Defines -------------------------------------------------------------------*/
  35:src/syscalls.c **** 
  36:src/syscalls.c **** /* Variables -----------------------------------------------------------------*/
  37:src/syscalls.c **** /* .ARM.exidx is sorted, so has to go in its own output section.  */
  38:src/syscalls.c **** extern char *__exidx_start;
  39:src/syscalls.c **** extern char *__exidx_end;
  40:src/syscalls.c **** 
  41:src/syscalls.c **** /* Constants -----------------------------------------------------------------*/
  42:src/syscalls.c **** 
  43:src/syscalls.c **** /* Function prototypes -------------------------------------------------------*/
  44:src/syscalls.c **** 
  45:src/syscalls.c **** /* Functions -----------------------------------------------------------------*/
  46:src/syscalls.c **** #if !defined(USE_SEMIHOSTING)
  47:src/syscalls.c **** /**************************************************************************/
  48:src/syscalls.c **** /*! 
  49:src/syscalls.c ****     @brief  Input Datas from STDIN with reentrancy.					@n
  50:src/syscalls.c **** 			"getch()" indicates retarget function.					@n
  51:src/syscalls.c **** 			See "syscalls_if.h"!
  52:src/syscalls.c **** */
  53:src/syscalls.c **** /**************************************************************************/
  54:src/syscalls.c **** _ssize_t _read_r(
  55:src/syscalls.c **** 	struct _reent *r,
  56:src/syscalls.c **** 	int file,
  57:src/syscalls.c **** 	void *ptr,
  58:src/syscalls.c **** 	size_t len)
  59:src/syscalls.c **** {
  27              		.loc 1 59 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 70B5     		push	{r4, r5, r6, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 16
  35              		.cfi_offset 4, -16
  36              		.cfi_offset 5, -12
  37              		.cfi_offset 6, -8
  38              		.cfi_offset 14, -4
  39 0002 1E46     		mov	r6, r3
  40              	.LVL1:
  41 0004 1546     		mov	r5, r2
  60:src/syscalls.c **** 	char c;
  61:src/syscalls.c **** 	int  i;
  62:src/syscalls.c **** 	unsigned char *p;
  63:src/syscalls.c **** 
  64:src/syscalls.c **** 	p = (unsigned char*)ptr;
  65:src/syscalls.c **** 	for (i = 0; i < len; i++)
  42              		.loc 1 65 0
  43 0006 0024     		movs	r4, #0
  44              	.LVL2:
  45              	.L2:
  46              		.loc 1 65 0 is_stmt 0 discriminator 1
  47 0008 B442     		cmp	r4, r6
  48 000a 11D0     		beq	.L5
  49              	.L8:
  66:src/syscalls.c **** 	{
  67:src/syscalls.c **** 		/* 20090521Nemui */
  68:src/syscalls.c **** 			do{		
  69:src/syscalls.c **** 				c = getch();
  50              		.loc 1 69 0 is_stmt 1
  51 000c FFF7FEFF 		bl	getch
  52              	.LVL3:
  70:src/syscalls.c **** 		}while(c == false);
  53              		.loc 1 70 0
  54 0010 10F0FF03 		ands	r3, r0, #255
  55 0014 FAD0     		beq	.L8
  71:src/syscalls.c **** 		/* 20090521Nemui */
  72:src/syscalls.c **** 
  73:src/syscalls.c **** 		*p++ = c;
  56              		.loc 1 73 0
  57 0016 05F8010B 		strb	r0, [r5], #1
  58              	.LVL4:
  74:src/syscalls.c **** 		#ifdef ECHOBACK 
  75:src/syscalls.c **** 		 putch(c);
  76:src/syscalls.c **** 		#endif
  77:src/syscalls.c **** 
  78:src/syscalls.c **** 		if (c == '\r' && i <= (len - 2)) /* 0x0D */
  59              		.loc 1 78 0
  60 001a 0D2B     		cmp	r3, #13
  61 001c 06D1     		bne	.L4
  62              		.loc 1 78 0 is_stmt 0 discriminator 1
  63 001e B01E     		subs	r0, r6, #2
  64              	.LVL5:
  65 0020 8442     		cmp	r4, r0
  66 0022 03D8     		bhi	.L4
  79:src/syscalls.c **** 		{
  80:src/syscalls.c **** 			*p = '\n';					 /* 0x0A */
  67              		.loc 1 80 0 is_stmt 1
  68 0024 0A21     		movs	r1, #10
  69 0026 2970     		strb	r1, [r5, #0]
  81:src/syscalls.c **** 		  #ifdef ECHOBACK 
  82:src/syscalls.c **** 			putch('\n');				 /* 0x0A */
  83:src/syscalls.c **** 		  #endif
  84:src/syscalls.c **** 			return i + 2;
  70              		.loc 1 84 0
  71 0028 0234     		adds	r4, r4, #2
  72              	.LVL6:
  73 002a 01E0     		b	.L5
  74              	.LVL7:
  75              	.L4:
  65:src/syscalls.c **** 	{
  76              		.loc 1 65 0
  77 002c 0134     		adds	r4, r4, #1
  78              	.LVL8:
  79 002e EBE7     		b	.L2
  80              	.LVL9:
  81              	.L5:
  85:src/syscalls.c **** 		}
  86:src/syscalls.c **** 	}
  87:src/syscalls.c **** 	return i;
  88:src/syscalls.c **** }
  82              		.loc 1 88 0
  83 0030 2046     		mov	r0, r4
  84 0032 70BD     		pop	{r4, r5, r6, pc}
  85              		.cfi_endproc
  86              	.LFE57:
  88              		.section	.text._write_r,"ax",%progbits
  89              		.align	1
  90              		.global	_write_r
  91              		.thumb
  92              		.thumb_func
  94              	_write_r:
  95              	.LFB58:
  89:src/syscalls.c **** 
  90:src/syscalls.c **** /**************************************************************************/
  91:src/syscalls.c **** /*! 
  92:src/syscalls.c ****     @brief  Output Datas to STDOUT with reentrancy.					@n
  93:src/syscalls.c **** 			"putch(x)" indicates retarget function.					@n
  94:src/syscalls.c **** 			See "syscalls_if.h"!
  95:src/syscalls.c **** */
  96:src/syscalls.c **** /**************************************************************************/
  97:src/syscalls.c **** _ssize_t _write_r (
  98:src/syscalls.c ****     struct _reent *r, 
  99:src/syscalls.c ****     int file, 
 100:src/syscalls.c ****     const void *ptr, 
 101:src/syscalls.c ****     size_t len)
 102:src/syscalls.c **** {
  96              		.loc 1 102 0
  97              		.cfi_startproc
  98              		@ args = 0, pretend = 0, frame = 0
  99              		@ frame_needed = 0, uses_anonymous_args = 0
 100              	.LVL10:
 101 0000 70B5     		push	{r4, r5, r6, lr}
 102              	.LCFI1:
 103              		.cfi_def_cfa_offset 16
 104              		.cfi_offset 4, -16
 105              		.cfi_offset 5, -12
 106              		.cfi_offset 6, -8
 107              		.cfi_offset 14, -4
 108 0002 1D46     		mov	r5, r3
 109              	.LVL11:
 110 0004 1446     		mov	r4, r2
 111              		.file 2 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-ea
   1:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** /* This header file provides the reentrancy.  */
   2:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
   3:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** /* The reentrant system calls here serve two purposes:
   4:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
   5:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    1) Provide reentrant versions of the system calls the ANSI C library
   6:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       requires.
   7:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    2) Provide these system calls in a namespace clean way.
   8:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
   9:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    It is intended that *all* system calls that the ANSI C library needs
  10:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    be declared here.  It documents them all in one place.  All library access
  11:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    to the system is via some form of these functions.
  12:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  13:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    The target may provide the needed syscalls by any of the following:
  14:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  15:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    1) Define the reentrant versions of the syscalls directly.
  16:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       (eg: _open_r, _close_r, etc.).  Please keep the namespace clean.
  17:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       When you do this, set "syscall_dir" to "syscalls" and add
  18:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       -DREENTRANT_SYSCALLS_PROVIDED to newlib_cflags in configure.host.
  19:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  20:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    2) Define namespace clean versions of the system calls by prefixing
  21:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       them with '_' (eg: _open, _close, etc.).  Technically, there won't be
  22:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       true reentrancy at the syscall level, but the library will be namespace
  23:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       clean.
  24:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       When you do this, set "syscall_dir" to "syscalls" in configure.host.
  25:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  26:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    3) Define or otherwise provide the regular versions of the syscalls
  27:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       (eg: open, close, etc.).  The library won't be reentrant nor namespace
  28:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       clean, but at least it will work.
  29:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       When you do this, add -DMISSING_SYSCALL_NAMES to newlib_cflags in
  30:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       configure.host.
  31:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  32:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    4) Define or otherwise provide the regular versions of the syscalls,
  33:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       and do not supply functional interfaces for any of the reentrant
  34:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       calls. With this method, the reentrant syscalls are redefined to
  35:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       directly call the regular system call without the reentrancy argument.
  36:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       When you do this, specify both -DREENTRANT_SYSCALLS_PROVIDED and 
  37:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       -DMISSING_SYSCALL_NAMES via newlib_cflags in configure.host and do
  38:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****       not specify "syscall_dir".
  39:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  40:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    Stubs of the reentrant versions of the syscalls exist in the libc/reent
  41:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    source directory and are provided if REENTRANT_SYSCALLS_PROVIDED isn't 
  42:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    defined.  These stubs call the native system calls: _open, _close, etc. 
  43:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    if MISSING_SYSCALL_NAMES is *not* defined, otherwise they call the
  44:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    non-underscored versions: open, close, etc. when MISSING_SYSCALL_NAMES
  45:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    *is* defined.
  46:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  47:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    By default, newlib functions call the reentrant syscalls internally,
  48:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    passing a reentrancy structure as an argument.  This reentrancy structure
  49:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    contains data that is thread-specific.  For example, the errno value is
  50:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    kept in the reentrancy structure.  If multiple threads exist, each will
  51:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    keep a separate errno value which is intuitive since the application flow
  52:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    cannot check for failure reliably otherwise.
  53:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  54:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    The reentrant syscalls are either provided by the platform, by the 
  55:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    libc/reent stubs, or in the case of both MISSING_SYSCALL_NAMES and 
  56:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    REENTRANT_SYSCALLS_PROVIDED being defined, the calls are redefined to
  57:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    simply call the regular syscalls with no reentrancy struct argument.
  58:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  59:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    A single-threaded application does not need to worry about the reentrancy
  60:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    structure.  It is used internally.  
  61:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  62:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    A multi-threaded application needs either to manually manage reentrancy 
  63:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    structures or use dynamic reentrancy.
  64:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    
  65:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    Manually managing reentrancy structures entails calling special reentrant
  66:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    versions of newlib functions that have an additional reentrancy argument.
  67:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    For example, _printf_r.  By convention, the first argument is the
  68:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    reentrancy structure.  By default, the normal version of the function
  69:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    uses the default reentrancy structure: _REENT.  The reentrancy structure
  70:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    is passed internally, eventually to the reentrant syscalls themselves.
  71:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    How the structures are stored and accessed in this model is up to the
  72:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    application.
  73:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  74:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    Dynamic reentrancy is specified by the __DYNAMIC_REENT__ flag.  This
  75:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    flag denotes setting up a macro to replace _REENT with a function call
  76:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    to __getreent().  This function needs to be implemented by the platform
  77:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    and it is meant to return the reentrancy structure for the current
  78:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    thread.  When the regular C functions (e.g. printf) go to call internal
  79:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    routines with the default _REENT structure, they end up calling with 
  80:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    the reentrancy structure for the thread.  Thus, application code does not
  81:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    need to call the _r routines nor worry about reentrancy structures.  */
  82:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  83:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** /* WARNING: All identifiers here must begin with an underscore.  This file is
  84:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    included by stdio.h and others and we therefore must only use identifiers
  85:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h ****    in the namespace allotted to us.  */
  86:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  87:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #ifndef _REENT_H_
  88:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #ifdef __cplusplus
  89:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern "C" {
  90:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #endif
  91:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _REENT_H_
  92:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  93:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #include <sys/reent.h>
  94:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #include <sys/_types.h>
  95:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #include <machine/types.h>
  96:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
  97:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define __need_size_t
  98:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define __need_ptrdiff_t
  99:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #include <stddef.h>
 100:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
 101:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** /* FIXME: not namespace clean */
 102:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** struct stat;
 103:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** struct tms;
 104:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** struct timeval;
 105:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** struct timezone;
 106:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
 107:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #if defined(REENTRANT_SYSCALLS_PROVIDED) && defined(MISSING_SYSCALL_NAMES)
 108:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
 109:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _close_r(__reent, __fd)                   close(__fd)
 110:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _execve_r(__reent, __f, __arg, __env)     execve(__f, __arg, __env)
 111:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _fcntl_r(__reent, __fd, __cmd, __arg)     fcntl(__fd, __cmd, __arg)
 112:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _fork_r(__reent)                          fork()
 113:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _fstat_r(__reent, __fdes, __stat)         fstat(__fdes, __stat)
 114:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _getpid_r(__reent)                        getpid()
 115:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _isatty_r(__reent, __desc)                isatty(__desc)
 116:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _kill_r(__reent, __pid, __signal)         kill(__pid, __signal)
 117:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _link_r(__reent, __oldpath, __newpath)    link(__oldpath, __newpath)
 118:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _lseek_r(__reent, __fdes, __off, __w)     lseek(__fdes, __off, __w)
 119:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _mkdir_r(__reent, __path, __m)		  mkdir(__path, __m)
 120:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _open_r(__reent, __path, __flag, __m)     open(__path, __flag, __m)
 121:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _read_r(__reent, __fd, __buff, __cnt)     read(__fd, __buff, __cnt)
 122:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _rename_r(__reent, __old, __new)	  rename(__old, __new)
 123:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _sbrk_r(__reent, __incr)                  sbrk(__incr)
 124:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _stat_r(__reent, __path, __buff)          stat(__path, __buff)
 125:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _times_r(__reent, __time)                 times(__time)
 126:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _unlink_r(__reent, __path)                unlink(__path)
 127:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _wait_r(__reent, __status)                wait(__status)
 128:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _write_r(__reent, __fd, __buff, __cnt)    write(__fd, __buff, __cnt)
 129:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _gettimeofday_r(__reent, __tp, __tzp)     gettimeofday(__tp, __tzp)
 130:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
 131:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #ifdef __LARGE64_FILES
 132:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _lseek64_r(__reent, __fd, __off, __w)     lseek64(__fd, __off, __w)
 133:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _fstat64_r(__reent, __fd, __buff)         fstat64(__fd, __buff)
 134:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #define _open64_r(__reent, __path, __flag, __m)   open64(__path, __flag, __m)
 135:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #endif
 136:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
 137:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** #else
 138:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** /* Reentrant versions of system calls.  */
 139:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** 
 140:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _close_r _PARAMS ((struct _reent *, int));
 141:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _execve_r _PARAMS ((struct _reent *, const char *, char *const *, char *const *));
 142:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _fcntl_r _PARAMS ((struct _reent *, int, int, int));
 143:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _fork_r _PARAMS ((struct _reent *));
 144:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _fstat_r _PARAMS ((struct _reent *, int, struct stat *));
 145:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _getpid_r _PARAMS ((struct _reent *));
 146:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _isatty_r _PARAMS ((struct _reent *, int));
 147:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _kill_r _PARAMS ((struct _reent *, int, int));
 148:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _link_r _PARAMS ((struct _reent *, const char *, const char *));
 149:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern _off_t _lseek_r _PARAMS ((struct _reent *, int, _off_t, int));
 150:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _mkdir_r _PARAMS ((struct _reent *, const char *, int));
 151:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _open_r _PARAMS ((struct _reent *, const char *, int, int));
 152:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern _ssize_t _read_r _PARAMS ((struct _reent *, int, void *, size_t));
 153:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _rename_r _PARAMS ((struct _reent *, const char *, const char *));
 154:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern void *_sbrk_r _PARAMS ((struct _reent *, ptrdiff_t));
 155:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _stat_r _PARAMS ((struct _reent *, const char *, struct stat *));
 156:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern _CLOCK_T_ _times_r _PARAMS ((struct _reent *, struct tms *));
 157:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _unlink_r _PARAMS ((struct _reent *, const char *));
 158:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern int _wait_r _PARAMS ((struct _reent *, int *));
 159:c:\devz\arm\bleeding-edge\bin\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include\reent.h **** extern _ssize_t _write_r _PARAMS ((struct _reent *, int, const void *, size_t));
 112              		.loc 2 159 0
 113 0006 D618     		adds	r6, r2, r3
 114              	.LVL12:
 115              	.L13:
 103:src/syscalls.c **** 	int i;
 104:src/syscalls.c **** 	const unsigned char *p;
 105:src/syscalls.c **** 	
 106:src/syscalls.c **** 	p = (const unsigned char*) ptr;
 107:src/syscalls.c **** 	
 108:src/syscalls.c **** 	for (i = 0; i < len; i++) {
 116              		.loc 1 108 0 discriminator 1
 117 0008 B442     		cmp	r4, r6
 118 000a 0BD0     		beq	.L16
 119              	.L15:
 109:src/syscalls.c **** 		if (*p == '\n' ) putch('\r');
 120              		.loc 1 109 0
 121 000c 14F8013B 		ldrb	r3, [r4], #1	@ zero_extendqisi2
 122 0010 0A2B     		cmp	r3, #10
 123 0012 02D1     		bne	.L14
 124              		.loc 1 109 0 is_stmt 0 discriminator 1
 125 0014 0D20     		movs	r0, #13
 126 0016 FFF7FEFF 		bl	putch
 127              	.LVL13:
 128              	.L14:
 110:src/syscalls.c **** 		putch(*p++);
 129              		.loc 1 110 0 is_stmt 1
 130 001a 14F8010C 		ldrb	r0, [r4, #-1]	@ zero_extendqisi2
 131 001e FFF7FEFF 		bl	putch
 132              	.LVL14:
 133 0022 F1E7     		b	.L13
 134              	.L16:
 111:src/syscalls.c **** 	}
 112:src/syscalls.c **** 	
 113:src/syscalls.c **** 	return len;
 114:src/syscalls.c **** }
 135              		.loc 1 114 0
 136 0024 2846     		mov	r0, r5
 137 0026 70BD     		pop	{r4, r5, r6, pc}
 138              		.cfi_endproc
 139              	.LFE58:
 141              		.section	.text._fini,"ax",%progbits
 142              		.align	1
 143              		.global	_fini
 144              		.thumb
 145              		.thumb_func
 147              	_fini:
 148              	.LFB59:
 115:src/syscalls.c **** 
 116:src/syscalls.c **** /**************************************************************************/
 117:src/syscalls.c **** /*! 
 118:src/syscalls.c ****     @brief  Dummy Function for Newlib C++ Destractor.
 119:src/syscalls.c **** */
 120:src/syscalls.c **** /**************************************************************************/
 121:src/syscalls.c **** void _fini(void)
 122:src/syscalls.c **** {
 149              		.loc 1 122 0
 150              		.cfi_startproc
 151              		@ args = 0, pretend = 0, frame = 0
 152              		@ frame_needed = 0, uses_anonymous_args = 0
 153              		@ link register save eliminated.
 154 0000 7047     		bx	lr
 155              		.cfi_endproc
 156              	.LFE59:
 158              		.section	.text._close_r,"ax",%progbits
 159              		.align	1
 160              		.global	_close_r
 161              		.thumb
 162              		.thumb_func
 164              	_close_r:
 165              	.LFB60:
 123:src/syscalls.c **** 	/* Nothing to do. */
 124:src/syscalls.c **** }
 125:src/syscalls.c **** 
 126:src/syscalls.c **** /**************************************************************************/
 127:src/syscalls.c **** /*! 
 128:src/syscalls.c ****     @brief  Dummy OS Function for Newlib with reentrancy.
 129:src/syscalls.c **** */
 130:src/syscalls.c **** /**************************************************************************/
 131:src/syscalls.c **** int _close_r(struct _reent *r, int file)
 132:src/syscalls.c **** {
 166              		.loc 1 132 0
 167              		.cfi_startproc
 168              		@ args = 0, pretend = 0, frame = 0
 169              		@ frame_needed = 0, uses_anonymous_args = 0
 170              		@ link register save eliminated.
 171              	.LVL15:
 172              		.loc 1 132 0
 133:src/syscalls.c **** 	return 0;
 134:src/syscalls.c **** }
 173              		.loc 1 134 0
 174 0000 0020     		movs	r0, #0
 175              	.LVL16:
 176 0002 7047     		bx	lr
 177              		.cfi_endproc
 178              	.LFE60:
 180              		.section	.text._lseek_r,"ax",%progbits
 181              		.align	1
 182              		.global	_lseek_r
 183              		.thumb
 184              		.thumb_func
 186              	_lseek_r:
 187              	.LFB61:
 135:src/syscalls.c **** 
 136:src/syscalls.c **** /**************************************************************************/
 137:src/syscalls.c **** /*! 
 138:src/syscalls.c ****     @brief  Dummy OS Function for Newlib with reentrancy.
 139:src/syscalls.c **** */
 140:src/syscalls.c **** /**************************************************************************/
 141:src/syscalls.c **** _off_t _lseek_r(
 142:src/syscalls.c ****     struct _reent *r, 
 143:src/syscalls.c ****     int file, 
 144:src/syscalls.c ****     _off_t ptr, 
 145:src/syscalls.c ****     int dir)
 146:src/syscalls.c **** {
 188              		.loc 1 146 0
 189              		.cfi_startproc
 190              		@ args = 0, pretend = 0, frame = 0
 191              		@ frame_needed = 0, uses_anonymous_args = 0
 192              		@ link register save eliminated.
 193              	.LVL17:
 147:src/syscalls.c **** 	return (_off_t)0;	/*  Always indicate we are at file beginning.	*/
 148:src/syscalls.c **** }
 194              		.loc 1 148 0
 195 0000 0020     		movs	r0, #0
 196              	.LVL18:
 197 0002 7047     		bx	lr
 198              		.cfi_endproc
 199              	.LFE61:
 201              		.section	.text._fstat_r,"ax",%progbits
 202              		.align	1
 203              		.global	_fstat_r
 204              		.thumb
 205              		.thumb_func
 207              	_fstat_r:
 208              	.LFB62:
 149:src/syscalls.c **** 
 150:src/syscalls.c **** /**************************************************************************/
 151:src/syscalls.c **** /*! 
 152:src/syscalls.c ****     @brief  Dummy OS Function for Newlib with reentrancy.
 153:src/syscalls.c **** */
 154:src/syscalls.c **** /**************************************************************************/
 155:src/syscalls.c **** int _fstat_r(
 156:src/syscalls.c ****     struct _reent *r, 
 157:src/syscalls.c ****     int file, 
 158:src/syscalls.c ****     struct stat *st)
 159:src/syscalls.c **** {
 209              		.loc 1 159 0
 210              		.cfi_startproc
 211              		@ args = 0, pretend = 0, frame = 0
 212              		@ frame_needed = 0, uses_anonymous_args = 0
 213              		@ link register save eliminated.
 214              	.LVL19:
 160:src/syscalls.c **** 	/*  Always set as character device.				*/
 161:src/syscalls.c **** 	st->st_mode = S_IFCHR;	
 215              		.loc 1 161 0
 216 0000 4FF40053 		mov	r3, #8192
 217 0004 5360     		str	r3, [r2, #4]
 162:src/syscalls.c **** 	/* assigned to strong type with implicit 		*/
 163:src/syscalls.c **** 	/* signed/unsigned conversion.  Required by 	*/
 164:src/syscalls.c **** 	/* newlib.										*/
 165:src/syscalls.c **** 	return 0;
 166:src/syscalls.c **** }
 218              		.loc 1 166 0
 219 0006 0020     		movs	r0, #0
 220              	.LVL20:
 221 0008 7047     		bx	lr
 222              		.cfi_endproc
 223              	.LFE62:
 225              		.section	.text._sbrk_r,"ax",%progbits
 226              		.align	1
 227              		.global	_sbrk_r
 228              		.thumb
 229              		.thumb_func
 231              	_sbrk_r:
 232              	.LFB63:
 167:src/syscalls.c **** 
 168:src/syscalls.c **** /**************************************************************************/
 169:src/syscalls.c **** /*! 
 170:src/syscalls.c ****     @brief  Memory Allocator Clue Function.								@n
 171:src/syscalls.c **** 			Adjusts end of heap to provide more memory to				@n
 172:src/syscalls.c **** 			memory allocator, With Simple sanity checks.				@n
 173:src/syscalls.c **** 																		@n
 174:src/syscalls.c **** 			This implementation is not thread safe (despite taking a	@n
 175:src/syscalls.c **** 			_reent structure as a parameter). 							@n
 176:src/syscalls.c **** 			Since _s_r is not used in the current implementation, 		@n
 177:src/syscalls.c **** 			the following messages must be suppressed.
 178:src/syscalls.c **** 	@param  struct _reent *_s_r: not in use currently.
 179:src/syscalls.c **** 	@param  ptrdiff_t nbytes: specify bytes to use memory.
 180:src/syscalls.c **** 	@retval None.
 181:src/syscalls.c **** */
 182:src/syscalls.c **** /**************************************************************************/
 183:src/syscalls.c **** extern char end[];              /* MUST be set in linker script command!	*/
 184:src/syscalls.c **** 								/* file and is the end of statically 		*/
 185:src/syscalls.c **** 								/* allocated data (thus start of heap).		*/
 186:src/syscalls.c **** extern char _heap_end[];		/* Bottom of HEAP region 					*/
 187:src/syscalls.c **** static char *heap_ptr=NULL;		/* Points to current end of the heap.		*/
 188:src/syscalls.c **** #ifdef USE_SP_AS_HEAP_END
 189:src/syscalls.c ****  #warning "use stackpointer as _sbrk's heapend!"
 190:src/syscalls.c ****  register char * stack_ptr asm ("sp");
 191:src/syscalls.c ****  #define _heap_end stack_ptr
 192:src/syscalls.c **** #endif
 193:src/syscalls.c **** 
 194:src/syscalls.c **** void * _sbrk_r(
 195:src/syscalls.c ****     struct _reent *_s_r, 
 196:src/syscalls.c ****     ptrdiff_t nbytes)
 197:src/syscalls.c **** {
 233              		.loc 1 197 0
 234              		.cfi_startproc
 235              		@ args = 0, pretend = 0, frame = 0
 236              		@ frame_needed = 0, uses_anonymous_args = 0
 237              	.LVL21:
 238 0000 08B5     		push	{r3, lr}
 239              	.LCFI2:
 240              		.cfi_def_cfa_offset 8
 241              		.cfi_offset 3, -8
 242              		.cfi_offset 14, -4
 198:src/syscalls.c **** 	char  *base;		/*  errno should be set to  ENOMEM on error	*/
 199:src/syscalls.c **** 
 200:src/syscalls.c **** 	if (!heap_ptr) {	/*  Initialize if first time through.		*/
 243              		.loc 1 200 0
 244 0002 0A4B     		ldr	r3, .L25
 245 0004 1A68     		ldr	r2, [r3, #0]
 246 0006 0AB9     		cbnz	r2, .L22
 201:src/syscalls.c **** 		heap_ptr = end;
 247              		.loc 1 201 0
 248 0008 0948     		ldr	r0, .L25+4
 249              	.LVL22:
 250 000a 1860     		str	r0, [r3, #0]
 251              	.L22:
 202:src/syscalls.c **** 	}
 203:src/syscalls.c **** 	base = heap_ptr;	/*  Point to end of heap.					*/
 252              		.loc 1 203 0
 253 000c 1868     		ldr	r0, [r3, #0]
 254              	.LVL23:
 204:src/syscalls.c **** 	
 205:src/syscalls.c **** 	if (heap_ptr + nbytes > _heap_end)
 255              		.loc 1 205 0
 256 000e 4118     		adds	r1, r0, r1
 257              	.LVL24:
 258 0010 6B46     		mov	r3, sp
 259 0012 9942     		cmp	r1, r3
 260 0014 06D9     		bls	.L23
 206:src/syscalls.c **** 	{
 207:src/syscalls.c **** 			errno = ENOMEM;
 261              		.loc 1 207 0
 262 0016 FFF7FEFF 		bl	__errno
 263              	.LVL25:
 264 001a 0C21     		movs	r1, #12
 265 001c 0160     		str	r1, [r0, #0]
 208:src/syscalls.c **** 			return (caddr_t) -1;
 266              		.loc 1 208 0
 267 001e 4FF0FF30 		mov	r0, #-1
 268 0022 08BD     		pop	{r3, pc}
 269              	.LVL26:
 270              	.L23:
 209:src/syscalls.c **** 	}
 210:src/syscalls.c **** 	heap_ptr += nbytes;	/*  Increase heap.							*/
 271              		.loc 1 210 0
 272 0024 014A     		ldr	r2, .L25
 273 0026 1160     		str	r1, [r2, #0]
 211:src/syscalls.c **** 	
 212:src/syscalls.c **** 	return base;		/*  Return pointer to start of new heap area.	*/
 213:src/syscalls.c **** }
 274              		.loc 1 213 0
 275 0028 08BD     		pop	{r3, pc}
 276              	.L26:
 277 002a 00BF     		.align	2
 278              	.L25:
 279 002c 00000000 		.word	.LANCHOR0
 280 0030 00000000 		.word	end
 281              		.cfi_endproc
 282              	.LFE63:
 284              		.section	.text.isatty,"ax",%progbits
 285              		.align	1
 286              		.global	isatty
 287              		.thumb
 288              		.thumb_func
 290              	isatty:
 291              	.LFB64:
 214:src/syscalls.c **** 
 215:src/syscalls.c **** 
 216:src/syscalls.c **** 
 217:src/syscalls.c **** /**************************************************************************/
 218:src/syscalls.c **** /*! 
 219:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 220:src/syscalls.c **** */
 221:src/syscalls.c **** /**************************************************************************/
 222:src/syscalls.c **** #ifdef __GNUC__
 223:src/syscalls.c ****  int isatty(int file); /* avoid warning */
 224:src/syscalls.c **** #endif
 225:src/syscalls.c **** int isatty(int file)
 226:src/syscalls.c **** {
 292              		.loc 1 226 0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 296              		@ link register save eliminated.
 297              	.LVL27:
 227:src/syscalls.c **** 	return 1;
 228:src/syscalls.c **** }
 298              		.loc 1 228 0
 299 0000 0120     		movs	r0, #1
 300              	.LVL28:
 301 0002 7047     		bx	lr
 302              		.cfi_endproc
 303              	.LFE64:
 305              		.section	.text._getpid,"ax",%progbits
 306              		.align	1
 307              		.global	_getpid
 308              		.thumb
 309              		.thumb_func
 311              	_getpid:
 312              	.LFB65:
 229:src/syscalls.c **** 
 230:src/syscalls.c **** /**************************************************************************/
 231:src/syscalls.c **** /*! 
 232:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 233:src/syscalls.c **** */
 234:src/syscalls.c **** /**************************************************************************/
 235:src/syscalls.c **** int _getpid(int file)
 236:src/syscalls.c **** {
 313              		.loc 1 236 0
 314              		.cfi_startproc
 315              		@ args = 0, pretend = 0, frame = 0
 316              		@ frame_needed = 0, uses_anonymous_args = 0
 317              		@ link register save eliminated.
 318              	.LVL29:
 237:src/syscalls.c **** 	return 1;
 238:src/syscalls.c **** }
 319              		.loc 1 238 0
 320 0000 0120     		movs	r0, #1
 321              	.LVL30:
 322 0002 7047     		bx	lr
 323              		.cfi_endproc
 324              	.LFE65:
 326              		.section	.text._sbrk,"ax",%progbits
 327              		.align	1
 328              		.global	_sbrk
 329              		.thumb
 330              		.thumb_func
 332              	_sbrk:
 333              	.LFB66:
 239:src/syscalls.c **** 
 240:src/syscalls.c **** /**************************************************************************/
 241:src/syscalls.c **** /*! 
 242:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 243:src/syscalls.c **** */
 244:src/syscalls.c **** /**************************************************************************/
 245:src/syscalls.c **** void * _sbrk(ptrdiff_t incr)
 246:src/syscalls.c **** {
 334              		.loc 1 246 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 0
 337              		@ frame_needed = 0, uses_anonymous_args = 0
 338              	.LVL31:
 339 0000 08B5     		push	{r3, lr}
 340              	.LCFI3:
 341              		.cfi_def_cfa_offset 8
 342              		.cfi_offset 3, -8
 343              		.cfi_offset 14, -4
 247:src/syscalls.c **** 	char  *base;
 248:src/syscalls.c **** 
 249:src/syscalls.c **** 	/* Initialize if first time through. */
 250:src/syscalls.c **** 	if (!heap_ptr) heap_ptr = end;
 344              		.loc 1 250 0
 345 0002 0A4B     		ldr	r3, .L33
 346 0004 1A68     		ldr	r2, [r3, #0]
 347 0006 0AB9     		cbnz	r2, .L30
 348              		.loc 1 250 0 is_stmt 0 discriminator 1
 349 0008 0949     		ldr	r1, .L33+4
 350 000a 1960     		str	r1, [r3, #0]
 351              	.L30:
 251:src/syscalls.c **** 
 252:src/syscalls.c **** 	base = heap_ptr;      /*  Point to end of heap.                       */
 352              		.loc 1 252 0 is_stmt 1
 353 000c 1B68     		ldr	r3, [r3, #0]
 354              	.LVL32:
 253:src/syscalls.c **** 
 254:src/syscalls.c **** 	if (heap_ptr + incr > _heap_end)
 355              		.loc 1 254 0
 356 000e 1818     		adds	r0, r3, r0
 357              	.LVL33:
 358 0010 6A46     		mov	r2, sp
 359 0012 9042     		cmp	r0, r2
 360 0014 06D9     		bls	.L31
 255:src/syscalls.c **** 	{
 256:src/syscalls.c **** 			errno = ENOMEM;
 361              		.loc 1 256 0
 362 0016 FFF7FEFF 		bl	__errno
 363              	.LVL34:
 364 001a 0C23     		movs	r3, #12
 365 001c 0360     		str	r3, [r0, #0]
 257:src/syscalls.c **** 			return (caddr_t) -1;
 366              		.loc 1 257 0
 367 001e 4FF0FF33 		mov	r3, #-1
 368 0022 01E0     		b	.L32
 369              	.LVL35:
 370              	.L31:
 258:src/syscalls.c **** 	}
 259:src/syscalls.c ****   
 260:src/syscalls.c **** 	heap_ptr += incr;     /*  Increase heap.                              */
 371              		.loc 1 260 0
 372 0024 0149     		ldr	r1, .L33
 373 0026 0860     		str	r0, [r1, #0]
 374              	.LVL36:
 375              	.L32:
 261:src/syscalls.c **** 
 262:src/syscalls.c **** 	return base;          /*  Return pointer to start of new heap area.   */
 263:src/syscalls.c **** }
 376              		.loc 1 263 0
 377 0028 1846     		mov	r0, r3
 378 002a 08BD     		pop	{r3, pc}
 379              	.L34:
 380              		.align	2
 381              	.L33:
 382 002c 00000000 		.word	.LANCHOR0
 383 0030 00000000 		.word	end
 384              		.cfi_endproc
 385              	.LFE66:
 387              		.section	.text._open,"ax",%progbits
 388              		.align	1
 389              		.global	_open
 390              		.thumb
 391              		.thumb_func
 393              	_open:
 394              	.LFB67:
 264:src/syscalls.c **** 
 265:src/syscalls.c **** /**************************************************************************/
 266:src/syscalls.c **** /*! 
 267:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 268:src/syscalls.c **** */
 269:src/syscalls.c **** /**************************************************************************/
 270:src/syscalls.c **** int _open(const char *path, int flags, ...)
 271:src/syscalls.c **** {
 395              		.loc 1 271 0
 396              		.cfi_startproc
 397              		@ args = 4, pretend = 12, frame = 0
 398              		@ frame_needed = 0, uses_anonymous_args = 1
 399              		@ link register save eliminated.
 400              	.LVL37:
 401 0000 0EB4     		push	{r1, r2, r3}
 402              	.LCFI4:
 403              		.cfi_def_cfa_offset 12
 404              		.cfi_offset 1, -12
 405              		.cfi_offset 2, -8
 406              		.cfi_offset 3, -4
 272:src/syscalls.c **** 	return 1;
 273:src/syscalls.c **** }
 407              		.loc 1 273 0
 408 0002 0120     		movs	r0, #1
 409              	.LVL38:
 410 0004 03B0     		add	sp, sp, #12
 411 0006 7047     		bx	lr
 412              		.cfi_endproc
 413              	.LFE67:
 415              		.section	.text._close,"ax",%progbits
 416              		.align	1
 417              		.global	_close
 418              		.thumb
 419              		.thumb_func
 421              	_close:
 422              	.LFB68:
 274:src/syscalls.c **** 
 275:src/syscalls.c **** /**************************************************************************/
 276:src/syscalls.c **** /*! 
 277:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 278:src/syscalls.c **** */
 279:src/syscalls.c **** /**************************************************************************/
 280:src/syscalls.c **** int _close(int fd)
 281:src/syscalls.c **** {
 423              		.loc 1 281 0
 424              		.cfi_startproc
 425              		@ args = 0, pretend = 0, frame = 0
 426              		@ frame_needed = 0, uses_anonymous_args = 0
 427              		@ link register save eliminated.
 428              	.LVL39:
 282:src/syscalls.c **** 	return 0;
 283:src/syscalls.c **** }
 429              		.loc 1 283 0
 430 0000 0020     		movs	r0, #0
 431              	.LVL40:
 432 0002 7047     		bx	lr
 433              		.cfi_endproc
 434              	.LFE68:
 436              		.section	.text._fstat,"ax",%progbits
 437              		.align	1
 438              		.global	_fstat
 439              		.thumb
 440              		.thumb_func
 442              	_fstat:
 443              	.LFB69:
 284:src/syscalls.c **** 
 285:src/syscalls.c **** /**************************************************************************/
 286:src/syscalls.c **** /*! 
 287:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 288:src/syscalls.c **** */
 289:src/syscalls.c **** /**************************************************************************/
 290:src/syscalls.c **** int _fstat(int fd, struct stat *st)
 291:src/syscalls.c **** {
 444              		.loc 1 291 0
 445              		.cfi_startproc
 446              		@ args = 0, pretend = 0, frame = 0
 447              		@ frame_needed = 0, uses_anonymous_args = 0
 448              		@ link register save eliminated.
 449              	.LVL41:
 292:src/syscalls.c **** 	st->st_mode = S_IFCHR;
 450              		.loc 1 292 0
 451 0000 4FF40053 		mov	r3, #8192
 452 0004 4B60     		str	r3, [r1, #4]
 293:src/syscalls.c **** 	return 0;
 294:src/syscalls.c **** }
 453              		.loc 1 294 0
 454 0006 0020     		movs	r0, #0
 455              	.LVL42:
 456 0008 7047     		bx	lr
 457              		.cfi_endproc
 458              	.LFE69:
 460              		.section	.text._isatty,"ax",%progbits
 461              		.align	1
 462              		.global	_isatty
 463              		.thumb
 464              		.thumb_func
 466              	_isatty:
 467              	.LFB70:
 295:src/syscalls.c **** 
 296:src/syscalls.c **** /**************************************************************************/
 297:src/syscalls.c **** /*! 
 298:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 299:src/syscalls.c **** */
 300:src/syscalls.c **** /**************************************************************************/
 301:src/syscalls.c **** int _isatty(int fd)
 302:src/syscalls.c **** {
 468              		.loc 1 302 0
 469              		.cfi_startproc
 470              		@ args = 0, pretend = 0, frame = 0
 471              		@ frame_needed = 0, uses_anonymous_args = 0
 472              		@ link register save eliminated.
 473              	.LVL43:
 303:src/syscalls.c **** 	return 1;
 304:src/syscalls.c **** }
 474              		.loc 1 304 0
 475 0000 0120     		movs	r0, #1
 476              	.LVL44:
 477 0002 7047     		bx	lr
 478              		.cfi_endproc
 479              	.LFE70:
 481              		.section	.text._lseek,"ax",%progbits
 482              		.align	1
 483              		.global	_lseek
 484              		.thumb
 485              		.thumb_func
 487              	_lseek:
 488              	.LFB71:
 305:src/syscalls.c **** 
 306:src/syscalls.c **** /**************************************************************************/
 307:src/syscalls.c **** /*! 
 308:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 309:src/syscalls.c **** */
 310:src/syscalls.c **** /**************************************************************************/
 311:src/syscalls.c **** int _lseek(int fd, off_t pos, int whence)
 312:src/syscalls.c **** {
 489              		.loc 1 312 0
 490              		.cfi_startproc
 491              		@ args = 0, pretend = 0, frame = 0
 492              		@ frame_needed = 0, uses_anonymous_args = 0
 493              		@ link register save eliminated.
 494              	.LVL45:
 313:src/syscalls.c **** 	return 0;
 314:src/syscalls.c **** }
 495              		.loc 1 314 0
 496 0000 0020     		movs	r0, #0
 497              	.LVL46:
 498 0002 7047     		bx	lr
 499              		.cfi_endproc
 500              	.LFE71:
 502              		.section	.text._read,"ax",%progbits
 503              		.align	1
 504              		.global	_read
 505              		.thumb
 506              		.thumb_func
 508              	_read:
 509              	.LFB72:
 315:src/syscalls.c **** 
 316:src/syscalls.c **** /**************************************************************************/
 317:src/syscalls.c **** /*! 
 318:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 319:src/syscalls.c **** */
 320:src/syscalls.c **** /**************************************************************************/
 321:src/syscalls.c **** int _read(int fd, char *buf, size_t cnt)
 322:src/syscalls.c **** {
 510              		.loc 1 322 0
 511              		.cfi_startproc
 512              		@ args = 0, pretend = 0, frame = 0
 513              		@ frame_needed = 0, uses_anonymous_args = 0
 514              	.LVL47:
 515 0000 10B5     		push	{r4, lr}
 516              	.LCFI5:
 517              		.cfi_def_cfa_offset 8
 518              		.cfi_offset 4, -8
 519              		.cfi_offset 14, -4
 520 0002 0C46     		mov	r4, r1
 323:src/syscalls.c **** 	*buf = getch();
 521              		.loc 1 323 0
 522 0004 FFF7FEFF 		bl	getch
 523              	.LVL48:
 524 0008 2070     		strb	r0, [r4, #0]
 324:src/syscalls.c **** 
 325:src/syscalls.c **** 	return 1;
 326:src/syscalls.c **** }
 525              		.loc 1 326 0
 526 000a 0120     		movs	r0, #1
 527 000c 10BD     		pop	{r4, pc}
 528              		.cfi_endproc
 529              	.LFE72:
 531              		.section	.text._write,"ax",%progbits
 532              		.align	1
 533              		.global	_write
 534              		.thumb
 535              		.thumb_func
 537              	_write:
 538              	.LFB73:
 327:src/syscalls.c **** 
 328:src/syscalls.c **** /**************************************************************************/
 329:src/syscalls.c **** /*! 
 330:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 331:src/syscalls.c **** */
 332:src/syscalls.c **** /**************************************************************************/
 333:src/syscalls.c **** int _write(int fd, const char *buf, size_t cnt)
 334:src/syscalls.c **** {
 539              		.loc 1 334 0
 540              		.cfi_startproc
 541              		@ args = 0, pretend = 0, frame = 0
 542              		@ frame_needed = 0, uses_anonymous_args = 0
 543              	.LVL49:
 544 0000 70B5     		push	{r4, r5, r6, lr}
 545              	.LCFI6:
 546              		.cfi_def_cfa_offset 16
 547              		.cfi_offset 4, -16
 548              		.cfi_offset 5, -12
 549              		.cfi_offset 6, -8
 550              		.cfi_offset 14, -4
 551 0002 1546     		mov	r5, r2
 552              	.LVL50:
 553 0004 0C46     		mov	r4, r1
 333:src/syscalls.c **** {
 554              		.loc 1 333 0
 555 0006 8E18     		adds	r6, r1, r2
 556              	.LVL51:
 557              	.L42:
 335:src/syscalls.c **** 	int i;
 336:src/syscalls.c **** 
 337:src/syscalls.c **** 	for (i = 0; i < cnt; i++)
 558              		.loc 1 337 0 discriminator 1
 559 0008 B442     		cmp	r4, r6
 560 000a 04D0     		beq	.L44
 561              	.L43:
 338:src/syscalls.c **** 		putch(buf[i]);
 562              		.loc 1 338 0 discriminator 2
 563 000c 14F8010B 		ldrb	r0, [r4], #1	@ zero_extendqisi2
 564 0010 FFF7FEFF 		bl	putch
 565              	.LVL52:
 566 0014 F8E7     		b	.L42
 567              	.L44:
 339:src/syscalls.c **** 
 340:src/syscalls.c **** 	return cnt;
 341:src/syscalls.c **** }
 568              		.loc 1 341 0
 569 0016 2846     		mov	r0, r5
 570 0018 70BD     		pop	{r4, r5, r6, pc}
 571              		.cfi_endproc
 572              	.LFE73:
 574              		.section	.text._times,"ax",%progbits
 575              		.align	1
 576              		.global	_times
 577              		.thumb
 578              		.thumb_func
 580              	_times:
 581              	.LFB74:
 342:src/syscalls.c **** 
 343:src/syscalls.c **** /**************************************************************************/
 344:src/syscalls.c **** /*! 
 345:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 346:src/syscalls.c **** */
 347:src/syscalls.c **** /**************************************************************************/
 348:src/syscalls.c **** int _times(struct tms *buf) {
 582              		.loc 1 348 0
 583              		.cfi_startproc
 584              		@ args = 0, pretend = 0, frame = 0
 585              		@ frame_needed = 0, uses_anonymous_args = 0
 586              		@ link register save eliminated.
 587              	.LVL53:
 349:src/syscalls.c **** 	return -1;
 350:src/syscalls.c **** }
 588              		.loc 1 350 0
 589 0000 4FF0FF30 		mov	r0, #-1
 590              	.LVL54:
 591 0004 7047     		bx	lr
 592              		.cfi_endproc
 593              	.LFE74:
 595              		.section	.text._link,"ax",%progbits
 596              		.align	1
 597              		.global	_link
 598              		.thumb
 599              		.thumb_func
 601              	_link:
 602              	.LFB75:
 351:src/syscalls.c **** 
 352:src/syscalls.c **** /**************************************************************************/
 353:src/syscalls.c **** /*! 
 354:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 355:src/syscalls.c **** */
 356:src/syscalls.c **** /**************************************************************************/
 357:src/syscalls.c **** int _link(char *old, char *new) {
 603              		.loc 1 357 0
 604              		.cfi_startproc
 605              		@ args = 0, pretend = 0, frame = 0
 606              		@ frame_needed = 0, uses_anonymous_args = 0
 607              	.LVL55:
 608 0000 08B5     		push	{r3, lr}
 609              	.LCFI7:
 610              		.cfi_def_cfa_offset 8
 611              		.cfi_offset 3, -8
 612              		.cfi_offset 14, -4
 358:src/syscalls.c **** 	errno = EMLINK;
 613              		.loc 1 358 0
 614 0002 FFF7FEFF 		bl	__errno
 615              	.LVL56:
 616 0006 1F23     		movs	r3, #31
 617 0008 0360     		str	r3, [r0, #0]
 359:src/syscalls.c **** 	return -1;
 360:src/syscalls.c **** }
 618              		.loc 1 360 0
 619 000a 4FF0FF30 		mov	r0, #-1
 620 000e 08BD     		pop	{r3, pc}
 621              		.cfi_endproc
 622              	.LFE75:
 624              		.section	.text._unlink,"ax",%progbits
 625              		.align	1
 626              		.global	_unlink
 627              		.thumb
 628              		.thumb_func
 630              	_unlink:
 631              	.LFB76:
 361:src/syscalls.c **** 
 362:src/syscalls.c **** /**************************************************************************/
 363:src/syscalls.c **** /*! 
 364:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 365:src/syscalls.c **** */
 366:src/syscalls.c **** /**************************************************************************/
 367:src/syscalls.c **** int _unlink(char *name) {
 632              		.loc 1 367 0
 633              		.cfi_startproc
 634              		@ args = 0, pretend = 0, frame = 0
 635              		@ frame_needed = 0, uses_anonymous_args = 0
 636              	.LVL57:
 637 0000 08B5     		push	{r3, lr}
 638              	.LCFI8:
 639              		.cfi_def_cfa_offset 8
 640              		.cfi_offset 3, -8
 641              		.cfi_offset 14, -4
 368:src/syscalls.c **** 	errno = ENOENT;
 642              		.loc 1 368 0
 643 0002 FFF7FEFF 		bl	__errno
 644              	.LVL58:
 645 0006 0223     		movs	r3, #2
 646 0008 0360     		str	r3, [r0, #0]
 369:src/syscalls.c **** 	return -1;
 370:src/syscalls.c **** }
 647              		.loc 1 370 0
 648 000a 4FF0FF30 		mov	r0, #-1
 649 000e 08BD     		pop	{r3, pc}
 650              		.cfi_endproc
 651              	.LFE76:
 653              		.section	.text._wait,"ax",%progbits
 654              		.align	1
 655              		.global	_wait
 656              		.thumb
 657              		.thumb_func
 659              	_wait:
 660              	.LFB77:
 371:src/syscalls.c **** 
 372:src/syscalls.c **** /**************************************************************************/
 373:src/syscalls.c **** /*! 
 374:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 375:src/syscalls.c **** */
 376:src/syscalls.c **** /**************************************************************************/
 377:src/syscalls.c **** int _wait(int *status) {
 661              		.loc 1 377 0
 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 0
 664              		@ frame_needed = 0, uses_anonymous_args = 0
 665              	.LVL59:
 666 0000 08B5     		push	{r3, lr}
 667              	.LCFI9:
 668              		.cfi_def_cfa_offset 8
 669              		.cfi_offset 3, -8
 670              		.cfi_offset 14, -4
 378:src/syscalls.c **** 	errno = ECHILD;
 671              		.loc 1 378 0
 672 0002 FFF7FEFF 		bl	__errno
 673              	.LVL60:
 674 0006 0A23     		movs	r3, #10
 675 0008 0360     		str	r3, [r0, #0]
 379:src/syscalls.c **** 	return -1;
 380:src/syscalls.c **** }
 676              		.loc 1 380 0
 677 000a 4FF0FF30 		mov	r0, #-1
 678 000e 08BD     		pop	{r3, pc}
 679              		.cfi_endproc
 680              	.LFE77:
 682              		.section	.text._execve,"ax",%progbits
 683              		.align	1
 684              		.global	_execve
 685              		.thumb
 686              		.thumb_func
 688              	_execve:
 689              	.LFB78:
 381:src/syscalls.c **** 
 382:src/syscalls.c **** /**************************************************************************/
 383:src/syscalls.c **** /*! 
 384:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 385:src/syscalls.c **** */
 386:src/syscalls.c **** /**************************************************************************/
 387:src/syscalls.c **** int _execve(char *name, char **argv, char **env) {
 690              		.loc 1 387 0
 691              		.cfi_startproc
 692              		@ args = 0, pretend = 0, frame = 0
 693              		@ frame_needed = 0, uses_anonymous_args = 0
 694              	.LVL61:
 695 0000 08B5     		push	{r3, lr}
 696              	.LCFI10:
 697              		.cfi_def_cfa_offset 8
 698              		.cfi_offset 3, -8
 699              		.cfi_offset 14, -4
 388:src/syscalls.c **** 	errno = ENOMEM;
 700              		.loc 1 388 0
 701 0002 FFF7FEFF 		bl	__errno
 702              	.LVL62:
 703 0006 0C23     		movs	r3, #12
 704 0008 0360     		str	r3, [r0, #0]
 389:src/syscalls.c **** 	return -1;
 390:src/syscalls.c **** }
 705              		.loc 1 390 0
 706 000a 4FF0FF30 		mov	r0, #-1
 707 000e 08BD     		pop	{r3, pc}
 708              		.cfi_endproc
 709              	.LFE78:
 711              		.section	.text._fork,"ax",%progbits
 712              		.align	1
 713              		.global	_fork
 714              		.thumb
 715              		.thumb_func
 717              	_fork:
 718              	.LFB79:
 391:src/syscalls.c **** 
 392:src/syscalls.c **** /**************************************************************************/
 393:src/syscalls.c **** /*! 
 394:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 395:src/syscalls.c **** */
 396:src/syscalls.c **** /**************************************************************************/
 397:src/syscalls.c **** int _fork(void) {
 719              		.loc 1 397 0
 720              		.cfi_startproc
 721              		@ args = 0, pretend = 0, frame = 0
 722              		@ frame_needed = 0, uses_anonymous_args = 0
 723 0000 08B5     		push	{r3, lr}
 724              	.LCFI11:
 725              		.cfi_def_cfa_offset 8
 726              		.cfi_offset 3, -8
 727              		.cfi_offset 14, -4
 398:src/syscalls.c **** 	errno = EAGAIN;
 728              		.loc 1 398 0
 729 0002 FFF7FEFF 		bl	__errno
 730              	.LVL63:
 731 0006 0B23     		movs	r3, #11
 732 0008 0360     		str	r3, [r0, #0]
 399:src/syscalls.c **** 	return -1;
 400:src/syscalls.c **** }
 733              		.loc 1 400 0
 734 000a 4FF0FF30 		mov	r0, #-1
 735 000e 08BD     		pop	{r3, pc}
 736              		.cfi_endproc
 737              	.LFE79:
 739              		.section	.text._exit,"ax",%progbits
 740              		.align	1
 741              		.global	_exit
 742              		.thumb
 743              		.thumb_func
 745              	_exit:
 746              	.LFB80:
 401:src/syscalls.c **** #endif
 402:src/syscalls.c **** 
 403:src/syscalls.c **** /**************************************************************************/
 404:src/syscalls.c **** /*! 
 405:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 406:src/syscalls.c **** */
 407:src/syscalls.c **** /**************************************************************************/
 408:src/syscalls.c **** void _exit(int n) {
 747              		.loc 1 408 0
 748              		.cfi_startproc
 749              		@ Volatile: function does not return.
 750              		@ args = 0, pretend = 0, frame = 0
 751              		@ frame_needed = 0, uses_anonymous_args = 0
 752              		@ link register save eliminated.
 753              	.L52:
 754              	.LVL64:
 755              	.L53:
 756 0000 FEE7     		b	.L53
 757              		.cfi_endproc
 758              	.LFE80:
 760              		.section	.text._kill,"ax",%progbits
 761              		.align	1
 762              		.global	_kill
 763              		.thumb
 764              		.thumb_func
 766              	_kill:
 767              	.LFB81:
 409:src/syscalls.c **** label:  goto label; /* endless loop */
 410:src/syscalls.c **** }
 411:src/syscalls.c **** 
 412:src/syscalls.c **** /**************************************************************************/
 413:src/syscalls.c **** /*! 
 414:src/syscalls.c ****     @brief  Dummy OS Function for Newlib.
 415:src/syscalls.c **** */
 416:src/syscalls.c **** /**************************************************************************/
 417:src/syscalls.c **** int _kill(int pid, int sig) {
 768              		.loc 1 417 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 0
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL65:
 773              		.loc 1 417 0
 774 0000 08B5     		push	{r3, lr}
 775              	.LCFI12:
 776              		.cfi_def_cfa_offset 8
 777              		.cfi_offset 3, -8
 778              		.cfi_offset 14, -4
 418:src/syscalls.c **** 	errno = EINVAL;
 779              		.loc 1 418 0
 780 0002 FFF7FEFF 		bl	__errno
 781              	.LVL66:
 782 0006 1623     		movs	r3, #22
 783 0008 0360     		str	r3, [r0, #0]
 419:src/syscalls.c **** 	return -1;
 420:src/syscalls.c **** }
 784              		.loc 1 420 0
 785 000a 4FF0FF30 		mov	r0, #-1
 786 000e 08BD     		pop	{r3, pc}
 787              		.cfi_endproc
 788              	.LFE81:
 790              		.section	.bss.heap_ptr,"aw",%nobits
 791              		.align	2
 792              		.set	.LANCHOR0,. + 0
 795              	heap_ptr:
 796 0000 00000000 		.space	4
 797              		.text
 798              	.Letext0:
 799              		.file 3 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/include/stddef.h"
 800              		.file 4 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-ea
 801              		.file 5 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-ea
 802              		.file 6 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-ea
 803              		.file 7 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/include/stdint-gcc.h"
 804              		.file 8 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-ea
 805              		.file 9 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-ea
 806              		.file 10 "./lib/CMSIS/Include/core_cm3.h"
 807              		.file 11 "./inc/systick.h"
 808              		.file 12 "./inc/uart_support_gps.h"
 809              		.file 13 "c:\\devz\\arm\\bleeding-edge\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-e
DEFINED SYMBOLS
                            *ABS*:0000000000000000 syscalls.c
  R:\TEMP\cc5DYr3o.s:19     .text._read_r:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:24     .text._read_r:0000000000000000 _read_r
  R:\TEMP\cc5DYr3o.s:89     .text._write_r:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:94     .text._write_r:0000000000000000 _write_r
  R:\TEMP\cc5DYr3o.s:142    .text._fini:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:147    .text._fini:0000000000000000 _fini
  R:\TEMP\cc5DYr3o.s:159    .text._close_r:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:164    .text._close_r:0000000000000000 _close_r
  R:\TEMP\cc5DYr3o.s:181    .text._lseek_r:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:186    .text._lseek_r:0000000000000000 _lseek_r
  R:\TEMP\cc5DYr3o.s:202    .text._fstat_r:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:207    .text._fstat_r:0000000000000000 _fstat_r
  R:\TEMP\cc5DYr3o.s:226    .text._sbrk_r:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:231    .text._sbrk_r:0000000000000000 _sbrk_r
  R:\TEMP\cc5DYr3o.s:279    .text._sbrk_r:000000000000002c $d
  R:\TEMP\cc5DYr3o.s:285    .text.isatty:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:290    .text.isatty:0000000000000000 isatty
  R:\TEMP\cc5DYr3o.s:306    .text._getpid:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:311    .text._getpid:0000000000000000 _getpid
  R:\TEMP\cc5DYr3o.s:327    .text._sbrk:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:332    .text._sbrk:0000000000000000 _sbrk
  R:\TEMP\cc5DYr3o.s:382    .text._sbrk:000000000000002c $d
  R:\TEMP\cc5DYr3o.s:388    .text._open:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:393    .text._open:0000000000000000 _open
  R:\TEMP\cc5DYr3o.s:416    .text._close:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:421    .text._close:0000000000000000 _close
  R:\TEMP\cc5DYr3o.s:437    .text._fstat:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:442    .text._fstat:0000000000000000 _fstat
  R:\TEMP\cc5DYr3o.s:461    .text._isatty:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:466    .text._isatty:0000000000000000 _isatty
  R:\TEMP\cc5DYr3o.s:482    .text._lseek:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:487    .text._lseek:0000000000000000 _lseek
  R:\TEMP\cc5DYr3o.s:503    .text._read:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:508    .text._read:0000000000000000 _read
  R:\TEMP\cc5DYr3o.s:532    .text._write:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:537    .text._write:0000000000000000 _write
  R:\TEMP\cc5DYr3o.s:575    .text._times:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:580    .text._times:0000000000000000 _times
  R:\TEMP\cc5DYr3o.s:596    .text._link:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:601    .text._link:0000000000000000 _link
  R:\TEMP\cc5DYr3o.s:625    .text._unlink:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:630    .text._unlink:0000000000000000 _unlink
  R:\TEMP\cc5DYr3o.s:654    .text._wait:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:659    .text._wait:0000000000000000 _wait
  R:\TEMP\cc5DYr3o.s:683    .text._execve:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:688    .text._execve:0000000000000000 _execve
  R:\TEMP\cc5DYr3o.s:712    .text._fork:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:717    .text._fork:0000000000000000 _fork
  R:\TEMP\cc5DYr3o.s:740    .text._exit:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:745    .text._exit:0000000000000000 _exit
  R:\TEMP\cc5DYr3o.s:761    .text._kill:0000000000000000 $t
  R:\TEMP\cc5DYr3o.s:766    .text._kill:0000000000000000 _kill
  R:\TEMP\cc5DYr3o.s:791    .bss.heap_ptr:0000000000000000 $d
  R:\TEMP\cc5DYr3o.s:795    .bss.heap_ptr:0000000000000000 heap_ptr
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
getch
putch
__errno
end
