   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"gps_support.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.get_line_GPS,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	get_line_GPS:
  24              	.LFB61:
  25              		.file 1 "src/gps_support.c"
   1:src/gps_support.c **** /********************************************************************************/
   2:src/gps_support.c **** /*!
   3:src/gps_support.c **** 	@file			gps_support.c
   4:src/gps_support.c **** 	@author         Nemui Trinomius (http://nemuisan.blog.bai.ne.jp)
   5:src/gps_support.c ****     @version        7.00
   6:src/gps_support.c ****     @date           2013.01.07
   7:src/gps_support.c **** 	@brief          Interface of FatFs For STM32 uC.				@n
   8:src/gps_support.c **** 					Based on Chan's GPS-Logger Program Thanks!
   9:src/gps_support.c **** 
  10:src/gps_support.c ****     @section HISTORY
  11:src/gps_support.c **** 		2011.03.10	V1.00	Start Here.
  12:src/gps_support.c **** 		2011.09.07	V2.00	Add RTC Synchronization from GPRMC.
  13:src/gps_support.c **** 		                    Fixed More Stability.
  14:src/gps_support.c **** 		2011.12.26	V3.00	Add PA6C Support.
  15:src/gps_support.c **** 		2012.08.31  V4.00   Imploved FatFs Support Function's Portability.
  16:src/gps_support.c **** 		2012.09.08	V5.00	Imploved PA6C Support.
  17:src/gps_support.c **** 		                     (Anti Interference & force 9600bps for 38400bps Firmware).
  18:src/gps_support.c **** 		2012.12.24  V6.00   Add Gms-g6a Support.
  19:src/gps_support.c **** 							Imploved Error Handlings.
  20:src/gps_support.c **** 		2013.01.07  V6.01   Fixed Minor bug.
  21:src/gps_support.c **** 
  22:src/gps_support.c ****     @section LICENSE
  23:src/gps_support.c **** 		BSD License. See Copyright.txt
  24:src/gps_support.c **** */
  25:src/gps_support.c **** /********************************************************************************/
  26:src/gps_support.c **** 
  27:src/gps_support.c **** /* Includes ------------------------------------------------------------------*/
  28:src/gps_support.c **** #include "gps_support.h"
  29:src/gps_support.c **** /* check header file version for fool proof */
  30:src/gps_support.c **** #if __GPS_SUPPORT_H!= 0x0700
  31:src/gps_support.c **** #error "header file version is not correspond!"
  32:src/gps_support.c **** #endif
  33:src/gps_support.c **** 
  34:src/gps_support.c **** /* Defines -------------------------------------------------------------------*/
  35:src/gps_support.c **** /* GT-723F,UP-501,PA6C default baud is 9600,8,n,1*/
  36:src/gps_support.c **** #define GPS_UART_PORT	2
  37:src/gps_support.c **** #define GPS_UART_BAUD	9600
  38:src/gps_support.c **** /* GPS Sentences */
  39:src/gps_support.c **** #define GPRMC_COL_VALID	2
  40:src/gps_support.c **** #define GPRMC_COL_DATE  9 /*  obsoleted */
  41:src/gps_support.c **** #define GPRMC_COL_YMD  	9
  42:src/gps_support.c **** #define GPRMC_COL_HMS  	1
  43:src/gps_support.c **** #define GPGGA_POS_TYPE	6
  44:src/gps_support.c **** #define GPGSV_NUM_VIEW	3
  45:src/gps_support.c **** 
  46:src/gps_support.c **** /* Synchronize the file in interval of 90Sec */
  47:src/gps_support.c **** #define SYNC_INTERVAL	90
  48:src/gps_support.c **** 
  49:src/gps_support.c **** /* To Enable GPGSV Logging, Uncomment this */
  50:src/gps_support.c **** /*#define ENABLE_SATELLITE_ID_LOGGING*/
  51:src/gps_support.c **** 
  52:src/gps_support.c **** /* Avoid f_close() Foolproof */
  53:src/gps_support.c **** #define STBY_STATE 		0
  54:src/gps_support.c **** #define LOGGING_STATE 	1
  55:src/gps_support.c **** 
  56:src/gps_support.c **** /* Acklowledge Limit in Second */
  57:src/gps_support.c **** #define ACK_LIMIT		5
  58:src/gps_support.c **** 
  59:src/gps_support.c **** /* Variables -----------------------------------------------------------------*/
  60:src/gps_support.c **** FF_RTC ff_rtc;						/* See ff_rtc_if.h */
  61:src/gps_support.c **** FATFS Fatfs[_VOLUMES];				/* File system object for each logical drive */
  62:src/gps_support.c **** FIL File1;							/* File objects */
  63:src/gps_support.c **** DIR Dir;							/* Directory object */
  64:src/gps_support.c **** uint8_t Buff[512]; 					/* Working buffer */
  65:src/gps_support.c **** volatile UINT Timer;				/* Performance timer (1kHz increment) */
  66:src/gps_support.c **** volatile UINT l_stat=STBY_STATE;	/* Avoid f_close() Foolproof */
  67:src/gps_support.c **** volatile UINT ack_limit;			/* Acklowledge Limit */
  68:src/gps_support.c **** 
  69:src/gps_support.c **** /* Constants -----------------------------------------------------------------*/
  70:src/gps_support.c **** 
  71:src/gps_support.c **** /* Function prototypes -------------------------------------------------------*/
  72:src/gps_support.c **** 
  73:src/gps_support.c **** /* Functions -----------------------------------------------------------------*/
  74:src/gps_support.c **** 
  75:src/gps_support.c **** /**************************************************************************/
  76:src/gps_support.c **** /*! 
  77:src/gps_support.c ****     MUST called by a timer interrupt-handler every 1ms
  78:src/gps_support.c **** */
  79:src/gps_support.c **** /**************************************************************************/
  80:src/gps_support.c **** inline void ff_support_timerproc(void)
  81:src/gps_support.c **** {
  82:src/gps_support.c **** 	Timer++;
  83:src/gps_support.c **** }
  84:src/gps_support.c **** 
  85:src/gps_support.c **** /**************************************************************************/
  86:src/gps_support.c **** /*! 
  87:src/gps_support.c **** 	RealTimeClock function
  88:src/gps_support.c **** */
  89:src/gps_support.c **** /**************************************************************************/
  90:src/gps_support.c **** uint32_t get_fattime (void)
  91:src/gps_support.c **** {
  92:src/gps_support.c **** 	/* Get local time */
  93:src/gps_support.c **** 	rtc_gettime(&ff_rtc);
  94:src/gps_support.c **** 
  95:src/gps_support.c **** 	/* Pack date and time into a DWORD variable */
  96:src/gps_support.c **** 	return	  ((DWORD)(ff_rtc.year - 1980) << 25)
  97:src/gps_support.c **** 			| ((DWORD)ff_rtc.month << 21)
  98:src/gps_support.c **** 			| ((DWORD)ff_rtc.mday << 16)
  99:src/gps_support.c **** 			| ((DWORD)ff_rtc.hour << 11)
 100:src/gps_support.c **** 			| ((DWORD)ff_rtc.min << 5)
 101:src/gps_support.c **** 			| ((DWORD)ff_rtc.sec >> 1);
 102:src/gps_support.c **** }
 103:src/gps_support.c **** 
 104:src/gps_support.c **** /**************************************************************************/
 105:src/gps_support.c **** /*! 
 106:src/gps_support.c **** 	Acklowledge Limit.
 107:src/gps_support.c **** */
 108:src/gps_support.c **** /**************************************************************************/
 109:src/gps_support.c **** void ChkAckLimit(void)
 110:src/gps_support.c **** {
 111:src/gps_support.c **** 
 112:src/gps_support.c **** 	if(ack_limit++ > ACK_LIMIT*1000){
 113:src/gps_support.c **** 		/* Wakeup(For MT333x) */
 114:src/gps_support.c **** 		cputs("$PMTK000*32\r\n");
 115:src/gps_support.c **** 		_delay_us(10000);
 116:src/gps_support.c **** 		ack_limit =0;
 117:src/gps_support.c **** 	}
 118:src/gps_support.c **** 
 119:src/gps_support.c **** }
 120:src/gps_support.c **** 
 121:src/gps_support.c **** 
 122:src/gps_support.c **** /**************************************************************************/
 123:src/gps_support.c **** /*! 
 124:src/gps_support.c **** 	File Close Function(gloval).
 125:src/gps_support.c **** */
 126:src/gps_support.c **** /**************************************************************************/
 127:src/gps_support.c **** void ShutFileClose(void)
 128:src/gps_support.c **** {
 129:src/gps_support.c **** 	if(l_stat==STBY_STATE) return;
 130:src/gps_support.c **** 	
 131:src/gps_support.c **** shutstat:
 132:src/gps_support.c **** 	if(f_close(&File1)) {goto shutstat;}
 133:src/gps_support.c **** }
 134:src/gps_support.c **** 
 135:src/gps_support.c **** 
 136:src/gps_support.c **** /**************************************************************************/
 137:src/gps_support.c **** /*! 
 138:src/gps_support.c **** 	0: Power fail occured, >0: Number of bytes received.
 139:src/gps_support.c **** */
 140:src/gps_support.c **** /**************************************************************************/
 141:src/gps_support.c **** static uint8_t get_line_GPS(void)	
 142:src/gps_support.c **** {
  26              		.loc 1 142 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 10B5     		push	{r4, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 4, -8
  34              		.cfi_offset 14, -4
  35              	.L16:
  36              	.LVL0:
 143:src/gps_support.c **** 	uint16_t c, i = 0;
  37              		.loc 1 143 0
  38 0002 0024     		movs	r4, #0
  39              	.LVL1:
  40              	.L15:
 144:src/gps_support.c **** 
 145:src/gps_support.c **** 	for (;;) {
 146:src/gps_support.c **** 		/* Get a char from the incoming stream */
 147:src/gps_support.c **** 		c = xfunc_in();
  41              		.loc 1 147 0
  42 0004 094B     		ldr	r3, .L18
  43 0006 1868     		ldr	r0, [r3, #0]
  44 0008 8047     		blx	r0
  45              	.LVL2:
 148:src/gps_support.c **** 		if (!c || (i == 0 && c != '$')) continue;
  46              		.loc 1 148 0
  47 000a 0028     		cmp	r0, #0
  48 000c FAD0     		beq	.L15
  49              		.loc 1 148 0 is_stmt 0 discriminator 2
  50 000e 0CB9     		cbnz	r4, .L4
  51              		.loc 1 148 0 discriminator 1
  52 0010 2428     		cmp	r0, #36
  53 0012 F6D1     		bne	.L16
  54              	.L4:
 149:src/gps_support.c **** 		Buff[i++] = c;
  55              		.loc 1 149 0 is_stmt 1
  56 0014 0649     		ldr	r1, .L18+4
  57 0016 0855     		strb	r0, [r1, r4]
  58 0018 0134     		adds	r4, r4, #1
  59              	.LVL3:
  60 001a A4B2     		uxth	r4, r4
  61              	.LVL4:
 150:src/gps_support.c **** 		if (c == '\n') break;
  62              		.loc 1 150 0
  63 001c 0A28     		cmp	r0, #10
  64 001e 03D0     		beq	.L5
 151:src/gps_support.c **** 		if (i >= sizeof(Buff)) i = 0;
  65              		.loc 1 151 0
  66 0020 B4F5007F 		cmp	r4, #512
  67 0024 EDD2     		bcs	.L16
  68 0026 EDE7     		b	.L15
  69              	.L5:
 152:src/gps_support.c **** 	}
 153:src/gps_support.c **** 	return i;
 154:src/gps_support.c **** }
  70              		.loc 1 154 0
  71 0028 E0B2     		uxtb	r0, r4
  72              	.LVL5:
  73 002a 10BD     		pop	{r4, pc}
  74              	.L19:
  75              		.align	2
  76              	.L18:
  77 002c 00000000 		.word	xfunc_in
  78 0030 00000000 		.word	.LANCHOR0
  79              		.cfi_endproc
  80              	.LFE61:
  82              		.section	.text.gp_val,"ax",%progbits
  83              		.align	1
  84              		.thumb
  85              		.thumb_func
  87              	gp_val:
  88              	.LFB63:
 155:src/gps_support.c **** 
 156:src/gps_support.c **** /**************************************************************************/
 157:src/gps_support.c **** /*! 
 158:src/gps_support.c **** 	Get a column item.
 159:src/gps_support.c **** */
 160:src/gps_support.c **** /**************************************************************************/
 161:src/gps_support.c **** static uint8_t* gp_col(	/* Returns pointer to the item (returns a NULL when not found) */
 162:src/gps_support.c **** 	const uint8_t* buf,	/* Pointer to the sentence */
 163:src/gps_support.c **** 	uint8_t col			/* Column number (0 is the 1st item) */
 164:src/gps_support.c **** ) 
 165:src/gps_support.c **** {
 166:src/gps_support.c **** 	uint8_t c;
 167:src/gps_support.c **** 
 168:src/gps_support.c **** 
 169:src/gps_support.c **** 	while (col) {
 170:src/gps_support.c **** 		do {
 171:src/gps_support.c **** 			c = *buf++;
 172:src/gps_support.c **** 			if (c <= ' ') return NULL;
 173:src/gps_support.c **** 		} while (c != ',');
 174:src/gps_support.c **** 		col--;
 175:src/gps_support.c **** 	}
 176:src/gps_support.c **** 	return (uint8_t*)buf;
 177:src/gps_support.c **** }
 178:src/gps_support.c **** 
 179:src/gps_support.c **** /**************************************************************************/
 180:src/gps_support.c **** /*! 
 181:src/gps_support.c **** 	Get a Value from sentence.
 182:src/gps_support.c **** */
 183:src/gps_support.c **** /**************************************************************************/
 184:src/gps_support.c **** static uint8_t gp_val(
 185:src/gps_support.c **** 	const uint8_t* db
 186:src/gps_support.c **** )
 187:src/gps_support.c **** {
  89              		.loc 1 187 0
  90              		.cfi_startproc
  91              		@ args = 0, pretend = 0, frame = 0
  92              		@ frame_needed = 0, uses_anonymous_args = 0
  93              		@ link register save eliminated.
  94              	.LVL6:
 188:src/gps_support.c **** 	uint8_t n, m;
 189:src/gps_support.c **** 
 190:src/gps_support.c **** 
 191:src/gps_support.c **** 	n = *db++ - '0';
  95              		.loc 1 191 0
  96 0000 0278     		ldrb	r2, [r0, #0]	@ zero_extendqisi2
  97 0002 303A     		subs	r2, r2, #48
  98 0004 D1B2     		uxtb	r1, r2
  99              	.LVL7:
 192:src/gps_support.c **** 	if (n >= 10) return 0;
 100              		.loc 1 192 0
 101 0006 0929     		cmp	r1, #9
 102 0008 09D8     		bhi	.L23
 193:src/gps_support.c **** 	m = *db - '0';
 103              		.loc 1 193 0
 104 000a 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 105 000c 303B     		subs	r3, r3, #48
 106 000e DAB2     		uxtb	r2, r3
 107              	.LVL8:
 194:src/gps_support.c **** 	if (m >= 10) return 0;
 108              		.loc 1 194 0
 109 0010 092A     		cmp	r2, #9
 110 0012 04D8     		bhi	.L23
 195:src/gps_support.c **** 
 196:src/gps_support.c **** 	return n * 10 + m;
 111              		.loc 1 196 0
 112 0014 0A20     		movs	r0, #10
 113              	.LVL9:
 114 0016 00FB0121 		mla	r1, r0, r1, r2
 115              	.LVL10:
 116 001a C8B2     		uxtb	r0, r1
 117 001c 7047     		bx	lr
 118              	.LVL11:
 119              	.L23:
 192:src/gps_support.c **** 	if (n >= 10) return 0;
 120              		.loc 1 192 0
 121 001e 0020     		movs	r0, #0
 122              	.LVL12:
 197:src/gps_support.c **** }
 123              		.loc 1 197 0
 124 0020 7047     		bx	lr
 125              		.cfi_endproc
 126              	.LFE63:
 128              		.section	.text.gp_comp.constprop.0,"ax",%progbits
 129              		.align	1
 130              		.thumb
 131              		.thumb_func
 133              	gp_comp.constprop.0:
 134              	.LFB67:
 198:src/gps_support.c **** 
 199:src/gps_support.c **** /**************************************************************************/
 200:src/gps_support.c **** /*! 
 201:src/gps_support.c **** 	Compare sentence header string.
 202:src/gps_support.c **** 	Correspond     :false
 203:src/gps_support.c **** 	Not Correspond :true
 204:src/gps_support.c **** */
 205:src/gps_support.c **** /**************************************************************************/
 206:src/gps_support.c **** static uint8_t gp_comp(uint8_t *str1, const char *str2)
 135              		.loc 1 206 0
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
 139              		@ link register save eliminated.
 140              	.LVL13:
 141              	.LVL14:
 142              		.loc 1 206 0
 143 0000 0023     		movs	r3, #0
 144              	.LVL15:
 145              	.L26:
 207:src/gps_support.c **** {
 208:src/gps_support.c **** 	uint8_t c;
 209:src/gps_support.c **** 
 210:src/gps_support.c **** 	do {
 211:src/gps_support.c **** 		c = *str2++;
 146              		.loc 1 211 0
 147 0002 C25C     		ldrb	r2, [r0, r3]	@ zero_extendqisi2
 148              	.LVL16:
 212:src/gps_support.c **** 	} while (c && c == *str1++);
 149              		.loc 1 212 0
 150 0004 22B1     		cbz	r2, .L25
 151 0006 0349     		ldr	r1, .L31
 152 0008 595C     		ldrb	r1, [r3, r1]	@ zero_extendqisi2
 153 000a 0133     		adds	r3, r3, #1
 154              	.LVL17:
 155 000c 8A42     		cmp	r2, r1
 156 000e F8D0     		beq	.L26
 157              	.LVL18:
 158              	.L25:
 213:src/gps_support.c **** 	return c;
 214:src/gps_support.c **** }
 159              		.loc 1 214 0
 160 0010 1046     		mov	r0, r2
 161 0012 7047     		bx	lr
 162              	.L32:
 163              		.align	2
 164              	.L31:
 165 0014 00000000 		.word	.LANCHOR0
 166              		.cfi_endproc
 167              	.LFE67:
 169              		.section	.text.gp_col.constprop.1,"ax",%progbits
 170              		.align	1
 171              		.thumb
 172              		.thumb_func
 174              	gp_col.constprop.1:
 175              	.LFB66:
 161:src/gps_support.c **** static uint8_t* gp_col(	/* Returns pointer to the item (returns a NULL when not found) */
 176              		.loc 1 161 0
 177              		.cfi_startproc
 178              		@ args = 0, pretend = 0, frame = 0
 179              		@ frame_needed = 0, uses_anonymous_args = 0
 180              		@ link register save eliminated.
 181              	.LVL19:
 182              	.LVL20:
 215:src/gps_support.c **** 
 216:src/gps_support.c **** /**************************************************************************/
 217:src/gps_support.c **** /*! 
 218:src/gps_support.c ****     Main GPS Task Routine.
 219:src/gps_support.c **** */
 220:src/gps_support.c **** /**************************************************************************/
 221:src/gps_support.c **** void gps_task(void)
 222:src/gps_support.c **** {
 223:src/gps_support.c **** 	uint8_t  *p = NULL;
 224:src/gps_support.c **** 	uint16_t b;
 225:src/gps_support.c **** 	UINT s;
 226:src/gps_support.c **** 	volatile uint16_t c_sync=0;
 227:src/gps_support.c **** 	time_t utc;
 228:src/gps_support.c **** 
 229:src/gps_support.c **** 	/* If MTK chip baud is 38400bps,then... */
 230:src/gps_support.c **** 	conio_init(GPS_UART_PORT,38400);
 231:src/gps_support.c **** 	/* Set to 9600 bps forcely */
 232:src/gps_support.c **** 	cputs("$PMTK251,9600*17\r\n");
 233:src/gps_support.c **** 	/* Wait Send String(instead of USART_TXBuffer_FreeSpace()*/
 234:src/gps_support.c **** 	_delay_ms(200);
 235:src/gps_support.c **** 
 236:src/gps_support.c **** 	/* Enable Anti Interference Control(for MT333x Only!) */
 237:src/gps_support.c **** 	cputs("$PMTK286,1*23\r\n");
 238:src/gps_support.c **** 	/* Wait Send String(instead of USART_TXBuffer_FreeSpace()*/
 239:src/gps_support.c **** 	_delay_ms(200);
 240:src/gps_support.c **** 
 241:src/gps_support.c **** 	/* Set UART and redirect to stdio */
 242:src/gps_support.c **** 	conio_init(GPS_UART_PORT,GPS_UART_BAUD);
 243:src/gps_support.c **** 	xfunc_out = putch;
 244:src/gps_support.c **** 	xfunc_in  = xgetc;
 245:src/gps_support.c **** 
 246:src/gps_support.c **** 	/* Mount FatFs */
 247:src/gps_support.c **** 	f_mount(0, &Fatfs[0]);
 248:src/gps_support.c **** 
 249:src/gps_support.c **** 	for (;;) {
 250:src/gps_support.c **** startstat:
 251:src/gps_support.c **** 		/* "Wait for GPS Valid Data Acquisition" State */
 252:src/gps_support.c **** 		l_stat = STBY_STATE;
 253:src/gps_support.c **** 		LED_RED_ON();
 254:src/gps_support.c **** 		/* Wait for valid RMC sentence. */
 255:src/gps_support.c **** 		do {
 256:src/gps_support.c **** 			__WFI();
 257:src/gps_support.c **** 			do{
 258:src/gps_support.c **** 				b = get_line_GPS();
 259:src/gps_support.c **** 				/* Got UART String ? */
 260:src/gps_support.c **** 				if (b) break;
 261:src/gps_support.c **** 			}while(1);
 262:src/gps_support.c **** 
 263:src/gps_support.c **** 			/* UART String Received */
 264:src/gps_support.c **** 			LED_RED_OFF();
 265:src/gps_support.c **** 			LED_GRN_ON();
 266:src/gps_support.c **** 	
 267:src/gps_support.c **** 			/* Get GPRMC & GNRMC Valid Flag Column */ 
 268:src/gps_support.c **** 			if (!gp_comp(Buff, "$GPRMC") || !gp_comp(Buff, "$GNRMC")){
 269:src/gps_support.c **** 				/* Skip this execution When not a GPRMC or GNRMC Sentence */
 270:src/gps_support.c **** 				p = gp_col(Buff,GPRMC_COL_VALID);
 271:src/gps_support.c **** 				LED_GRN_OFF();
 272:src/gps_support.c **** 			}
 273:src/gps_support.c **** 			ack_limit =0;
 274:src/gps_support.c **** 		} while (!p || *p != 'A'); /* Valid Flag ? */
 275:src/gps_support.c **** 
 276:src/gps_support.c **** 
 277:src/gps_support.c **** 		/* "GPS Sentence Logging" State */
 278:src/gps_support.c **** 		l_stat = LOGGING_STATE;
 279:src/gps_support.c **** 		LED_RED_OFF();
 280:src/gps_support.c **** 		LED_GRN_OFF();
 281:src/gps_support.c **** 
 282:src/gps_support.c **** 		/* Synchronize STM32 RTC Module */
 283:src/gps_support.c **** 		p = gp_col(Buff,GPRMC_COL_HMS);
 284:src/gps_support.c **** 		/* if (!p) break; */
 285:src/gps_support.c **** 		rtc.tm_hour = gp_val(p);
 286:src/gps_support.c **** 		rtc.tm_min  = gp_val(p+2);
 287:src/gps_support.c **** 		rtc.tm_sec  = gp_val(p+4);
 288:src/gps_support.c **** 		p = gp_col(Buff,GPRMC_COL_YMD);
 289:src/gps_support.c **** 		/* if (!p) break; */
 290:src/gps_support.c **** 		rtc.tm_mday = gp_val(p);
 291:src/gps_support.c **** 		rtc.tm_mon  = gp_val(p+2) - 1;
 292:src/gps_support.c **** 		rtc.tm_year = gp_val(p+4) + 100;
 293:src/gps_support.c **** 
 294:src/gps_support.c **** 		utc = mktime(&rtc);				/* Get UNIX epoch Time */
 295:src/gps_support.c **** 		utc += 3600 * 9;				/* Create Time in JST*/
 296:src/gps_support.c **** 		Time_SetUnixTime(utc);			/* Set UNIX epoch Time */
 297:src/gps_support.c **** 
 298:src/gps_support.c **** 		/* Get a FileName */
 299:src/gps_support.c **** 		rtc = Time_GetCalendarTime();
 300:src/gps_support.c **** 		sprintf((char*)Buff,"%02u%02u%02u.log",
 301:src/gps_support.c **** 						rtc.tm_year % 100,
 302:src/gps_support.c **** 						rtc.tm_mon+1,
 303:src/gps_support.c **** 						rtc.tm_mday);
 304:src/gps_support.c **** 
 305:src/gps_support.c **** 		/* Open or Create logfile */
 306:src/gps_support.c **** 		if (f_open(&File1, (const char*)Buff, FA_OPEN_ALWAYS | FA_WRITE) ||
 307:src/gps_support.c **** 		    f_lseek(&File1, File1.fsize)) {goto errstat;}
 308:src/gps_support.c **** 
 309:src/gps_support.c **** 		/* Logging GPS Data */
 310:src/gps_support.c **** 		while ((b = get_line_GPS()) > 0)
 311:src/gps_support.c **** 		{
 312:src/gps_support.c **** 
 313:src/gps_support.c **** 			if (!gp_comp(Buff,"$GPGGA"))
 314:src/gps_support.c **** 			{
 315:src/gps_support.c **** 				p = gp_col(Buff,GPGGA_POS_TYPE);
 316:src/gps_support.c **** 				if(*p != '0'){ /* 0 is invalid tracking data */
 317:src/gps_support.c **** 					LED_RED_ON();
 318:src/gps_support.c **** 					if (f_write(&File1, Buff, b, &s) || b != s) {goto errstat;}
 319:src/gps_support.c **** 				}
 320:src/gps_support.c **** 			}
 321:src/gps_support.c **** 
 322:src/gps_support.c **** 			else if (!gp_comp(Buff,"$GPRMC"))
 323:src/gps_support.c **** 			{
 324:src/gps_support.c **** 				p = gp_col(Buff,GPRMC_COL_VALID);
 325:src/gps_support.c **** 				if(*p == 'A'){
 326:src/gps_support.c **** 					LED_RED_ON();
 327:src/gps_support.c **** 					if (f_write(&File1, Buff, b, &s) || b != s) {goto errstat;}
 328:src/gps_support.c **** 				}
 329:src/gps_support.c **** 			}
 330:src/gps_support.c **** 
 331:src/gps_support.c **** 			/* Gms-g6a(MT3333) Support */
 332:src/gps_support.c **** 			if (!gp_comp(Buff,"$GNGGA"))
 333:src/gps_support.c **** 			{
 334:src/gps_support.c **** 				p = gp_col(Buff,GPGGA_POS_TYPE);
 335:src/gps_support.c **** 				if(*p != '0'){ /* 0 is invalid tracking data */
 336:src/gps_support.c **** 					LED_RED_ON();
 337:src/gps_support.c **** 					if (f_write(&File1, Buff, b, &s) || b != s) {goto errstat;}
 338:src/gps_support.c **** 				}
 339:src/gps_support.c **** 			}
 340:src/gps_support.c **** 
 341:src/gps_support.c **** 			/* Gms-g6a(MT3333) Support */
 342:src/gps_support.c **** 			else if (!gp_comp(Buff,"$GNRMC"))
 343:src/gps_support.c **** 			{
 344:src/gps_support.c **** 				p = gp_col(Buff,GPRMC_COL_VALID);
 183              		.loc 1 344 0
 184 0000 074B     		ldr	r3, .L42
 185              	.LVL21:
 186              	.L34:
 169:src/gps_support.c **** 	while (col) {
 187              		.loc 1 169 0
 188 0002 58B1     		cbz	r0, .L35
 189 0004 1A46     		mov	r2, r3
 190              	.LVL22:
 191              	.L36:
 171:src/gps_support.c **** 			c = *buf++;
 192              		.loc 1 171 0
 193 0006 12F8011B 		ldrb	r1, [r2], #1	@ zero_extendqisi2
 194              	.LVL23:
 195 000a 1346     		mov	r3, r2
 196              	.LVL24:
 172:src/gps_support.c **** 			if (c <= ' ') return NULL;
 197              		.loc 1 172 0
 198 000c 2029     		cmp	r1, #32
 199 000e 04D9     		bls	.L37
 173:src/gps_support.c **** 		} while (c != ',');
 200              		.loc 1 173 0
 201 0010 2C29     		cmp	r1, #44
 202 0012 F8D1     		bne	.L36
 174:src/gps_support.c **** 		col--;
 203              		.loc 1 174 0
 204 0014 0138     		subs	r0, r0, #1
 205              	.LVL25:
 206 0016 C0B2     		uxtb	r0, r0
 207              	.LVL26:
 208 0018 F3E7     		b	.L34
 209              	.L37:
 172:src/gps_support.c **** 			if (c <= ' ') return NULL;
 210              		.loc 1 172 0
 211 001a 0023     		movs	r3, #0
 212              	.LVL27:
 213              	.L35:
 177:src/gps_support.c **** }
 214              		.loc 1 177 0
 215 001c 1846     		mov	r0, r3
 216              	.LVL28:
 217 001e 7047     		bx	lr
 218              	.L43:
 219              		.align	2
 220              	.L42:
 221 0020 00000000 		.word	.LANCHOR0
 222              		.cfi_endproc
 223              	.LFE66:
 225              		.section	.text.ff_support_timerproc,"ax",%progbits
 226              		.align	1
 227              		.global	ff_support_timerproc
 228              		.thumb
 229              		.thumb_func
 231              	ff_support_timerproc:
 232              	.LFB57:
  81:src/gps_support.c **** {
 233              		.loc 1 81 0
 234              		.cfi_startproc
 235              		@ args = 0, pretend = 0, frame = 0
 236              		@ frame_needed = 0, uses_anonymous_args = 0
 237              		@ link register save eliminated.
  82:src/gps_support.c **** 	Timer++;
 238              		.loc 1 82 0
 239 0000 024B     		ldr	r3, .L45
 240 0002 1A68     		ldr	r2, [r3, #0]
 241 0004 501C     		adds	r0, r2, #1
 242 0006 1860     		str	r0, [r3, #0]
 243 0008 7047     		bx	lr
 244              	.L46:
 245 000a 00BF     		.align	2
 246              	.L45:
 247 000c 00000000 		.word	.LANCHOR1
 248              		.cfi_endproc
 249              	.LFE57:
 251              		.section	.text.get_fattime,"ax",%progbits
 252              		.align	1
 253              		.global	get_fattime
 254              		.thumb
 255              		.thumb_func
 257              	get_fattime:
 258              	.LFB58:
  91:src/gps_support.c **** {
 259              		.loc 1 91 0
 260              		.cfi_startproc
 261              		@ args = 0, pretend = 0, frame = 0
 262              		@ frame_needed = 0, uses_anonymous_args = 0
 263 0000 10B5     		push	{r4, lr}
 264              	.LCFI1:
 265              		.cfi_def_cfa_offset 8
 266              		.cfi_offset 4, -8
 267              		.cfi_offset 14, -4
  93:src/gps_support.c **** 	rtc_gettime(&ff_rtc);
 268              		.loc 1 93 0
 269 0002 0C4C     		ldr	r4, .L48
 270 0004 2046     		mov	r0, r4
 271 0006 FFF7FEFF 		bl	rtc_gettime
 272              	.LVL29:
  98:src/gps_support.c **** 			| ((DWORD)ff_rtc.mday << 16)
 273              		.loc 1 98 0
 274 000a E278     		ldrb	r2, [r4, #3]	@ zero_extendqisi2
  97:src/gps_support.c **** 			| ((DWORD)ff_rtc.month << 21)
 275              		.loc 1 97 0
 276 000c A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 277 000e 5805     		lsls	r0, r3, #21
 278 0010 40EA0241 		orr	r1, r0, r2, lsl #16
  99:src/gps_support.c **** 			| ((DWORD)ff_rtc.hour << 11)
 279              		.loc 1 99 0
 280 0014 6279     		ldrb	r2, [r4, #5]	@ zero_extendqisi2
  98:src/gps_support.c **** 			| ((DWORD)ff_rtc.mday << 16)
 281              		.loc 1 98 0
 282 0016 41EAC223 		orr	r3, r1, r2, lsl #11
 100:src/gps_support.c **** 			| ((DWORD)ff_rtc.min << 5)
 283              		.loc 1 100 0
 284 001a A079     		ldrb	r0, [r4, #6]	@ zero_extendqisi2
  99:src/gps_support.c **** 			| ((DWORD)ff_rtc.hour << 11)
 285              		.loc 1 99 0
 286 001c 43EA4011 		orr	r1, r3, r0, lsl #5
 101:src/gps_support.c **** 			| ((DWORD)ff_rtc.sec >> 1);
 287              		.loc 1 101 0
 288 0020 E279     		ldrb	r2, [r4, #7]	@ zero_extendqisi2
 100:src/gps_support.c **** 			| ((DWORD)ff_rtc.min << 5)
 289              		.loc 1 100 0
 290 0022 41EA5203 		orr	r3, r1, r2, lsr #1
  96:src/gps_support.c **** 	return	  ((DWORD)(ff_rtc.year - 1980) << 25)
 291              		.loc 1 96 0
 292 0026 2088     		ldrh	r0, [r4, #0]
 293 0028 A0F2BC71 		subw	r1, r0, #1980
 102:src/gps_support.c **** }
 294              		.loc 1 102 0
 295 002c 43EA4160 		orr	r0, r3, r1, lsl #25
 296 0030 10BD     		pop	{r4, pc}
 297              	.L49:
 298 0032 00BF     		.align	2
 299              	.L48:
 300 0034 00000000 		.word	.LANCHOR2
 301              		.cfi_endproc
 302              	.LFE58:
 304              		.section	.text.ChkAckLimit,"ax",%progbits
 305              		.align	1
 306              		.global	ChkAckLimit
 307              		.thumb
 308              		.thumb_func
 310              	ChkAckLimit:
 311              	.LFB59:
 110:src/gps_support.c **** {
 312              		.loc 1 110 0
 313              		.cfi_startproc
 314              		@ args = 0, pretend = 0, frame = 0
 315              		@ frame_needed = 0, uses_anonymous_args = 0
 316 0000 10B5     		push	{r4, lr}
 317              	.LCFI2:
 318              		.cfi_def_cfa_offset 8
 319              		.cfi_offset 4, -8
 320              		.cfi_offset 14, -4
 112:src/gps_support.c **** 	if(ack_limit++ > ACK_LIMIT*1000){
 321              		.loc 1 112 0
 322 0002 094C     		ldr	r4, .L52
 323 0004 2368     		ldr	r3, [r4, #0]
 324 0006 5A1C     		adds	r2, r3, #1
 325 0008 2260     		str	r2, [r4, #0]
 326 000a 41F28830 		movw	r0, #5000
 327 000e 8342     		cmp	r3, r0
 328 0010 08D9     		bls	.L50
 114:src/gps_support.c **** 		cputs("$PMTK000*32\r\n");
 329              		.loc 1 114 0
 330 0012 0648     		ldr	r0, .L52+4
 331 0014 FFF7FEFF 		bl	cputs
 332              	.LVL30:
 115:src/gps_support.c **** 		_delay_us(10000);
 333              		.loc 1 115 0
 334 0018 42F21070 		movw	r0, #10000
 335 001c FFF7FEFF 		bl	_delay_us
 336              	.LVL31:
 116:src/gps_support.c **** 		ack_limit =0;
 337              		.loc 1 116 0
 338 0020 0021     		movs	r1, #0
 339 0022 2160     		str	r1, [r4, #0]
 340              	.L50:
 341 0024 10BD     		pop	{r4, pc}
 342              	.L53:
 343 0026 00BF     		.align	2
 344              	.L52:
 345 0028 00000000 		.word	.LANCHOR3
 346 002c 00000000 		.word	.LC0
 347              		.cfi_endproc
 348              	.LFE59:
 350              		.section	.text.ShutFileClose,"ax",%progbits
 351              		.align	1
 352              		.global	ShutFileClose
 353              		.thumb
 354              		.thumb_func
 356              	ShutFileClose:
 357              	.LFB60:
 128:src/gps_support.c **** {
 358              		.loc 1 128 0
 359              		.cfi_startproc
 360              		@ args = 0, pretend = 0, frame = 0
 361              		@ frame_needed = 0, uses_anonymous_args = 0
 362 0000 08B5     		push	{r3, lr}
 363              	.LCFI3:
 364              		.cfi_def_cfa_offset 8
 365              		.cfi_offset 3, -8
 366              		.cfi_offset 14, -4
 129:src/gps_support.c **** 	if(l_stat==STBY_STATE) return;
 367              		.loc 1 129 0
 368 0002 044B     		ldr	r3, .L59
 369 0004 1868     		ldr	r0, [r3, #0]
 370 0006 20B1     		cbz	r0, .L54
 371              	.L57:
 132:src/gps_support.c **** 	if(f_close(&File1)) {goto shutstat;}
 372              		.loc 1 132 0
 373 0008 0348     		ldr	r0, .L59+4
 374 000a FFF7FEFF 		bl	f_close
 375              	.LVL32:
 376 000e 0028     		cmp	r0, #0
 377 0010 FAD1     		bne	.L57
 378              	.L54:
 379 0012 08BD     		pop	{r3, pc}
 380              	.L60:
 381              		.align	2
 382              	.L59:
 383 0014 00000000 		.word	.LANCHOR4
 384 0018 00000000 		.word	.LANCHOR5
 385              		.cfi_endproc
 386              	.LFE60:
 388              		.section	.text.gps_task,"ax",%progbits
 389              		.align	1
 390              		.global	gps_task
 391              		.thumb
 392              		.thumb_func
 394              	gps_task:
 395              	.LFB65:
 222:src/gps_support.c **** {
 396              		.loc 1 222 0
 397              		.cfi_startproc
 398              		@ args = 0, pretend = 0, frame = 48
 399              		@ frame_needed = 0, uses_anonymous_args = 0
 400 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 401              	.LCFI4:
 402              		.cfi_def_cfa_offset 20
 403              		.cfi_offset 4, -20
 404              		.cfi_offset 5, -16
 405              		.cfi_offset 6, -12
 406              		.cfi_offset 7, -8
 407              		.cfi_offset 14, -4
 408 0002 8FB0     		sub	sp, sp, #60
 409              	.LCFI5:
 410              		.cfi_def_cfa_offset 80
 411              	.LVL33:
 226:src/gps_support.c **** 	volatile uint16_t c_sync=0;
 412              		.loc 1 226 0
 413 0004 0024     		movs	r4, #0
 414 0006 ADF83240 		strh	r4, [sp, #50]	@ movhi
 415              	.LVL34:
 230:src/gps_support.c **** 	conio_init(GPS_UART_PORT,38400);
 416              		.loc 1 230 0
 417 000a 0220     		movs	r0, #2
 418 000c 4FF41641 		mov	r1, #38400
 419 0010 FFF7FEFF 		bl	conio_init
 420              	.LVL35:
 232:src/gps_support.c **** 	cputs("$PMTK251,9600*17\r\n");
 421              		.loc 1 232 0
 422 0014 8C48     		ldr	r0, .L106
 423 0016 FFF7FEFF 		bl	cputs
 424              	.LVL36:
 234:src/gps_support.c **** 	_delay_ms(200);
 425              		.loc 1 234 0
 426 001a C820     		movs	r0, #200
 427 001c FFF7FEFF 		bl	_delay_ms
 428              	.LVL37:
 237:src/gps_support.c **** 	cputs("$PMTK286,1*23\r\n");
 429              		.loc 1 237 0
 430 0020 8A48     		ldr	r0, .L106+4
 431 0022 FFF7FEFF 		bl	cputs
 432              	.LVL38:
 239:src/gps_support.c **** 	_delay_ms(200);
 433              		.loc 1 239 0
 434 0026 C820     		movs	r0, #200
 435 0028 FFF7FEFF 		bl	_delay_ms
 436              	.LVL39:
 242:src/gps_support.c **** 	conio_init(GPS_UART_PORT,GPS_UART_BAUD);
 437              		.loc 1 242 0
 438 002c 0220     		movs	r0, #2
 439 002e 4FF41651 		mov	r1, #9600
 440 0032 FFF7FEFF 		bl	conio_init
 441              	.LVL40:
 243:src/gps_support.c **** 	xfunc_out = putch;
 442              		.loc 1 243 0
 443 0036 864A     		ldr	r2, .L106+8
 444 0038 864B     		ldr	r3, .L106+12
 445 003a 1A60     		str	r2, [r3, #0]
 244:src/gps_support.c **** 	xfunc_in  = xgetc;
 446              		.loc 1 244 0
 447 003c 8648     		ldr	r0, .L106+16
 448 003e 8749     		ldr	r1, .L106+20
 449 0040 0860     		str	r0, [r1, #0]
 247:src/gps_support.c **** 	f_mount(0, &Fatfs[0]);
 450              		.loc 1 247 0
 451 0042 2046     		mov	r0, r4
 452 0044 8649     		ldr	r1, .L106+24
 453 0046 FFF7FEFF 		bl	f_mount
 454              	.LVL41:
 455              	.L101:
 252:src/gps_support.c **** 		l_stat = STBY_STATE;
 456              		.loc 1 252 0
 457 004a 0025     		movs	r5, #0
 458 004c 854E     		ldr	r6, .L106+28
 459 004e 3560     		str	r5, [r6, #0]
 253:src/gps_support.c **** 		LED_RED_ON();
 460              		.loc 1 253 0
 461 0050 8548     		ldr	r0, .L106+32
 462 0052 0221     		movs	r1, #2
 463 0054 FFF7FEFF 		bl	GPIO_SetBits
 464              	.LVL42:
 465              	.L99:
 466              	.LBB6:
 467              	.LBB7:
 468              		.file 2 "./lib/CMSIS/Include/core_cmInstr.h"
   1:./lib/CMSIS/Include/core_cmInstr.h **** /**************************************************************************//**
   2:./lib/CMSIS/Include/core_cmInstr.h ****  * @file     core_cmInstr.h
   3:./lib/CMSIS/Include/core_cmInstr.h ****  * @brief    CMSIS Cortex-M Core Instruction Access Header File
   4:./lib/CMSIS/Include/core_cmInstr.h ****  * @version  V3.01
   5:./lib/CMSIS/Include/core_cmInstr.h ****  * @date     06. March 2012
   6:./lib/CMSIS/Include/core_cmInstr.h ****  *
   7:./lib/CMSIS/Include/core_cmInstr.h ****  * @note
   8:./lib/CMSIS/Include/core_cmInstr.h ****  * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
   9:./lib/CMSIS/Include/core_cmInstr.h ****  *
  10:./lib/CMSIS/Include/core_cmInstr.h ****  * @par
  11:./lib/CMSIS/Include/core_cmInstr.h ****  * ARM Limited (ARM) is supplying this software for use with Cortex-M
  12:./lib/CMSIS/Include/core_cmInstr.h ****  * processor based microcontrollers.  This file can be freely distributed
  13:./lib/CMSIS/Include/core_cmInstr.h ****  * within development tools that are supporting such ARM based processors.
  14:./lib/CMSIS/Include/core_cmInstr.h ****  *
  15:./lib/CMSIS/Include/core_cmInstr.h ****  * @par
  16:./lib/CMSIS/Include/core_cmInstr.h ****  * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  17:./lib/CMSIS/Include/core_cmInstr.h ****  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  18:./lib/CMSIS/Include/core_cmInstr.h ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
  19:./lib/CMSIS/Include/core_cmInstr.h ****  * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
  20:./lib/CMSIS/Include/core_cmInstr.h ****  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
  21:./lib/CMSIS/Include/core_cmInstr.h ****  *
  22:./lib/CMSIS/Include/core_cmInstr.h ****  ******************************************************************************/
  23:./lib/CMSIS/Include/core_cmInstr.h **** 
  24:./lib/CMSIS/Include/core_cmInstr.h **** #ifndef __CORE_CMINSTR_H
  25:./lib/CMSIS/Include/core_cmInstr.h **** #define __CORE_CMINSTR_H
  26:./lib/CMSIS/Include/core_cmInstr.h **** 
  27:./lib/CMSIS/Include/core_cmInstr.h **** 
  28:./lib/CMSIS/Include/core_cmInstr.h **** /* ##########################  Core Instruction Access  ######################### */
  29:./lib/CMSIS/Include/core_cmInstr.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  30:./lib/CMSIS/Include/core_cmInstr.h ****   Access to dedicated instructions
  31:./lib/CMSIS/Include/core_cmInstr.h ****   @{
  32:./lib/CMSIS/Include/core_cmInstr.h **** */
  33:./lib/CMSIS/Include/core_cmInstr.h **** 
  34:./lib/CMSIS/Include/core_cmInstr.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  35:./lib/CMSIS/Include/core_cmInstr.h **** /* ARM armcc specific functions */
  36:./lib/CMSIS/Include/core_cmInstr.h **** 
  37:./lib/CMSIS/Include/core_cmInstr.h **** #if (__ARMCC_VERSION < 400677)
  38:./lib/CMSIS/Include/core_cmInstr.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  39:./lib/CMSIS/Include/core_cmInstr.h **** #endif
  40:./lib/CMSIS/Include/core_cmInstr.h **** 
  41:./lib/CMSIS/Include/core_cmInstr.h **** 
  42:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  No Operation
  43:./lib/CMSIS/Include/core_cmInstr.h **** 
  44:./lib/CMSIS/Include/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
  45:./lib/CMSIS/Include/core_cmInstr.h ****  */
  46:./lib/CMSIS/Include/core_cmInstr.h **** #define __NOP                             __nop
  47:./lib/CMSIS/Include/core_cmInstr.h **** 
  48:./lib/CMSIS/Include/core_cmInstr.h **** 
  49:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Interrupt
  50:./lib/CMSIS/Include/core_cmInstr.h **** 
  51:./lib/CMSIS/Include/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
  52:./lib/CMSIS/Include/core_cmInstr.h ****     until one of a number of events occurs.
  53:./lib/CMSIS/Include/core_cmInstr.h ****  */
  54:./lib/CMSIS/Include/core_cmInstr.h **** #define __WFI                             __wfi
  55:./lib/CMSIS/Include/core_cmInstr.h **** 
  56:./lib/CMSIS/Include/core_cmInstr.h **** 
  57:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Event
  58:./lib/CMSIS/Include/core_cmInstr.h **** 
  59:./lib/CMSIS/Include/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
  60:./lib/CMSIS/Include/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
  61:./lib/CMSIS/Include/core_cmInstr.h ****  */
  62:./lib/CMSIS/Include/core_cmInstr.h **** #define __WFE                             __wfe
  63:./lib/CMSIS/Include/core_cmInstr.h **** 
  64:./lib/CMSIS/Include/core_cmInstr.h **** 
  65:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Send Event
  66:./lib/CMSIS/Include/core_cmInstr.h **** 
  67:./lib/CMSIS/Include/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
  68:./lib/CMSIS/Include/core_cmInstr.h ****  */
  69:./lib/CMSIS/Include/core_cmInstr.h **** #define __SEV                             __sev
  70:./lib/CMSIS/Include/core_cmInstr.h **** 
  71:./lib/CMSIS/Include/core_cmInstr.h **** 
  72:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
  73:./lib/CMSIS/Include/core_cmInstr.h **** 
  74:./lib/CMSIS/Include/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
  75:./lib/CMSIS/Include/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
  76:./lib/CMSIS/Include/core_cmInstr.h ****     memory, after the instruction has been completed.
  77:./lib/CMSIS/Include/core_cmInstr.h ****  */
  78:./lib/CMSIS/Include/core_cmInstr.h **** #define __ISB()                           __isb(0xF)
  79:./lib/CMSIS/Include/core_cmInstr.h **** 
  80:./lib/CMSIS/Include/core_cmInstr.h **** 
  81:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
  82:./lib/CMSIS/Include/core_cmInstr.h **** 
  83:./lib/CMSIS/Include/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
  84:./lib/CMSIS/Include/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
  85:./lib/CMSIS/Include/core_cmInstr.h ****  */
  86:./lib/CMSIS/Include/core_cmInstr.h **** #define __DSB()                           __dsb(0xF)
  87:./lib/CMSIS/Include/core_cmInstr.h **** 
  88:./lib/CMSIS/Include/core_cmInstr.h **** 
  89:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Data Memory Barrier
  90:./lib/CMSIS/Include/core_cmInstr.h **** 
  91:./lib/CMSIS/Include/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
  92:./lib/CMSIS/Include/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
  93:./lib/CMSIS/Include/core_cmInstr.h ****  */
  94:./lib/CMSIS/Include/core_cmInstr.h **** #define __DMB()                           __dmb(0xF)
  95:./lib/CMSIS/Include/core_cmInstr.h **** 
  96:./lib/CMSIS/Include/core_cmInstr.h **** 
  97:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
  98:./lib/CMSIS/Include/core_cmInstr.h **** 
  99:./lib/CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in integer value.
 100:./lib/CMSIS/Include/core_cmInstr.h **** 
 101:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 102:./lib/CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 103:./lib/CMSIS/Include/core_cmInstr.h ****  */
 104:./lib/CMSIS/Include/core_cmInstr.h **** #define __REV                             __rev
 105:./lib/CMSIS/Include/core_cmInstr.h **** 
 106:./lib/CMSIS/Include/core_cmInstr.h **** 
 107:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 108:./lib/CMSIS/Include/core_cmInstr.h **** 
 109:./lib/CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 110:./lib/CMSIS/Include/core_cmInstr.h **** 
 111:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 112:./lib/CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 113:./lib/CMSIS/Include/core_cmInstr.h ****  */
 114:./lib/CMSIS/Include/core_cmInstr.h **** __attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
 115:./lib/CMSIS/Include/core_cmInstr.h **** {
 116:./lib/CMSIS/Include/core_cmInstr.h ****   rev16 r0, r0
 117:./lib/CMSIS/Include/core_cmInstr.h ****   bx lr
 118:./lib/CMSIS/Include/core_cmInstr.h **** }
 119:./lib/CMSIS/Include/core_cmInstr.h **** 
 120:./lib/CMSIS/Include/core_cmInstr.h **** 
 121:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 122:./lib/CMSIS/Include/core_cmInstr.h **** 
 123:./lib/CMSIS/Include/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 124:./lib/CMSIS/Include/core_cmInstr.h **** 
 125:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 126:./lib/CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 127:./lib/CMSIS/Include/core_cmInstr.h ****  */
 128:./lib/CMSIS/Include/core_cmInstr.h **** __attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
 129:./lib/CMSIS/Include/core_cmInstr.h **** {
 130:./lib/CMSIS/Include/core_cmInstr.h ****   revsh r0, r0
 131:./lib/CMSIS/Include/core_cmInstr.h ****   bx lr
 132:./lib/CMSIS/Include/core_cmInstr.h **** }
 133:./lib/CMSIS/Include/core_cmInstr.h **** 
 134:./lib/CMSIS/Include/core_cmInstr.h **** 
 135:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 136:./lib/CMSIS/Include/core_cmInstr.h **** 
 137:./lib/CMSIS/Include/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
 138:./lib/CMSIS/Include/core_cmInstr.h **** 
 139:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to rotate
 140:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 141:./lib/CMSIS/Include/core_cmInstr.h ****     \return               Rotated value
 142:./lib/CMSIS/Include/core_cmInstr.h ****  */
 143:./lib/CMSIS/Include/core_cmInstr.h **** #define __ROR                             __ror
 144:./lib/CMSIS/Include/core_cmInstr.h **** 
 145:./lib/CMSIS/Include/core_cmInstr.h **** 
 146:./lib/CMSIS/Include/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 147:./lib/CMSIS/Include/core_cmInstr.h **** 
 148:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Reverse bit order of value
 149:./lib/CMSIS/Include/core_cmInstr.h **** 
 150:./lib/CMSIS/Include/core_cmInstr.h ****     This function reverses the bit order of the given value.
 151:./lib/CMSIS/Include/core_cmInstr.h **** 
 152:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    value  Value to reverse
 153:./lib/CMSIS/Include/core_cmInstr.h ****     \return               Reversed value
 154:./lib/CMSIS/Include/core_cmInstr.h ****  */
 155:./lib/CMSIS/Include/core_cmInstr.h **** #define __RBIT                            __rbit
 156:./lib/CMSIS/Include/core_cmInstr.h **** 
 157:./lib/CMSIS/Include/core_cmInstr.h **** 
 158:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 159:./lib/CMSIS/Include/core_cmInstr.h **** 
 160:./lib/CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 161:./lib/CMSIS/Include/core_cmInstr.h **** 
 162:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 163:./lib/CMSIS/Include/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 164:./lib/CMSIS/Include/core_cmInstr.h ****  */
 165:./lib/CMSIS/Include/core_cmInstr.h **** #define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
 166:./lib/CMSIS/Include/core_cmInstr.h **** 
 167:./lib/CMSIS/Include/core_cmInstr.h **** 
 168:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 169:./lib/CMSIS/Include/core_cmInstr.h **** 
 170:./lib/CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 171:./lib/CMSIS/Include/core_cmInstr.h **** 
 172:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 173:./lib/CMSIS/Include/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 174:./lib/CMSIS/Include/core_cmInstr.h ****  */
 175:./lib/CMSIS/Include/core_cmInstr.h **** #define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
 176:./lib/CMSIS/Include/core_cmInstr.h **** 
 177:./lib/CMSIS/Include/core_cmInstr.h **** 
 178:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 179:./lib/CMSIS/Include/core_cmInstr.h **** 
 180:./lib/CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
 181:./lib/CMSIS/Include/core_cmInstr.h **** 
 182:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 183:./lib/CMSIS/Include/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 184:./lib/CMSIS/Include/core_cmInstr.h ****  */
 185:./lib/CMSIS/Include/core_cmInstr.h **** #define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
 186:./lib/CMSIS/Include/core_cmInstr.h **** 
 187:./lib/CMSIS/Include/core_cmInstr.h **** 
 188:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 189:./lib/CMSIS/Include/core_cmInstr.h **** 
 190:./lib/CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 191:./lib/CMSIS/Include/core_cmInstr.h **** 
 192:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 193:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 194:./lib/CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 195:./lib/CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 196:./lib/CMSIS/Include/core_cmInstr.h ****  */
 197:./lib/CMSIS/Include/core_cmInstr.h **** #define __STREXB(value, ptr)              __strex(value, ptr)
 198:./lib/CMSIS/Include/core_cmInstr.h **** 
 199:./lib/CMSIS/Include/core_cmInstr.h **** 
 200:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 201:./lib/CMSIS/Include/core_cmInstr.h **** 
 202:./lib/CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 203:./lib/CMSIS/Include/core_cmInstr.h **** 
 204:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 205:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 206:./lib/CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 207:./lib/CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 208:./lib/CMSIS/Include/core_cmInstr.h ****  */
 209:./lib/CMSIS/Include/core_cmInstr.h **** #define __STREXH(value, ptr)              __strex(value, ptr)
 210:./lib/CMSIS/Include/core_cmInstr.h **** 
 211:./lib/CMSIS/Include/core_cmInstr.h **** 
 212:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 213:./lib/CMSIS/Include/core_cmInstr.h **** 
 214:./lib/CMSIS/Include/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 215:./lib/CMSIS/Include/core_cmInstr.h **** 
 216:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to store
 217:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 218:./lib/CMSIS/Include/core_cmInstr.h ****     \return          0  Function succeeded
 219:./lib/CMSIS/Include/core_cmInstr.h ****     \return          1  Function failed
 220:./lib/CMSIS/Include/core_cmInstr.h ****  */
 221:./lib/CMSIS/Include/core_cmInstr.h **** #define __STREXW(value, ptr)              __strex(value, ptr)
 222:./lib/CMSIS/Include/core_cmInstr.h **** 
 223:./lib/CMSIS/Include/core_cmInstr.h **** 
 224:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 225:./lib/CMSIS/Include/core_cmInstr.h **** 
 226:./lib/CMSIS/Include/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 227:./lib/CMSIS/Include/core_cmInstr.h **** 
 228:./lib/CMSIS/Include/core_cmInstr.h ****  */
 229:./lib/CMSIS/Include/core_cmInstr.h **** #define __CLREX                           __clrex
 230:./lib/CMSIS/Include/core_cmInstr.h **** 
 231:./lib/CMSIS/Include/core_cmInstr.h **** 
 232:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Signed Saturate
 233:./lib/CMSIS/Include/core_cmInstr.h **** 
 234:./lib/CMSIS/Include/core_cmInstr.h ****     This function saturates a signed value.
 235:./lib/CMSIS/Include/core_cmInstr.h **** 
 236:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 237:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 238:./lib/CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 239:./lib/CMSIS/Include/core_cmInstr.h ****  */
 240:./lib/CMSIS/Include/core_cmInstr.h **** #define __SSAT                            __ssat
 241:./lib/CMSIS/Include/core_cmInstr.h **** 
 242:./lib/CMSIS/Include/core_cmInstr.h **** 
 243:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Unsigned Saturate
 244:./lib/CMSIS/Include/core_cmInstr.h **** 
 245:./lib/CMSIS/Include/core_cmInstr.h ****     This function saturates an unsigned value.
 246:./lib/CMSIS/Include/core_cmInstr.h **** 
 247:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 248:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 249:./lib/CMSIS/Include/core_cmInstr.h ****     \return             Saturated value
 250:./lib/CMSIS/Include/core_cmInstr.h ****  */
 251:./lib/CMSIS/Include/core_cmInstr.h **** #define __USAT                            __usat
 252:./lib/CMSIS/Include/core_cmInstr.h **** 
 253:./lib/CMSIS/Include/core_cmInstr.h **** 
 254:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Count leading zeros
 255:./lib/CMSIS/Include/core_cmInstr.h **** 
 256:./lib/CMSIS/Include/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 257:./lib/CMSIS/Include/core_cmInstr.h **** 
 258:./lib/CMSIS/Include/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 259:./lib/CMSIS/Include/core_cmInstr.h ****     \return             number of leading zeros in value
 260:./lib/CMSIS/Include/core_cmInstr.h ****  */
 261:./lib/CMSIS/Include/core_cmInstr.h **** #define __CLZ                             __clz
 262:./lib/CMSIS/Include/core_cmInstr.h **** 
 263:./lib/CMSIS/Include/core_cmInstr.h **** #endif /* (__CORTEX_M >= 0x03) */
 264:./lib/CMSIS/Include/core_cmInstr.h **** 
 265:./lib/CMSIS/Include/core_cmInstr.h **** 
 266:./lib/CMSIS/Include/core_cmInstr.h **** 
 267:./lib/CMSIS/Include/core_cmInstr.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 268:./lib/CMSIS/Include/core_cmInstr.h **** /* IAR iccarm specific functions */
 269:./lib/CMSIS/Include/core_cmInstr.h **** 
 270:./lib/CMSIS/Include/core_cmInstr.h **** #include <cmsis_iar.h>
 271:./lib/CMSIS/Include/core_cmInstr.h **** 
 272:./lib/CMSIS/Include/core_cmInstr.h **** 
 273:./lib/CMSIS/Include/core_cmInstr.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 274:./lib/CMSIS/Include/core_cmInstr.h **** /* TI CCS specific functions */
 275:./lib/CMSIS/Include/core_cmInstr.h **** 
 276:./lib/CMSIS/Include/core_cmInstr.h **** #include <cmsis_ccs.h>
 277:./lib/CMSIS/Include/core_cmInstr.h **** 
 278:./lib/CMSIS/Include/core_cmInstr.h **** 
 279:./lib/CMSIS/Include/core_cmInstr.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 280:./lib/CMSIS/Include/core_cmInstr.h **** /* GNU gcc specific functions */
 281:./lib/CMSIS/Include/core_cmInstr.h **** 
 282:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  No Operation
 283:./lib/CMSIS/Include/core_cmInstr.h **** 
 284:./lib/CMSIS/Include/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 285:./lib/CMSIS/Include/core_cmInstr.h ****  */
 286:./lib/CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
 287:./lib/CMSIS/Include/core_cmInstr.h **** {
 288:./lib/CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("nop");
 289:./lib/CMSIS/Include/core_cmInstr.h **** }
 290:./lib/CMSIS/Include/core_cmInstr.h **** 
 291:./lib/CMSIS/Include/core_cmInstr.h **** 
 292:./lib/CMSIS/Include/core_cmInstr.h **** /** \brief  Wait For Interrupt
 293:./lib/CMSIS/Include/core_cmInstr.h **** 
 294:./lib/CMSIS/Include/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
 295:./lib/CMSIS/Include/core_cmInstr.h ****     until one of a number of events occurs.
 296:./lib/CMSIS/Include/core_cmInstr.h ****  */
 297:./lib/CMSIS/Include/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
 298:./lib/CMSIS/Include/core_cmInstr.h **** {
 299:./lib/CMSIS/Include/core_cmInstr.h ****   __ASM volatile ("wfi");
 469              		.loc 2 299 0
 470              	@ 299 "./lib/CMSIS/Include/core_cmInstr.h" 1
 471 0058 30BF     		wfi
 472              	@ 0 "" 2
 473              		.thumb
 474              	.L64:
 475              	.LBE7:
 476              	.LBE6:
 258:src/gps_support.c **** 				b = get_line_GPS();
 477              		.loc 1 258 0
 478 005a FFF7FEFF 		bl	get_line_GPS
 479              	.LVL43:
 260:src/gps_support.c **** 				if (b) break;
 480              		.loc 1 260 0
 481 005e 0028     		cmp	r0, #0
 482 0060 FBD0     		beq	.L64
 264:src/gps_support.c **** 			LED_RED_OFF();
 483              		.loc 1 264 0
 484 0062 8148     		ldr	r0, .L106+32
 485              	.LVL44:
 486 0064 0221     		movs	r1, #2
 487 0066 FFF7FEFF 		bl	GPIO_ResetBits
 488              	.LVL45:
 265:src/gps_support.c **** 			LED_GRN_ON();
 489              		.loc 1 265 0
 490 006a 7F48     		ldr	r0, .L106+32
 491 006c 0121     		movs	r1, #1
 492 006e FFF7FEFF 		bl	GPIO_SetBits
 493              	.LVL46:
 268:src/gps_support.c **** 			if (!gp_comp(Buff, "$GPRMC") || !gp_comp(Buff, "$GNRMC")){
 494              		.loc 1 268 0
 495 0072 7E48     		ldr	r0, .L106+36
 496 0074 FFF7FEFF 		bl	gp_comp.constprop.0
 497              	.LVL47:
 498 0078 18B1     		cbz	r0, .L65
 268:src/gps_support.c **** 			if (!gp_comp(Buff, "$GPRMC") || !gp_comp(Buff, "$GNRMC")){
 499              		.loc 1 268 0 is_stmt 0 discriminator 1
 500 007a 7D48     		ldr	r0, .L106+40
 501 007c FFF7FEFF 		bl	gp_comp.constprop.0
 502              	.LVL48:
 503 0080 38B9     		cbnz	r0, .L66
 504              	.L65:
 270:src/gps_support.c **** 				p = gp_col(Buff,GPRMC_COL_VALID);
 505              		.loc 1 270 0 is_stmt 1
 506 0082 0220     		movs	r0, #2
 507 0084 FFF7FEFF 		bl	gp_col.constprop.1
 508              	.LVL49:
 509 0088 0446     		mov	r4, r0
 510              	.LVL50:
 271:src/gps_support.c **** 				LED_GRN_OFF();
 511              		.loc 1 271 0
 512 008a 7748     		ldr	r0, .L106+32
 513              	.LVL51:
 514 008c 0121     		movs	r1, #1
 515 008e FFF7FEFF 		bl	GPIO_ResetBits
 516              	.LVL52:
 517              	.L66:
 273:src/gps_support.c **** 			ack_limit =0;
 518              		.loc 1 273 0
 519 0092 0027     		movs	r7, #0
 520 0094 774A     		ldr	r2, .L106+44
 521 0096 1760     		str	r7, [r2, #0]
 274:src/gps_support.c **** 		} while (!p || *p != 'A'); /* Valid Flag ? */
 522              		.loc 1 274 0
 523 0098 002C     		cmp	r4, #0
 524 009a DDD0     		beq	.L99
 274:src/gps_support.c **** 		} while (!p || *p != 'A'); /* Valid Flag ? */
 525              		.loc 1 274 0 is_stmt 0 discriminator 1
 526 009c 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 527 009e 412B     		cmp	r3, #65
 528 00a0 DAD1     		bne	.L99
 278:src/gps_support.c **** 		l_stat = LOGGING_STATE;
 529              		.loc 1 278 0 is_stmt 1
 530 00a2 0124     		movs	r4, #1
 531              	.LVL53:
 532 00a4 6F48     		ldr	r0, .L106+28
 533 00a6 0460     		str	r4, [r0, #0]
 279:src/gps_support.c **** 		LED_RED_OFF();
 534              		.loc 1 279 0
 535 00a8 6F48     		ldr	r0, .L106+32
 536 00aa 0221     		movs	r1, #2
 537 00ac FFF7FEFF 		bl	GPIO_ResetBits
 538              	.LVL54:
 280:src/gps_support.c **** 		LED_GRN_OFF();
 539              		.loc 1 280 0
 540 00b0 6D48     		ldr	r0, .L106+32
 541 00b2 2146     		mov	r1, r4
 542 00b4 FFF7FEFF 		bl	GPIO_ResetBits
 543              	.LVL55:
 283:src/gps_support.c **** 		p = gp_col(Buff,GPRMC_COL_HMS);
 544              		.loc 1 283 0
 545 00b8 2046     		mov	r0, r4
 546 00ba FFF7FEFF 		bl	gp_col.constprop.1
 547              	.LVL56:
 548 00be 0546     		mov	r5, r0
 549              	.LVL57:
 285:src/gps_support.c **** 		rtc.tm_hour = gp_val(p);
 550              		.loc 1 285 0
 551 00c0 FFF7FEFF 		bl	gp_val
 552              	.LVL58:
 553 00c4 6C4F     		ldr	r7, .L106+48
 554 00c6 B860     		str	r0, [r7, #8]
 286:src/gps_support.c **** 		rtc.tm_min  = gp_val(p+2);
 555              		.loc 1 286 0
 556 00c8 A81C     		adds	r0, r5, #2
 557 00ca FFF7FEFF 		bl	gp_val
 558              	.LVL59:
 559 00ce 7860     		str	r0, [r7, #4]
 287:src/gps_support.c **** 		rtc.tm_sec  = gp_val(p+4);
 560              		.loc 1 287 0
 561 00d0 281D     		adds	r0, r5, #4
 562 00d2 FFF7FEFF 		bl	gp_val
 563              	.LVL60:
 564 00d6 3860     		str	r0, [r7, #0]
 288:src/gps_support.c **** 		p = gp_col(Buff,GPRMC_COL_YMD);
 565              		.loc 1 288 0
 566 00d8 0920     		movs	r0, #9
 567 00da FFF7FEFF 		bl	gp_col.constprop.1
 568              	.LVL61:
 569 00de 0446     		mov	r4, r0
 570              	.LVL62:
 290:src/gps_support.c **** 		rtc.tm_mday = gp_val(p);
 571              		.loc 1 290 0
 572 00e0 FFF7FEFF 		bl	gp_val
 573              	.LVL63:
 574 00e4 F860     		str	r0, [r7, #12]
 291:src/gps_support.c **** 		rtc.tm_mon  = gp_val(p+2) - 1;
 575              		.loc 1 291 0
 576 00e6 A01C     		adds	r0, r4, #2
 577 00e8 FFF7FEFF 		bl	gp_val
 578              	.LVL64:
 579 00ec 411E     		subs	r1, r0, #1
 580 00ee 3961     		str	r1, [r7, #16]
 292:src/gps_support.c **** 		rtc.tm_year = gp_val(p+4) + 100;
 581              		.loc 1 292 0
 582 00f0 201D     		adds	r0, r4, #4
 583 00f2 FFF7FEFF 		bl	gp_val
 584              	.LVL65:
 585 00f6 6430     		adds	r0, r0, #100
 586 00f8 7861     		str	r0, [r7, #20]
 294:src/gps_support.c **** 		utc = mktime(&rtc);				/* Get UNIX epoch Time */
 587              		.loc 1 294 0
 588 00fa 3846     		mov	r0, r7
 589 00fc FFF7FEFF 		bl	mktime
 590              	.LVL66:
 295:src/gps_support.c **** 		utc += 3600 * 9;				/* Create Time in JST*/
 591              		.loc 1 295 0
 592 0100 00F5FD40 		add	r0, r0, #32384
 593              	.LVL67:
 296:src/gps_support.c **** 		Time_SetUnixTime(utc);			/* Set UNIX epoch Time */
 594              		.loc 1 296 0
 595 0104 1030     		adds	r0, r0, #16
 596              	.LVL68:
 597 0106 FFF7FEFF 		bl	Time_SetUnixTime
 598              	.LVL69:
 299:src/gps_support.c **** 		rtc = Time_GetCalendarTime();
 599              		.loc 1 299 0
 600 010a 02A8     		add	r0, sp, #8
 601 010c FFF7FEFF 		bl	Time_GetCalendarTime
 602              	.LVL70:
 603 0110 3D46     		mov	r5, r7
 604 0112 02AE     		add	r6, sp, #8
 605 0114 0FCE     		ldmia	r6!, {r0, r1, r2, r3}
 606 0116 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 607 0118 0FCE     		ldmia	r6!, {r0, r1, r2, r3}
 608 011a 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 609 011c 3268     		ldr	r2, [r6, #0]
 610 011e 2A60     		str	r2, [r5, #0]
 300:src/gps_support.c **** 		sprintf((char*)Buff,"%02u%02u%02u.log",
 611              		.loc 1 300 0
 612 0120 7A69     		ldr	r2, [r7, #20]
 613 0122 6425     		movs	r5, #100
 614 0124 92FBF5F6 		sdiv	r6, r2, r5
 615 0128 0346     		mov	r3, r0
 616 012a F868     		ldr	r0, [r7, #12]
 617 012c 0090     		str	r0, [sp, #0]
 618 012e 5348     		ldr	r0, .L106+52
 619 0130 5349     		ldr	r1, .L106+56
 620 0132 05FB1622 		mls	r2, r5, r6, r2
 621 0136 0133     		adds	r3, r3, #1
 622 0138 FFF7FEFF 		bl	sprintf
 623              	.LVL71:
 306:src/gps_support.c **** 		if (f_open(&File1, (const char*)Buff, FA_OPEN_ALWAYS | FA_WRITE) ||
 624              		.loc 1 306 0
 625 013c 514F     		ldr	r7, .L106+60
 626 013e 3846     		mov	r0, r7
 627 0140 4E49     		ldr	r1, .L106+52
 628 0142 1222     		movs	r2, #18
 629 0144 FFF7FEFF 		bl	f_open
 630              	.LVL72:
 631 0148 0028     		cmp	r0, #0
 632 014a 73D1     		bne	.L90
 307:src/gps_support.c **** 		    f_lseek(&File1, File1.fsize)) {goto errstat;}
 633              		.loc 1 307 0 discriminator 1
 634 014c 3846     		mov	r0, r7
 635 014e F968     		ldr	r1, [r7, #12]
 636 0150 FFF7FEFF 		bl	f_lseek
 637              	.LVL73:
 306:src/gps_support.c **** 		if (f_open(&File1, (const char*)Buff, FA_OPEN_ALWAYS | FA_WRITE) ||
 638              		.loc 1 306 0 discriminator 1
 639 0154 0028     		cmp	r0, #0
 640 0156 6DD1     		bne	.L90
 641              	.LVL74:
 642              	.L100:
 310:src/gps_support.c **** 		while ((b = get_line_GPS()) > 0)
 643              		.loc 1 310 0 discriminator 1
 644 0158 FFF7FEFF 		bl	get_line_GPS
 645              	.LVL75:
 646 015c 0546     		mov	r5, r0
 647 015e 0028     		cmp	r0, #0
 648 0160 3FF473AF 		beq	.L101
 649              	.L76:
 313:src/gps_support.c **** 			if (!gp_comp(Buff,"$GPGGA"))
 650              		.loc 1 313 0
 651 0164 4848     		ldr	r0, .L106+64
 652              	.LVL76:
 653 0166 FFF7FEFF 		bl	gp_comp.constprop.0
 654              	.LVL77:
 655 016a 38B9     		cbnz	r0, .L70
 315:src/gps_support.c **** 				p = gp_col(Buff,GPGGA_POS_TYPE);
 656              		.loc 1 315 0
 657 016c 0620     		movs	r0, #6
 658 016e FFF7FEFF 		bl	gp_col.constprop.1
 659              	.LVL78:
 660 0172 0446     		mov	r4, r0
 661              	.LVL79:
 316:src/gps_support.c **** 				if(*p != '0'){ /* 0 is invalid tracking data */
 662              		.loc 1 316 0
 663 0174 0278     		ldrb	r2, [r0, #0]	@ zero_extendqisi2
 664 0176 302A     		cmp	r2, #48
 665 0178 0BD1     		bne	.L104
 666 017a 19E0     		b	.L71
 667              	.LVL80:
 668              	.L70:
 322:src/gps_support.c **** 			else if (!gp_comp(Buff,"$GPRMC"))
 669              		.loc 1 322 0
 670 017c 3B48     		ldr	r0, .L106+36
 671 017e FFF7FEFF 		bl	gp_comp.constprop.0
 672              	.LVL81:
 673 0182 A8B9     		cbnz	r0, .L71
 324:src/gps_support.c **** 				p = gp_col(Buff,GPRMC_COL_VALID);
 674              		.loc 1 324 0
 675 0184 0220     		movs	r0, #2
 676 0186 FFF7FEFF 		bl	gp_col.constprop.1
 677              	.LVL82:
 678 018a 0446     		mov	r4, r0
 679              	.LVL83:
 325:src/gps_support.c **** 				if(*p == 'A'){
 680              		.loc 1 325 0
 681 018c 0178     		ldrb	r1, [r0, #0]	@ zero_extendqisi2
 682 018e 4129     		cmp	r1, #65
 683 0190 0ED1     		bne	.L71
 684              	.L104:
 326:src/gps_support.c **** 					LED_RED_ON();
 685              		.loc 1 326 0
 686 0192 3548     		ldr	r0, .L106+32
 687              	.LVL84:
 688 0194 0221     		movs	r1, #2
 689 0196 FFF7FEFF 		bl	GPIO_SetBits
 690              	.LVL85:
 327:src/gps_support.c **** 					if (f_write(&File1, Buff, b, &s) || b != s) {goto errstat;}
 691              		.loc 1 327 0
 692 019a 3A48     		ldr	r0, .L106+60
 693 019c 3749     		ldr	r1, .L106+52
 694 019e 2A46     		mov	r2, r5
 695 01a0 0DAB     		add	r3, sp, #52
 696 01a2 FFF7FEFF 		bl	f_write
 697              	.LVL86:
 698 01a6 0028     		cmp	r0, #0
 699 01a8 44D1     		bne	.L90
 327:src/gps_support.c **** 					if (f_write(&File1, Buff, b, &s) || b != s) {goto errstat;}
 700              		.loc 1 327 0 is_stmt 0 discriminator 1
 701 01aa 0D9E     		ldr	r6, [sp, #52]
 702 01ac B542     		cmp	r5, r6
 703 01ae 41D1     		bne	.L90
 704              	.LVL87:
 705              	.L71:
 332:src/gps_support.c **** 			if (!gp_comp(Buff,"$GNGGA"))
 706              		.loc 1 332 0 is_stmt 1
 707 01b0 3648     		ldr	r0, .L106+68
 708 01b2 FFF7FEFF 		bl	gp_comp.constprop.0
 709              	.LVL88:
 710 01b6 38B9     		cbnz	r0, .L72
 334:src/gps_support.c **** 				p = gp_col(Buff,GPGGA_POS_TYPE);
 711              		.loc 1 334 0
 712 01b8 0620     		movs	r0, #6
 713 01ba FFF7FEFF 		bl	gp_col.constprop.1
 714              	.LVL89:
 715 01be 0446     		mov	r4, r0
 716              	.LVL90:
 335:src/gps_support.c **** 				if(*p != '0'){ /* 0 is invalid tracking data */
 717              		.loc 1 335 0
 718 01c0 0078     		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 719              	.LVL91:
 720 01c2 3028     		cmp	r0, #48
 721 01c4 0BD1     		bne	.L105
 722 01c6 18E0     		b	.L73
 723              	.LVL92:
 724              	.L72:
 342:src/gps_support.c **** 			else if (!gp_comp(Buff,"$GNRMC"))
 725              		.loc 1 342 0
 726 01c8 2948     		ldr	r0, .L106+40
 727 01ca FFF7FEFF 		bl	gp_comp.constprop.0
 728              	.LVL93:
 729 01ce A0B9     		cbnz	r0, .L73
 730              		.loc 1 344 0
 731 01d0 0220     		movs	r0, #2
 732 01d2 FFF7FEFF 		bl	gp_col.constprop.1
 733              	.LVL94:
 734 01d6 0446     		mov	r4, r0
 735              	.LVL95:
 345:src/gps_support.c **** 				if(*p == 'A'){
 736              		.loc 1 345 0
 737 01d8 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 738 01da 412B     		cmp	r3, #65
 739 01dc 0DD1     		bne	.L73
 740              	.LVL96:
 741              	.L105:
 346:src/gps_support.c **** 					LED_RED_ON();
 742              		.loc 1 346 0
 743 01de 2248     		ldr	r0, .L106+32
 744 01e0 0221     		movs	r1, #2
 745 01e2 FFF7FEFF 		bl	GPIO_SetBits
 746              	.LVL97:
 347:src/gps_support.c **** 					if (f_write(&File1, Buff, b, &s) || b != s) {goto errstat;}
 747              		.loc 1 347 0
 748 01e6 2748     		ldr	r0, .L106+60
 749 01e8 2449     		ldr	r1, .L106+52
 750 01ea 2A46     		mov	r2, r5
 751 01ec 0DAB     		add	r3, sp, #52
 752 01ee FFF7FEFF 		bl	f_write
 753              	.LVL98:
 754 01f2 F8B9     		cbnz	r0, .L90
 755              		.loc 1 347 0 is_stmt 0 discriminator 1
 756 01f4 0D9F     		ldr	r7, [sp, #52]
 757 01f6 BD42     		cmp	r5, r7
 758 01f8 1CD1     		bne	.L90
 759              	.LVL99:
 760              	.L73:
 348:src/gps_support.c **** 				}
 349:src/gps_support.c **** 			}
 350:src/gps_support.c **** 
 351:src/gps_support.c **** #if defined(ENABLE_SATELLITE_ID_LOGGING)
 352:src/gps_support.c **** 			else if (!gp_comp(Buff,"$GPGSV"))
 353:src/gps_support.c **** 			{
 354:src/gps_support.c **** 				char it;
 355:src/gps_support.c **** 				p = gp_col(Buff,GPGSV_NUM_VIEW);
 356:src/gps_support.c **** 				it = gp_val(p);
 357:src/gps_support.c **** 				if(it >= 5){
 358:src/gps_support.c **** 					LED_RED_ON();
 359:src/gps_support.c **** 					if (f_write(&File1, Buff, b, &s) || b != s) {goto errstat;}
 360:src/gps_support.c **** 				}
 361:src/gps_support.c **** 			}
 362:src/gps_support.c **** #endif
 363:src/gps_support.c **** 			if(++c_sync > SYNC_INTERVAL) {
 761              		.loc 1 363 0 is_stmt 1
 762 01fa BDF83250 		ldrh	r5, [sp, #50]
 763              	.LVL100:
 764 01fe 691C     		adds	r1, r5, #1
 765 0200 8AB2     		uxth	r2, r1
 766 0202 ADF83220 		strh	r2, [sp, #50]	@ movhi
 767              	.LVL101:
 768 0206 5A2A     		cmp	r2, #90
 769 0208 08D8     		bhi	.L74
 770              	.L75:
 364:src/gps_support.c **** 				LED_RED_ON();
 365:src/gps_support.c **** 				c_sync =0;
 366:src/gps_support.c **** 				if (f_sync(&File1)) {goto errstat;}
 367:src/gps_support.c **** 			}
 368:src/gps_support.c **** 
 369:src/gps_support.c **** 			LED_RED_OFF();
 771              		.loc 1 369 0
 772 020a 1748     		ldr	r0, .L106+32
 773 020c 0221     		movs	r1, #2
 774 020e FFF7FEFF 		bl	GPIO_ResetBits
 775              	.LVL102:
 370:src/gps_support.c **** 			ack_limit =0;
 776              		.loc 1 370 0
 777 0212 0020     		movs	r0, #0
 778 0214 174B     		ldr	r3, .L106+44
 779 0216 1860     		str	r0, [r3, #0]
 780              	.LBB8:
 781              	.LBB9:
 782              		.loc 2 299 0
 783              	@ 299 "./lib/CMSIS/Include/core_cmInstr.h" 1
 784 0218 30BF     		wfi
 785              	@ 0 "" 2
 786              		.thumb
 787 021a 9DE7     		b	.L100
 788              	.L74:
 789              	.LBE9:
 790              	.LBE8:
 364:src/gps_support.c **** 				LED_RED_ON();
 791              		.loc 1 364 0
 792 021c 1248     		ldr	r0, .L106+32
 793 021e 0221     		movs	r1, #2
 794 0220 FFF7FEFF 		bl	GPIO_SetBits
 795              	.LVL103:
 365:src/gps_support.c **** 				c_sync =0;
 796              		.loc 1 365 0
 797 0224 0026     		movs	r6, #0
 798 0226 ADF83260 		strh	r6, [sp, #50]	@ movhi
 366:src/gps_support.c **** 				if (f_sync(&File1)) {goto errstat;}
 799              		.loc 1 366 0
 800 022a 1648     		ldr	r0, .L106+60
 801 022c FFF7FEFF 		bl	f_sync
 802              	.LVL104:
 803 0230 0028     		cmp	r0, #0
 804 0232 EAD0     		beq	.L75
 805              	.L68:
 806              	.L90:
 371:src/gps_support.c **** 			__WFI();
 372:src/gps_support.c **** 		}
 373:src/gps_support.c **** 
 374:src/gps_support.c **** 	}
 375:src/gps_support.c **** 
 376:src/gps_support.c **** errstat:
 377:src/gps_support.c **** 		/* If got error state,close file forcibly */
 378:src/gps_support.c **** 		LED_RED_ON();
 807              		.loc 1 378 0 discriminator 1
 808 0234 0C48     		ldr	r0, .L106+32
 809 0236 0221     		movs	r1, #2
 810 0238 FFF7FEFF 		bl	GPIO_SetBits
 811              	.LVL105:
 379:src/gps_support.c **** 		if(f_close(&File1)) {goto errstat;}
 812              		.loc 1 379 0 discriminator 1
 813 023c 1148     		ldr	r0, .L106+60
 814 023e FFF7FEFF 		bl	f_close
 815              	.LVL106:
 816 0242 0028     		cmp	r0, #0
 817 0244 F6D1     		bne	.L90
 818 0246 00E7     		b	.L101
 819              	.L107:
 820              		.align	2
 821              	.L106:
 822 0248 0E000000 		.word	.LC1
 823 024c 21000000 		.word	.LC2
 824 0250 00000000 		.word	putch
 825 0254 00000000 		.word	xfunc_out
 826 0258 00000000 		.word	xgetc
 827 025c 00000000 		.word	xfunc_in
 828 0260 00000000 		.word	.LANCHOR6
 829 0264 00000000 		.word	.LANCHOR4
 830 0268 00180140 		.word	1073813504
 831 026c 31000000 		.word	.LC3
 832 0270 38000000 		.word	.LC4
 833 0274 00000000 		.word	.LANCHOR3
 834 0278 00000000 		.word	rtc
 835 027c 00000000 		.word	.LANCHOR0
 836 0280 3F000000 		.word	.LC5
 837 0284 00000000 		.word	.LANCHOR5
 838 0288 50000000 		.word	.LC6
 839 028c 57000000 		.word	.LC7
 840              		.cfi_endproc
 841              	.LFE65:
 843              		.global	ack_limit
 844              		.global	l_stat
 845              		.global	Timer
 846              		.global	Buff
 847              		.global	Dir
 848              		.global	File1
 849              		.global	Fatfs
 850              		.global	ff_rtc
 851              		.section	.bss.File1,"aw",%nobits
 852              		.align	2
 853              		.set	.LANCHOR5,. + 0
 856              	File1:
 857 0000 00000000 		.space	40
 857      00000000 
 857      00000000 
 857      00000000 
 857      00000000 
 858              		.section	.bss.Fatfs,"aw",%nobits
 859              		.align	2
 860              		.set	.LANCHOR6,. + 0
 863              	Fatfs:
 864 0000 00000000 		.space	564
 864      00000000 
 864      00000000 
 864      00000000 
 864      00000000 
 865              		.section	.bss.ff_rtc,"aw",%nobits
 866              		.align	1
 867              		.set	.LANCHOR2,. + 0
 870              	ff_rtc:
 871 0000 00000000 		.space	8
 871      00000000 
 872              		.section	.bss.ack_limit,"aw",%nobits
 873              		.align	2
 874              		.set	.LANCHOR3,. + 0
 877              	ack_limit:
 878 0000 00000000 		.space	4
 879              		.section	.rodata.str1.1,"aMS",%progbits,1
 880              	.LC0:
 881 0000 24504D54 		.ascii	"$PMTK000*32\015\012\000"
 881      4B303030 
 881      2A33320D 
 881      0A00
 882              	.LC1:
 883 000e 24504D54 		.ascii	"$PMTK251,9600*17\015\012\000"
 883      4B323531 
 883      2C393630 
 883      302A3137 
 883      0D0A00
 884              	.LC2:
 885 0021 24504D54 		.ascii	"$PMTK286,1*23\015\012\000"
 885      4B323836 
 885      2C312A32 
 885      330D0A00 
 886              	.LC3:
 887 0031 24475052 		.ascii	"$GPRMC\000"
 887      4D4300
 888              	.LC4:
 889 0038 24474E52 		.ascii	"$GNRMC\000"
 889      4D4300
 890              	.LC5:
 891 003f 25303275 		.ascii	"%02u%02u%02u.log\000"
 891      25303275 
 891      25303275 
 891      2E6C6F67 
 891      00
 892              	.LC6:
 893 0050 24475047 		.ascii	"$GPGGA\000"
 893      474100
 894              	.LC7:
 895 0057 24474E47 		.ascii	"$GNGGA\000"
 895      474100
 896              		.section	.bss.Buff,"aw",%nobits
 897              		.set	.LANCHOR0,. + 0
 900              	Buff:
 901 0000 00000000 		.space	512
 901      00000000 
 901      00000000 
 901      00000000 
 901      00000000 
 902              		.section	.bss.Dir,"aw",%nobits
 903              		.align	2
 906              	Dir:
 907 0000 00000000 		.space	28
 907      00000000 
 907      00000000 
 907      00000000 
 907      00000000 
 908              		.section	.bss.l_stat,"aw",%nobits
 909              		.align	2
 910              		.set	.LANCHOR4,. + 0
 913              	l_stat:
 914 0000 00000000 		.space	4
 915              		.section	.bss.Timer,"aw",%nobits
 916              		.align	2
 917              		.set	.LANCHOR1,. + 0
 920              	Timer:
 921 0000 00000000 		.space	4
 922              		.text
 923              	.Letext0:
 924              		.file 3 "c:\\devz\\arm\\launchpad\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/i
 925              		.file 4 "c:\\devz\\arm\\launchpad\\bin\\../lib/gcc/arm-none-eabi/4.7.3/include/stdint-gcc.h"
 926              		.file 5 "./lib/CMSIS/Device/ST/STM32F10x/Include/stm32f10x.h"
 927              		.file 6 "c:\\devz\\arm\\launchpad\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/i
 928              		.file 7 "./lib/ff/integer.h"
 929              		.file 8 "./lib/ff/ff.h"
 930              		.file 9 "./lib/ff/ff_rtc_if.h"
 931              		.file 10 "./lib/CMSIS/Include/core_cm3.h"
 932              		.file 11 "./inc/systick.h"
 933              		.file 12 "./inc/xprintf.h"
 934              		.file 13 "./inc/rtc_support.h"
 935              		.file 14 "./inc/uart_support_gps.h"
 936              		.file 15 "./lib/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h"
 937              		.file 16 "c:\\devz\\arm\\launchpad\\bin\\../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/
DEFINED SYMBOLS
                            *ABS*:00000000 gps_support.c
  R:\TEMP\ccfofwKW.s:19     .text.get_line_GPS:00000000 $t
  R:\TEMP\ccfofwKW.s:23     .text.get_line_GPS:00000000 get_line_GPS
  R:\TEMP\ccfofwKW.s:77     .text.get_line_GPS:0000002c $d
  R:\TEMP\ccfofwKW.s:83     .text.gp_val:00000000 $t
  R:\TEMP\ccfofwKW.s:87     .text.gp_val:00000000 gp_val
  R:\TEMP\ccfofwKW.s:129    .text.gp_comp.constprop.0:00000000 $t
  R:\TEMP\ccfofwKW.s:133    .text.gp_comp.constprop.0:00000000 gp_comp.constprop.0
  R:\TEMP\ccfofwKW.s:165    .text.gp_comp.constprop.0:00000014 $d
  R:\TEMP\ccfofwKW.s:170    .text.gp_col.constprop.1:00000000 $t
  R:\TEMP\ccfofwKW.s:174    .text.gp_col.constprop.1:00000000 gp_col.constprop.1
  R:\TEMP\ccfofwKW.s:221    .text.gp_col.constprop.1:00000020 $d
  R:\TEMP\ccfofwKW.s:226    .text.ff_support_timerproc:00000000 $t
  R:\TEMP\ccfofwKW.s:231    .text.ff_support_timerproc:00000000 ff_support_timerproc
  R:\TEMP\ccfofwKW.s:247    .text.ff_support_timerproc:0000000c $d
  R:\TEMP\ccfofwKW.s:252    .text.get_fattime:00000000 $t
  R:\TEMP\ccfofwKW.s:257    .text.get_fattime:00000000 get_fattime
  R:\TEMP\ccfofwKW.s:300    .text.get_fattime:00000034 $d
  R:\TEMP\ccfofwKW.s:305    .text.ChkAckLimit:00000000 $t
  R:\TEMP\ccfofwKW.s:310    .text.ChkAckLimit:00000000 ChkAckLimit
  R:\TEMP\ccfofwKW.s:345    .text.ChkAckLimit:00000028 $d
  R:\TEMP\ccfofwKW.s:351    .text.ShutFileClose:00000000 $t
  R:\TEMP\ccfofwKW.s:356    .text.ShutFileClose:00000000 ShutFileClose
  R:\TEMP\ccfofwKW.s:383    .text.ShutFileClose:00000014 $d
  R:\TEMP\ccfofwKW.s:389    .text.gps_task:00000000 $t
  R:\TEMP\ccfofwKW.s:394    .text.gps_task:00000000 gps_task
  R:\TEMP\ccfofwKW.s:822    .text.gps_task:00000248 $d
  R:\TEMP\ccfofwKW.s:877    .bss.ack_limit:00000000 ack_limit
  R:\TEMP\ccfofwKW.s:913    .bss.l_stat:00000000 l_stat
  R:\TEMP\ccfofwKW.s:920    .bss.Timer:00000000 Timer
  R:\TEMP\ccfofwKW.s:900    .bss.Buff:00000000 Buff
  R:\TEMP\ccfofwKW.s:906    .bss.Dir:00000000 Dir
  R:\TEMP\ccfofwKW.s:856    .bss.File1:00000000 File1
  R:\TEMP\ccfofwKW.s:863    .bss.Fatfs:00000000 Fatfs
  R:\TEMP\ccfofwKW.s:870    .bss.ff_rtc:00000000 ff_rtc
  R:\TEMP\ccfofwKW.s:852    .bss.File1:00000000 $d
  R:\TEMP\ccfofwKW.s:859    .bss.Fatfs:00000000 $d
  R:\TEMP\ccfofwKW.s:866    .bss.ff_rtc:00000000 $d
  R:\TEMP\ccfofwKW.s:873    .bss.ack_limit:00000000 $d
  R:\TEMP\ccfofwKW.s:901    .bss.Buff:00000000 $d
  R:\TEMP\ccfofwKW.s:903    .bss.Dir:00000000 $d
  R:\TEMP\ccfofwKW.s:909    .bss.l_stat:00000000 $d
  R:\TEMP\ccfofwKW.s:916    .bss.Timer:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xfunc_in
rtc_gettime
cputs
_delay_us
f_close
conio_init
_delay_ms
f_mount
GPIO_SetBits
GPIO_ResetBits
mktime
Time_SetUnixTime
Time_GetCalendarTime
sprintf
f_open
f_lseek
f_write
f_sync
putch
xfunc_out
xgetc
rtc
